<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Philadelphia AI Chat - Elevating Your Experience</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <meta name="description" content="Experience Philadelphia AI: an advanced chat platform with powerful creative, audio, video, and web generation tools." />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
    <style>
        /* --- Root Variables for Theming --- */
        :root {
            /* Cyber Theme (Default) */
            --cyan: #00fff7;
            --blue: #0a8afe;
            --dark-bg: #070b1a;
            --fade-blue: #133c8b;
            --gradient-1: linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%); /* AI Bubble */
            --gradient-user: linear-gradient(120deg, #0857ee 32%, #00fff0 89%); /* User Bubble */
            --glass: rgba(25, 38, 67, 0.82);
            --bubble-glow: 0 0 13px #00d8ffb1, 0 0 24px #0197ff40; /* AI Bubble Glow */
            --user-glow: 0 0 22px #0fffd555, 0 0 14px #36f9ff70; /* User Bubble Glow */
            --header-glass: rgba(17,29,47,0.92);
            --code-bg: linear-gradient(92deg,#031d39 79%,#092ff8 120%);
            --code-border: #15faff;
            --code-text: #17fafd;
            --main-text: #e1fafe; /* General text color */
            --link-text: #13efff;
            --input-bg: #09284c;
            --body-bg: radial-gradient(circle at 60% 45%, #112250 37%, #060e1e 88%, #1e0942 100%) fixed, repeating-linear-gradient(100deg,#061c4c 0 9%,#080e20 16% 19%,#030721 30% 41%,#052650 44% 62%,#050b16 74% 89%,#041048 99% 100%);
            --body-blend-mode: lighten, color-dodge;
            --panel-bg: linear-gradient(118deg,#131642 80%,#1629af 200%);
            --panel-border: #00fbffcb;
            --panel-shadow: 0 0 42px #25f8ffc9;
            --submit-bg: linear-gradient(94deg,#00ffff,#0090ff 90%);
            --submit-text: #102649;
            --submit-hover-bg: #008cff;
            --submit-hover-text: #fff;
            --header-text-glow: 0 0 12px #00ffe0cc, 0 0 27px #178fcf88;
            --header-text-anim-glow-1: 0 0 17px #00e7ff70,0 0 30px #0b8fff44;
            --header-text-anim-glow-2: 0 0 29px #00ffe9ee,0 0 44px #31d2ff82;
            --header-text-fill: linear-gradient(90deg,#00fff1,#00b4ff 40%,#fff 59%,#1093f1 89%,#24e0fa 100%);
        }

        /* --- Base & Global Styles --- */
        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            color: var(--main-text);
            background: var(--body-bg);
            background-blend-mode: var(--body-blend-mode);
            font-family: 'Roboto', 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            transition: background 0.3s ease;
            overflow: hidden; /* Prevent body scroll */
            min-height: 100vh;
        }

        /* --- Stars Background Animation --- */
        #stars-container {
            pointer-events: none;
            position: fixed;
            left:0; top:0; right:0; bottom:0;
            width:100vw; height:100vh;
            z-index:1;
            overflow: hidden;
        }
        .star {
            position:absolute;
            background: var(--cyan);
            box-shadow: 0 0 12px var(--cyan), 0 0 22px var(--cyan);
            opacity: 0.23;
            border-radius: 50%;
            pointer-events: none;
            animation: star-twinkle 2.7s infinite alternate;
        }
        @keyframes star-twinkle {
            0% { opacity:.18; }
            41% { opacity:.88; }
            100%{ opacity:.09;}
        }

        /* --- Header Bar --- */
        .header-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--header-glass);
            z-index: 1003;
            padding: 0;
            box-shadow: 0 7px 48px #00aaff27, 0 3px 41px #09fcfe15;
            border-radius: 0 0 22px 22px;
            height: 70px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }
        .header-bar .menu-btn {
            background: none;
            border: none;
            color: var(--cyan);
            font-size: 2em;
            cursor: pointer;
            border-radius: 14px;
            margin-left: 17px;
            margin-right: 3px;
            padding: 7px 11px;
            transition: background 0.15s, color 0.15s;
        }
        .header-bar .menu-btn:hover {
            background: #00eaff28;
            color: #fff;
        }
        #themeBtn { font-size: 1.6em; padding: 7px 12px; margin-left: -10px; }
        .site-heading {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.28em;
            font-weight: 700;
            text-align: center;
            flex: 1;
            letter-spacing: .27px;
            white-space: nowrap;
            background: var(--header-text-fill);
            background-size: 250% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: neonglow 4.2s ease-in-out infinite alternate;
            text-shadow: var(--header-text-glow);
            user-select: none;
            margin-left: 8px;
            margin-right: 10px;
        }
        @keyframes neonglow {
            0% { text-shadow: var(--header-text-anim-glow-1);}
            100% { text-shadow: var(--header-text-anim-glow-2);}
        }
        .header-welcome {
            color: #68e6fd;
            font-size: .97em;
            margin: -2px 0 .7em 0;
            text-align: center;
            text-shadow: 0 0 14px #00bcb4a8;
        }

        /* --- Main Content Area (Chat + Input) --- */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow-y: hidden;
            position: relative;
            padding-top: 70px; /* Space for fixed header */
            padding-bottom: 86px; /* Space for fixed input row */
            box-sizing: border-box;
        }

        /* --- Chat Box --- */
        .chat-box {
            flex: 1 1 0px; /* Allows it to grow and shrink */
            overflow-y: auto;
            overflow-x: hidden;
            width: 100vw;
            max-width: 635px;
            margin: 0 auto;
            box-sizing: border-box;
            padding: 15px 8px;
            position: relative;
            z-index:3;
            scroll-behavior: smooth;
            display: flex;
            flex-direction: column;
        }
        .chat-message {
            width: 100%;
            display: flex;
            gap:9px;
            align-items: flex-end;
            margin: 8px 0;
            max-width:100vw;
            flex-shrink: 0;
        }
        .chat-message .msg {
            font-size: 1.01em;
            line-height: 1.58;
            max-width: 62vw;
            min-width:0;
            padding: 11px 16px 12px 15px;
            border-radius: 16px 14px 11px 12px;
            word-break: break-word;
            white-space: pre-wrap;
            overflow-x: auto;
            background: var(--gradient-1);
            color: var(--main-text);
            text-shadow: 0 0 3px #23d8ff15;
            box-shadow: var(--bubble-glow);
            margin-right: auto;
            margin-left: 0;
            border: 1.2px solid #0090ffa0;
            position:relative;
            transition:background .3s, color .3s, box-shadow .3s;
        }
        .chat-message.user { justify-content: flex-end; }
        .chat-message.user .msg {
            background: var(--gradient-user);
            color: var(--submit-text);
            font-weight: 700;
            text-shadow: 0 0 5px #00e0ff77, 0 0 2px #00ffe033;
            border-radius: 17px 13px 15px 11px;
            margin-left: auto;
            margin-right: 0;
            box-shadow: var(--user-glow);
            border: 1.2px solid #04eef4c9;
            max-width: 68vw;
        }

        /* --- Typing Indicator --- */
        #typing-status {
            display: none; /* Hidden by default */
            max-width: 635px;
            margin: 0 auto;
            padding: 0 8px;
            width: 100vw;
            box-sizing: border-box;
            flex-shrink: 0;
            min-height: 20px;
            padding-bottom: 10px;
        }
        .typing-bubble {
            display: inline-flex;
            align-items: center;
            height: 28px;
            padding: 4px 12px;
            margin: 6px 4px;
            border-radius: 15px;
            background: linear-gradient(90deg,#0a4477dd 30%,#0ebfff88 95%);
            box-shadow: 0 2px 12px #0dfcff77;
            border: 1px solid #00ffff55;
        }
        .dot-anim {
            display:inline-block;
            width: 8px;
            height: 8px;
            margin:0 3px;
            background: var(--cyan);
            border-radius: 50%;
            opacity: 0.85;
            animation: typing-blink 1.4s infinite both;
            box-shadow: 0 0 6px var(--cyan);
        }
        .dot-anim:nth-child(2){animation-delay:.3s;}
        .dot-anim:nth-child(3){animation-delay:.6s;}
        @keyframes typing-blink {
            0%,100% {opacity:.25; transform: scale(0.8);}
            25% {opacity:.95; transform: scale(1.1);}
            50% {opacity:1; transform: scale(1.2);}
            75% {opacity:.65; transform: scale(1);}
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 247, 0.3);
            border-radius: 50%;
            border-top-color: var(--cyan);
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Code Blocks --- */
        pre, code {
            font-family: 'JetBrains Mono', 'Fira Mono', 'Menlo', monospace;
            font-size: .99em;
            background: var(--code-bg);
            border-radius: 11px;
            border: 1.7px solid var(--code-border);
            color: var(--code-text);
            box-shadow: 0 0 19px #00eaff38, 0 0 48px #0beaff38 inset;
            transition: background 0.3s, border-color 0.3s, color 0.3s;
        }
        pre {
            overflow-x: auto;
            padding: 1.18em 1.3em 1.16em 1.13em;
            margin: 1.15em 0 1em 0;
            position: relative;
        }
        pre:before {
            content: "CODE";
            color: var(--cyan);
            font-size: 0.82em;
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 5px;
            right: 29px;
            opacity: 0.17;
            letter-spacing: 0.13em;
            pointer-events: none;
        }
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 13px;
            z-index: 3;
            border-radius: 8px;
            border: none;
            padding: 3px 15px;
            background: linear-gradient(95deg,#0cf3ff 40%,#0980ff 120%);
            color: #06182f;
            font-size: .98em;
            font-family: 'Inter';
            font-weight: bold;
            box-shadow: 0 2px 9px #18e3ffc5,0 0 7px #00ffd7a4;
            transition: background .15s, color .15s;
            cursor: pointer;
            outline: none;
            border: 1px solid #0cf3ff35;
        }
        .copy-btn:hover { background: #008cee; color: #fff; }

        /* --- Chat Message Controls (Copy, Share, Regen, Edit) --- */
        .inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn {
            padding:4px 10px;
            border-radius:7px;
            border:none;
            background:var(--submit-bg);
            color:var(--submit-text);
            font-family:'Inter',Arial,sans-serif;
            font-size:.96em;
            font-weight:600;
            display:inline-flex;
            align-items:center;
            gap:4px;
            margin-top:6px;
            margin-right: 3px;
            cursor:pointer;
            box-shadow:0 2px 7px #17f6fe51;
            transition:background .14s,color .13s;
        }
        .inline-copy-btn:hover, .inline-share-btn:hover, .regen-btn:hover, .inline-edit-btn:hover{
            background:var(--submit-hover-bg);
            color:var(--submit-hover-text);
        }

        /* --- File Attachments & Previews --- */
        .file-attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 8px 0;
            max-width: 100%;
        }
        .chat-media-preview {
            max-width: 100%;
            max-height: 250px;
            border-radius: 12px;
            display: block;
        }
        .image-preview-thumb, .video-preview-thumb {
            border: 2px solid var(--cyan);
            box-shadow: 0 0 10px var(--cyan);
        }
        .chat-message.ai .msg img.chat-media-preview { cursor: zoom-in; } /* Make AI images clickable */
        .audio-preview-thumb { width: 90%; min-height: 40px; border-radius: 10px; }
        .file-link, .file-placeholder {
            display: inline-block;
            padding: 8px 12px;
            background: #0b2447;
            border: 1px solid #1af8ff51;
            border-radius: 10px;
            color: var(--cyan);
            text-decoration: none;
            font-size: 0.9em;
            font-weight: bold;
        }
        .file-link i, .file-placeholder i { margin-right: 5px; }
        .file-preview{
            display:none;
            background:rgba(15,36,65,0.98);
            border-radius:12px;
            color:#c4f2ff;
            font-size:.98em;
            box-shadow:0 3px 15px #00aac0bb;
            margin:0 auto 10px auto;
            width:94vw;
            max-width:520px;
            padding:10px 14px 10px 15px;
            position: fixed;
            bottom: 100px; /* Above the input row */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            border: 1.5px solid #00ffff44;
        }
        .file-preview img, .file-preview video { max-width:58px;max-height:41px;border-radius:6px;margin-right:6px;vertical-align: middle; }
        .file-preview audio { width:52px; margin-right:7px; }
        .remove-file-btn {
            color: #fff !important;
            background:#d23 !important;
            border:none !important;
            border-radius:50% !important;
            padding:2px 6px !important;
            cursor:pointer !important;
            font-size:1.2em !important;
            font-weight:bold !important;
            margin-left:8px !important;
            transition: background .16s, color .16s !important;
            min-width: 24px !important;
            height: 24px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        .remove-file-btn:hover { background:#ff4444 !important; color:#fff !important; transform: scale(1.1) !important; }

        /* --- Chat Input Row --- */
        .chat-input-row {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 0;
            display: flex;
            align-items: stretch;
            gap: 8px;
            background: rgba(17, 29, 47, 0.94);
            backdrop-filter: blur(8px);
            border: 1.5px solid #1af8ff51;
            border-radius: 23px 23px 0 0;
            width: 95vw;
            max-width: 900px;
            padding: 9px 12px 10px 13px;
            box-shadow: 0 0 39px #007fff22, 0 11px 33px #00fff014;
            z-index: 1003;
            box-sizing: border-box; /* Ensure padding is included in width */
        }
        .chat-input-row textarea {
            flex:1 1 auto;
            resize:none;
            min-height:36px;
            max-height:120px;
            background: var(--input-bg);
            color: var(--main-text);
            font-size:1em;
            padding:10px 12px;
            border:none;
            border-radius:11px;
            box-shadow:0 1px 6px #00f2ff27;
            transition: background 0.3s, color 0.3s;
            outline: none; /* Remove focus outline */
        }
        .chat-input-row button, .chat-input-row label {
            background:none;
            border:none;
            color:var(--cyan);
            font-size:1.21em;
            cursor:pointer;
            border-radius:10px;
            transition:color .13s,background .15s;
            padding:0;
            display:flex;
            align-items:center;
            justify-content:center;
            min-width:33px;
            box-shadow: 0 0 3px #00eaff20;
        }
        .chat-input-row button:hover, .chat-input-row label:hover{color:#fff;background:#00cdf247;}
        #callBtn { font-size: 1.1em; }
        #stopBtn {
            background: #ff4d4d;
            color: white;
            font-size: 1.2em;
            border-radius: 10px;
            padding: 0;
            min-width: 33px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px #ff4d4d88;
            transition: background .1s, color .1s;
        }
        #stopBtn:hover { background: #ff7777; }

        /* --- Emoji Panel --- */
        #emojiPanel {
            display:none;
            position: fixed;
            left:10px;
            bottom:110px; /* Above file preview if present, above input row */
            z-index:2222;
            background: #051f46f9;
            border-radius: 15px;
            padding: 16px 15px 12px 15px;
            box-shadow: 0 5px 22px #00fff194;
            border: 1px solid #00ffff66;
            animation: fadeInScale .15s ease-out;
        }
        .emoji-pick {
            font-size:1.23em;
            cursor:pointer;
            padding:4px 8px;
            border-radius:10px;
            transition:background .13s;
            user-select:none;
        }
        .emoji-pick:hover { background:#35cdfd66; }

        /* --- Status Messages (General, Profile, Tool) --- */
        .status-message{
            padding:6px 13px;
            color:#12ffc7;
            font-size:.98em;
            min-height:17px;
            text-align:center;
            margin:4px auto 0 auto;
            max-width:430px;
            word-break:break-word;
        }

        /* --- Side Panels (Profile, Links, Tools, Tool Form) --- */
        .panel-bg {
            display:none;
            position:fixed;
            top:0;
            left:0;
            width:100vw;
            height:100vh;
            background:rgba(13,20,52,0.86);
            z-index:1200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-out;
        }
        .panel-bg.active {
            display:block;
            opacity: 1;
            pointer-events: all;
        }
        .side-panel {
            position:absolute;
            top:0;
            left:-350px; /* Start off-screen */
            height:100vh;
            width:325px;
            background: var(--panel-bg);
            border-right:2.5px solid var(--panel-border);
            box-shadow: var(--panel-shadow);
            z-index:1212;
            padding:18px 16px 20px 15px;
            overflow-y:auto;
            border-radius:0 24px 32px 0;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, left 0.25s ease-out;
            box-sizing: border-box;
        }
        .panel-bg.active .side-panel { left: 0; } /* Slide in */

        .side-panel .panel-header{text-align:center;margin:18px 0 13px 0;}
        .side-panel img{width:56px;height:56px;border-radius:53%;margin-bottom:8px;border:2px solid #31f6ffea;}
        .side-panel .username{font-weight:700;font-size:1.11em;color:#08d0fe;font-family:'Orbitron',sans-serif;text-shadow:0 0 8px #00eaffbb;}
        .side-panel .email{font-size:.97em;color:#a8eaff;}
        .panel-links a{
            color: var(--link-text);
            text-decoration:none;
            font-weight:500;
            font-size:1.08em;
            padding:8px 4px;
            display:flex;
            align-items:center;
            gap:12px;
            border-radius:9px;
            transition:background .14s;
        }
        .panel-links a:hover{background:#00eaff55;color:#f4fdff;}
        .panel-links a i { width: 20px; text-align: center; }

        /* Chats List Specifics */
        #chatsList button{background:none;border:none;cursor:pointer;outline:none;font-size:1.11em;margin:0 5px;vertical-align:middle;border-radius:7px;padding:3px 5px;}
        #chatsList .fa-pen{color:#0fe0ee;transition:color .13s;}
        #chatsList .fa-pen:hover{color:#ffd800;}
        #chatsList .fa-trash{color:#ff244e;transition:color .10s;}
        #chatsList .fa-trash:hover{color:#fff900;}
        #chatsList .fa-play{color:#04ea70;font-size:1.2em;}
        #chatsList .fa-play:hover{color:#31adff;}

        /* Edit Form for Profile / Tools */
        .edit-form label{display:block;margin-top:10px;font-size:.99em;color:#38e4ff;text-shadow:0 1px 14px #11aaff71;}
        .edit-form input, .edit-form textarea, .edit-form select{
            width:99%;padding:7px 11px;margin-top:5px;
            border:1.7px solid #13f0ff95;border-radius:9px;background:#071f35;color:#fff;font-size:1.02em;
            box-shadow:0 0 8px #04f6fd81 inset;transition:border-color .17s,box-shadow .17s;
            outline: none;
        }
        .edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus{border-color:#27eeff;background:#273f5d;color:#fff;}
        .edit-form textarea { resize:vertical; min-height: 80px; }
        .submit-btn{
            margin-top:14px; padding:10px 20px;
            background: var(--submit-bg);
            border:none; border-radius:10px;
            color: var(--submit-text); font-weight:bold;
            cursor:pointer; font-size:1.11em;
            box-shadow:0 2px 13px #00fff292;
            transition:background .14s,color .13s;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px; /* For spinner */
        }
        .submit-btn:hover{background: var(--submit-hover-bg);color: var(--submit-hover-text);}

        /* AI Image Preview */
        #ai-image-preview {
            display:none;
            position:fixed;
            z-index:1210;
            right:22px;
            bottom:100px; /* Above chat input */
            max-width:320px;
            background:#191a26e9;
            padding:12px;
            border-radius:17px;
            box-shadow:0 2px 19px #00fff2b8;
            animation: fadeInScale .2s ease-out;
        }
        #ai-image-close {
            float:right;
            background:#23233a;
            border:none;
            border-radius:7px;
            color:#00ffff;
            font-size:1.5em;
            cursor:pointer;
            margin-left:5px;
            line-height: 1;
            padding: 2px 8px;
            transition: background .15s, color .15s;
        }
        #ai-image-close:hover { background: #00ffff55; color: #fff; }
        #ai-image-container img { max-width:210px;max-height:210px;border-radius:12px;display:block; }
        #ai-image-dl {
            margin-top:9px;padding:7px 20px;
            background:linear-gradient(90deg,#00ffff,#0090ff);
            color:#222;border:none;border-radius:8px;
            box-shadow:0 2px 7px #00fff2c7;cursor:pointer;font-weight:bold;
            transition: background .15s, color .15s;
        }
        #ai-image-dl:hover { background: #008cee; color: #fff; }

        /* --- Image Lightbox --- */
        #lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.85);
            z-index: 5000;
            justify-content: center;
            align-items: center;
            animation: fadeIn .2s ease-out;
            cursor: zoom-out;
        }
        #lightbox.active { display: flex; }
        #lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            border: 2px solid var(--cyan);
            border-radius: 10px;
            box-shadow: 0 0 50px var(--cyan);
            animation: fadeInScale .2s ease-out;
        }

        /* --- Voice Call Modal --- */
        #callModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--dark-bg);
            z-index: 4000;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            justify-content: space-between; /* Space out content */
        }
        #callModal.active { display: flex; }
        #callHeader {
            color: var(--cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            text-shadow: 0 0 10px var(--cyan);
            margin-bottom: 20px;
        }
        #botImageContainer { margin-top: 20px; position: relative; }
        #botImageContainer img {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid var(--cyan);
            box-shadow: 0 0 30px var(--cyan);
            transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        @keyframes head-nod {
            0% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
            100% { transform: translateY(0); }
        }
        @keyframes glow-spread {
            0% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; }
            50% { box-shadow: 0 0 30px #00ff00, 0 0 50px #00ff0088; opacity: 1; }
            100% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; }
        }
        #botImageContainer.speaking img {
            border-color: #00ff00;
            box-shadow: 0 0 30px #00ff00;
            transform: scale(1.05);
            animation: head-nod 1.2s infinite ease-in-out;
        }
        #botSpeakingIndicator {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 160px;
            height: 160px;
            border-radius: 50%;
            border: 5px solid transparent; /* Hidden by default */
            box-shadow: 0 0 20px var(--cyan);
            animation: pulse 1s infinite;
            display: none;
            z-index: -1;
        }
        #botImageContainer.speaking #botSpeakingIndicator {
            box-shadow: 0 0 30px #00ff00;
            border-color: #00ff00;
            display: block;
            animation: glow-spread 1.7s infinite ease-in-out;
        }
        #callStatusMessage {
            color: var(--cyan);
            font-size: 1.1em;
            margin-top: 15px;
            height: 30px;
            text-align: center;
            font-style: italic;
            text-shadow: 0 0 5px #00aaff;
        }
        #tapToTalk {
            color: #ff00ff;
            font-size: 1.2em;
            margin-top: 5px;
            text-shadow: 0 0 8px #ff00ff;
            animation: neon-pulse 1.5s infinite alternate;
            display: none;
        }
        @keyframes neon-pulse { from { opacity: 0.7; transform: scale(1.0); } to { opacity: 1.0; transform: scale(1.02); } }
        @keyframes pulse {
            0% { opacity: 0; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0; transform: scale(1); }
        }
        #callConversation {
            flex-grow: 1;
            width: 100%;
            max-width: 600px;
            overflow-y: auto;
            margin: 20px 0;
            border: 1px solid var(--fade-blue);
            border-radius: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            box-sizing: border-box;
        }
        .call-msg {
            padding: 8px 12px;
            border-radius: 10px;
            margin-bottom: 10px;
            line-height: 1.5;
            word-break: break-word;
        }
        .call-msg.user {
            background: var(--gradient-user);
            color: var(--submit-text);
            text-align: right;
            margin-left: auto;
            max-width: 80%;
        }
        .call-msg.bot {
            background: var(--gradient-1);
            color: var(--main-text);
            margin-right: auto;
            max-width: 80%;
        }
        .call-msg.status { text-align: center; color: #888; font-style: italic; background: none; }
        #callControls {
            display: flex;
            gap: 20px;
            padding-bottom: 20px;
            margin-top: auto;
        }
        #endCallBtn, #muteCallBtn {
            background: #d23;
            color: white;
            font-size: 1.2em;
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 10px #d2388;
            transition: background .1s, box-shadow .1s;
        }
        #endCallBtn:hover, #muteCallBtn:hover { background: #ff7777; box-shadow: 0 0 15px #ff7777aa; }
        #muteCallBtn {
            background: #007bff; /* Default blue for unmute */
            box-shadow: 0 0 10px #007bff88;
        }
        #muteCallBtn.muted {
            background: #555; /* Grey when muted */
            box-shadow: none;
        }
        #muteCallBtn.muted:hover { background: #777; }

        /* --- Keyframe Animations --- */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        /* --- Responsive Design --- */
        @media (max-width: 920px) {
            .chat-input-row {
                width: 95vw;
                max-width: 100%;
                left: 50%;
                transform: translateX(-50%);
                border-radius: 22px 22px 8px 8px;
            }
        }
        @media (max-width: 790px) {
            .chat-box { max-width:100vw; padding: 15px 4px; }
            #typing-status { padding: 0 4px 10px 4px; }
            .chat-message .msg { font-size: .97em; padding:9px 4vw 10px 5vw; max-width:80vw;}
            .chat-message.user .msg { max-width: 83vw; }
            .header-bar { height: 60px; }
            .main-content { padding-top: 60px; }
            .header-bar .menu-btn { font-size: 1.7em; padding: 5px 9px; margin-left: 10px; }
            #themeBtn { margin-left: -5px; }
            .site-heading { font-size: 1.1em; letter-spacing: .15px; margin-left: 5px; margin-right: 5px; }
            .side-panel { width: 280px; padding: 15px; }
            #emojiPanel { bottom: 95px; }
            .file-preview { bottom: 85px; max-width: 90vw; }
        }
    </style>
</head>
<body>
    <div id="stars-container"></div>

    <!-- Header Bar -->
    <header class="header-bar">
        <button class="menu-btn" id="openProfileMenu" aria-label="Open profile menu"><i class="fa-solid fa-user"></i></button>
        <div class="header-titles">
            <h1 class="site-heading">ðŸ¦…Philadelphia AIðŸ¦…</h1>
            <p class="header-welcome" id="headerWelcome"></p>
        </div>
        <button class="menu-btn" id="themeBtn" aria-label="Change theme"><i class="fa-solid fa-moon"></i></button>
        <button class="menu-btn" id="openLinksMenu" aria-label="Open links menu"><i class="fa-solid fa-link"></i></button>
    </header>

    <!-- Main Chat Content Area -->
    <main class="main-content">
        <div class="chat-box" id="chatBox">
            <!-- Chat messages will be dynamically inserted here -->
        </div>

        <!-- Typing Indicator (AI response pending) -->
        <div id="typing-status" class="chat-message ai" style="display: none;"></div>

        <!-- Chat Input Form -->
        <form class="chat-input-row" id="chatForm" autocomplete="off">
            <button type="button" id="emojiBtn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>
            <label for="chatFile" class="file-upload-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label>
            <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
            <textarea id="chatInput" placeholder="Type hereâ€¦ (Shift+Enter for new line, Enter to send)"></textarea>
            <button type="button" id="callBtn" title="Start Voice Call"><i class="fa-solid fa-phone"></i></button>
            <button type="button" id="toolBtn" title="Philadelphia Tools" aria-controls="toolMenu" aria-expanded="false"><i class="fa-solid fa-wrench"></i></button>
            <button type="submit" id="sendBtn" title="Send"><i class="fa-solid fa-paper-plane"></i></button>
        </form>
    </main>

    <!-- Global Modals & Panels -->

    <!-- Emoji Picker Panel -->
    <div id="emojiPanel" role="dialog" aria-modal="true" aria-label="Emoji Picker"></div>

    <!-- General Status Message Display -->
    <div class="status-message" id="statusMsg"></div>

    <!-- File Preview for Attachments -->
    <div id="filePreview" class="file-preview" role="alert" aria-live="polite"></div>

    <!-- AI Generated Image Preview (Floating) -->
    <div id="ai-image-preview" role="dialog" aria-modal="false" aria-label="AI Generated Image">
        <button id="ai-image-close" aria-label="Close image preview">&times;</button>
        <div id="ai-image-container"></div>
        <button id="ai-image-dl"><i class="fa-solid fa-download"></i> Download</button>
    </div>

    <!-- Profile & Chats Side Panel -->
    <div class="panel-bg" id="profileMenuBg">
        <nav class="side-panel" id="profileMenu" role="navigation" aria-label="Profile and Chats">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:1.17em;font-weight:700;color:#00ffff;margin:18px 0 0 13px;">Chats</span>
                <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;" onclick="profileMenuBg.classList.remove('active');" aria-label="Close profile menu">&times;</button>
            </div>
            <div id="chatsList" style="margin:7px 0 8px 6px;max-height:161px;overflow-y:auto;">
                <div class="spinner" style="margin: 20px auto; display: block;"></div>
                <p style="padding: 10px; color: #a8eaff; display: none;" id="noChatsMessage">No chats yet. Create one!</p>
            </div>
            <button id="newChatBtn" class="submit-btn" style="margin:0 0 12px 11px;"><i class="fa-solid fa-plus"></i> New Chat</button>
            <hr style="width:91%;margin:11px 0 7px 3%;border:1px solid #00fff031;">
            <div class="panel-header">
                <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profileMenuUser">User</div>
                <div class="email" id="profileMenuEmail">email@example.com</div>
            </div>
            <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;">
                <label for="edit-name">Name</label>
                <input type="text" id="edit-name" required>
                <label for="edit-photo">Photo URL</label>
                <input type="url" id="edit-photo" placeholder="Paste image link">
                <span style="font-size:0.83em;color:#aae;display:block;margin:5px 0 7px 2px;">
                    Tip: <a href="https://postimg.cc/" target="_blank" rel="noopener noreferrer" style="color:#19fcff;">Upload at postimg.cc</a>
                </span>
                <button type="submit" class="submit-btn">Save Profile</button>
                <div class="status-message" id="profileStatusMsg"></div>
            </form>
            <button class="submit-btn" id="logoutBtn" style="background:#10213b;color:#00eefd;margin:7px 7px 17px 7px;"><i class="fa-solid fa-right-from-bracket"></i> Logout</button>
        </nav>
    </div>

    <!-- External Links Side Panel -->
    <div class="panel-bg" id="linkMenuBg">
        <nav class="side-panel" id="linkMenu" role="navigation" aria-label="External Links">
            <button style="position: absolute; top: 18px; right: 16px; font-size: 1.55em; color: #f44; background: transparent; border: none; cursor: pointer; border-radius: 7px;" onclick="linkMenuBg.classList.remove('active');" aria-label="Close links menu">&times;</button>
            <div class="panel-header">
                <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia AI logo">
                <div class="username">Philadelphia AI</div>
            </div>
            <div class="panel-links">
                <a href="philadelphia.html"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a>
                <a href="index.html"><i class="fa-solid fa-home"></i>Elvion Homepage</a>
                <a href="about.html"><i class="fa-solid fa-circle-info"></i> About US</a>
                <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
                <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms</a>
                <a href="https://t.me/writingurubot" target="_blank" rel="noopener noreferrer"><i class="fab fa-telegram"></i> Try Telegram Version</a>
            </div>
        </nav>
    </div>

    <!-- AI Tools Side Panel -->
    <div class="panel-bg" id="toolsMenuBg">
        <nav class="side-panel" id="toolsMenu" role="navigation" aria-label="AI Tools">
            <button style="position: absolute; top: 18px; right: 16px; font-size: 1.55em; color: #f44; background: transparent; border: none; cursor: pointer; border-radius: 7px;" onclick="closeToolMenu();" aria-label="Close tools menu">&times;</button>
            <div class="panel-header" style="text-align:left;">
                <div class="username" style="font-size:1.2em;margin-left:-8px;text-align:center;">Philadelphia AI Tools</div>
            </div>
            <div class="panel-links">
                <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Creative Suite</h3>
                <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
                <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
                <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a>
                <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a>
                <hr style="border-color: #00eaff30; margin: 10px 0;">
                <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Audio & Video</h3>
                <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
                <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
                <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a>
                <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
                <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a>
                <hr style="border-color: #00eaff30; margin: 10px 0;">
                <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Web & Research</h3>
                <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a>
                <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
                <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a>
                <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
            </div>
            <button class="submit-btn" style="margin-top:17px;" onclick="closeToolMenu();"><i class="fa-solid fa-times"></i> Close</button>
        </nav>
    </div>

    <!-- Tool Form Modal (Appears when a tool is selected) -->
    <div class="panel-bg" id="toolFormModalBg">
        <nav class="side-panel" id="toolFormModal" role="dialog" aria-modal="true" aria-label="Tool Form">
            <button style="position: absolute; top: 18px; right: 16px; font-size: 1.55em; color: #f44; background: transparent; border: none; cursor: pointer; border-radius: 7px;" onclick="toolFormModalBg.classList.remove('active'); openToolMenu();" aria-label="Close tool form">&times;</button>
            <div class="panel-header">
                <div class="username" id="toolFormTitle">Tool Title</div>
            </div>
            <form class="edit-form" id="toolForm" style="padding:0 6px;"></form>
            <button id="toolFormBackBtn" class="submit-btn" style="background:#10213b;color:#00eefd;margin:7px 7px 17px 7px;">
                <i class="fa-solid fa-arrow-left"></i> Back to Tools
            </button>
            <div class="status-message" id="toolStatusMsg"></div>
        </nav>
    </div>

    <!-- Full-screen Image Lightbox -->
    <div id="lightbox" role="dialog" aria-modal="true" aria-label="Image viewer">
        <img src="" alt="Lightbox image">
    </div>

    <!-- Voice Call Modal -->
    <div id="callModal" role="dialog" aria-modal="true" aria-label="Voice Call">
        <h2 id="callHeader">Philadelphia AI - Live Call</h2>
        <div id="botImageContainer">
            <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Bot avatar">
            <div id="botSpeakingIndicator"></div>
        </div>
        <p id="callStatusMessage">Connecting...</p>
        <p id="tapToTalk">Tap Anywhere to Speak</p>
        <div id="callConversation" role="log" aria-live="polite">
            <div class="call-msg status">Waiting for connection...</div>
        </div>
        <div id="callControls">
            <button id="muteCallBtn" class="submit-btn"><i class="fa-solid fa-microphone"></i> Mute Microphone</button>
            <button id="endCallBtn" class="submit-btn" style="background: #d23;"><i class="fa-solid fa-phone-slash"></i> End Call</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        // --- START OF FULLY REVAMPED & FIRESTORE-INTEGRATED JAVASCRIPT ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        // Firebase Configuration (Replace with your actual config)
        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Global State Management ---
        let chats = []; // Array of {id, name, createdAt}
        let currentChatId = null;
        let currentMessages = []; // Array of {id, role, text, files, createdAt}
        let uploadedFiles = []; // Files staged for the next user message
        let currentUser = null;
        let currentController = null; // AbortController for ongoing fetch requests
        let chatsUnsubscribe = null; // Firestore listener unsubscriber for chats
        let messagesUnsubscribe = null; // Firestore listener unsubscriber for messages

        // API Base URL for backend services
        const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

        // --- Utility Functions ---
        const $ = id => document.getElementById(id);
        const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

        // Safely converts Blob to Base64 for storing in DB
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // --- Markdown Rendering for Chat Messages ---
        function inlineMarkdown(text = '') {
            let processedText = String(text)
                .replace(/`([^`]+?)`/g, (_, code) => `<code>${escapeHTML(code)}</code>`) // Inline code
                .replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>'); // Italic
            processedText = processedText.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>'); // Links
            return processedText.replace(/\n/g, '<br>'); // Newlines to <br>
        }

        function renderMarkdown(text = '') {
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            let html = '';
            let lastIndex = 0;

            text = text || ''; // Ensure text is a string

            text.replace(codeBlockRegex, (match, lang, code, offset) => {
                // Render content before the code block
                const before = text.slice(lastIndex, offset);
                html += inlineMarkdown(before);

                // Render the code block
                const language = (lang || '').toLowerCase().trim();
                const safeCode = escapeHTML(code);
                html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safeCode}</code></pre>`;
                lastIndex = offset + match.length;
                return match; // Return original match to continue `replace` iteration
            });

            // Render any remaining content after the last code block
            html += inlineMarkdown(text.slice(lastIndex));
            return { html };
        }

        // Applies Highlight.js and adds copy buttons to code blocks
        function enhanceCodeBlocks(container) {
            if (!container) return;
            container.querySelectorAll('pre').forEach(pre => {
                const codeEl = pre.querySelector('code');
                if (window.hljs && codeEl) {
                    try {
                        hljs.highlightElement(codeEl);
                    } catch (e) { /* ignore highlight error */ }
                }
                const btn = pre.querySelector('.copy-btn');
                if (btn && codeEl) {
                    btn.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard.writeText(codeEl.innerText);
                            const prev = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => btn.textContent = prev, 800);
                        } catch (e) {
                            btn.textContent = 'Failed';
                            setTimeout(() => btn.textContent = 'Copy', 800);
                        }
                    });
                }
            });
        }

        // --- Chat Message Rendering ---
        function renderChatBox(messages = []) {
            if (!chatBox) return;
            chatBox.innerHTML = ''; // Clear existing messages

            (messages || []).forEach((msg) => {
                const div = document.createElement('div');
                div.className = `chat-message ${msg.role === 'user' ? 'user' : 'ai'}`;
                div.setAttribute('data-message-id', msg.id);

                let contentHtml = '';
                if (msg.role === 'user') {
                    // Render attached files if any
                    const fileHtml = (msg.files || [])
                        .map(file => {
                            let icon = 'fa-file';
                            if (file.type.startsWith('image/')) icon = 'fa-file-image';
                            else if (file.type.startsWith('video/')) icon = 'fa-file-video';
                            else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
                            else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                            return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                        })
                        .join('');

                    contentHtml = `
                        ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                        ${escapeHTML(msg.text || '')}
                        <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                            <button class="inline-edit-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i> Edit</button>
                            <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i> Copy</button>
                        </div>
                    `;
                } else {
                    // AI message: handle raw HTML for tool outputs (media) or markdown for text
                    let messageBody;
                    if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                        messageBody = msg.text; // Render raw HTML for tool outputs
                    } else {
                        messageBody = renderMarkdown(msg.text || '').html;
                    }

                    contentHtml = `
                        ${messageBody}
                        <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                            <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i> Copy</button>
                            <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i> Share</button>
                            <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i> Regenerate</button>
                        </div>
                    `;
                }
                div.innerHTML = `<div class="msg">${contentHtml}</div>`;
                chatBox.appendChild(div);
            });

            enhanceCodeBlocks(chatBox);
            hookAiMsgControls();
            hookUserMsgControls();

            // Auto-scroll to bottom after rendering
            setTimeout(() => {
                chatBox.scrollTop = chatBox.scrollHeight;
            }, 50);
        }

        // --- Message Control Event Handlers (Copy, Edit, Regenerate, Share) ---
        async function deleteMessagesFrom(messageId) {
            if (!currentChatId || !currentUser) return;
            const msgIndex = currentMessages.findIndex(m => m.id === messageId);
            if (msgIndex === -1) return;

            const batch = writeBatch(db);
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');

            // Delete the message itself and all subsequent messages
            for (let i = msgIndex; i < currentMessages.length; i++) {
                const msgToDel = currentMessages[i];
                const docRef = doc(messagesCol, msgToDel.id);
                batch.delete(docRef);
            }
            try {
                await batch.commit();
                // UI will auto-update via the onSnapshot listener
            } catch (e) {
                console.error("Error deleting messages: ", e);
                statusMsg.textContent = "Error deleting messages.";
                statusMsg.style.color = "#ff4444";
            }
        }

        function hookAiMsgControls() {
            if (!chatBox) return;
            chatBox.querySelectorAll('.chat-message.ai').forEach(div => {
                const messageId = div.getAttribute('data-message-id');
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;

                const controls = div.querySelector('.ai-msg-controls');
                if (!controls) return;

                const copyBtn = controls.querySelector('.inline-copy-btn');
                const shareBtn = controls.querySelector('.inline-share-btn');
                const regenBtn = controls.querySelector('.regen-btn');

                if (copyBtn) copyBtn.onclick = () => {
                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.text;
                        const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                        navigator.clipboard.writeText(textToCopy);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy", 950);
                    } catch (e) {
                        console.warn('Copy failed:', e);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Failed";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy", 950);
                    }
                };

                if (shareBtn) shareBtn.onclick = () => {
                    try {
                        const url = window.location.origin;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.text;
                        const plainText = tempDiv.textContent || tempDiv.innerText || '';
                        const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;
                        if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
                        else prompt("Copy and share manually:", shareText);
                    } catch (e) {
                        console.warn('Share failed:', e);
                    }
                };

                if (regenBtn) regenBtn.onclick = async () => {
                    const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                    if (msgIndex < 1) return; // Cannot regenerate the very first message
                    const userMsg = currentMessages[msgIndex - 1];
                    if (userMsg.role !== 'user') return; // Preceding message wasn't user's prompt

                    await deleteMessagesFrom(messageId); // Delete this AI message and all subsequent ones

                    chatInput.value = userMsg.text; // Load user's prompt into input
                    chatInput.style.height = 'auto'; // Reset height
                    chatInput.style.height = Math.min(chatInput.scrollHeight, 168) + 'px';
                    uploadedFiles = []; // Clear files (files are handled separately via db entry)
                    renderFilePreview();

                    showTypingAtNext(); // Show "thinking..." immediately

                    // Build history for regeneration, excluding the user's prompt and subsequent AI responses
                    const historyForRegen = currentMessages
                        .slice(0, msgIndex - 1)
                        .map(m => ({ role: m.role, content: m.text || '' }));

                    try {
                        const res = await fetch(`${API_BASE_URL}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                message: userMsg.text,
                                history: historyForRegen,
                                user_id: currentUser?.uid || "user"
                            })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || "Server error.");
                        removeTyping();
                        await startTypewriter(data.response, false); // Typewriter effect, don't save (onSnapshot will handle it)
                    } catch (err) {
                        removeTyping();
                        await startTypewriter(`âŒ Regeneration error: ${err.message}`, false);
                    }
                };
            });
        }

        function hookUserMsgControls() {
            if (!chatBox) return;
            chatBox.querySelectorAll('.chat-message.user').forEach(div => {
                const messageId = div.getAttribute('data-message-id');
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;

                const controls = div.querySelector('.user-msg-controls');
                if (!controls) return;

                const copyBtn = controls.querySelector('.inline-copy-btn');
                const editBtn = controls.querySelector('.inline-edit-btn');

                if (copyBtn) copyBtn.onclick = () => {
                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.text;
                        const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                        navigator.clipboard.writeText(textToCopy);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy", 950);
                    } catch (e) {
                        console.warn('Copy failed:', e);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Failed";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy", 950);
                    }
                };

                if (editBtn) editBtn.onclick = async () => {
                    try {
                        if (!msg.text) return;
                        chatInput.value = msg.text;
                        chatInput.focus();
                        // Delete this message and all subsequent messages
                        await deleteMessagesFrom(messageId); // UI will update via onSnapshot
                    } catch (e) {
                        console.warn('Edit failed:', e);
                        statusMsg.textContent = "Error editing message.";
                        statusMsg.style.color = "#ff4444";
                    }
                };
            });
        }

        // --- Typing Indicator Functions ---
        function showTypingAtNext() {
            if (!typingStatus) return;
            typingStatus.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span></div>`;
            typingStatus.style.display = 'flex';
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function showTypingWithText(text) {
            if (!typingStatus) return;
            typingStatus.innerHTML = `<div class="msg" style="display:flex;align-items:center;"><span class="spinner"></span> <span style="margin-left:8px; color:var(--main-text); font-style:italic;">${escapeHTML(text)}</span></div>`;
            typingStatus.style.display = 'flex';
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function removeTyping() {
            if (!typingStatus) return;
            typingStatus.style.display = 'none';
            typingStatus.innerHTML = '';
        }

        // --- Typewriter Effect for AI Responses ---
        async function startTypewriter(text, saveToDb = true) {
            // If response includes raw HTML for media, skip typewriter and save/render directly
            if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) {
                if (saveToDb) {
                    await addMessageToChat('ai', text); // Save full HTML to DB
                } else {
                    // For regeneration, if we skip typewriter, we still need to add it to the chatbox
                    // and manually save it as the regen logic relies on it being *not* saved to DB yet (saveToDb=false)
                    const tempDiv = document.createElement('div');
                    tempDiv.className = "chat-message ai";
                    tempDiv.innerHTML = `<div class="msg">${text}</div>`;
                    chatBox.appendChild(tempDiv);
                    chatBox.scrollTop = chatBox.scrollHeight;
                    // Now manually save the regen response
                    const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                    try {
                        await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
                    } catch (e) {
                        console.error("Error saving regenerated AI tool message: ", e);
                    }
                }
                return;
            }

            if (!chatBox) return;

            // Create a temporary message node for the animation
            const div = document.createElement('div');
            div.className = "chat-message ai";
            const msgdiv = document.createElement('div');
            msgdiv.className = 'msg';
            div.appendChild(msgdiv);
            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;

            let currentRenderedText = '';
            const words = text.split(/(\s+)/); // Split on spaces, keeping them for realistic typing

            for (const word of words) {
                if (currentController?.signal.aborted) {
                    text = currentRenderedText; // Abort: set text to what was rendered so far
                    break;
                }

                currentRenderedText += word;

                // Simple check for unclosed code blocks to prevent partial rendering issues
                // This is an approximation; a full markdown parser would be more robust.
                const openCodeBlocks = (currentRenderedText.match(/```/g) || []).length;
                if (openCodeBlocks % 2 === 0) { // If all code blocks are closed, render as markdown
                    msgdiv.innerHTML = renderMarkdown(currentRenderedText).html;
                } else { // Otherwise, just append raw text to avoid breaking markdown rendering
                    msgdiv.textContent = currentRenderedText;
                }

                chatBox.scrollTop = chatBox.scrollHeight;
                const delay = word.match(/[\s.,!?]/) ? 10 : 30; // Faster for symbols/spaces
                await new Promise(res => setTimeout(res, delay));
            }

            // Ensure final content is correctly rendered as markdown
            const finalRenderText = text;
            msgdiv.innerHTML = renderMarkdown(finalRenderText).html + `
                <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                    <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i> Copy</button>
                    <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i> Share</button>
                    <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i> Regenerate</button>
                </div>
            `;
            enhanceCodeBlocks(msgdiv);
            chatBox.scrollTop = chatBox.scrollHeight;

            // Save the final message to Firestore if needed
            if (saveToDb) {
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesCol, { role: 'ai', text: finalRenderText, createdAt: serverTimestamp() });
                    // onSnapshot listener will update UI seamlessly, replacing temp node with persistent one
                } catch (e) {
                    console.error("Error saving AI message: ", e);
                    msgdiv.innerHTML += "<br><small style='color: #f44;'>Failed to save message.</small>";
                }
            }
        }

        // --- File Preview Management ---
        function renderFilePreview() {
            if (!filePreview) return;
            if (!uploadedFiles.length) {
                filePreview.style.display = 'none';
                filePreview.innerHTML = '';
                return;
            }

            filePreview.style.display = 'block';
            filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                let preview = '';
                if (file.type.startsWith('image/')) {
                    preview = `<img src="${URL.createObjectURL(file)}" alt="Image Preview" style="max-width:58px;max-height:41px;vertical-align:middle;border-radius:8px;margin-right:6px;">`;
                } else if (file.type.startsWith('video/')) {
                    preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:58px;height:41px;vertical-align:middle;border-radius:8px;margin-right:7px;"></video>`;
                } else if (file.type.startsWith('audio/')) {
                    preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:52px;margin-right:7px;"></audio>`;
                } else if (file.type === 'application/pdf') {
                    preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`;
                }
                return `
                    <div style="display:flex;align-items:center;gap:7px;margin-bottom:1px;">
                        ${preview}
                        <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span>
                        <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
                    </div>`;
            }).join('');

            filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.getAttribute('data-idx'));
                    uploadedFiles.splice(idx, 1);
                    if (!uploadedFiles.length && chatFile) chatFile.value = ''; // Clear input if no files left
                    renderFilePreview();
                });
            });
        }

        // --- AI Image Floating Preview ---
        function showAIImagePreview(base64, caption = '') {
            if (!aiPrevBox || !aiPrevImgBox) return;
            aiPrevImgBox.innerHTML = `
                <img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:210px;max-height:210px;border-radius:12px;display:block;">
                <div style="color:#aee;font-size:.95em;margin-top:3px;text-align:center;">${escapeHTML(caption)}</div>
            `;
            aiPrevBox.style.display = 'block';
        }

        // --- Firebase Firestore Chat & Message Management ---
        async function addMessageToChat(role, text, files = []) {
            if (!currentChatId || !currentUser) return;
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            try {
                await addDoc(messagesCol, {
                    role,
                    text,
                    files, // Store array of {name, type} for history
                    createdAt: serverTimestamp()
                });
                // UI update handled by onSnapshot listener
            } catch (e) {
                console.error("Error adding message to Firestore: ", e);
                statusMsg.textContent = "Error saving message.";
                statusMsg.style.color = "#ff4444";
            }
        }

        async function loadUserChats(userId) {
            if (chatsUnsubscribe) chatsUnsubscribe(); // Unsubscribe from previous listener

            const chatsCol = collection(db, 'users', userId, 'chats');
            const q = query(chatsCol, orderBy('createdAt', 'desc'));

            chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                if (chats.length === 0) {
                    $('noChatsMessage').style.display = 'block';
                    await createNewChat(userId); // Create a new chat if none exist
                    // The listener will re-run with the new chat, so we return here.
                    return;
                } else {
                    $('noChatsMessage').style.display = 'none';
                }

                renderChatsListSidebar();

                // If no chat is selected, or the selected chat was deleted, select the newest one
                if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                    currentChatId = chats.id;
                    subscribeToMessages(userId, currentChatId); // Subscribe to messages for the newly selected chat
                }
            }, (error) => {
                console.error("Error fetching chats: ", error);
                chatsListEl.innerHTML = `<div style="color: #f44;">Error loading chats.</div>`;
            });
        }

        async function createNewChat(userId) {
            if (!userId) userId = currentUser?.uid;
            if (!userId) {
                console.error("Cannot create chat: User ID not available.");
                return;
            }
            const chatsCol = collection(db, 'users', userId, 'chats');
            try {
                // Add a new chat with a default name, the listener will pick it up
                const newChatDoc = await addDoc(chatsCol, { name: "New Chat", createdAt: serverTimestamp() });
                currentChatId = newChatDoc.id; // Set new chat as current
                // No need to manually switch, the loadUserChats listener will handle the re-render and message subscription
            } catch (e) {
                console.error("Error creating new chat: ", e);
                statusMsg.textContent = "Error creating new chat.";
                statusMsg.style.color = "#ff4444";
            }
        }

        function subscribeToMessages(userId, chatId) {
            if (messagesUnsubscribe) messagesUnsubscribe(); // Unsubscribe from old listener

            if (!userId || !chatId) {
                renderChatBox([]); // Clear chat box if no chat is selected
                return;
            }

            const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
            const q = query(messagesCol, orderBy('createdAt'));

            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderChatBox(currentMessages);
            }, (error) => {
                console.error("Error fetching messages: ", error);
                chatBox.innerHTML = `<div style="color: #f44; text-align: center; margin-top: 20px;">Error loading messages for this chat.</div>`;
            });
        }

        // --- UI Initialization and Event Listeners (DOMContentLoaded) ---
        window.addEventListener('DOMContentLoaded', () => {
            // Element References
            const starsContainer = $('stars-container');
            const profileMenuBg = $('profileMenuBg');
            const profileMenu = $('profileMenu');
            const linkMenuBg = $('linkMenuBg');
            const linkMenu = $('linkMenu');
            const toolsMenuBg = $('toolsMenuBg');
            const toolsMenu = $('toolsMenu');
            const toolBtn = $('toolBtn');
            const logoutBtn = $('logoutBtn');
            const headerWelcome = $('headerWelcome');
            const profileMenuUser = $('profileMenuUser');
            const profileMenuEmail = $('profileMenuEmail');
            const editName = $('edit-name');
            const editPhoto = $('edit-photo');
            const profilePicPreview = $('profilePicPreview');
            const profileForm = $('profileForm');
            const chatBox = $('chatBox');
            const chatForm = $('chatForm');
            const chatInput = $('chatInput');
            const sendBtn = $('sendBtn');
            const chatFile = $('chatFile');
            const filePreview = $('filePreview');
            const newChatBtn = $('newChatBtn');
            const chatsListEl = $('chatsList');
            const emojiPanel = $('emojiPanel');
            const emojiBtn = $('emojiBtn');
            const toolFormModalBg = $('toolFormModalBg');
            const toolForm = $('toolForm');
            const toolFormTitle = $('toolFormTitle');
            const toolFormBackBtn = $('toolFormBackBtn');
            const aiPrevBox = $('ai-image-preview');
            const aiPrevClose = $('ai-image-close');
            const aiPrevDLBtn = $('ai-image-dl');
            const aiPrevImgBox = $('ai-image-container');
            const themeBtn = $('themeBtn');
            const lightbox = $('lightbox');
            const callBtn = $('callBtn');
            const callModal = $('callModal');
            const endCallBtn = $('endCallBtn');
            const muteCallBtn = $('muteCallBtn');
            const callConversation = $('callConversation');
            const botImageContainer = $('botImageContainer');
            const callStatusMessage = $('callStatusMessage');
            const tapToTalk = $('tapToTalk');
            const typingStatus = $('typing-status');
            const statusMsg = $('statusMsg'); // Global status message element

            // Basic UI element check
            if (!chatForm || !chatBox || !toolsMenu || !typingStatus || !statusMsg) {
                console.error("Essential UI elements are missing. App functionality will be limited.");
                return;
            }

            // --- Star Field Initialization ---
            if (starsContainer) {
                starsContainer.innerHTML = '';
                for (let i = 0; i < 34; i++) {
                    const s = document.createElement('div');
                    s.className = 'star';
                    const z = Math.random() * 2.1 + 1;
                    s.style.width = z + 'px';
                    s.style.height = z + 'px';
                    s.style.left = Math.random() * 100 + '%';
                    s.style.top = Math.random() * 100 + '%';
                    s.style.animationDelay = (Math.random() * 3.69) + 's';
                    s.style.animationDuration = (2.2 + Math.random() * 1.1) + 's';
                    starsContainer.appendChild(s);
                }
            }

            // --- Emoji Panel Logic ---
            const emojis = ["ðŸ˜€","ðŸ˜‚","ðŸ˜","ðŸ¥°","ðŸ˜Ž","ðŸ‘","ðŸ™","ðŸ”¥","ðŸ’¯","ðŸŽ‰","ðŸ˜‡","ðŸ¤–","ðŸ‘€"];
            if (emojiBtn && emojiPanel && chatInput) {
                emojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent document click from immediately closing
                    emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
                    emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block';
                    try {
                        const rect = emojiBtn.getBoundingClientRect();
                        emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
                    } catch (e) { /* ignore positioning errors */ } // Fallback if getBoundingClientRect fails

                    emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
                        span.addEventListener('click', function () {
                            const text = this.textContent || '';
                            const start = chatInput.selectionStart || 0;
                            const end = chatInput.selectionEnd || 0;
                            chatInput.value = chatInput.value.slice(0, start) + text + chatInput.value.slice(end);
                            chatInput.focus();
                            chatInput.selectionStart = chatInput.selectionEnd = start + text.length;
                            emojiPanel.style.display = 'none';
                            chatInput.dispatchEvent(new Event('input')); // Trigger auto-resize
                        });
                    });
                });
                document.addEventListener('click', e => {
                    if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
                        emojiPanel.style.display = 'none';
                    }
                });
            }

            // --- Chat Input Auto-Resize & Send Logic ---
            if (chatInput) {
                const autoResize = () => {
                    chatInput.style.height = 'auto'; // Reset height
                    chatInput.style.height = Math.min(chatInput.scrollHeight, 168) + 'px'; // Set to scrollHeight, max 168px
                };
                chatInput.addEventListener('input', autoResize);
                chatInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Prevent default new line behavior for Enter
                        chatForm.requestSubmit(); // Submit form on Enter key
                    } else if (e.key === 'Enter' && e.shiftKey) {
                        // Shift+Enter will naturally add a new line without preventing default.
                        // We do nothing specific here, allowing the browser to handle new line.
                    }
                });
                autoResize(); // Initial resize
            }

            // --- File Input Change Handler ---
            if (chatFile) {
                chatFile.addEventListener('change', function() {
                    uploadedFiles = Array.from(this.files || []);
                    renderFilePreview();
                });
            }

            // --- AI Image Preview Actions ---
            if (aiPrevClose) aiPrevClose.addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
            if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
                const img = aiPrevImgBox.querySelector('img');
                if (img) {
                    const a = document.createElement('a');
                    a.href = img.src;
                    a.download = 'philadelphia_ai_image.png';
                    a.click();
                }
            });

            // --- Image Lightbox Handler ---
            if (lightbox) {
                lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
            }
            if (chatBox) {
                chatBox.addEventListener('click', e => {
                    if (e.target.tagName === 'IMG' && e.target.closest('.chat-message.ai .msg')) {
                        e.preventDefault();
                        const lbImg = lightbox.querySelector('img');
                        if (lbImg) {
                            lbImg.src = e.target.src;
                            lightbox.classList.add('active');
                        }
                    }
                });
            }

            // --- Panel & Modal Management ---
            window.closeToolMenu = () => { // Global function for closing tool menu
                if (toolsMenuBg) {
                    toolsMenu.style.left = '-350px';
                    toolsMenuBg.classList.remove('active');
                }
            };
            window.openToolMenu = () => { // Global function for opening tool menu
                if (toolsMenuBg) {
                    toolsMenuBg.classList.add('active');
                    toolsMenu.style.left = '0';
                }
            };

            const togglePanel = (menuBg, menu) => {
                const isActive = menuBg.classList.contains('active');
                if (isActive) {
                    menu.style.left = '-350px'; // Slide out
                    menuBg.classList.remove('active');
                } else {
                    menuBg.classList.add('active');
                    menu.style.left = '0'; // Slide in
                }
            };

            if (profileMenuBg) {
                $('openProfileMenu').addEventListener('click', () => togglePanel(profileMenuBg, profileMenu));
                profileMenuBg.addEventListener('click', e => {
                    if (e.target === profileMenuBg) togglePanel(profileMenuBg, profileMenu);
                });
            }

            if (linkMenuBg) {
                $('openLinksMenu').addEventListener('click', () => togglePanel(linkMenuBg, linkMenu));
                linkMenuBg.addEventListener('click', e => {
                    if (e.target === linkMenuBg) togglePanel(linkMenuBg, linkMenu);
                });
            }

            if (toolBtn) toolBtn.addEventListener('click', openToolMenu); // Open tool menu
            if (toolsMenuBg) toolsMenuBg.addEventListener('click', e => { if (e.target === toolsMenuBg) closeToolMenu(); });

            if (toolFormBackBtn) {
                toolFormBackBtn.addEventListener('click', () => {
                    toolFormModal.style.left = '-350px';
                    toolFormModalBg.classList.remove('active');
                    openToolMenu(); // Go back to tools menu
                });
            }
            if (toolFormModalBg) toolFormModalBg.addEventListener('click', e => {
                if (e.target === toolFormModalBg) {
                    toolFormModal.style.left = '-350px';
                    toolFormModalBg.classList.remove('active');
                }
            });

            // --- Logout Functionality ---
            if (logoutBtn) logoutBtn.addEventListener('click', () => {
                auth.signOut().then(() => {
                    window.location.href = 'signup-login.html'; // Redirect on successful logout
                }).catch(error => {
                    console.error("Logout error:", error);
                    statusMsg.textContent = "Logout failed: " + error.message;
                    statusMsg.style.color = "#ff4444";
                });
            });

            // --- Authentication & Profile Management ---
            onAuthStateChanged(auth, user => {
                if (!user) {
                    try { window.location.href = "signup-login.html"; } catch (e) {} // Redirect to login if no user
                    return;
                }
                currentUser = user;
                if (headerWelcome) headerWelcome.textContent = "Welcome, " + (user.displayName || (user.email || '').split('@'));
                if (profileMenuUser) profileMenuUser.textContent = user.displayName || "User";
                if (profileMenuEmail) profileMenuEmail.textContent = user.email || "";
                if (editName) editName.value = user.displayName || "";
                if (editPhoto) editPhoto.value = user.photoURL || "";
                if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

                loadUserChats(user.uid); // Start loading chats after user authenticates
            });

            // Profile Form Submission
            if (profileForm) {
                profileForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!currentUser) return;

                    const status = $('profileStatusMsg');
                    if (status) {
                        status.textContent = '<div class="spinner"></div> Saving...';
                        status.style.color = "#00ffff";
                    }

                    try {
                        await updateProfile(currentUser, {
                            displayName: editName.value,
                            photoURL: editPhoto.value
                        });
                        if (auth.currentUser) await auth.currentUser.reload(); // Refresh user token/info

                        if (status) {
                            status.textContent = "Profile updated!";
                            status.style.color = "#00ffff";
                        }
                        // Close profile menu after successful update
                        setTimeout(() => { profileMenuBg?.classList.remove('active'); }, 800);
                        if (headerWelcome) headerWelcome.textContent = "Welcome, " + (auth.currentUser?.displayName || 'User');
                    } catch (err) {
                        console.error("Profile update error:", err);
                        if (status) {
                            status.textContent = `Error: ${err.message}`;
                            status.style.color = "#ffd700";
                        }
                    }
                });
            }

            // --- Render Chats List in Sidebar ---
            function renderChatsListSidebar() {
                if (!chatsListEl) return;
                chatsListEl.innerHTML = ''; // Clear previous list

                if (chats.length === 0) {
                    $('noChatsMessage').style.display = 'block';
                    return;
                } else {
                    $('noChatsMessage').style.display = 'none';
                }

                chats.forEach((chat) => {
                    const container = document.createElement('div');
                    container.style.display = 'flex';
                    container.style.alignItems = 'center';
                    container.style.marginBottom = '6px';
                    container.style.background = chat.id === currentChatId ? 'rgba(0, 234, 255, 0.15)' : 'transparent';
                    container.style.borderRadius = '8px';
                    container.style.paddingRight = '5px'; // Padding for buttons

                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = escapeHTML(chat.name || `Chat`);
                    titleSpan.style.flex = '1';
                    titleSpan.style.cursor = 'pointer';
                    titleSpan.style.padding = '8px 5px 8px 10px';
                    titleSpan.title = chat.name;
                    titleSpan.onclick = () => {
                        currentChatId = chat.id;
                        subscribeToMessages(currentUser.uid, currentChatId);
                        renderChatsListSidebar(); // Re-render to show selection
                        profileMenuBg?.classList.remove('active'); // Close menu on chat select
                        profileMenu?.style.left = '-350px'; // Slide out
                    };

                    const renameBtn = document.createElement('button');
                    renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                    renameBtn.title = 'Rename Chat';
                    renameBtn.style.margin = '0 6px 0 8px';
                    renameBtn.onclick = async (e) => {
                        e.stopPropagation();
                        const newName = prompt("Rename chat:", chat.name);
                        if (newName && newName.trim()) {
                            const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                            await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
                            // Listener will update UI automatically
                        }
                    };

                    const delBtn = document.createElement('button');
                    delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                    delBtn.title = 'Delete Chat';
                    delBtn.style.marginLeft = '6px';
                    delBtn.onclick = async (e) => {
                        e.stopPropagation();
                        if (!confirm(`Are you sure you want to delete "${chat.name}"? This will delete all messages.`)) return;

                        // Delete all messages in subcollection first (batched)
                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                        const messagesSnap = await getDocs(messagesCol);
                        const batch = writeBatch(db);
                        messagesSnap.docs.forEach(d => batch.delete(d.ref));
                        await batch.commit();

                        // Delete chat document
                        const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                        await deleteDoc(chatDoc);

                        // If deleting the currently active chat, reset it
                        if (currentChatId === chat.id) {
                            currentChatId = null;
                        }
                        // Listener will update sidebar and re-select chat if needed
                    };

                    container.appendChild(titleSpan);
                    container.appendChild(renameBtn);
                    container.appendChild(delBtn);
                    chatsListEl.appendChild(container);
                });
            }

            if (newChatBtn) {
                newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));
            }

            // --- AI Tool Definitions & Handling ---
            const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
            const toolDefinitions = {
                "image": {
                    title: "Generate Image",
                    description: "Create stunning visuals from a text prompt. Choose a model for different results.",
                    buildForm: () => `
                        <label for="tool-provider">Generation Model</label>
                        <select id="tool-provider" class="edit-form-input"><option value="thena">Version 1 (Stylized, Fast & Recommended)</option><option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option></select>
                        <label for="tool-prompt">Image Prompt</label>
                        <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required class="edit-form-textarea"></textarea>
                        <label for="tool-style">Style (for Version1 only)</label>
                        <select id="tool-style" class="edit-form-input">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate</button>
                    `,
                    handleSubmit: async (form) => {
                        const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                        const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)';
                        const payload = {
                            prompt: form.querySelector('#tool-prompt').value,
                            model: form.querySelector('#tool-style').value,
                            use_minimax
                        };
                        await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                        showTypingWithText('Generating your image...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/generate-image`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload),
                                signal: currentController?.signal // Allow cancellation
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                            removeTyping();
                            await addMessageToChat('ai', 'âœ… Image generated! Check the floating image box to view or download.');
                            return null;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Image generation stopped.' : `âŒ Image generation failed: ${err.message}`;
                        }
                    }
                },
                "edit-photo": {
                    title: "Edit Photo",
                    description: "Upload a photo and describe the changes you want to make.",
                    buildForm: () => `
                        <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required class="edit-form-textarea"></textarea>
                        <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required class="edit-form-input">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>
                    `,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files;
                        const prompt = form.querySelector('#tool-prompt').value;
                        if (!file) return "Please select a file to edit.";
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('prompt', prompt);
                        await addMessageToChat('user', `Photo edit request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Editing your photo...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, {
                                method: 'POST',
                                body: fd,
                                signal: currentController?.signal
                            });
                            if (!res.ok) throw new Error((await res.json()).error || 'Failed to edit photo.');
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob); // Convert blob to base64 for persistence
                            const imgHtml = `âœ… Photo edited successfully! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Photo edit stopped.' : `âŒ Photo edit failed: ${err.message}`;
                        }
                    }
                },
                "remove-bg": {
                    title: "Remove Background",
                    description: "Select an image file to automatically remove its background.",
                    buildForm: () => `
                        <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;" class="edit-form-input">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Remove Background</button>
                    `,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files;
                        if (!file) return "Please select a file.";
                        await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Removing background...');
                        const fd = new FormData();
                        fd.append('file', file);
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, {
                                method: 'POST',
                                body: fd,
                                signal: currentController?.signal
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const imgHtml = `âœ… Background removed! <br><img src="${base64String}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Background removal stopped.' : `âŒ Background removal failed: ${err.message}`;
                        }
                    }
                },
                "comic": {
                    title: "Create Comic",
                    description: "Write a story and watch it transform into a comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.",
                    buildForm: () => `
                        <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required class="edit-form-textarea"></textarea>
                        <label for="tool-style">Comic Style</label><select id="tool-style" class="edit-form-input"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
                        <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" class="edit-form-input" />
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Create Comic</button>
                    `,
                    handleSubmit: async (form) => {
                        const payload = {
                            story: form.querySelector('#tool-story').value,
                            style: form.querySelector('#tool-style').value,
                            panels: parseInt(form.querySelector('#tool-panels').value, 10),
                            user: currentUser?.displayName || "User"
                        };
                        await addMessageToChat('user', `Comic creation request with style: ${payload.style}.`);
                        showTypingWithText('Generating your comic panels...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload),
                                signal: currentController?.signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join('');
                            const comicMessage = `ðŸ–¼ï¸ Comic successfully created! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                            removeTyping();
                            await addMessageToChat('ai', comicMessage); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Comic generation stopped.' : `âŒ Comic generation failed: ${err.message}`;
                        }
                    }
                },
                "voice-gen": {
                    title: "Voice Generation",
                    description: "Transform text into realistic speech. Choose a provider and voice style.",
                    buildForm: () => `
                        <label for="tool-provider">Voice Provider</label><select id="tool-provider" class="edit-form-input"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
                        <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required class="edit-form-textarea"></textarea>
                        <label for="tool-style">Voice Style</label><select id="tool-style" class="edit-form-input"></select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice</button>
                    `,
                    onFormReady: () => {
                        const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
                        const voices = {
                            gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                            minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                        };
                        const updateStyles = () => {
                            styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                        };
                        providerSelect.addEventListener('change', updateStyles);
                        updateStyles();
                    },
                    handleSubmit: async (form) => {
                        const provider = form.querySelector('#tool-provider').value,
                            text = form.querySelector('#tool-prompt').value,
                            style = form.querySelector('#tool-style').value;
                        const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';
                        await addMessageToChat('user', `Voice generation request using ${providerName}.`);
                        showTypingWithText('Generating your audio...');
                        try {
                            let res;
                            if (provider === 'gemini') {
                                const fd = new FormData();
                                fd.append('text', text);
                                fd.append('style', style);
                                res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd, signal: currentController?.signal });
                            } else {
                                res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({ text, voice_id: style }),
                                    signal: currentController?.signal
                                });
                            }
                            if (!res.ok) throw new Error(await res.text());
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob); // Temporary URL
                            const audioHtml = `ðŸ—£ï¸ Voice generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', audioHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Voice generation stopped.' : `âŒ Voice generation failed: ${err.message}`;
                        }
                    }
                },
                "audio-narration": {
                    title: "Audio Narration",
                    description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.",
                    buildForm: () => `
                        <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;" class="edit-form-input">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>
                    `,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files;
                        if (!file) return "Please select a file.";
                        await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Analyzing and narrating document...');
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('style', 'podcast');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, {
                                method: 'POST',
                                body: fd,
                                signal: currentController?.signal
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob); // Temporary URL
                            const narrationHtml = `ðŸ—£ï¸ Narration generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', narrationHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Audio narration stopped.' : `âŒ Audio narration failed: ${err.message}`;
                        }
                    }
                },
                "video-text": {
                    title: "Generate Video from Text",
                    description: "Describe the video you want to create. This process can take a few minutes.",
                    buildForm: () => `
                        <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required class="edit-form-textarea"></textarea>
                        <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15" class="edit-form-input">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>
                    `,
                    handleSubmit: async (form) => {
                        const payload = {
                            prompt: form.querySelector('#video-prompt').value,
                            duration: parseInt(form.querySelector('#video-duration').value, 10),
                            resolution: "1080P"
                        };
                        await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
                        handleVideoGeneration(payload, false); // Handle video generation process
                        return null; // Will be handled by handleVideoGeneration
                    }
                },
                "video-image": {
                    title: "Generate Video from Image",
                    description: "Upload a starting image and describe how you want to animate it.",
                    buildForm: () => `
                        <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required class="edit-form-textarea"></textarea>
                        <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required class="edit-form-input">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>
                    `,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#video-image-file').files;
                        if (!file) return "Please select an image.";
                        await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{name: file.name, type: file.type}]);
                        const fd = new FormData();
                        fd.append('prompt', form.querySelector('#video-image-prompt').value);
                        fd.append('file', file);
                        handleVideoGeneration(fd, true); // Handle video generation process
                        return null; // Will be handled by handleVideoGeneration
                    }
                },
                "music": {
                    title: "Generate Music",
                    description: "Generate music from a prompt, lyrics, and optional reference audio. Thanks to MiniMax.",
                    buildForm: () => `
                        <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required class="edit-form-textarea"></textarea>
                        <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..." class="edit-form-textarea"></textarea>
                        <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*" class="edit-form-input">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Music</button>
                    `,
                    handleSubmit: async (form) => {
                        const payload = {
                            prompt: form.querySelector('#music-prompt').value,
                            lyrics: form.querySelector('#music-lyrics').value,
                            model: 'music-1.5'
                        };
                        const refFile = form.querySelector('#music-ref').files;
                        await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
                        showTypingWithText('Composing your music...');
                        try {
                            if (refFile) {
                                showTypingWithText('Uploading reference audio first...');
                                const fd = new FormData();
                                fd.append('file', refFile);
                                const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, {
                                    method: 'POST',
                                    body: fd,
                                    signal: currentController?.signal
                                });
                                const uploadData = await uploadRes.json();
                                if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed.");
                                if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                                if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                                showTypingWithText('Reference uploaded. Composing music...');
                            }
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload),
                                signal: currentController?.signal
                            });
                            if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob); // Temporary URL
                            const musicHtml = `ðŸŽµ Your music is ready! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', musicHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Music generation stopped.' : `âŒ Music generation failed: ${err.message}`;
                        }
                    }
                },
                "website": {
                    title: "Create Website",
                    description: "Describe the website you want to build and get a live, working prototype.",
                    buildForm: () => `
                        <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required class="edit-form-textarea"></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Website</button>
                    `,
                    handleSubmit: async (form) => {
                        const prompt = form.querySelector('#website-prompt').value;
                        await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`);
                        showTypingWithText('Building and deploying your website...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt, user_id: currentUser.uid }),
                                signal: currentController?.signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return `ðŸŒ Website deployed successfully! [View here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Website creation stopped.' : `âŒ Website creation failed: ${err.message}`;
                        }
                    }
                },
                "edit-website": {
                    title: "Edit Last Website",
                    description: "Provide an instruction to modify the most recent website you created.",
                    buildForm: () => `
                        <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required class="edit-form-textarea"></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>
                    `,
                    handleSubmit: async (form) => {
                        const instruction = form.querySelector('#edit-instruction').value;
                        await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`);
                        showTypingWithText('Editing and redeploying your website...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ instruction, user_id: currentUser.uid }),
                                signal: currentController?.signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return `âœï¸ Website updated successfully! [View new version here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Website edit stopped.' : `âŒ Website edit failed: ${err.message}`;
                        }
                    }
                },
                "my-sites": {
                    isAction: true,
                    runAction: async () => {
                        await addMessageToChat('user', 'Show me a list of my websites.');
                        showTypingWithText('Fetching your website list...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`, { signal: currentController?.signal });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || 'Could not fetch sites.');
                            if (!data.sites || data.sites.length === 0) return "You haven't created any websites yet.";
                            const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank" rel="noopener noreferrer">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                            removeTyping();
                            return `Here are the websites you've created:\n${siteList}`;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Website list request stopped.' : `âŒ Error fetching websites: ${err.message}`;
                        }
                    }
                },
                "research-report": {
                    title: "Research Report",
                    description: "Generate a comprehensive research report in PDF format on any topic.",
                    buildForm: () => `
                        <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required class="edit-form-input">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>
                    `,
                    handleSubmit: async (form) => {
                        const topic = form.querySelector('#research-topic').value;
                        await addMessageToChat('user', `Research report request on: "${topic}"`);
                        showTypingWithText('Conducting research and compiling report...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ topic }),
                                signal: currentController?.signal
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob); // Temporary URL
                            const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--link-text);font-weight:bold;" rel="noopener noreferrer">Download PDF Report</a>`;
                            removeTyping();
                            return `âœ… Research report on **${escapeHTML(topic)}** is ready! ${downloadLink}`;
                        } catch (err) {
                            removeTyping();
                            return err.name === 'AbortError' ? 'âŒ Research report generation stopped.' : `âŒ Research report failed: ${err.message}`;
                        }
                    }
                },
            };

            // Helper function for video generation due to polling
            async function handleVideoGeneration(payload, isImageToVideo = false) {
                currentController = new AbortController(); // New controller for video polling
                const signal = currentController.signal;

                showTypingWithText('Submitting video generation job...');
                try {
                    const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
                    const commonPayload = {
                        model: "MiniMax-Hailuo-02",
                        duration: payload.duration || 6,
                        resolution: payload.resolution || "1080P"
                    };

                    let options;
                    if (isImageToVideo) {
                        // FormData for image upload
                        payload.append('model', commonPayload.model);
                        payload.append('duration', commonPayload.duration);
                        payload.append('resolution', commonPayload.resolution);
                        options = { method: 'POST', body: payload, signal };
                    } else {
                        // JSON for text
                        const finalPayload = { ...payload, ...commonPayload };
                        options = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(finalPayload), signal };
                    }

                    const startRes = await fetch(API_BASE_URL + endpoint, options);
                    const startData = await startRes.json();

                    if (!startRes.ok || !startData.task_id) {
                        throw new Error(startData.detail || 'Failed to start video task.');
                    }

                    removeTyping();
                    await startTypewriter(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. I'll notify you when it's ready. This can take a few minutes. Do not leave this page or send another message or task.`);

                    const pollInterval = setInterval(async () => {
                        if (signal.aborted) { // Check for abortion during polling
                            clearInterval(pollInterval);
                            await startTypewriter('âŒ Video generation stopped by user.', false);
                            return;
                        }
                        try {
                            const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`, { signal });
                            const statusData = await statusRes.json();

                            if (statusRes.ok && statusData.url) {
                                clearInterval(pollInterval);
                                const videoHtml = `ðŸŽ‰ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                                await addMessageToChat('ai', videoHtml); // Save HTML directly
                                currentController = null; // Clear controller
                            } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                                clearInterval(pollInterval);
                                await startTypewriter(`âŒ Video generation failed. Reason: ${statusData.error || 'Unknown error'}`);
                                currentController = null;
                            } else {
                                // Update status message
                                const currentTaskStatus = statusData.status || 'processing';
                                showTypingWithText(`Video is ${currentTaskStatus}... (Task ID: ${startData.task_id})`);
                            }
                        } catch (pollErr) {
                            if (pollErr.name === 'AbortError') {
                                clearInterval(pollInterval);
                                await startTypewriter('âŒ Video status check stopped.', false);
                            } else {
                                clearInterval(pollInterval);
                                await startTypewriter(`âŒ Error checking video status: ${pollErr.message}`);
                            }
                            currentController = null;
                        }
                    }, 20000); // Poll every 20 seconds
                } catch (err) {
                    removeTyping();
                    currentController = null;
                    await startTypewriter(err.name === 'AbortError' ? 'âŒ Video generation stopped.' : `âŒ Could not start video generation: ${err.message}`);
                }
            }


            // --- Tool Menu Click Handler ---
            if (toolsMenu) {
                toolsMenu.addEventListener('click', async (e) => {
                    const toolLink = e.target.closest('.tool-link');
                    if (!toolLink) return;

                    e.preventDefault();
                    const toolKey = toolLink.getAttribute('data-tool');
                    const tool = toolDefinitions[toolKey];
                    if (!tool) {
                        console.error(`Tool "${toolKey}" is not defined.`);
                        return;
                    }

                    closeToolMenu(); // Close the main tools menu

                    if (tool.isAction) {
                        // For direct actions like "My Websites"
                        currentController = new AbortController(); // Set controller for this action
                        const result = await tool.runAction();
                        removeTyping();
                        if(result) await startTypewriter(result);
                        currentController = null; // Clear controller after action
                    } else {
                        // For tools requiring a form
                        displayToolForm(toolKey);
                    }
                });
            }

            // --- Display Tool Form Logic ---
            function displayToolForm(toolKey) {
                const tool = toolDefinitions[toolKey];
                if (!tool || !toolFormModalBg || !toolFormModal) return;

                toolFormTitle.textContent = tool.title;
                const descriptionHtml = tool.description ? `<div style="color:#a8eaff;font-size:.9em;margin-bottom:12px;">${escapeHTML(tool.description)}</div>` : '';
                toolForm.innerHTML = descriptionHtml + tool.buildForm();

                if (typeof tool.onFormReady === 'function') tool.onFormReady();

                toolForm.onsubmit = async (e) => {
                    e.preventDefault();
                    const submitButton = toolForm.querySelector('button[type="submit"]');
                    const originalButtonContent = submitButton.innerHTML;

                    submitButton.innerHTML = `<div class="spinner"></div> Processing...`;
                    submitButton.disabled = true;

                    toolFormModal.style.left = '-350px'; // Slide out the form modal
                    toolFormModalBg.classList.remove('active'); // Hide the overlay

                    currentController = new AbortController(); // Set controller for tool submission

                    const resultText = await tool.handleSubmit(toolForm);

                    if (resultText) {
                        removeTyping(); // Ensure typing indicator is gone
                        await startTypewriter(resultText); // Display result using typewriter
                    }

                    submitButton.innerHTML = originalButtonContent;
                    submitButton.disabled = false;
                    currentController = null; // Clear controller after submission
                };

                // Show the tool form modal
                toolFormModalBg.classList.add('active');
                toolFormModal.style.left = '0'; // Slide in
            }

            // --- Main Chat Form Submission Handler (Including AbortController) ---
            chatForm.addEventListener('submit', async function (e) {
                e.preventDefault();
                if (!currentChatId) {
                    statusMsg.textContent = "Please select a chat or create a new one.";
                    statusMsg.style.color = "#ff4444";
                    return;
                }

                const msgText = chatInput.value.trim();
                if (!msgText && uploadedFiles.length === 0) return;

                // 1. Replace Send button with Stop button
                const stopButton = document.createElement('button');
                stopButton.type = 'button';
                stopButton.id = 'stopBtn';
                stopButton.innerHTML = '<i class="fa-solid fa-stop"></i> Stop';
                sendBtn.replaceWith(stopButton);

                currentController = new AbortController(); // Initialize new AbortController for this request
                const signal = currentController.signal;
                let finalResponse = '';

                stopButton.addEventListener('click', () => {
                    if (currentController) {
                        currentController.abort(); // Abort the ongoing fetch
                    }
                });

                // 2. Save user message to Firestore
                const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
                await addMessageToChat('user', msgText, filesForHistory);

                const localUploadedFiles = [...uploadedFiles]; // Copy files for processing
                chatInput.value = ''; // Clear input
                uploadedFiles = []; // Clear staged files
                renderFilePreview(); // Update file preview area
                chatInput.style.height = 'auto'; // Reset textarea height

                // 3. Handle file analysis or chat message
                if (localUploadedFiles.length > 0) {
                    showTypingWithText('Analyzing your file(s)...');
                    let endpoint = '';
                    const file = localUploadedFiles; // Process first file for now

                    if (file.type.startsWith('image/')) endpoint = '/understand-image';
                    else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                    else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                    else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                    else {
                        removeTyping();
                        finalResponse = "Sorry, I can't analyze that file type.";
                    }

                    try {
                        if(endpoint) {
                            const fd = new FormData();
                            fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]}`);
                            fd.append('file', file);
                            const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Analysis failed.");
                            finalResponse = data.response;
                        }
                    } catch (err) {
                        finalResponse = err.name === 'AbortError' ? 'âŒ File analysis stopped.' : `âŒ File analysis failed: ${err.message}`;
                    }
                } else if (msgText) {
                    showTypingAtNext(); // Show "..." dots for regular chat
                    try {
                        // Build history from currentMessages (excluding the last user message as it's the current prompt)
                        const history = currentMessages
                            .slice(0, -1) // Exclude the just-sent user message from history for the API call
                            .map(m => ({ role: m.role, content: m.text || '' }));

                        const res = await fetch(`${API_BASE_URL}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                message: msgText,
                                history: history,
                                user_id: currentUser?.uid || "user"
                            }),
                            signal // Pass abort signal to fetch
                        });
                        const data = await res.json(); // Assuming the backend sends JSON response
                        if (!res.ok) throw new Error(data.error || "Server error.");
                        finalResponse = data.response;
                    } catch (err) {
                        finalResponse = err.name === 'AbortError' ? 'âŒ Response stopped.' : `âŒ An error occurred: ${err.message}`;
                    }
                }

                // 4. Handle final response and cleanup
                removeTyping();
                if (finalResponse) {
                    await startTypewriter(finalResponse); // Use typewriter effect for the response
                }

                // 5. Restore Send button and clear controller
                stopButton.replaceWith(sendBtn);
                currentController = null;
            });

            // --- Theme Switcher Logic ---
            const themes = {
                cyber: { /* Existing Cyber Theme */
                    '--cyan': '#00fff7', '--blue': '#0a8afe', '--dark-bg': '#070b1a', '--fade-blue': '#133c8b',
                    '--gradient-1': 'linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #0857ee 32%, #00fff0 89%)',
                    '--bubble-glow': '0 0 13px #00d8ffb1, 0 0 24px #0197ff40', '--user-glow': '0 0 22px #0fffd555, 0 0 14px #36f9ff70',
                    '--header-glass': 'rgba(17,29,47,0.92)', '--code-bg': 'linear-gradient(92deg,#031d39 79%,#092ff8 120%)',
                    '--code-border': '#15faff', '--code-text': '#17fafd', '--main-text': '#e1fafe', '--link-text': '#13efff',
                    '--input-bg': '#09284c',
                    '--body-bg': 'radial-gradient(circle at 60% 45%, #112250 37%, #060e1e 88%, #1e0942 100%) fixed, repeating-linear-gradient(100deg,#061c4c 0 9%,#080e20 16% 19%,#030721 30% 41%,#052650 44% 62%,#050b16 74% 89%,#041048 99% 100%)',
                    '--body-blend-mode': 'lighten, color-dodge',
                    '--panel-bg': 'linear-gradient(118deg,#131642 80%,#1629af 200%)', '--panel-border': '#00fbffcb', '--panel-shadow': '0 0 42px #25f8ffc9',
                    '--submit-bg': 'linear-gradient(94deg,#00ffff,#0090ff 90%)', '--submit-text': '#102649',
                    '--submit-hover-bg': '#008cff', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 12px #00ffe0cc, 0 0 27px #178fcf88',
                    '--header-text-anim-glow-1': '0 0 17px #00e7ff70,0 0 30px #0b8fff44',
                    '--header-text-anim-glow-2': '0 0 29px #00ffe9ee,0 0 44px #31d2ff82',
                    '--header-text-fill': 'linear-gradient(90deg,#00fff1,#00b4ff 40%,#fff 59%,#1093f1 89%,#24e0fa 100%)'
                },
                celestial: { /* Otherworldly, Space (Deep Purple/Pink) */
                    '--cyan': '#ff00ff', '--blue': '#8a2be2', '--dark-bg': '#0f001a', '--fade-blue': '#2b003e',
                    '--gradient-1': 'linear-gradient(120deg, #2b003e 39%, #580080 68%, #ff00ff 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #8a2be2 32%, #ff00ff 89%)',
                    '--bubble-glow': '0 0 15px #ff00ffb1', '--user-glow': '0 0 25px #ff66ff55, 0 0 16px #cc00cc70',
                    '--header-glass': 'rgba(25,0,35,0.92)', '--code-bg': 'linear-gradient(92deg,#2b003e 79%,#8a2be2 120%)',
                    '--code-border': '#ff00ff', '--code-text': '#f0e6ff', '--main-text': '#f0e6ff', '--link-text': '#ff66ff',
                    '--input-bg': '#2b003e',
                    '--body-bg': 'radial-gradient(circle at 50% 50%, #1a0033 0%, #0f001a 100%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#2b003e 80%,#580080 200%)', '--panel-border': '#ff00ffcb', '--panel-shadow': '0 0 45px #ff00ffc9',
                    '--submit-bg': 'linear-gradient(94deg,#ff00ff,#8a2be2 90%)', '--submit-text': '#0f001a',
                    '--submit-hover-bg': '#8a2be2', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 15px #ff00ffcc', '--header-text-anim-glow-1': '0 0 20px #ff00ff70',
                    '--header-text-anim-glow-2': '0 0 35px #ff00ffee',
                    '--header-text-fill': 'linear-gradient(90deg,#ff00ff,#8a2be2 40%,#fff 59%,#8a2be2 89%,#ff00ff 100%)'
                },
                starlight: { /* Perfectable Stars (Soft Blue/White) */
                    '--cyan': '#a6faff', '--blue': '#00c3ff', '--dark-bg': '#030010', '--fade-blue': '#100c25',
                    '--gradient-1': 'linear-gradient(120deg, #100c25 39%, #1c153f 68%, #3f337f 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #00c3ff 32%, #a6faff 89%)',
                    '--bubble-glow': '0 0 13px #00c3ffb1', '--user-glow': '0 0 22px #a6faff55',
                    '--header-glass': 'rgba(16,12,37,0.92)', '--code-bg': 'linear-gradient(92deg,#100c25 79%,#3f337f 120%)',
                    '--code-border': '#a6faff', '--code-text': '#a6faff', '--main-text': '#f0faff', '--link-text': '#a6faff',
                    '--input-bg': '#100c25',
                    '--body-bg': 'radial-gradient(ellipse at bottom, #0d0920 0%, #030010 70%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#100c25 80%,#1c153f 200%)', '--panel-border': '#a6faffcb', '--panel-shadow': '0 0 42px #a6faffc9',
                    '--submit-bg': 'linear-gradient(94deg,#a6faff,#00c3ff 90%)', '--submit-text': '#030010',
                    '--submit-hover-bg': '#00c3ff', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 12px #a6faffcc', '--header-text-anim-glow-1': '0 0 17px #a6faff70',
                    '--header-text-anim-glow-2': '0 0 29px #a6faffee',
                    '--header-text-fill': 'linear-gradient(90deg,#a6faff,#00c3ff 40%,#fff 59%,#00f2ff 89%,#a6faff 100%)'
                },
                midnight: { /* Regular Dark */
                    '--cyan': '#3391ff', '--blue': '#007bff', '--dark-bg': '#121212', '--fade-blue': '#282828',
                    '--gradient-1': 'linear-gradient(120deg, #282828 39%, #333 68%, #444 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #007bff 32%, #3391ff 89%)',
                    '--bubble-glow': '0 0 8px #007bff44', '--user-glow': '0 0 12px #3391ff44',
                    '--header-glass': 'rgba(18,18,18,0.92)', '--code-bg': 'linear-gradient(92deg,#222 79%,#333 120%)',
                    '--code-border': '#444', '--code-text': '#f1f1f1', '--main-text': '#f1f1f1', '--link-text': '#3391ff',
                    '--input-bg': '#282828',
                    '--body-bg': 'linear-gradient(180deg, #181818 0%, #121212 100%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#1e1e1e 80%,#282828 200%)', '--panel-border': '#444', '--panel-shadow': '0 0 20px #000000c9',
                    '--submit-bg': 'linear-gradient(94deg,#007bff,#3391ff 90%)', '--submit-text': '#fff',
                    '--submit-hover-bg': '#0069d9', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 10px #3391ffaa', '--header-text-anim-glow-1': '0 0 12px #3391ff70',
                    '--header-text-anim-glow-2': '0 0 15px #3391ffee',
                    '--header-text-fill': 'linear-gradient(90deg,#3391ff,#007bff 40%,#fff 59%,#3391ff 89%,#aaccff 100%)'
                },
                forest: { /* NEW THEME: Forest */
                    '--cyan': '#99cc99', '--blue': '#669966', '--dark-bg': '#2a362a', '--fade-blue': '#4a5a4a',
                    '--gradient-1': 'linear-gradient(120deg, #3a473a 39%, #5a6b5a 68%, #99cc99 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #669966 32%, #99cc99 89%)',
                    '--bubble-glow': '0 0 10px #99cc99b1', '--user-glow': '0 0 18px #99cc9955',
                    '--header-glass': 'rgba(42,54,42,0.92)', '--code-bg': 'linear-gradient(92deg,#3a473a 79%,#5a6b5a 120%)',
                    '--code-border': '#99cc99', '--code-text': '#e0ffe0', '--main-text': '#e0ffe0', '--link-text': '#99cc99',
                    '--input-bg': '#4a5a4a',
                    '--body-bg': 'linear-gradient(180deg, #3a473a 0%, #2a362a 100%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#3a473a 80%,#4a5a4a 200%)', '--panel-border': '#99cc99cb', '--panel-shadow': '0 0 35px #99cc99c9',
                    '--submit-bg': 'linear-gradient(94deg,#99cc99,#669966 90%)', '--submit-text': '#2a362a',
                    '--submit-hover-bg': '#669966', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 10px #99cc99cc', '--header-text-anim-glow-1': '0 0 15px #99cc9970',
                    '--header-text-anim-glow-2': '0 0 25px #99cc99ee',
                    '--header-text-fill': 'linear-gradient(90deg,#99cc99,#669966 40%,#fff 59%,#669966 89%,#99cc99 100%)'
                },
                volcano: { /* NEW THEME: Volcano */
                    '--cyan': '#ff7043', '--blue': '#bf360c', '--dark-bg': '#3e1a0b', '--fade-blue': '#5e2a1b',
                    '--gradient-1': 'linear-gradient(120deg, #4e2211 39%, #6e3a2c 68%, #ff7043 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #bf360c 32%, #ff7043 89%)',
                    '--bubble-glow': '0 0 12px #ff7043b1', '--user-glow': '0 0 20px #ff704355',
                    '--header-glass': 'rgba(62,26,11,0.92)', '--code-bg': 'linear-gradient(92deg,#4e2211 79%,#6e3a2c 120%)',
                    '--code-border': '#ff7043', '--code-text': '#fff0e0', '--main-text': '#fff0e0', '--link-text': '#ff7043',
                    '--input-bg': '#5e2a1b',
                    '--body-bg': 'radial-gradient(circle at 50% 50%, #6e3a2c 0%, #3e1a0b 100%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#4e2211 80%,#5e2a1b 200%)', '--panel-border': '#ff7043cb', '--panel-shadow': '0 0 40px #ff7043c9',
                    '--submit-bg': 'linear-gradient(94deg,#ff7043,#bf360c 90%)', '--submit-text': '#3e1a0b',
                    '--submit-hover-bg': '#bf360c', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 12px #ff7043cc', '--header-text-anim-glow-1': '0 0 17px #ff704370',
                    '--header-text-anim-glow-2': '0 0 29px #ff7043ee',
                    '--header-text-fill': 'linear-gradient(90deg,#ff7043,#bf360c 40%,#fff 59%,#bf360c 89%,#ff7043 100%)'
                }
            };

            let currentThemeIdx = 0;
            const themeKeys = Object.keys(themes);

            function applyTheme(themeName) {
                const theme = themes[themeName];
                if (!theme) return;
                for (const key in theme) {
                    document.documentElement.style.setProperty(key, theme[key]);
                }
                localStorage.setItem('philadelphia-theme', themeName);

                // Update theme button icon based on theme
                let iconClass = 'fa-moon'; // Default icon
                if (themeName === 'forest') iconClass = 'fa-leaf';
                else if (themeName === 'volcano') iconClass = 'fa-fire';
                else if (themeName === 'celestial') iconClass = 'fa-galaxy'; // Assuming a galaxy icon
                else if (themeName === 'starlight') iconClass = 'fa-star'; // Assuming a star icon

                themeBtn.innerHTML = `<i class="fa-solid ${iconClass}"></i>`;
            }

            themeBtn.addEventListener('click', () => {
                currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
                applyTheme(themeKeys[currentThemeIdx]);
            });

            // Load saved theme on startup
            const savedTheme = localStorage.getItem('philadelphia-theme');
            if (savedTheme && themes[savedTheme]) {
                currentThemeIdx = themeKeys.indexOf(savedTheme);
                applyTheme(savedTheme);
            } else {
                applyTheme('cyber'); // Default theme
            }

            // --- Voice Call Logic ---
            let speechRecognition;
            let isCallActive = false;
            let callHistory = [];
            let botIsSpeaking = false;
            let userSaidSomething = false; // To track if user actually spoke
            let currentAudio = null; // Reference to the currently playing audio
            let isMuted = false;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (SpeechRecognition) {
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = true; // Keep listening
                speechRecognition.interimResults = true; // Get results as they come in
                speechRecognition.lang = 'en-US';

                speechRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    userSaidSomething = true; // User is speaking or attempting to speak

                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i].transcript;
                        } else {
                            interimTranscript += event.results[i].transcript;
                        }
                    }

                    // Update user's interim speech in the call conversation
                    let userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                    if (!userMsgEl) {
                        userMsgEl = document.createElement('div');
                        userMsgEl.className = 'call-msg user interim';
                        callConversation.appendChild(userMsgEl);
                    }
                    userMsgEl.textContent = finalTranscript || interimTranscript;
                    callConversation.scrollTop = callConversation.scrollHeight;

                    callStatusMessage.textContent = finalTranscript ? 'User Speaking (Final)' : 'User Speaking...';
                    tapToTalk.style.display = 'none'; // Hide tap to talk when actively speaking
                };

                speechRecognition.onend = () => {
                    if (!isCallActive) return;

                    if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                        return;
                    }

                    let finalTranscript = '';
                    const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                    if (userMsgEl) {
                        finalTranscript = userMsgEl.textContent.trim();
                        userMsgEl.classList.remove('interim');
                        userMsgEl.remove(); // Remove interim element now that it's final or empty
                    }

                    if (botIsSpeaking) {
                        // Bot is still speaking, recognition will restart after bot finishes
                        return;
                    } else if (finalTranscript && userSaidSomething) {
                        userSaidSomething = false; // Reset flag
                        callHistory.push({ role: 'user', content: finalTranscript });
                        addCallMessage('user', finalTranscript); // Add user's final message
                        handleCallBotResponse();
                    } else {
                        // User didn't say anything meaningful, restart listening
                        if (isCallActive && !isMuted) {
                            callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
                        }
                    }
                };

                speechRecognition.onerror = (event) => {
                    console.error('Speech recognition error', event.error);
                    if (event.error === 'no-speech' && isCallActive && !isMuted) {
                        userSaidSomething = false; // Reset flag if no speech was detected
                        // Force restart listening if no speech was detected and not muted
                        speechRecognition.stop(); // Stop might trigger onend, which then restarts
                    } else if (event.error === 'network' && isCallActive) {
                        callStatusMessage.textContent = 'Network error. Attempting restart...';
                        speechRecognition.stop();
                    } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                        callStatusMessage.textContent = 'Microphone permission denied. Please allow in browser settings.';
                        endCall(); // End call if permission is denied
                    }
                };
            } else {
                callBtn.style.display = 'none'; // Hide call button if not supported
                console.warn("Speech Recognition not supported in this browser.");
            }

            // Adds a message to the voice call conversation log
            function addCallMessage(role, text) {
                const msgEl = document.createElement('div');
                msgEl.className = `call-msg ${role}`;
                msgEl.textContent = text;
                callConversation.appendChild(msgEl);
                callConversation.scrollTop = callConversation.scrollHeight;
            }

            // Handles sending user's speech to the bot and receiving a response
            async function handleCallBotResponse() {
                if (!isCallActive) return;
                callStatusMessage.textContent = 'Philadelphia AI is thinking...';
                tapToTalk.style.display = 'none';

                // Get only the current user message for the API call, plus prior history
                const userMessage = callHistory[callHistory.length - 1].content;
                const historyForBot = callHistory.slice(0, -1).map(m => ({ role: m.role, content: m.content }));

                try {
                    speechRecognition.stop(); // Stop recognition while bot is thinking
                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: userMessage,
                            history: historyForBot,
                            user_id: currentUser?.uid || "user"
                        }),
                        signal: currentController?.signal // Allow stopping this fetch too
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "Server error.");

                    const botResponse = data.response;
                    callHistory.push({ role: 'ai', content: botResponse }); // Add bot response to call history
                    addCallMessage('bot', botResponse); // Display bot's text response
                    speakBotResponse(botResponse); // Make bot speak
                } catch (err) {
                    const errorMsg = err.name === 'AbortError' ? 'âŒ Call response stopped.' : `âŒ Call error: ${err.message}`;
                    addCallMessage('bot', errorMsg);
                    // Restart listening if call is still active and not muted
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
                    }
                }
            }

            // Makes the bot speak the provided text
            async function speakBotResponse(text) {
                if (!isCallActive) return;
                botIsSpeaking = true;
                botImageContainer.classList.add('speaking');
                callStatusMessage.textContent = 'Philadelphia AI is speaking...';
                tapToTalk.style.display = 'none';

                try {
                    // Using Minimax "elder" voice specifically for a distinctive AI voice
                    const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ text: text, voice_id: 'elder' }),
                        signal: currentController?.signal
                    });
                    if (!res.ok) throw new Error(await res.text());

                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    currentAudio = audio; // Store reference to allow stopping audio

                    audio.onended = audio.onerror = () => {
                        botIsSpeaking = false;
                        botImageContainer.classList.remove('speaking');
                        currentAudio = null; // Clear audio reference

                        // Restart listening for user if call is active and not muted
                        if (isCallActive && !isMuted) {
                            callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
                        } else if (isMuted) {
                            callStatusMessage.textContent = 'Microphone Muted.';
                            tapToTalk.style.display = 'none';
                        }
                    };
                    audio.play();
                } catch (err) {
                    console.error("Voice generation error:", err);
                    botIsSpeaking = false;
                    botImageContainer.classList.remove('speaking');
                    currentAudio = null;

                    // If speaking failed, restart listening for user
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening (Voice Failed)...';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
                    } else if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                    }
                }
            }

            // Allows user to tap the screen to interrupt bot speaking and start talking
            function stopBotSpeakingAndStartListening() {
                if (!isCallActive || !botIsSpeaking) return;

                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                botIsSpeaking = false;
                botImageContainer.classList.remove('speaking');

                if (!isMuted) {
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try {
                        speechRecognition.stop(); // Stop current recognition session
                        speechRecognition.start(); // Start a new one immediately
                    } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
                } else {
                    callStatusMessage.textContent = 'Microphone Muted.';
                    tapToTalk.style.display = 'none';
                }
                // Clear any leftover interim message
                const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                if (userMsgEl) userMsgEl.remove();
            }

            // Attach tap-to-talk listeners to the call modal
            callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
            callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);

            // Start Call Button
            callBtn.addEventListener('click', () => {
                if (!SpeechRecognition) {
                    alert("Sorry, your browser doesn't support the Speech Recognition needed for this feature.");
                    return;
                }
                isCallActive = true;
                isMuted = false; // Reset mute state
                muteCallBtn.classList.remove('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
                callModal.classList.add('active');
                callConversation.innerHTML = ''; // Clear old call conversation
                addCallMessage('status', 'Connecting to Philadelphia AI...');
                callStatusMessage.textContent = 'Calling...';
                tapToTalk.style.display = 'none';
                callHistory = []; // Reset call history

                // Simulate connection delay, then start listening
                setTimeout(() => {
                    if (!isCallActive) return; // If call was ended during delay
                    addCallMessage('status', 'Call Connected. Speak when ready.');
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try {
                        speechRecognition.start();
                    } catch(e) {
                        console.error("Speech recognition start failed", e);
                        callStatusMessage.textContent = 'Microphone error. Check permissions.';
                        endCall(); // End call if microphone fails to start
                    }
                }, 1500);
            });

            // End Call Function
            function endCall() {
                isCallActive = false;
                botIsSpeaking = false;
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                callModal.classList.remove('active');
                try {
                    speechRecognition.stop(); // Stop recognition
                } catch(e) {} // Ignore error if already stopped
                botImageContainer.classList.remove('speaking');
                tapToTalk.style.display = 'none';
                callStatusMessage.textContent = 'Call Ended.';

                // Ensure any interim user message is removed
                const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                if (userMsgEl) userMsgEl.remove();
            }
            endCallBtn.addEventListener('click', endCall);

            // Mute Button Functionality
            if (muteCallBtn) {
                muteCallBtn.addEventListener('click', () => {
                    isMuted = !isMuted;
                    if (isMuted) {
                        muteCallBtn.classList.add('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute Microphone';
                        speechRecognition.stop(); // Stop listening
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                    } else {
                        muteCallBtn.classList.remove('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
                        if (isCallActive && !botIsSpeaking) {
                            callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
                        } else if (isCallActive && botIsSpeaking) {
                            callStatusMessage.textContent = 'Philadelphia AI is speaking...';
                            tapToTalk.style.display = 'none';
                        }
                    }
                });
            }

            // Focus chat input on page load
            if(chatInput) chatInput.focus();
        }); // end DOMContentLoaded
    </script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
