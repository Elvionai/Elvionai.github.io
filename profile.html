<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Philadelphia AI - Cosmic Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-purple: #bd00ff;
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            --glass-bg-strong: rgba(20, 20, 35, 0.7);
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            --text-glow: 0 0 10px rgba(0, 242, 255, 0.7), 0 0 20px rgba(189, 0, 255, 0.5);
            --box-glow: 0 0 20px rgba(0, 242, 255, 0.2);
            --deep-space: #050714;
            --main-text-color: #e1fafe; /* Adjusted for better contrast */
            --sub-text-color: rgba(255, 255, 255, 0.7);
            --button-text-color: #000;
            --link-color: #00eaff;

            /* Call Modal specific */
            --call-bg: linear-gradient(145deg, #0f0a28, #2a003e);
            --call-header-color: var(--neon-blue);
            --call-status-color: #fff066;
            --call-bot-bubble: linear-gradient(135deg, rgba(30, 30, 60, 0.7), rgba(20, 20, 35, 0.9));
            --call-user-bubble: linear-gradient(135deg, rgba(0, 242, 255, 0.4), rgba(189, 0, 255, 0.4));
            --call-glow-active: 0 0 25px var(--neon-blue);
            --call-glow-speaking: 0 0 30px #00ff00;
            --call-mute-btn-bg: #4a4a4a; /* Muted state */
        }

        /* General Reset */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            height: 100vh;
            width: 100vw;
            font-family: 'Roboto', 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
            background-color: var(--deep-space);
            color: var(--main-text-color);
            overflow: hidden; /* Prevent body scroll, UI handles its own */
            display: flex;
            justify-content: center;
        }

        a { color: var(--link-color); text-decoration: none; transition: color 0.3s; }
        a:hover { color: var(--neon-purple); text-shadow: var(--text-glow); }

        /* --- COSMIC BACKGROUND ENGINE --- */
        #cosmos-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
            background: linear-gradient(to bottom right, #00000a, #1a0a2e); /* Base deep space */
        }

        .nebula-layer {
            position: absolute; top: 0; left: 0; width: 250%; height: 250%; /* Larger for more drift */
            background:
                radial-gradient(circle at 50% 50%, rgba(76, 0, 255, 0.15), transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.15), transparent 40%),
                radial-gradient(circle at 30% 70%, rgba(255, 0, 255, 0.1), transparent 60%);
            mix-blend-mode: screen; /* Lighten effect */
            animation: drift 75s infinite linear;
            filter: blur(2px); /* Soften nebulae */
        }

        .nebula-layer:nth-child(2) {
            background: radial-gradient(circle at 20% 80%, rgba(189, 0, 255, 0.2), transparent 50%);
            animation: drift 60s infinite linear reverse;
            mix-blend-mode: overlay; /* Deeper color blending */
            filter: blur(3px) brightness(0.9);
        }

        .nebula-layer:nth-child(3) { /* New layer for more depth */
            background: radial-gradient(circle at 70% 30%, rgba(0, 255, 0, 0.08), transparent 45%);
            animation: drift 90s infinite linear alternate;
            mix-blend-mode: hard-light;
            filter: blur(1px) contrast(1.1);
        }

        @keyframes drift {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(-25%, -25%) scale(1.1); } /* Zoom in slightly */
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .star, .shooting-star, .stardust, .cosmic-entity {
            position: absolute;
            pointer-events: none;
        }

        .star {
            background: white; border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out;
            box-shadow: 0 0 5px #fff, 0 0 10px rgba(255,255,255,0.7); /* Stronger glow */
        }

        .stardust {
            background: var(--neon-blue); border-radius: 50%;
            width: 1px; height: 1px;
            opacity: 0.5;
            animation: floatUp var(--duration) infinite linear;
            box-shadow: 0 0 3px var(--neon-blue);
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(0.8); filter: brightness(0.8); }
            50% { opacity: 1; transform: scale(1.1); filter: brightness(1.5); }
        }
        @keyframes floatUp { to { transform: translateY(-100vh) translateX(var(--shiftX)); opacity: 0; } }

        .shooting-star {
            height: 2px;
            background: linear-gradient(-90deg, white, transparent);
            filter: drop-shadow(0 0 6px var(--neon-blue)) drop-shadow(0 0 10px var(--neon-purple)); /* Dual glow */
            animation: shoot var(--duration) ease-out; opacity: 0; z-index: 0;
        }
        @keyframes shoot {
            0% { transform: translate(var(--startX), var(--startY)) rotate(var(--angle)); opacity: 1; width: 0; }
            20% { width: var(--length); }
            100% { transform: translate(calc(var(--startX) + var(--endX)), calc(var(--startY) + var(--endY))) rotate(var(--angle)); opacity: 0; width: 0; }
        }

        /* New: Cosmic Entity (Eagle) */
        .cosmic-entity {
            width: 80px; height: 80px;
            background: url('https://i.ibb.co/3kXy0Fp/cosmic-eagle.png') no-repeat center center / contain; /* Placeholder - replace with actual cosmic eagle SVG/PNG */
            filter: drop-shadow(0 0 8px var(--neon-blue)) drop-shadow(0 0 15px var(--neon-purple));
            animation: entityFlight var(--duration) infinite ease-in-out alternate;
            opacity: 0.6;
            z-index: -1;
        }
        @keyframes entityFlight {
            0% { transform: translate(var(--startX), var(--startY)) rotateZ(0deg) scale(0.9); opacity: 0.5; }
            50% { transform: translate(calc(var(--startX) + var(--pathX)), calc(var(--startY) + var(--pathY))) rotateZ(10deg) scale(1); opacity: 0.8; }
            100% { transform: translate(calc(var(--startX) + var(--pathX) * 2), calc(var(--startY) + var(--pathY) * 0.5)) rotateZ(-5deg) scale(0.9); opacity: 0.5; }
        }

        /* --- UI MAIN STRUCTURE --- */
        .ui-container {
            width: 100%; max-width: 680px; /* Slightly wider for better content display */
            height: 100%; display: flex; flex-direction: column;
            position: relative; z-index: 10;
            background: rgba(5, 7, 20, 0.4); /* Subtle darkening for readability */
            overflow: hidden; /* Important for clean edges */
        }

        /* Header */
        header {
            padding: 20px 25px;
            display: flex; justify-content: space-between; align-items: center;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2), var(--box-glow);
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .brand-plasma {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem; font-weight: 800; letter-spacing: 2px;
            background: linear-gradient(90deg, #fff, var(--neon-blue), var(--neon-purple), #fff);
            background-size: 300% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: plasmaFlow 5s linear infinite;
            text-shadow: var(--text-glow);
            user-select: none;
        }
        @keyframes plasmaFlow { to { background-position: 300% center; } }

        .header-actions { display: flex; gap: 20px; font-size: 1.4rem; }
        .icon-btn {
            cursor: pointer; opacity: 0.7; transition: 0.3s; position: relative;
            color: var(--neon-blue);
        }
        .icon-btn:hover { opacity: 1; text-shadow: var(--text-glow); transform: scale(1.1); color: #fff; }

        /* Chat Area */
        #chat-viewport {
            flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px;
            scroll-behavior: smooth;
            /* Hide Scrollbar visually but keep functionality */
            scrollbar-width: none; -ms-overflow-style: none;
            position: relative;
        }
        #chat-viewport::-webkit-scrollbar { display: none; }

        .message-group { display: flex; flex-direction: column; gap: 8px; max-width: 85%; position: relative; }
        .message-group.ai { align-self: flex-start; }
        .message-group.user { align-self: flex-end; align-items: flex-end; }

        .msg-bubble {
            padding: 16px 22px; border-radius: 24px;
            font-size: 1rem; line-height: 1.5;
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            word-break: break-word; /* Ensure long words wrap */
        }
        @keyframes popIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }

        .ai .msg-bubble {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8));
            border-bottom-left-radius: 4px;
            box-shadow: inset 0 0 20px rgba(0, 242, 255, 0.05);
        }

        .user .msg-bubble {
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.3), rgba(189, 0, 255, 0.3));
            border-bottom-right-radius: 4px;
            color: var(--main-text-color);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            box-shadow: var(--box-glow);
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* Typing Indicator */
        #typing-status {
            display: none;
            margin: 0 auto;
            padding: 0 8px 10px 8px;
            width: 100%;
            box-sizing: border-box;
            flex-shrink: 0;
            min-height: 20px;
            align-self: flex-start;
        }
        #typing-status .msg-bubble {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8));
            border-bottom-left-radius: 4px;
            box-shadow: inset 0 0 20px rgba(0, 242, 255, 0.05);
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
            padding: 8px 15px;
            max-width: fit-content;
        }
        .dot-anim {
            display: inline-block;
            width: 8px; height: 8px;
            background: var(--neon-blue);
            border-radius: 50%;
            opacity: 0.85;
            animation: typing-blink 1.4s infinite both;
            box-shadow: 0 0 6px var(--neon-blue);
        }
        .dot-anim:nth-child(2){animation-delay:.3s;}
        .dot-anim:nth-child(3){animation-delay:.6s;}
        @keyframes typing-blink {
            0%,100% {opacity:.25; transform: scale(0.8);}
            25% {opacity:.95; transform: scale(1.1);}
            50% {opacity:1; transform: scale(1.2);}
            75% {opacity:.65; transform: scale(1);}
        }
        .spinner {
            display: inline-block;
            width: 20px; height: 20px;
            border: 3px solid rgba(0, 255, 247, 0.3);
            border-radius: 50%;
            border-top-color: var(--neon-blue);
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Holographic Suggestions */
        .suggestions-dock {
            display: flex; flex-wrap: wrap; justify-content: flex-end; gap: 10px; margin-top: 10px;
            align-self: flex-end; /* Align to bottom-right of chat viewport */
        }

        /* The Shimmer Effect Class */
        .holo-shimmer {
            position: relative; overflow: hidden;
        }
        .holo-shimmer::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(
                120deg, transparent, rgba(255, 255, 255, 0.4), transparent
            );
            transform: skewX(-25deg);
            animation: holoSheen 3s infinite linear;
        }
        @keyframes holoSheen { 0% { left: -100%; } 50%, 100% { left: 200%; } }

        .chip {
            padding: 12px 20px; border-radius: 16px; font-size: 0.9rem; cursor: pointer;
            background: rgba(255, 255, 255, 0.07);
            border: 1px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(10px);
            transition: 0.3s; text-align: right; color: rgba(255,255,255,0.9);
        }
        .chip:hover {
            background: rgba(0, 242, 255, 0.15);
            border-color: var(--neon-blue);
            box-shadow: var(--box-glow);
            transform: translateY(-2px); color: #fff;
        }

        /* Input Capsule */
        .input-dock {
            padding: 20px 25px;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(25px);
            border-top: 1px solid var(--glass-border);
            display: flex; gap: 15px; align-items: flex-end; /* Align items to bottom for textarea growth */
            flex-shrink: 0;
        }

        .capsule-input {
            flex: 1; position: relative; min-height: 55px;
            background: var(--glass-bg-light);
            border-radius: 30px; border: 1px solid var(--glass-border);
            transition: 0.3s; display: flex; align-items: center;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
            padding-right: 15px; /* Space for internal buttons */
        }
        .capsule-input:focus-within {
            border-color: var(--neon-blue);
            box-shadow: var(--box-glow), inset 0 2px 10px rgba(0,0,0,0.2);
            background: rgba(0, 242, 255, 0.05);
        }
        .capsule-input textarea {
            flex: 1; width: 100%; min-height: 30px; max-height: 120px; /* Limit height */
            background: transparent; border: none;
            padding: 12px 25px; color: #fff; font-size: 1.05rem; outline: none;
            resize: none; /* Disable manual resize */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .capsule-input textarea::-webkit-scrollbar { display: none; }


        .input-action-btn {
            background: none; border: none;
            color: var(--neon-blue);
            font-size: 1.1em;
            cursor: pointer;
            border-radius: 8px;
            transition: color 0.13s, background 0.15s;
            padding: 5px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .input-action-btn:hover {
            color: #fff;
            background: rgba(0, 207, 242, 0.28);
        }

        .thruster-btn {
            width: 55px; height: 55px; border-radius: 50%; border: none; cursor: pointer;
            background: var(--plasma-gradient);
            display: flex; align-items: center; justify-content: center;
            box-shadow: var(--box-glow); transition: 0.3s;
            color: var(--button-text-color);
            font-size: 1.3em;
        }
        .thruster-btn:hover { transform: scale(1.05) rotate(-10deg); box-shadow: 0 0 30px rgba(189, 0, 255, 0.6); }

        #stopBtn {
            background: #ff4d4d;
            color: white;
            box-shadow: 0 0 10px #ff4d4d88;
        }
        #stopBtn:hover {
            background: #ff7777;
            transform: scale(1.05) rotate(-10deg);
        }


        /* Modals and Side Panels (Unified Cosmic Style) */
        .panel-bg {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(13, 20, 52, 0.86); /* Darker overlay */
            backdrop-filter: blur(10px);
            z-index: 1200;
        }
        .panel-bg.active { display: block; }

        .side-panel, .cosmic-modal {
            position: fixed;
            background: linear-gradient(118deg,#131642 80%,#1629af 200%);
            border: 2.5px solid var(--neon-blue);
            box-shadow: 0 0 42px var(--neon-blue);
            z-index: 1212;
            padding: 20px;
            border-radius: 24px;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            transform: translateX(-100%) scale(0.9); opacity: 0;
            overflow-y: auto;
            max-height: 90vh;
            color: var(--main-text-color);
        }
        .side-panel.active, .cosmic-modal.active {
            transform: translateX(0) scale(1); opacity: 1;
        }
        .side-panel {
            top: 0; left: 0;
            height: 100vh;
            width: 325px;
            border-radius: 0 24px 32px 0;
        }
        .cosmic-modal {
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            opacity: 0;
            max-width: 90vw;
            width: 450px;
        }
        .cosmic-modal.active {
            transform: translate(-50%, -50%) scale(1); opacity: 1;
        }


        .panel-header {
            text-align: center;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3em;
            color: var(--neon-blue);
            text-shadow: var(--text-glow);
        }

        .panel-header img {
            width: 60px; height: 60px; border-radius: 50%;
            border: 2px solid var(--neon-blue);
            margin-bottom: 10px;
            box-shadow: 0 0 15px var(--neon-blue);
        }

        .username {
            font-weight: 700; font-size: 1.1em;
            color: #08d0fe; text-shadow: 0 0 8px #00eaffbb;
        }
        .email {
            font-size: 0.9em; color: #a8eaff;
        }

        .panel-links a, .tool-link {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500; font-size: 1.05em;
            padding: 10px 12px;
            display: flex; align-items: center; gap: 15px;
            border-radius: 9px;
            transition: background 0.14s, color 0.13s, transform 0.1s;
            margin-bottom: 5px;
        }
        .panel-links a:hover, .tool-link:hover {
            background: rgba(0, 234, 255, 0.2);
            color: #f4fdff;
            transform: translateX(5px);
        }
        .panel-links a i, .tool-link i {
            width: 20px; text-align: center;
        }

        .edit-form label {
            display: block; margin-top: 15px;
            font-size: 0.95em; color: var(--neon-blue);
            text-shadow: 0 1px 14px rgba(0, 170, 255, 0.44);
        }
        .edit-form input, .edit-form textarea, .edit-form select {
            width: 100%; padding: 10px 12px; margin-top: 8px;
            border: 1.7px solid rgba(0, 240, 255, 0.58);
            border-radius: 9px; background: rgba(7, 31, 53, 0.7);
            color: #fff; font-size: 1em;
            box-shadow: 0 0 8px rgba(4, 246, 253, 0.5) inset;
            transition: border-color 0.17s, box-shadow 0.17s, background 0.17s;
        }
        .edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus {
            border-color: var(--neon-blue);
            background: rgba(39, 63, 93, 0.8);
            box-shadow: var(--box-glow) inset;
        }
        .edit-form textarea { resize: vertical; min-height: 80px; }

        .submit-btn {
            margin-top: 20px; padding: 12px 25px;
            background: var(--plasma-gradient);
            border: none; border-radius: 10px;
            color: var(--button-text-color); font-weight: bold;
            cursor: pointer; font-size: 1.1em;
            box-shadow: 0 2px 13px rgba(0, 255, 242, 0.57);
            transition: background 0.14s, color 0.13s, transform 0.1s;
        }
        .submit-btn:hover {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-blue));
            color: #fff;
            transform: translateY(-2px);
        }

        #logoutBtn {
            background: rgba(16, 33, 59, 0.7);
            color: var(--neon-blue);
            box-shadow: none;
        }
        #logoutBtn:hover {
            background: rgba(16, 33, 59, 1);
            color: #fff;
        }

        /* Chat List specific styling */
        #chatsList button {
            background: none; border: none; cursor: pointer; outline: none;
            font-size: 1.05em; margin: 0 5px; vertical-align: middle;
            border-radius: 7px; padding: 3px 5px;
        }
        #chatsList .fa-pen { color: #0fe0ee; transition: color 0.13s; }
        #chatsList .fa-pen:hover { color: #ffd800; }
        #chatsList .fa-trash { color: #ff244e; transition: color 0.10s; }
        #chatsList .fa-trash:hover { color: #fff900; }

        /* Code Block Styling */
        pre, code {
            font-family: 'JetBrains Mono', 'Fira Mono', 'Menlo', monospace;
            font-size: 0.95em;
            background: linear-gradient(92deg,#031d39 79%,#092ff8 120%);
            border-radius: 11px;
            border: 1.7px solid var(--neon-blue);
            color: #17fafd;
            box-shadow: 0 0 19px rgba(0, 234, 255, 0.22), 0 0 48px rgba(11, 234, 255, 0.22) inset;
            transition: background 0.3s, border-color 0.3s, color 0.3s;
            margin: 1.15em 0 1em 0;
            overflow-x: auto;
            position: relative;
            padding: 1.18em 1.3em 1.16em 1.13em;
        }
        pre::before {
            content: "CODE";
            color: var(--neon-blue);
            font-size: 0.82em;
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 5px; right: 29px;
            opacity: 0.17;
            letter-spacing: 0.13em;
            pointer-events: none;
        }
        .copy-btn {
            position: absolute;
            top: 10px; right: 13px;
            z-index: 3;
            border-radius: 8px;
            border: none;
            padding: 3px 15px;
            background: linear-gradient(95deg,#0cf3ff 40%,#0980ff 120%);
            color: #06182f;
            font-size: 0.9em;
            font-family: 'Inter';
            font-weight: bold;
            box-shadow: 0 2px 9px rgba(24, 227, 255, 0.77), 0 0 7px rgba(0, 255, 215, 0.64);
            transition: background 0.15s, color 0.15s;
            cursor: pointer;
            outline: none;
            border: 1px solid rgba(12, 243, 255, 0.21);
        }
        .copy-btn:hover {
            background: #008cee; color: #fff;
        }

        /* In-message controls (Copy, Share, Regenerate, Edit) */
        .inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn {
            padding: 4px 10px; border-radius: 7px; border: none;
            background: var(--plasma-gradient);
            color: var(--button-text-color);
            font-family: 'Inter', Arial, sans-serif;
            font-size: 0.9em; font-weight: 600;
            display: inline-flex; align-items: center; gap: 4px;
            margin-top: 6px; margin-right: 3px;
            cursor: pointer;
            box-shadow: 0 2px 7px rgba(23, 246, 254, 0.32);
            transition: background 0.14s, color 0.13s;
        }
        .inline-copy-btn:hover, .inline-share-btn:hover, .regen-btn:hover, .inline-edit-btn:hover{
            background: linear-gradient(94deg, var(--neon-purple), var(--neon-blue) 90%);
            color: #fff;
        }

        /* File Attachments & Previews */
        .file-attachments {
            display: flex; flex-wrap: wrap; gap: 8px; margin: 8px 0; max-width: 100%;
        }
        .chat-media-preview {
            max-width: 100%; max-height: 250px; border-radius: 12px; display: block;
        }
        .image-preview-thumb, .video-preview-thumb {
            border: 2px solid var(--neon-blue); box-shadow: 0 0 10px var(--neon-blue);
        }
        .chat-message.ai .msg img.chat-media-preview { cursor: zoom-in; }
        .audio-preview-thumb { width: 90%; min-height: 40px; border-radius: 10px; }
        .file-link, .file-placeholder {
            display: inline-block; padding: 8px 12px; background: rgba(11, 36, 71, 0.7);
            border: 1px solid rgba(26, 248, 255, 0.32); border-radius: 10px;
            color: var(--neon-blue); text-decoration: none; font-size: 0.9em; font-weight: bold;
        }
        .file-link i, .file-placeholder i { margin-right: 5px; }

        .file-preview{
            display:none;
            background:rgba(15,36,65,0.98);
            border-radius:12px;
            color:#c4f2ff;
            font-size:.98em;
            box-shadow:0 3px 15px #00aac0bb;
            margin:0 auto 10px auto;
            width:94vw;
            max-width:520px;
            padding:10px 14px 10px 15px;
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            border: 1.5px solid rgba(0, 255, 255, 0.27);
        }
        .file-preview img, .file-preview video {
            max-width:58px; max-height:41px; border-radius:6px; margin-right:6px; vertical-align: middle;
        }
        .file-preview audio { width:52px; margin-right:7px; }
        .remove-file-btn {
            color: #fff !important; background:#d23 !important; border:none !important;
            border-radius:50% !important; padding:2px 6px !important; cursor:pointer !important;
            font-size:1.2em !important; font-weight:bold !important; margin-left:8px !important;
            transition: background .16s, color .16s !important; min-width: 24px !important; height: 24px !important;
            display: inline-flex !important; align-items: center !important; justify-content: center !important;
        }
        .remove-file-btn:hover { background:#ff4444 !important; color:#fff !important; transform: scale(1.1) !important; }

        /* Emoji Panel */
        #emojiPanel {
            display:none; position: fixed; left:10px; bottom:110px; z-index:2222;
            background: rgba(5, 31, 70, 0.98); border-radius: 15px;
            padding: 16px 15px 12px 15px;
            box-shadow: 0 5px 22px rgba(0, 255, 241, 0.58);
            border: 1px solid rgba(0, 255, 255, 0.4);
        }
        .emoji-pick {
            font-size:1.23em; cursor:pointer; padding:4px 8px; border-radius:10px;
            transition:background .13s; user-select:none;
        }
        .emoji-pick:hover { background:rgba(53, 205, 253, 0.4); }

        /* AI Image Preview */
        #ai-image-preview {
            display:none; position:fixed; z-index:1210; right:22px; bottom:100px; max-width:320px;
            background:rgba(25, 26, 38, 0.9); padding:12px; border-radius:17px;
            box-shadow:0 2px 19px rgba(0, 255, 242, 0.72);
        }
        #ai-image-preview img {
            max-width:210px; max-height:210px; border-radius:12px; display:block;
            box-shadow: 0 0 10px var(--neon-blue); /* Added glow to AI generated images */
        }
        #ai-image-close {
            float:right; background:rgba(35, 35, 58, 0.7); border:none; border-radius:7px;
            color:var(--neon-blue); font-size:1.5em; cursor:pointer; margin-left:5px;
        }
        #ai-image-close:hover { color:#fff; background:rgba(35, 35, 58, 1); }
        #ai-image-dl {
            margin-top:9px; padding:7px 20px; background:linear-gradient(90deg,#00ffff,#0090ff);
            color:#222; border:none; border-radius:8px;
            box-shadow:0 2px 7px rgba(0, 255, 242, 0.78); cursor:pointer; font-weight:bold;
        }

        /* Lightbox for large images */
        #lightbox {
            display: none; position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.85); z-index: 5000;
            justify-content: center; align-items: center;
        }
        #lightbox.active { display: flex; }
        #lightbox img {
            max-width: 90vw; max-height: 90vh;
            border: 2px solid var(--neon-blue); border-radius: 10px;
            box-shadow: 0 0 50px var(--neon-blue);
        }

        /* Call Modal - Cosmic Redesign */
        #callModal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: var(--call-bg);
            z-index: 4000;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }
        #callModal.active { display: flex; }

        #callHeader {
            color: var(--call-header-color);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em;
            text-shadow: var(--text-glow);
            margin-bottom: 20px;
            animation: plasmaFlow 4s linear infinite; /* Reuse plasma glow */
            background-size: 300% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        #botImageContainer {
            margin-top: 20px;
            position: relative;
        }
        #botImageContainer img {
            width: 180px; height: 180px;
            border-radius: 50%;
            border: 4px solid var(--neon-blue);
            box-shadow: 0 0 30px var(--neon-blue);
            transition: transform 0.3s ease;
            object-fit: cover;
        }
        @keyframes head-nod {
            0% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }
        #botImageContainer.speaking img {
            border-color: #00ff00;
            box-shadow: 0 0 30px #00ff00, 0 0 50px rgba(0,255,0,0.5);
            transform: scale(1.08);
            animation: head-nod 1.2s infinite ease-in-out;
        }

        #botSpeakingIndicator {
            position: absolute;
            top: -10px; left: -10px;
            width: 200px; height: 200px;
            border-radius: 50%;
            border: 5px solid transparent;
            box-shadow: 0 0 20px var(--neon-blue);
            animation: pulse 1s infinite;
            display: none;
            z-index: -1;
        }
        #botImageContainer.speaking #botSpeakingIndicator {
            box-shadow: 0 0 40px #00ff00, 0 0 60px rgba(0,255,0,0.6);
            border-color: #00ff00;
            display: block;
            animation: glow-spread 1.7s infinite ease-in-out;
        }
        @keyframes glow-spread {
            0% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; }
            50% { box-shadow: 0 0 30px #00ff00, 0 0 50px #00ff0088; opacity: 1; }
            100% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; }
        }

        #callStatusMessage {
            color: var(--call-status-color);
            font-size: 1.2em;
            margin-top: 25px;
            height: 30px;
            text-align: center;
            font-style: italic;
            text-shadow: 0 0 10px var(--call-status-color);
            font-family: 'JetBrains Mono', monospace;
        }

        #tapToTalk {
            color: var(--neon-purple);
            font-size: 1.3em;
            margin-top: 10px;
            text-shadow: var(--text-glow);
            animation: neon-pulse 1.5s infinite alternate;
            display: none;
            font-family: 'Orbitron', sans-serif;
        }
        @keyframes neon-pulse {
            from { opacity: 0.7; transform: scale(1.0); }
            to { opacity: 1.0; transform: scale(1.02); }
        }

        #callConversation {
            flex-grow: 1;
            width: 100%;
            max-width: 600px;
            overflow-y: auto;
            margin: 30px 0;
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        #callConversation::-webkit-scrollbar { display: none; }

        .call-msg {
            padding: 12px 18px;
            border-radius: 18px;
            line-height: 1.5;
            word-break: break-word;
            font-size: 1em;
            animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .call-msg.user {
            background: var(--call-user-bubble);
            color: var(--main-text-color);
            text-align: right;
            margin-left: auto;
            max-width: 80%;
            border-bottom-right-radius: 6px;
            box-shadow: var(--box-glow);
        }
        .call-msg.bot {
            background: var(--call-bot-bubble);
            color: var(--main-text-color);
            margin-right: auto;
            max-width: 80%;
            border-bottom-left-radius: 6px;
            box-shadow: inset 0 0 15px rgba(0,242,255,0.08);
        }
        .call-msg.status {
            text-align: center;
            color: #888;
            font-style: italic;
            background: none;
            font-size: 0.9em;
            text-shadow: none;
            padding: 5px 10px;
        }

        #callControls {
            display: flex;
            gap: 30px;
            padding-bottom: 20px;
            margin-top: auto;
        }
        #endCallBtn, #muteCallBtn {
            background: #d23;
            color: white;
            font-size: 1.2em;
            padding: 12px 25px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(221, 34, 51, 0.6);
            transition: background 0.1s, box-shadow 0.1s, transform 0.1s;
        }
        #endCallBtn:hover, #muteCallBtn:hover {
            background: #ff7777;
            box-shadow: 0 0 20px rgba(255, 119, 119, 0.7);
            transform: translateY(-2px);
        }
        #muteCallBtn {
            background: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.6);
            color: var(--button-text-color);
        }
        #muteCallBtn:hover {
            background: var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.8);
            color: white;
        }
        #muteCallBtn.muted {
            background: var(--call-mute-btn-bg);
            box-shadow: none;
            color: var(--sub-text-color);
        }
        #muteCallBtn.muted:hover {
            background: #777;
            box-shadow: none;
            color: #fff;
        }

        /* WOW Feature 1: Particle interaction */
        .interactive-particle {
            position: absolute;
            background: radial-gradient(circle, var(--neon-blue), var(--neon-purple));
            border-radius: 50%;
            opacity: 0.6;
            animation: pulse-grow 2s infinite alternate ease-in-out;
            pointer-events: auto; /* Make it clickable */
            cursor: pointer;
            transform-origin: center;
            transition: all 0.1s ease-out;
        }
        .interactive-particle:hover {
            transform: scale(1.5);
            box-shadow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple);
            animation: none; /* Pause normal animation on hover */
        }
        @keyframes pulse-grow {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(0.8); opacity: 0.5; }
        }
        .interactive-particle.burst {
            animation: burst 0.5s forwards;
            pointer-events: none;
        }
        @keyframes burst {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(3); opacity: 0; filter: blur(5px); }
        }

        /* WOW Feature 3: Dynamic AI Avatar (simplified visual) */
        #ai-status-visual {
            position: absolute;
            top: 10px; right: 10px;
            width: 30px; height: 30px;
            border-radius: 50%;
            background: var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
            animation: ai-pulse 2s infinite ease-in-out;
            display: none; /* Controlled by JS */
            z-index: 100;
        }
        @keyframes ai-pulse {
            0%, 100% { transform: scale(0.8); opacity: 0.6; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        #ai-status-visual.active { display: block; }
        #ai-status-visual.thinking { background: var(--neon-purple); box-shadow: 0 0 10px var(--neon-purple); animation: ai-fast-pulse 0.8s infinite alternate; }
        @keyframes ai-fast-pulse {
            0%, 100% { transform: scale(0.9); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        #ai-status-visual.speaking { background: #00ff00; box-shadow: 0 0 10px #00ff00; animation: ai-speaking-wave 1s infinite alternate; }
        @keyframes ai-speaking-wave {
            0% { transform: scale(0.8) translateY(0); opacity: 0.7; }
            50% { transform: scale(1.1) translateY(-3px); opacity: 1; }
            100% { transform: scale(0.8) translateY(0); opacity: 0.7; }
        }


        /* WOW Feature 4: Quantum Leap Transitions for chat switching */
        .chat-transition-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 5000;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 3em;
            color: var(--neon-blue);
            text-shadow: var(--text-glow);
            letter-spacing: 5px;
            overflow: hidden;
        }
        .chat-transition-overlay::before {
            content: '';
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,242,255,0.3) 0%, transparent 70%);
            opacity: 0;
            animation: warp-pulse 1.5s ease-out forwards;
        }

        .chat-transition-overlay.active {
            animation: fade-in-out 1.5s forwards;
            pointer-events: auto;
        }

        @keyframes fade-in-out {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
        @keyframes warp-pulse {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(2.5); opacity: 0; }
        }
        .chat-transition-text {
            transform: scale(0.8);
            opacity: 0;
            animation: text-reveal 1.5s ease-out forwards;
        }
        @keyframes text-reveal {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        /* WOW Feature 5: Contextual Background Shifting */
        .chat-viewport.creative-mode .nebula-layer:nth-child(1) { animation-duration: 40s; }
        .chat-viewport.creative-mode .nebula-layer:nth-child(2) { animation-duration: 30s; }
        .chat-viewport.creative-mode .star { opacity: 0.5; }
        .chat-viewport.creative-mode .stardust { opacity: 0.8; }
        .chat-viewport.creative-mode #cosmos-container {
            background: linear-gradient(to bottom right, #0a001a, #2e0a0a); /* Redder hue */
        }

        @media (max-width: 768px) {
            .side-panel { width: 100%; border-radius: 0; }
            .cosmic-modal { max-width: 95vw; width: unset; }
            .thruster-btn { width: 45px; height: 45px; font-size: 1.1em; }
            .capsule-input { min-height: 45px; border-radius: 25px; }
            .capsule-input textarea { padding: 8px 15px; font-size: 0.95em; }
            .input-action-btn { font-size: 1em; padding: 3px 6px; }
            header { padding: 15px 20px; }
            .brand-plasma { font-size: 1.2rem; }
            .header-actions { gap: 15px; font-size: 1.2rem; }
        }

    </style>
</head>
<body>

    <div id="cosmos-container">
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div> <!-- More depth -->
    </div>

    <div class="ui-container">
        <header>
            <div class="brand-plasma">ðŸ¦… Philadelphia AI</div>
            <div class="header-actions">
                <div class="icon-btn" id="openProfileMenu" title="User Profile">
                    <i class="fa-solid fa-user-astronaut"></i>
                </div>
                <div class="icon-btn" id="openToolsMenu" title="AI Tools">
                    <i class="fa-solid fa-screwdriver-wrench"></i>
                </div>
                <div class="icon-btn" id="openLinksMenu" title="Cosmic Links">
                    <i class="fa-solid fa-satellite-dish"></i>
                </div>
            </div>
        </header>

        <div id="ai-status-visual"></div> <!-- WOW Feature 3 -->

        <div id="chat-viewport">
            <div class="message-group ai">
                <div class="msg-bubble">
                    Greetings, traveler. ðŸ¦… The cosmos is aligned. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨
                </div>
            </div>

            <div id="typing-status"></div> <!-- Typing indicator -->

            <div class="suggestions-dock" id="suggestions">
                <div class="chip holo-shimmer" onclick="sendSuggestion(this, 'Create a comic. Style: Cyberpunk Anime.')">Create a comic. Style: Cyberpunk Anime.</div>
                <div class="chip holo-shimmer" onclick="sendSuggestion(this, 'Design a website landing page for a space tourism company named \"Stellar Journeys\".')">Design a website for "Stellar Journeys".</div>
                <div class="chip holo-shimmer" onclick="sendSuggestion(this, 'Generate a sci-fi short story prompt about a lone explorer discovering an ancient alien artifact.')">Sci-fi short story prompt.</div>
            </div>
        </div>

        <div class="input-dock">
            <div class="capsule-input">
                <button type="button" class="input-action-btn" id="emojiBtn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>
                <label for="chatFile" class="input-action-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label>
                <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
                <textarea id="userInput" placeholder="Broadcast your message..." autocomplete="off"></textarea>
                <button type="button" class="input-action-btn" id="callBtn" title="Start Voice Call"><i class="fa-solid fa-phone"></i></button>
            </div>
            <button class="thruster-btn holo-shimmer" id="sendBtn" onclick="sendMessage()">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
        </div>
    </div>

    <div id="emojiPanel" class="cosmic-modal"></div>
    <div id="filePreview" class="file-preview"></div>
    <div id="ai-image-preview"></div>

    <!-- Modals & Side Panels -->
    <div class="panel-bg" id="profileMenuBg">
        <nav class="side-panel" id="profileMenu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span class="panel-header" style="text-align:left;margin-top:0;">Profile & Chats</span>
                <button class="icon-btn" style="font-size:1.5em;color:#f44;" onclick="profileMenuBg.classList.remove('active');">&times;</button>
            </div>
            <hr style="border-color: rgba(0, 255, 240, 0.19); margin: 10px 0;">
            <div id="chatsList" style="margin-bottom:15px;max-height:161px;overflow-y:auto; padding-right: 5px;">
                <div class="spinner" style="margin: 20px auto; display: block;"></div>
            </div>
            <button id="newChatBtn" class="submit-btn" style="width:100%;"><i class="fa-solid fa-plus"></i> Initiate New Transmission</button>
            <hr style="border-color: rgba(0, 255, 240, 0.19); margin: 20px 0;">
            <div class="panel-header" style="margin-top:0;">
                <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profileMenuUser">User</div>
                <div class="email" id="profileMenuEmail">email@example.com</div>
            </div>
            <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;">
                <label for="edit-name">Designation</label>
                <input type="text" id="edit-name" required>
                <label for="edit-photo">CommLink Image (URL)</label>
                <input type="url" id="edit-photo" placeholder="Paste image link">
                <span style="font-size:0.83em;color:#aae;display:block;margin:5px 0 7px 2px;"> Tip: <a href="https://postimg.cc/" target="_blank" style="color:#19fcff;">Upload at postimg.cc</a> </span>
                <button type="submit" class="submit-btn">Update Profile</button>
                <div class="status-message" id="profileStatusMsg" style="color:var(--neon-blue); text-align:center; margin-top:10px;"></div>
            </form>
            <button class="submit-btn" id="logoutBtn" style="width:100%; background:#8b0000; margin-top:20px;">Terminate Session</button>
        </nav>
    </div>

    <div class="panel-bg" id="linkMenuBg">
        <nav class="side-panel" id="linkMenu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span class="panel-header" style="text-align:left;margin-top:0;">Cosmic Links</span>
                <button class="icon-btn" style="font-size:1.5em;color:#f44;" onclick="linkMenuBg.classList.remove('active');">&times;</button>
            </div>
            <hr style="border-color: rgba(0, 255, 240, 0.19); margin: 10px 0;">
            <div class="panel-links">
                <a href="philadelphia.html"><i class="fa-solid fa-house-chimney-crack"></i>Philadelphia Nexus</a>
                <a href="index.html"><i class="fa-solid fa-globe-americas"></i>Elvion Portal</a>
                <a href="about.html"><i class="fa-solid fa-info-circle"></i> About Philadelphia AI</a>
                <a href="privacy.html"><i class="fa-solid fa-shield-alt"></i> Privacy Protocols</a>
                <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms of Engagement</a>
                <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Engage Telegram Unit</a>
            </div>
        </nav>
    </div>

    <div class="panel-bg" id="toolsMenuBg">
        <nav class="side-panel" id="toolsMenu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span class="panel-header" style="text-align:left;margin-top:0;">Philadelphia AI Tools</span>
                <button class="icon-btn" style="font-size:1.5em;color:#f44;" onclick="toolsMenuBg.classList.remove('active');">&times;</button>
            </div>
            <hr style="border-color: rgba(0, 255, 240, 0.19); margin: 10px 0;">
            <div class="panel-links">
                <h3 style="color:var(--neon-blue);margin:15px 0 8px 4px;font-size:0.9em;text-transform:uppercase;">Creative Forge</h3>
                <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
                <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Modify Photo Matrix</a>
                <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Disengage Background</a>
                <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Synthesize Comic Narrative</a>
                <hr style="border-color: #00eaff30; margin: 15px 0;">
                <h3 style="color:var(--neon-blue);margin:15px 0 8px 4px;font-size:0.9em;text-transform:uppercase;">Audio & Video Matrix</h3>
                <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Stream Generation</a>
                <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Data Narration</a>
                <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Visual Sequence</a>
                <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Visual Sequence</a>
                <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Sonic Composition</a>
                <hr style="border-color: #00eaff30; margin: 15px 0;">
                <h3 style="color:var(--neon-blue);margin:15px 0 8px 4px;font-size:0.9em;text-transform:uppercase;">Data & Portal Management</h3>
                <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Construct Web Portal</a>
                <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Portal</a>
                <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Portal Directory</a>
                <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Generate Research Report</a>
            </div>
            <button class="submit-btn" style="width:100%; margin-top:20px;" onclick="toolsMenuBg.classList.remove('active');">Close Tools</button>
        </nav>
    </div>

    <div class="panel-bg" id="toolFormModalBg">
        <div class="cosmic-modal" id="toolFormModal">
            <div class="panel-header" id="toolFormTitle">Tool Title</div>
            <hr style="border-color: rgba(0, 255, 240, 0.19); margin: 10px 0;">
            <form class="edit-form" id="toolForm" style="padding:0 6px;"></form>
            <button id="toolFormBackBtn" class="submit-btn" style="width:100%; background:#8b0000; margin-top:20px;">
                <i class="fa-solid fa-arrow-left"></i> Return to Tools
            </button>
            <div class="status-message" id="toolStatusMsg" style="color:var(--neon-blue); text-align:center; margin-top:10px;"></div>
        </div>
    </div>

    <div id="lightbox">
        <img src="" alt="Lightbox image">
    </div>

    <!-- Cosmic Call Modal -->
    <div id="callModal">
        <div id="callHeader">LIVE ORBITAL COMMUNICATION</div>
        <div id="botImageContainer">
            <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Philadelphia AI">
            <div id="botSpeakingIndicator"></div>
        </div>
        <div id="callStatusMessage">Establishing link...</div>
        <div id="tapToTalk">Initiate Vocal Transmission</div>
        <div id="callConversation">
            <div class="call-msg status">Waiting for secure connection...</div>
        </div>
        <div id="callControls">
            <button id="muteCallBtn"><i class="fa-solid fa-microphone"></i> Mute Link</button>
            <button id="endCallBtn"><i class="fa-solid fa-phone-slash"></i> Terminate Link</button>
        </div>
    </div>

    <div class="chat-transition-overlay" id="chatTransitionOverlay">
        <span class="chat-transition-text">Quantum Leap</span>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const $ = id => document.getElementById(id);

        const API_BASE_URL = 'https://web-production-9a18.up.railway.app'; // Your provided API URL

        let chats = [];
        let currentChatId = null;
        let currentMessages = [];
        let uploadedFiles = [];
        let currentUser = null;
        let currentController = null; // For aborting fetch requests

        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;

        // WOW Feature 5: Contextual background shifting state
        let currentContext = 'general'; // 'general', 'creative', 'research'

        window.addEventListener('DOMContentLoaded', () => {
            // --- UI Element References ---
            const cosmos = $('cosmos-container');
            const profileMenuBg = $('profileMenuBg');
            const profileMenu = $('profileMenu');
            const linkMenuBg = $('linkMenuBg');
            const linkMenu = $('linkMenu');
            const toolsMenuBg = $('toolsMenuBg');
            const toolsMenu = $('toolsMenu');
            const openProfileMenu = $('openProfileMenu');
            const openToolsMenu = $('openToolsMenu');
            const openLinksMenu = $('openLinksMenu');

            const logoutBtn = $('logoutBtn');
            const profileMenuUser = $('profileMenuUser');
            const profileMenuEmail = $('profileMenuEmail');
            const editName = $('edit-name');
            const editPhoto = $('edit-photo');
            const profilePicPreview = $('profilePicPreview');
            const profileForm = $('profileForm');
            const chatView = $('chat-viewport');
            const userInput = $('userInput');
            const sendBtn = $('sendBtn');
            const chatFile = $('chatFile');
            const filePreview = $('filePreview');
            const newChatBtn = $('newChatBtn');
            const chatsListEl = $('chatsList');
            const emojiPanel = $('emojiPanel');
            const emojiBtn = $('emojiBtn');
            const toolFormModalBg = $('toolFormModalBg');
            const toolFormModal = $('toolFormModal');
            const toolForm = $('toolForm');
            const toolFormTitle = $('toolFormTitle');
            const toolFormBackBtn = $('toolFormBackBtn');
            const aiPrevBox = $('ai-image-preview');
            const aiPrevClose = aiPrevBox ? aiPrevBox.querySelector('#ai-image-close') : null; // Dynamically added
            const aiPrevDLBtn = aiPrevBox ? aiPrevBox.querySelector('#ai-image-dl') : null; // Dynamically added
            const aiPrevImgBox = aiPrevBox ? aiPrevBox.querySelector('#ai-image-container') : null; // Dynamically added
            const lightbox = $('lightbox');
            const callBtn = $('callBtn');
            const callModal = $('callModal');
            const endCallBtn = $('endCallBtn');
            const muteCallBtn = $('muteCallBtn');
            const callConversation = $('callConversation');
            const botImageContainer = $('botImageContainer');
            const callStatusMessage = $('callStatusMessage');
            const tapToTalk = $('tapToTalk');
            const typingStatus = $('typing-status');
            const chatTransitionOverlay = $('chatTransitionOverlay'); // WOW Feature 4
            const aiStatusVisual = $('ai-status-visual'); // WOW Feature 3

            // --- Cosmic Engine JS ---
            function igniteCosmos() {
                // 1. Static distant stars
                for (let i = 0; i < 200; i++) {
                    createParticle('star', 100, 3);
                }
                // 2. Floating Stardust (closer layer)
                for (let i = 0; i < 80; i++) {
                   createParticle('stardust', 100, 20);
                }
                // WOW Feature 2: Cosmic Entity (Eagle)
                createCosmicEntity('cosmic-entity', 120, 40);
            }

            function createParticle(type, spread, maxDuration) {
                const particle = document.createElement('div');
                particle.className = type;
                const size = Math.random() * (type === 'star' ? 2 : 1.5) + 0.5;
                particle.style.width = `${size}px`; particle.style.height = `${size}px`;
                particle.style.left = `${Math.random() * spread}%`;
                particle.style.top = `${Math.random() * spread}%`;
                particle.style.setProperty('--duration', `${Math.random() * maxDuration + 5}s`);
                if(type==='star') particle.style.opacity = Math.random();
                if(type==='stardust') particle.style.setProperty('--shiftX', `${(Math.random() - 0.5) * 50}px`);

                cosmos.appendChild(particle);
            }

            function createCosmicEntity(className, spread, maxDuration) {
                const entity = document.createElement('div');
                entity.className = className;
                entity.style.left = `${Math.random() * spread}%`;
                entity.style.top = `${Math.random() * spread}%`;
                entity.style.setProperty('--duration', `${Math.random() * maxDuration + 20}s`); // Slower movement
                entity.style.setProperty('--startX', `${Math.random() * window.innerWidth}px`);
                entity.style.setProperty('--startY', `${Math.random() * window.innerHeight}px`);
                entity.style.setProperty('--pathX', `${(Math.random() - 0.5) * 400}px`); // Random flight path
                entity.style.setProperty('--pathY', `${(Math.random() - 0.5) * 300}px`);
                cosmos.appendChild(entity);
            }

            function launchShootingStar() {
                const star = document.createElement('div');
                star.className = 'shooting-star';
                const startX = Math.random() * window.innerWidth * 1.5;
                const startY = -100;
                star.style.setProperty('--startX', `${startX}px`);
                star.style.setProperty('--startY', `${startY}px`);
                star.style.setProperty('--angle', `${-35 + (Math.random() * 20 - 10)}deg`); // Slight angle variation
                star.style.setProperty('--length', `${Math.random() * 100 + 50}px`);
                star.style.setProperty('--duration', `${Math.random() * 2 + 1.5}s`);
                star.style.setProperty('--endX', `${(Math.random() - 0.5) * 800 - 300}px`); // More varied end points
                star.style.setProperty('--endY', `${(Math.random() - 0.5) * 600 + 400}px`);

                cosmos.appendChild(star);
                setTimeout(() => star.remove(), parseFloat(star.style.getPropertyValue('--duration')) * 1000);
            }

            igniteCosmos();
            // Launch a shooting star randomly between 3 and 8 seconds
            const randomLaunch = () => {
                launchShootingStar();
                setTimeout(randomLaunch, Math.random() * 5000 + 3000);
            }
            setTimeout(randomLaunch, 2000);

            // WOW Feature 1: Interactive Cosmic Particles
            function createInteractiveParticle() {
                const particle = document.createElement('div');
                particle.className = 'interactive-particle';
                const size = Math.random() * 10 + 5;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                particle.style.animationDelay = `${Math.random() * 3}s`;
                cosmos.appendChild(particle);

                particle.addEventListener('click', () => {
                    particle.classList.add('burst');
                    setTimeout(() => particle.remove(), 500); // Remove after burst animation
                    // Add new one after some time
                    setTimeout(createInteractiveParticle, Math.random() * 2000 + 1000);
                });
            }
            // Create a few interactive particles initially
            for(let i = 0; i < 5; i++) {
                createInteractiveParticle();
            }


            // --- UI Logic ---
            if (userInput) {
                const autoResize = () => {
                    userInput.style.height = 'auto';
                    userInput.style.height = Math.min(userInput.scrollHeight, 120) + 'px';
                };
                userInput.addEventListener('input', autoResize);
                userInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    } else if (e.key === 'Enter' && e.shiftKey) {
                        // Allow shift+enter for new line
                        const start = userInput.selectionStart;
                        const end = userInput.selectionEnd;
                        userInput.value = userInput.value.substring(0, start) + "\n" + userInput.value.substring(end);
                        userInput.selectionStart = userInput.selectionEnd = start + 1;
                        autoResize();
                    }
                });
                autoResize();
            }

            // General click handler for modals
            document.addEventListener('click', e => {
                const menus = [profileMenuBg, linkMenuBg, toolsMenuBg, emojiPanel, toolFormModalBg];
                menus.forEach(menuBg => {
                    if (menuBg && menuBg.classList.contains('active') && e.target === menuBg) {
                        menuBg.classList.remove('active');
                        // For side panels, add a slight delay for transition
                        const panel = menuBg.querySelector('.side-panel') || menuBg.querySelector('.cosmic-modal');
                        if (panel) panel.classList.remove('active');
                    }
                });

                if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
                    emojiPanel.style.display = 'none';
                }
            });

            // Toggle menu functions
            function toggleSidePanel(panelBg, panel) {
                if (panelBg.classList.contains('active')) {
                    panel.classList.remove('active');
                    setTimeout(() => panelBg.classList.remove('active'), 300); // Match CSS transition duration
                } else {
                    panelBg.classList.add('active');
                    setTimeout(() => panel.classList.add('active'), 10);
                }
            }
            if (openProfileMenu) openProfileMenu.addEventListener('click', () => toggleSidePanel(profileMenuBg, profileMenu));
            if (openLinksMenu) openLinksMenu.addEventListener('click', () => toggleSidePanel(linkMenuBg, linkMenu));
            if (openToolsMenu) openToolsMenu.addEventListener('click', () => toggleSidePanel(toolsMenuBg, toolsMenu));


            if (logoutBtn) logoutBtn.addEventListener('click', () => {
                auth.signOut();
                window.location.href = 'signup-login.html';
            });

            // Firebase Authentication State
            onAuthStateChanged(auth, user => {
                if (!user) {
                    try {
                        window.location.href = "signup-login.html";
                    } catch (e) {} // Already on login page
                    return;
                }
                currentUser = user;
                if (profileMenuUser) profileMenuUser.textContent = user.displayName || "Cosmic Traveler";
                if (profileMenuEmail) profileMenuEmail.textContent = user.email || "";
                if (editName) editName.value = user.displayName || "";
                if (editPhoto) editPhoto.value = user.photoURL || "";
                if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";
                loadUserChats(user.uid);
            });

            // Profile Form Update
            if (profileForm) {
                profileForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!currentUser) return;
                    const status = $('profileStatusMsg');
                    if (status) status.textContent = 'Transmitting data...';
                    try {
                        await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
                        if (auth.currentUser) await auth.currentUser.reload();
                        if (status) {
                            status.textContent = "Profile updated!";
                            status.style.color = var(--neon-blue);
                        }
                        setTimeout(() => {
                            profileMenuBg?.classList.remove('active');
                            profileMenu?.classList.remove('active');
                        }, 800);
                    } catch (err) {
                        if (status) {
                            status.textContent = `Error: ${err.message}`;
                            status.style.color = "#ffd700";
                        }
                    }
                });
            }

            // Chat Management
            async function loadUserChats(userId) {
                if (chatsUnsubscribe) chatsUnsubscribe();
                const chatsCol = collection(db, 'users', userId, 'chats');
                const q = query(chatsCol, orderBy('createdAt', 'desc'));
                chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                    if (snapshot.empty && !currentChatId) { // Only create new if no chats and no current chat selected
                        await createNewChat(userId);
                        return;
                    }
                    chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatsListSidebar();
                    if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                        currentChatId = chats[0].id;
                        await showQuantumLeapTransition(`Accessing Chat ${chats[0].name || 'New Chat'}`); // WOW Feature 4
                    }
                    subscribeToMessages(userId, currentChatId);
                }, (error) => {
                    console.error("Error fetching chats: ", error);
                    chatsListEl.innerHTML = `<div style="color: #f44;">Error loading transmissions.</div>`;
                });
            }

            async function createNewChat(userId) {
                if (!userId) userId = currentUser?.uid;
                if (!userId) return;
                const chatsCol = collection(db, 'users', userId, 'chats');
                try {
                    const newChatDoc = await addDoc(chatsCol, { name: "New Transmission", createdAt: serverTimestamp() });
                    currentChatId = newChatDoc.id;
                    await showQuantumLeapTransition('Initiating New Transmission'); // WOW Feature 4
                } catch (e) {
                    console.error("Error creating new chat: ", e);
                }
            }

            function subscribeToMessages(userId, chatId) {
                if (messagesUnsubscribe) messagesUnsubscribe();
                if (!userId || !chatId) {
                    renderChatBox([]);
                    return;
                }
                const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
                const q = query(messagesCol, orderBy('createdAt'));
                messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                    currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatBox(currentMessages);
                }, (error) => {
                    console.error("Error fetching messages: ", error);
                    chatView.innerHTML = `<div style="color: #f44; text-align: center; margin-top: 20px;">Error loading messages for this transmission.</div>`;
                });
            }

            if (newChatBtn) {
                newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));
            }

            function renderChatsListSidebar() {
                if (!chatsListEl) return;
                chatsListEl.innerHTML = '';
                if (chats.length === 0) {
                    chatsListEl.innerHTML = `<div style="padding: 10px; color: #a8eaff;">No transmissions yet.</div>`;
                    return;
                }
                chats.forEach((chat) => {
                    const container = document.createElement('div');
                    container.style.display = 'flex';
                    container.style.alignItems = 'center';
                    container.style.marginBottom = '6px';
                    container.style.background = chat.id === currentChatId ? 'rgba(0, 234, 255, 0.15)' : 'transparent';
                    container.style.borderRadius = '8px';
                    container.style.paddingLeft = '5px';

                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = chat.name || `Transmission`;
                    titleSpan.style.flex = '1';
                    titleSpan.style.cursor = 'pointer';
                    titleSpan.style.padding = '8px 5px';
                    titleSpan.onclick = async () => {
                        if (currentChatId !== chat.id) {
                            currentChatId = chat.id;
                            await showQuantumLeapTransition(`Accessing Chat ${chat.name || 'Untitled'}`); // WOW Feature 4
                            subscribeToMessages(currentUser.uid, currentChatId);
                            renderChatsListSidebar();
                        }
                        profileMenu?.classList.remove('active');
                        profileMenuBg?.classList.remove('active');
                    };

                    const renameBtn = document.createElement('button');
                    renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                    renameBtn.title = 'Rename';
                    renameBtn.style.margin = '0 6px 0 8px';
                    renameBtn.onclick = async (e) => {
                        e.stopPropagation();
                        const newName = prompt("Rename transmission:", chat.name);
                        if (newName && newName.trim()) {
                            const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                            await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
                        }
                    };

                    const delBtn = document.createElement('button');
                    delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                    delBtn.title = 'Delete';
                    delBtn.style.marginLeft = '6px';
                    delBtn.onclick = async (e) => {
                        e.stopPropagation();
                        if (!confirm(`Delete "${chat.name}"? This will erase all data.`)) return;

                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                        const messagesSnap = await getDocs(messagesCol);
                        const batch = writeBatch(db);
                        messagesSnap.docs.forEach(d => batch.delete(d.ref));
                        await batch.commit();

                        const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                        await deleteDoc(chatDoc);

                        if (currentChatId === chat.id) {
                            currentChatId = null;
                        }
                    };

                    container.appendChild(titleSpan);
                    container.appendChild(renameBtn);
                    container.appendChild(delBtn);
                    chatsListEl.appendChild(container);
                });
            }

            // Markdown & Code Rendering (Improved)
            const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

            function inlineMarkdown(t = '') {
                let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
                s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
                s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
                s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                return s.replace(/\n/g, '<br>');
            }

            function renderMarkdown(text = '') {
                const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
                let html = '';
                let lastIndex = 0;
                text = text || '';
                text.replace(codeBlockRegex, (match, lang, code, offset) => {
                    const before = text.slice(lastIndex, offset);
                    html += inlineMarkdown(before);
                    const language = (lang || '').toLowerCase().trim();
                    const safe = escapeHTML(code);
                    html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safe}</code></pre>`;
                    lastIndex = offset + match.length;
                    return match;
                });
                html += inlineMarkdown(text.slice(lastIndex));
                return { html };
            }

            function enhanceCodeBlocks(container) {
                if (!container) return;
                container.querySelectorAll('pre').forEach(pre => {
                    const codeEl = pre.querySelector('code');
                    if (window.hljs && codeEl) {
                        try { hljs.highlightElement(codeEl); } catch (e) { /* ignore highlight errors */ }
                    }
                    const btn = pre.querySelector('.copy-btn');
                    if (btn && codeEl) {
                        btn.addEventListener('click', async () => {
                            try {
                                await navigator.clipboard.writeText(codeEl.innerText);
                                const prev = btn.textContent;
                                btn.textContent = 'Copied!';
                                setTimeout(() => btn.textContent = prev, 800);
                            } catch (e) {
                                btn.textContent = 'Failed';
                                setTimeout(() => btn.textContent = 'Copy', 800);
                            }
                        });
                    }
                });
            }

            function renderChatBox(messages = []) {
                if (!chatView) return;
                chatView.innerHTML = '';
                (messages || []).forEach((msg) => {
                    const group = document.createElement('div');
                    group.className = 'message-group ' + (msg.role === 'user' ? 'user' : 'ai');
                    group.setAttribute('data-message-id', msg.id);
                    let innerHtml = '';

                    if (msg.role === 'user') {
                        const fileHtml = (msg.files || [])
                            .map(file => {
                                let icon = 'fa-file';
                                if (file.type.startsWith('image/')) icon = 'fa-file-image';
                                else if (file.type.startsWith('video/')) icon = 'fa-file-video';
                                else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
                                else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                                return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                            })
                            .join('');

                        innerHtml = `<div class="msg-bubble">
                            ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                            ${escapeHTML(msg.text || '')}
                            <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                                <button class="inline-edit-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                            </div>
                        </div>`;
                    } else {
                        let content;
                        if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                            content = msg.text;
                        } else {
                            content = renderMarkdown(msg.text || '').html;
                        }
                        innerHtml = `<div class="msg-bubble">${content}
                            <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                                <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                                <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                                <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                            </div>
                        </div>`;
                    }
                    group.innerHTML = innerHtml;
                    chatView.appendChild(group);
                });
                enhanceCodeBlocks(chatView);
                hookAiMsgControls();
                hookUserMsgControls();
                // Ensure suggestions dock is always at the end
                if (suggestions) chatView.appendChild(suggestions);
                setTimeout(() => {
                    chatView.scrollTop = chatView.scrollHeight;
                }, 50);
            }

            async function deleteMessagesFrom(messageId) {
                if (!currentChatId || !currentUser) return;
                const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                if (msgIndex === -1) return;
                const batch = writeBatch(db);
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                for (let i = msgIndex; i < currentMessages.length; i++) {
                    const msgToDel = currentMessages[i];
                    const docRef = doc(messagesCol, msgToDel.id);
                    batch.delete(docRef);
                }
                try {
                    await batch.commit();
                } catch (e) {
                    console.error("Error deleting messages: ", e);
                }
            }

            function hookAiMsgControls() {
                if (!chatView) return;
                chatView.querySelectorAll('.message-group.ai').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;

                    const controls = div.querySelector('.ai-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const shareBtn = controls.querySelector('.inline-share-btn');
                    const regenBtn = controls.querySelector('.regen-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                        } catch (e) {
                            console.warn('copy failed', e);
                        }
                    };

                    if (shareBtn) shareBtn.onclick = () => {
                        try {
                            const url = window.location.origin;
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const plainText = tempDiv.textContent || tempDiv.innerText || '';
                            const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;
                            if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
                            else prompt("Copy and share manually:", shareText);
                        } catch (e) {
                            console.warn('share failed', e);
                        }
                    };

                    if (regenBtn) regenBtn.onclick = async () => {
                        const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                        if (msgIndex < 1) return;
                        const userMsg = currentMessages[msgIndex - 1];
                        if (userMsg.role !== 'user') return;

                        await deleteMessagesFrom(messageId);
                        userInput.value = userMsg.text;
                        userInput.style.height = 'auto';
                        userInput.style.height = Math.min(userInput.scrollHeight, 120) + 'px';
                        uploadedFiles = [];
                        renderFilePreview();

                        showTypingAtNext();

                        const historyForRegen = currentMessages
                            .slice(0, msgIndex - 1)
                            .map(m => ({ role: m.role, content: m.text || '' }));

                        try {
                            const res = await fetch(`${API_BASE_URL}/chat`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ message: userMsg.text, history: historyForRegen, user_id: currentUser?.uid || "user" })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Server error.");
                            removeTyping();
                            await startTypewriter(data.response, false);
                        } catch (err) {
                            removeTyping();
                            await startTypewriter(`âŒ Regeneration error: ${err.message}`, false);
                        }
                    };
                });
            }

            function hookUserMsgControls() {
                if (!chatView) return;
                chatView.querySelectorAll('.message-group.user').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;

                    const controls = div.querySelector('.user-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const editBtn = controls.querySelector('.inline-edit-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                        } catch (e) {
                            console.warn('copy failed', e);
                        }
                    };

                    if (editBtn) editBtn.onclick = async () => {
                        try {
                            if (!msg.text) return;
                            userInput.value = msg.text;
                            userInput.focus();
                            await deleteMessagesFrom(messageId);
                        } catch (e) {
                            console.warn('edit failed', e);
                        }
                    };
                });
            }

            // Typing Indicators & AI Status Visual (WOW Feature 3)
            function showTypingAtNext() {
                if (!typingStatus) return;
                typingStatus.innerHTML = `<div class="msg-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></div>`;
                typingStatus.style.display = 'flex';
                aiStatusVisual.classList.add('active', 'thinking');
                chatView.scrollTop = chatView.scrollHeight;
            }

            function showTypingWithText(text) {
                if (!typingStatus) return;
                typingStatus.innerHTML = `<div class="msg-bubble" style="display:flex;align-items:center;"><span class="spinner"></span> <span style="margin-left:8px; color:var(--main-text-color); font-style:italic;">${text}</span></div>`;
                typingStatus.style.display = 'flex';
                aiStatusVisual.classList.add('active', 'thinking');
                chatView.scrollTop = chatView.scrollHeight;
            }

            function removeTyping() {
                if (!typingStatus) return;
                typingStatus.style.display = 'none';
                typingStatus.innerHTML = '';
                aiStatusVisual.classList.remove('active', 'thinking', 'speaking');
            }

            // Improved Typewriter Function for Markdown and Code
            async function startTypewriter(text, saveToDb = true) {
                removeTyping(); // Ensure typing indicator is gone

                // Special handling for rich media content
                if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) {
                    if (saveToDb) {
                        await addMessageToChat('ai', text);
                    } else {
                        const group = document.createElement('div');
                        group.className = "message-group ai";
                        group.innerHTML = `<div class="msg-bubble">${text}</div>`;
                        chatView.appendChild(group);
                        chatView.scrollTop = chatView.scrollHeight;
                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                        try {
                            await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
                        } catch (e) {
                            console.error("Error saving regenerated AI tool message: ", e);
                        }
                    }
                    return;
                }

                if (!chatView) return;

                const group = document.createElement('div');
                group.className = "message-group ai";
                const msgBubble = document.createElement('div');
                msgBubble.className = 'msg-bubble';
                group.appendChild(msgBubble);
                chatView.appendChild(group);

                const codeBlockDelimiter = '```';
                let currentSegment = '';
                let inCodeBlock = false;
                let codeLang = '';
                const parts = text.split(new RegExp(`(${codeBlockDelimiter}(\\w+)?\\n|${codeBlockDelimiter})`, 'g'));

                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];

                    if (part.startsWith(codeBlockDelimiter)) {
                        if (inCodeBlock) {
                            // End of code block
                            msgBubble.innerHTML = renderMarkdown(currentSegment + codeBlockDelimiter).html;
                            enhanceCodeBlocks(msgBubble); // Highlight the newly finished code block
                            inCodeBlock = false;
                            currentSegment += codeBlockDelimiter;
                        } else {
                            // Start of code block
                            const langMatch = part.match(/```(\w+)?\n/);
                            codeLang = langMatch ? (langMatch[1] || 'plaintext') : '';
                            msgBubble.innerHTML = renderMarkdown(currentSegment + part).html; // Render the opening ```
                            inCodeBlock = true;
                            currentSegment += part;
                        }
                        chatView.scrollTop = chatView.scrollHeight;
                        await new Promise(res => setTimeout(res, 50)); // Short pause for delimiter
                    } else {
                        // Regular text or code content
                        const words = part.split(/(\s+)/);
                        for (const word of words) {
                            if (currentController?.signal.aborted) {
                                // If aborted, stop typing and show current content
                                msgBubble.innerHTML = renderMarkdown(currentSegment + `\n\nâŒ Transmission Interrupted.`).html;
                                enhanceCodeBlocks(msgBubble);
                                return;
                            }
                            currentSegment += word;
                            msgBubble.innerHTML = renderMarkdown(currentSegment).html; // Re-render with new word
                            chatView.scrollTop = chatView.scrollHeight;
                            const delay = word.match(/[\s\.\,\!\?]/) ? 10 : 30; // Faster for punctuation/spaces
                            await new Promise(res => setTimeout(res, delay));
                        }
                    }
                }

                const finalRenderText = currentSegment;

                // Final render and controls
                msgBubble.innerHTML = renderMarkdown(finalRenderText).html + `
                    <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                        <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                        <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                        <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                    </div>
                `;
                enhanceCodeBlocks(msgBubble); // Apply highlighting to final code blocks
                chatView.scrollTop = chatView.scrollHeight;

                if (saveToDb) {
                    const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                    try {
                        await addDoc(messagesCol, { role: 'ai', text: finalRenderText, createdAt: serverTimestamp() });
                    } catch (e) {
                        console.error("Error saving AI message: ", e);
                        msgBubble.innerHTML += "<br><small style='color: #f44;'>Failed to save transmission.</small>";
                    }
                }
            }


            function renderFilePreview() {
                if (!filePreview) return;
                if (!uploadedFiles.length) {
                    filePreview.style.display = 'none';
                    filePreview.innerHTML = '';
                    return;
                }
                filePreview.style.display = 'block';
                filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                    let preview = '';
                    if (file.type.startsWith('image/')) {
                        preview = `<img src="${URL.createObjectURL(file)}" style="max-width:58px;max-height:41px;vertical-align:middle;border-radius:8px;margin-right:6px;">`;
                    } else if (file.type.startsWith('video/')) {
                        preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:58px;height:41px;vertical-align:middle;border-radius:8px;margin-right:7px;"></video>`;
                    } else if (file.type.startsWith('audio/')) {
                        preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:52px;margin-right:7px;"></audio>`;
                    } else if (file.type === 'application/pdf') {
                        preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`;
                    }
                    return `
                        <div style="display:flex;align-items:center;gap:7px;margin-bottom:1px;">
                            ${preview}
                            <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span>
                            <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
                        </div>`;
                }).join('');

                filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const idx = parseInt(btn.getAttribute('data-idx'));
                        uploadedFiles.splice(idx, 1);
                        if (!uploadedFiles.length && chatFile) chatFile.value = '';
                        renderFilePreview();
                    });
                });
            }

            function showAIImagePreview(base64, caption = '') {
                // Ensure ai-image-preview elements are created if not present
                if (!aiPrevImgBox) {
                    aiPrevBox.innerHTML = `
                        <button id="ai-image-close" style="float:right;background:#23233a;border:none;border-radius:7px;color:#00ffff;font-size:1.5em;cursor:pointer;margin-left:5px;">&times;</button>
                        <div id="ai-image-container"></div>
                        <button id="ai-image-dl" style="margin-top:9px;padding:7px 20px;background:linear-gradient(90deg,#00ffff,#0090ff);color:#222;border:none;border-radius:8px;box-shadow:0 2px 7px #00fff2c7;cursor:pointer;font-weight:bold;">Download</button>
                    `;
                    // Re-get references after adding elements
                    const aiPrevClose = aiPrevBox.querySelector('#ai-image-close');
                    const aiPrevDLBtn = aiPrevBox.querySelector('#ai-image-dl');
                    const aiPrevImgBox = aiPrevBox.querySelector('#ai-image-container');

                    if (aiPrevClose) aiPrevClose.addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
                    if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
                        const img = aiPrevImgBox.querySelector('img');
                        if (img) {
                            const a = document.createElement('a');
                            a.href = img.src;
                            a.download = 'philadelphia_ai_image.png';
                            a.click();
                        }
                    });
                }


                if (!aiPrevBox || !aiPrevImgBox) return; // Still might be null if elements aren't correctly created
                aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:210px;max-height:210px;border-radius:12px;display:block;">` + `<div style="color:#aee;font-size:.95em;margin-top:3px;text-align:center;">${caption}</div>`;
                aiPrevBox.style.display = 'block';
            }

            async function addMessageToChat(role, text, files = []) {
                if (!currentChatId || !currentUser) return;
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesCol, { role, text, files, createdAt: serverTimestamp() });
                } catch (e) {
                    console.error("Error adding message to Firestore: ", e);
                }
            }

            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            async function handleVideoGeneration(payload, isImageToVideo = false) {
                showTypingWithText('Submitting video generation job...');
                try {
                    const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
                    const commonPayload = { model: "MiniMax-Hailuo-02", duration: payload.duration || 6, resolution: payload.resolution || "1080P" };
                    let options;

                    if (isImageToVideo) {
                        payload.append('model', commonPayload.model);
                        payload.append('duration', commonPayload.duration);
                        payload.append('resolution', commonPayload.resolution);
                        options = { method: 'POST', body: payload };
                    } else {
                        const finalPayload = { ...payload, ...commonPayload };
                        options = {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(finalPayload)
                        };
                    }

                    const startRes = await fetch(API_BASE_URL + endpoint, options);
                    const startData = await startRes.json();

                    if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to start video task.');

                    removeTyping();
                    await startTypewriter(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. Standby for completion. This may take several cycles. Do not initiate new transmissions or close this channel.`);

                    const pollInterval = setInterval(async () => {
                        try {
                            const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                            const statusData = await statusRes.json();

                            if (statusRes.ok && statusData.url) {
                                clearInterval(pollInterval);
                                const videoHtml = `ðŸŽ‰ Your video sequence is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                                await addMessageToChat('ai', videoHtml);
                            } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                                clearInterval(pollInterval);
                                await startTypewriter(`âŒ Video sequence generation failed. Reason: ${statusData.error || 'Unknown error'}`);
                            }
                        } catch (pollErr) {
                            clearInterval(pollInterval);
                            await startTypewriter(`âŒ Error checking video status.`);
                        }
                    }, 20000); // Poll every 20 seconds
                } catch (err) {
                    removeTyping();
                    await startTypewriter(`âŒ Could not initiate video sequence generation: ${err.message}`);
                }
            }

            const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
            const toolDefinitions = {
                "image": {
                    title: "Generate Image",
                    description: "Fabricate stunning visuals from a textual prompt. Select a model for varied output styles.",
                    buildForm: () => `
                        <label for="tool-provider">Generation Matrix</label>
                        <select id="tool-provider"><option value="thena">Version 1 (Stylized, Rapid)</option><option value="minimax">Version 2 (Creative, Realistic)</option></select>
                        <label for="tool-prompt">Image Prompt Protocol</label>
                        <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required></textarea>
                        <label for="tool-style">Aesthetic Sub-routine (Version 1 only)</label>
                        <select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s.charAt(0).toUpperCase() + s.slice(1)}</option>`).join('')}</select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Execute Generation</button>`,
                    handleSubmit: async (form) => {
                        const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                        const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)';
                        const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
                        await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                        showTypingWithText('Activating image synthesis protocols...');
                        currentContext = 'creative'; // WOW Feature 5
                        try {
                            const res = await fetch(`${API_BASE_URL}/generate-image`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                            removeTyping();
                            await addMessageToChat('ai', 'âœ… Image synthesized! Consult the floating visualizer for output or download.');
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Image synthesis failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "edit-photo": {
                    title: "Modify Photo Matrix",
                    description: "Upload a visual data stream and dictate desired alterations.",
                    buildForm: () => `
                        <label for="tool-prompt">Modification Protocol</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required></textarea>
                        <label for="tool-file">Visual Data Stream for Modification</label><input type="file" id="tool-file" accept="image/*" required>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Modification</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files;
                        const prompt = form.querySelector('#tool-prompt').value;
                        if (!file) return "Please select a visual data stream for modification.";
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('prompt', prompt);
                        await addMessageToChat('user', `Photo modification request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Executing visual data modification...');
                        currentContext = 'creative'; // WOW Feature 5
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error((await res.json()).error || 'Failed to modify photo matrix.');
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const imgHtml = `âœ… Photo matrix modified! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Photo matrix modification failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "remove-bg": {
                    title: "Disengage Background",
                    description: "Select a visual data stream to isolate its primary subject from its environmental matrix.",
                    buildForm: () => `
                        <label for="tool-file">Select Visual Data Stream</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Disengage Background</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files;
                        if (!file) return "Please select a visual data stream.";
                        await addMessageToChat('user', `Background disengagement request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Initiating background disengagement protocols...');
                        currentContext = 'creative'; // WOW Feature 5
                        const fd = new FormData();
                        fd.append('file', file);
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const imgHtml = `âœ… Background disengaged! <br><img src="${url}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Background disengagement failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "comic": {
                    title: "Synthesize Comic Narrative",
                    description: "Input a narrative sequence to transform it into a visual comic strip. Utilize tags like [DIALOGUE], [INSTRUCTION], and [NARRATION] for structural guidance.",
                    buildForm: () => `
                        <label for="tool-story">Comic Narrative Protocol</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required></textarea>
                        <label for="tool-style">Comic Aesthetic</label><select id="tool-style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
                        <label for="tool-panels">Number of Visual Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" />
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Synthesize Comic</button>`,
                    handleSubmit: async (form) => {
                        const payload = {
                            story: form.querySelector('#tool-story').value,
                            style: form.querySelector('#tool-style').value,
                            panels: parseInt(form.querySelector('#tool-panels').value, 10),
                            user: currentUser?.displayName || "User"
                        };
                        await addMessageToChat('user', `Comic narrative synthesis request with aesthetic: ${payload.style}.`);
                        showTypingWithText('Generating visual narrative panels...');
                        currentContext = 'creative'; // WOW Feature 5
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join('');
                            const comicMessage = `ðŸ–¼ï¸ Comic narrative successfully synthesized! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                            removeTyping();
                            await addMessageToChat('ai', comicMessage);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Comic narrative synthesis failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "voice-gen": {
                    title: "Voice Stream Generation",
                    description: "Translate textual data into realistic auditory streams. Select a provider and vocal tonality.",
                    buildForm: () => `
                        <label for="tool-provider">Voice Stream Provider</label><select id="tool-provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
                        <label for="tool-prompt">Textual Data for Vocalization</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required></textarea>
                        <label for="tool-style">Vocal Tonality</label><select id="tool-style"></select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice Stream</button>`,
                    onFormReady: () => {
                        const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
                        const voices = {
                            gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                            minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                        };
                        const updateStyles = () => {
                            styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                        };
                        providerSelect.addEventListener('change', updateStyles);
                        updateStyles();
                    },
                    handleSubmit: async (form) => {
                        const provider = form.querySelector('#tool-provider').value,
                            text = form.querySelector('#tool-prompt').value,
                            style = form.querySelector('#tool-style').value;
                        const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';
                        await addMessageToChat('user', `Voice stream generation request using ${providerName}.`);
                        showTypingWithText('Initiating auditory stream synthesis...');
                        currentContext = 'creative'; // WOW Feature 5
                        try {
                            let res;
                            if (provider === 'gemini') {
                                const fd = new FormData();
                                fd.append('text', text);
                                fd.append('style', style);
                                res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                            } else {
                                res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({ text, voice_id: style })
                                });
                            }
                            if (!res.ok) throw new Error(await res.text());
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const audioHtml = `ðŸ—£ï¸ Voice stream generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', audioHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Voice stream generation failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "audio-narration": {
                    title: "Audio Data Narration",
                    description: "Upload a data document (PDF, TXT) to obtain an auditory summary in a podcast tonality.",
                    buildForm: () => `
                        <label for="tool-file">Select Data Document for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files;
                        if (!file) return "Please select a data document.";
                        await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Analyzing data and synthesizing narration...');
                        currentContext = 'creative'; // WOW Feature 5
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('style', 'podcast');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const narrationHtml = `ðŸ—£ï¸ Narration generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', narrationHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Audio narration failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "video-text": {
                    title: "Text-to-Visual Sequence",
                    description: "Articulate the desired visual sequence. This process may require several processing cycles.",
                    buildForm: () => `
                        <label for="video-prompt">Visual Sequence Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required></textarea>
                        <label for="video-duration">Sequence Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Initiate Sequence</button>`,
                    handleSubmit: async (form) => {
                        const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
                        await addMessageToChat('user', `Text-to-Visual Sequence request: "${payload.prompt}"`);
                        handleVideoGeneration(payload);
                        return null; // Handle generation in separate function for polling
                    }
                },
                "video-image": {
                    title: "Image-to-Visual Sequence",
                    description: "Upload an initial visual and define its desired animation parameters.",
                    buildForm: () => `
                        <label for="video-image-prompt">Animation Protocol</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required></textarea>
                        <label for="video-image-file">Initial Visual Data</label><input type="file" id="video-image-file" accept="image/*" required>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Initiate Sequence</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#video-image-file').files;
                        if (!file) return "Please select an initial visual data stream.";
                        await addMessageToChat('user', `Image-to-Visual Sequence request for: ${file.name}`, [{name: file.name, type: file.type}]);
                        const fd = new FormData();
                        fd.append('prompt', form.querySelector('#video-image-prompt').value);
                        fd.append('file', file);
                        handleVideoGeneration(fd, true);
                        return null; // Handle generation in separate function for polling
                    }
                },
                "music": {
                    title: "Sonic Composition",
                    description: "Compose auditory experiences from a prompt, lyrical data, and optional reference audio input. Courtesy of MiniMax.",
                    buildForm: () => `
                        <label for="music-prompt">Sonic Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required></textarea>
                        <label for="music-lyrics">Lyrical Data (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..."></textarea>
                        <label for="music-ref">Reference Audio Input (Optional)</label><input type="file" id="music-ref" accept="audio/*">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Sonic Stream</button>`,
                    handleSubmit: async (form) => {
                        const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
                        const refFile = form.querySelector('#music-ref').files;
                        await addMessageToChat('user', `Sonic composition request: "${payload.prompt}"`);
                        showTypingWithText('Composing sonic stream...');
                        currentContext = 'creative'; // WOW Feature 5
                        try {
                            if (refFile) {
                                showTypingWithText('Uploading reference audio data first...');
                                const fd = new FormData();
                                fd.append('file', refFile);
                                const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                                const uploadData = await uploadRes.json();
                                if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed.");
                                if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                                if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                                showTypingWithText('Reference data uploaded. Composing sonic stream...');
                            }
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const musicHtml = `ðŸŽµ Your sonic stream is ready! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', musicHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Sonic composition failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "website": {
                    title: "Construct Web Portal",
                    description: "Describe the desired web portal and receive a live, functional prototype.",
                    buildForm: () => `
                        <label for="website-prompt">Web Portal Blueprint</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Web Portal</button>`,
                    handleSubmit: async (form) => {
                        const prompt = form.querySelector('#website-prompt').value;
                        await addMessageToChat('user', `Web portal construction request: "${prompt.substring(0, 50)}..."`);
                        showTypingWithText('Assembling and deploying web portal...');
                        currentContext = 'creative'; // WOW Feature 5
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt, user_id: currentUser.uid })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return `ðŸŒ Web portal deployed successfully! [Access here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Web portal construction failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "edit-website": {
                    title: "Edit Last Portal",
                    description: "Provide a directive to modify your most recently constructed web portal.",
                    buildForm: () => `
                        <label for="edit-instruction">Modification Directive</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Modifications</button>`,
                    handleSubmit: async (form) => {
                        const instruction = form.querySelector('#edit-instruction').value;
                        await addMessageToChat('user', `Web portal modification request: "${instruction.substring(0, 50)}..."`);
                        showTypingWithText('Modifying and redeploying web portal...');
                        currentContext = 'creative'; // WOW Feature 5
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ instruction, user_id: currentUser.uid })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return `âœï¸ Web portal updated successfully! [Access new version here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Web portal modification failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
                "my-sites": {
                    isAction: true,
                    runAction: async () => {
                        await addMessageToChat('user', 'Show me a directory of my web portals.');
                        showTypingWithText('Accessing web portal directory...');
                        currentContext = 'general'; // WOW Feature 5
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || 'Could not fetch portals.');
                            if (!data.sites || data.sites.length === 0) return "No web portals constructed yet.";
                            const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank">${site.site_url}</a> (Constructed: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                            removeTyping();
                            return `Here is your web portal directory:\n${siteList}`;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Error fetching web portals: ${err.message}`;
                        }
                    }
                },
                "research-report": {
                    title: "Generate Research Report",
                    description: "Compile a comprehensive research report in PDF format on any specified subject.",
                    buildForm: () => `
                        <label for="research-topic">Research Subject</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>`,
                    handleSubmit: async (form) => {
                        const topic = form.querySelector('#research-topic').value;
                        await addMessageToChat('user', `Research report generation request on: "${topic}"`);
                        showTypingWithText('Initiating data acquisition and report compilation...');
                        currentContext = 'research'; // WOW Feature 5
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ topic })
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--link-color);font-weight:bold;">Download PDF Report</a>`;
                            removeTyping();
                            return `âœ… Research report on **${topic}** is ready! ${downloadLink}`;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Research report compilation failed: ${err.message}`;
                        } finally {
                            currentContext = 'general'; // WOW Feature 5
                        }
                    }
                },
            };

            if (toolsMenu) {
                toolsMenu.addEventListener('click', async (e) => {
                    const toolLink = e.target.closest('.tool-link');
                    if (!toolLink) return;
                    e.preventDefault();
                    const toolKey = toolLink.getAttribute('data-tool');
                    const tool = toolDefinitions[toolKey];
                    if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);
                    toggleSidePanel(toolsMenuBg, toolsMenu); // Close tools menu
                    if (tool.isAction) {
                        const result = await tool.runAction();
                        removeTyping();
                        if(result) await startTypewriter(result);
                    } else {
                        displayToolForm(toolKey);
                    }
                });
            }

            function displayToolForm(toolKey) {
                const tool = toolDefinitions[toolKey];
                if (!tool || !toolFormModalBg || !toolFormModal) return;
                toolFormTitle.textContent = tool.title;
                const descriptionHtml = tool.description ? `<div style="color:var(--sub-text-color);font-size:.9em;margin-bottom:12px;">${tool.description}</div>` : '';
                toolForm.innerHTML = descriptionHtml + tool.buildForm();
                if (typeof tool.onFormReady === 'function') tool.onFormReady();

                toolForm.onsubmit = async (e) => {
                    e.preventDefault();
                    const submitButton = toolForm.querySelector('button[type="submit"]');
                    const originalButtonContent = submitButton.innerHTML;
                    submitButton.innerHTML = `<span class="spinner"></span> Processing...`;
                    submitButton.disabled = true;
                    toggleSidePanel(toolFormModalBg, toolFormModal); // Close tool form modal
                    const resultText = await tool.handleSubmit(toolForm);
                    if (resultText) {
                        removeTyping();
                        await startTypewriter(resultText);
                    }
                    submitButton.innerHTML = originalButtonContent;
                    submitButton.disabled = false;
                };
                toggleSidePanel(toolFormModalBg, toolFormModal); // Open tool form modal
            }


            // Chat input and file handling
            if (chatFile) {
                chatFile.addEventListener('change', function() {
                    uploadedFiles = Array.from(this.files || []);
                    renderFilePreview();
                });
            }

            function sendSuggestion(chipEl, text) {
                userInput.value = text;
                sendMessage();
                suggestions.style.display = 'none'; // Hide suggestions after use
            }

            async function sendMessage() {
                if (!currentChatId) {
                    alert("Please select a transmission channel or initiate a new one.");
                    return;
                }
                const msgText = userInput.value.trim();
                if (!msgText && uploadedFiles.length === 0) return;

                const stopButton = document.createElement('button');
                stopButton.type = 'button';
                stopButton.id = 'stopBtn';
                stopButton.className = 'thruster-btn holo-shimmer';
                stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>';
                sendBtn.replaceWith(stopButton);
                currentController = new AbortController();
                const signal = currentController.signal;

                stopButton.addEventListener('click', () => {
                    if (currentController) {
                        currentController.abort();
                    }
                });

                const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
                await addMessageToChat('user', msgText, filesForHistory);
                const localUploadedFiles = [...uploadedFiles];
                userInput.value = '';
                uploadedFiles = [];
                renderFilePreview();
                userInput.style.height = 'auto'; // Reset textarea height

                let finalResponse = '';

                if (localUploadedFiles.length > 0) {
                    showTypingWithText('Analyzing your data stream...');
                    let endpoint = '';
                    const file = localUploadedFiles;
                    if (file.type.startsWith('image/')) endpoint = '/understand-image';
                    else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                    else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                    else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                    else {
                        removeTyping();
                        finalResponse = "Error: Unsupported data stream type.";
                    }
                    try {
                        if(endpoint) {
                            const fd = new FormData();
                            fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]}`);
                            fd.append('file', file);
                            const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Analysis failed.");
                            finalResponse = data.response;
                        }
                    } catch (err) {
                        finalResponse = err.name === 'AbortError' ? 'âŒ Data stream analysis interrupted.' : `âŒ Data stream analysis failed: ${err.message}`;
                    }
                } else if (msgText) {
                    showTypingAtNext();
                    try {
                        const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                        const res = await fetch(`${API_BASE_URL}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }),
                            signal
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || "Server error.");
                        finalResponse = data.response;
                    } catch (err) {
                        finalResponse = err.name === 'AbortError' ? 'âŒ Transmission Interrupted.' : `âŒ An error occurred: ${err.message}`;
                    }
                }

                removeTyping();
                if (finalResponse) {
                    await startTypewriter(finalResponse);
                }

                stopButton.replaceWith(sendBtn);
                currentController = null;
            }


            // Emoji functionality
            const emojis = ["ðŸ˜€","ðŸ˜‚","ðŸ˜","ðŸ¥°","ðŸ˜Ž","ðŸ‘","ðŸ™","ðŸ”¥","ðŸ’¯","ðŸŽ‰","ðŸ˜‡","ðŸ¤–","ðŸ‘€"];
            if (emojiBtn && emojiPanel && userInput) {
                emojiBtn.addEventListener('click', (e) => {
                    emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
                    emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block';
                    try {
                        const rect = emojiBtn.getBoundingClientRect();
                        emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
                    } catch (e) { /* ignore positioning errors */ }
                    emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
                        span.addEventListener('click', function () {
                            const text = this.textContent || '';
                            const start = userInput.selectionStart || 0;
                            const end = userInput.selectionEnd || 0;
                            userInput.value = userInput.value.slice(0, start) + text + userInput.value.slice(end);
                            userInput.focus();
                            userInput.selectionStart = userInput.selectionEnd = start + text.length;
                            emojiPanel.style.display = 'none';
                            userInput.dispatchEvent(new Event('input'));
                        });
                    });
                });
            }

            // WOW Feature 4: Quantum Leap Chat Transitions
            async function showQuantumLeapTransition(message) {
                if (!chatTransitionOverlay) return;
                chatTransitionOverlay.querySelector('.chat-transition-text').textContent = message;
                chatTransitionOverlay.classList.add('active');
                await new Promise(resolve => setTimeout(resolve, 1500)); // Match animation duration
                chatTransitionOverlay.classList.remove('active');
            }


            // Call Functionality (Improved UI and logic)
            let speechRecognition;
            let isCallActive = false;
            let callHistory = [];
            let botIsSpeaking = false;
            let userSaidSomething = false;
            let currentAudio = null;
            let isMuted = false;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = false; // Only listen for one utterance at a time
                speechRecognition.interimResults = true;
                speechRecognition.lang = 'en-US';

                speechRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    userSaidSomething = true;
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i].transcript;
                        } else {
                            interimTranscript += event.results[i].transcript;
                        }
                    }

                    let userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                    if (!userMsgEl) {
                        userMsgEl = document.createElement('div');
                        userMsgEl.className = 'call-msg user interim';
                        callConversation.appendChild(userMsgEl);
                    }
                    userMsgEl.textContent = finalTranscript || interimTranscript;
                    callConversation.scrollTop = callConversation.scrollHeight;

                    callStatusMessage.textContent = finalTranscript ? 'User Transmission (Final)' : 'User Transmitting...';
                    tapToTalk.style.display = 'none';
                };

                speechRecognition.onspeechend = () => {
                    // This event fires when speech is detected and then stops.
                    // We only stop listening if the bot is not speaking.
                    if (!botIsSpeaking && isCallActive) {
                        speechRecognition.stop();
                    }
                };

                speechRecognition.onend = () => {
                    if (!isCallActive) return;

                    if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted. No input accepted.';
                        tapToTalk.style.display = 'none';
                        return;
                    }

                    let finalTranscript = '';
                    const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                    if (userMsgEl) {
                        finalTranscript = userMsgEl.textContent.trim();
                        userMsgEl.remove(); // Remove interim element after final result
                    }

                    if (botIsSpeaking) {
                        // If bot is still speaking, we restart listening in speakBotResponse
                    } else if (finalTranscript && userSaidSomething) {
                        userSaidSomething = false;
                        callHistory.push({ role: 'user', content: finalTranscript });
                        addCallMessage('user', finalTranscript);
                        handleCallBotResponse();
                    } else if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening for Transmission...';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
                    }
                };

                speechRecognition.onerror = (event) => {
                    console.error('Speech recognition error', event.error);
                    if (event.error === 'no-speech' && isCallActive && !isMuted) {
                        userSaidSomething = false;
                        if (!botIsSpeaking) { // Only restart if bot isn't about to speak
                            speechRecognition.stop();
                        }
                    } else if (event.error === 'network' && isCallActive) {
                        callStatusMessage.textContent = 'Network anomaly detected. Attempting re-link...';
                        speechRecognition.stop();
                    } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                        callStatusMessage.textContent = 'Microphone access denied. Please re-configure browser settings.';
                        endCall();
                    }
                };
            } else {
                callBtn.style.display = 'none';
                console.warn("Speech Recognition not supported in this browser.");
            }

            function addCallMessage(role, text) {
                const msgEl = document.createElement('div');
                msgEl.className = `call-msg ${role}`;
                msgEl.textContent = text;
                callConversation.appendChild(msgEl);
                callConversation.scrollTop = callConversation.scrollHeight;
            }

            async function handleCallBotResponse() {
                if (!isCallActive) return;
                callStatusMessage.textContent = 'Philadelphia AI Processing...';
                tapToTalk.style.display = 'none';
                const historyForBot = callHistory.map(m => m);
                const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : "";

                try {
                    speechRecognition.stop(); // Ensure microphone is off while bot processes
                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: userMessage, history: historyForBot.slice(0, -1), user_id: currentUser?.uid || "user" })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "Server error.");
                    const botResponse = data.response;
                    callHistory.push({ role: 'ai', content: botResponse });
                    // No longer addMessage here, speakBotResponse will handle the bot text to avoid duplication
                    speakBotResponse(botResponse);
                } catch (err) {
                    const errorMsg = `âŒ Call error: ${err.message}`;
                    addCallMessage('bot', errorMsg);
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening for Transmission...';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
                    }
                }
            }

            async function speakBotResponse(text) {
                if (!isCallActive) return;
                botIsSpeaking = true;
                botImageContainer.classList.add('speaking');
                aiStatusVisual.classList.add('active', 'speaking'); // WOW Feature 3
                callStatusMessage.textContent = 'Philadelphia AI Transmitting...';

                // Display bot's full response immediately in call chat
                addCallMessage('bot', text);

                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ text: text, voice_id: 'elder' })
                    });
                    if (!res.ok) throw new Error(await res.text());
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    currentAudio = audio;
                    audio.onended = audio.onerror = () => {
                        botIsSpeaking = false;
                        botImageContainer.classList.remove('speaking');
                        aiStatusVisual.classList.remove('speaking'); // WOW Feature 3
                        currentAudio = null;
                        if (isCallActive && !isMuted) {
                            callStatusMessage.textContent = 'Listening for Transmission...';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
                        } else if (isMuted) {
                            callStatusMessage.textContent = 'Microphone Muted. No input accepted.';
                            tapToTalk.style.display = 'none';
                        }
                    };
                    audio.play();
                } catch (err) {
                    console.error("Voice gen error:", err);
                    botIsSpeaking = false;
                    botImageContainer.classList.remove('speaking');
                    aiStatusVisual.classList.remove('speaking'); // WOW Feature 3
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening (Voice Protocol Failed)...';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
                    } else if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted. No input accepted.';
                        tapToTalk.style.display = 'none';
                    }
                }
            }

            // Interrupt bot speech and allow user to talk
            function stopBotSpeakingAndStartListening() {
                if (!isCallActive) return;

                // Clear any interim user messages
                const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                if (userMsgEl) userMsgEl.remove();

                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                botIsSpeaking = false;
                botImageContainer.classList.remove('speaking');
                aiStatusVisual.classList.remove('speaking'); // WOW Feature 3

                if (!isMuted) {
                    callStatusMessage.textContent = 'Listening for Transmission...';
                    tapToTalk.style.display = 'block';
                    try {
                        speechRecognition.stop(); // Stop current listening session if any
                        speechRecognition.start(); // Start a new one
                    } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
                } else {
                    callStatusMessage.textContent = 'Microphone Muted. No input accepted.';
                    tapToTalk.style.display = 'none';
                }
            }

            callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
            callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);

            callBtn.addEventListener('click', () => {
                if (!SpeechRecognition) {
                    alert("Error: Your browser lacks the necessary Speech Recognition protocols for this feature.");
                    return;
                }
                isCallActive = true;
                isMuted = false;
                muteCallBtn.classList.remove('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Link';
                callModal.classList.add('active');
                callConversation.innerHTML = '';
                addCallMessage('status', 'Establishing secure link to Philadelphia AI...');
                callStatusMessage.textContent = 'Initiating Link...';
                tapToTalk.style.display = 'none';
                callHistory = [];
                aiStatusVisual.classList.add('active'); // WOW Feature 3
                setTimeout(() => {
                    if (!isCallActive) return;
                    addCallMessage('status', 'Link Established. Awaiting Vocal Transmission.');
                    callStatusMessage.textContent = 'Listening for Transmission...';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) { console.error("Speech recognition start failed", e); callStatusMessage.textContent = 'Microphone anomaly. Verify access permissions.'; }
                }, 1500);
            });

            function endCall() {
                isCallActive = false;
                botIsSpeaking = false;
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                callModal.classList.remove('active');
                try { speechRecognition.stop(); } catch(e) {}
                botImageContainer.classList.remove('speaking');
                aiStatusVisual.classList.remove('active', 'thinking', 'speaking'); // WOW Feature 3
                tapToTalk.style.display = 'none';
                callStatusMessage.textContent = 'Link Terminated.';
            }

            endCallBtn.addEventListener('click', endCall);

            if (muteCallBtn) {
                muteCallBtn.addEventListener('click', () => {
                    isMuted = !isMuted;
                    if (isMuted) {
                        muteCallBtn.classList.add('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute Link';
                        speechRecognition.stop();
                        callStatusMessage.textContent = 'Microphone Muted. No input accepted.';
                        tapToTalk.style.display = 'none';
                    } else {
                        muteCallBtn.classList.remove('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Link';
                        if (isCallActive && !botIsSpeaking) {
                            callStatusMessage.textContent = 'Listening for Transmission...';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
                        } else if (isCallActive && botIsSpeaking) {
                            callStatusMessage.textContent = 'Philadelphia AI Transmitting...';
                            tapToTalk.style.display = 'none';
                        }
                    }
                });
            }

            // WOW Feature 5: Contextual Background Shifting
            function updateBackgroundContext() {
                const bgContainer = $('cosmos-container');
                if (currentContext === 'creative') {
                    bgContainer.style.background = 'linear-gradient(to bottom right, #1a002a, #3e0a0a)'; // Darker, reddish-purple
                    // Also adjust nebula speeds, etc. via CSS classes
                    chatView.classList.add('creative-mode');
                } else if (currentContext === 'research') {
                    bgContainer.style.background = 'linear-gradient(to top left, #050a14, #0a1a1a)'; // Darker, greenish-blue
                    chatView.classList.add('research-mode'); // New class if needed
                }
                else {
                    bgContainer.style.background = 'linear-gradient(to bottom right, #00000a, #1a0a2e)'; // Default
                    chatView.classList.remove('creative-mode', 'research-mode');
                }
            }
            // Hook `currentContext` changes to `updateBackgroundContext`
            Object.defineProperty(window, 'currentContext', {
                get: () => currentContext,
                set: (value) => {
                    currentContext = value;
                    updateBackgroundContext();
                }
            });
            updateBackgroundContext(); // Set initial context


            if(userInput) userInput.focus();
        });
    </script>

</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
