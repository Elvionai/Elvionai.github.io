<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Philadelphia AI Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
  <style>
:root {
  /* --- DEFAULT THEME --- */
  --primary-color: #00fff7;
  --secondary-color: #0a8afe;
  --dark-bg: #070b1a;
  --fade-blue: #133c8b;
  --gradient-1: linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%);
  --gradient-user: linear-gradient(120deg, #0857ee 32%, #00fff0 89%);
  --glass: rgba(25, 38, 67, 0.82);
  --bubble-glow: 0 0 13px #00d8ffb1, 0 0 24px #0197ff40;
  --user-glow: 0 0 22px #0fffd555, 0 0 14px #36f9ff70;
  --header-glass: rgba(17,29,47,0.92);
  --code-bg: linear-gradient(92deg,#031d39 79%,#092ff8 120%);
  --code-border: #15faff;
  --code-text: #17fafd;
  --text-color: #e1fafe;
  --body-bg-radial-start: #112250;
  --body-bg-radial-mid: #060e1e;
  --body-bg-radial-end: #1e0942;
  --body-bg-linear-1: #061c4c;
  --body-bg-linear-2: #080e20;
  --body-bg-linear-3: #030721;
  --body-bg-linear-4: #052650;
  --body-bg-linear-5: #050b16;
  --body-bg-linear-6: #041048;
}

/* --- DARK THEME --- */
body.theme-dark {
  --primary-color: #8c9eff;
  --secondary-color: #a8b8ff;
  --dark-bg: #1a1a2e;
  --fade-blue: #2a2a4a;
  --gradient-1: linear-gradient(120deg, #2a2a4a 39%, #3a3a5a 68%, #4a4a7a 97%);
  --gradient-user: linear-gradient(120deg, #5a5a8a 32%, #6a6a9a 89%);
  --glass: rgba(30, 30, 45, 0.82);
  --bubble-glow: 0 0 10px #8c9effb1, 0 0 18px #a8b8ff40;
  --user-glow: 0 0 15px #a8b8ff55, 0 0 10px #c0c0ff70;
  --header-glass: rgba(26,26,46,0.92);
  --code-bg: linear-gradient(92deg,#2a2a4a 79%,#3a3a5a 120%);
  --code-border: #8c9eff;
  --code-text: #a8b8ff;
  --text-color: #e0e0e0;
  --body-bg-radial-start: #22223a;
  --body-bg-radial-mid: #1a1a2e;
  --body-bg-radial-end: #2a1a3a;
  --body-bg-linear-1: #1a1a2e;
  --body-bg-linear-2: #1a1a2e;
  --body-bg-linear-3: #1a1a2e;
  --body-bg-linear-4: #2a2a4a;
  --body-bg-linear-5: #1a1a2e;
  --body-bg-linear-6: #2a1a3a;
}

/* --- FOREST GREEN THEME --- */
body.theme-forest {
  --primary-color: #92e092;
  --secondary-color: #63a363;
  --dark-bg: #0a1f0a;
  --fade-blue: #1a3a1a;
  --gradient-1: linear-gradient(120deg, #1f3a1f 39%, #2f4f2f 68%, #3f6f3f 97%);
  --gradient-user: linear-gradient(120deg, #4f7f4f 32%, #5f8f5f 89%);
  --glass: rgba(20, 40, 20, 0.82);
  --bubble-glow: 0 0 10px #92e092b1, 0 0 18px #63a36340;
  --user-glow: 0 0 15px #63a36355, 0 0 10px #73b37370;
  --header-glass: rgba(10,31,10,0.92);
  --code-bg: linear-gradient(92deg,#1a2a1a 79%,#2a3a2a 120%);
  --code-border: #92e092;
  --code-text: #a6f0a6;
  --text-color: #e6ffe6;
  --body-bg-radial-start: #152c15;
  --body-bg-radial-mid: #0a1f0a;
  --body-bg-radial-end: #1a2a1a;
  --body-bg-linear-1: #0a1f0a;
  --body-bg-linear-2: #0a1f0a;
  --body-bg-linear-3: #0a1f0a;
  --body-bg-linear-4: #1a3a1a;
  --body-bg-linear-5: #0a1f0a;
  --body-bg-linear-6: #1a2a1a;
}

/* --- MYSTIC PURPLE THEME --- */
body.theme-purple {
  --primary-color: #d09cfd;
  --secondary-color: #9e64e0;
  --dark-bg: #1a0a2a;
  --fade-blue: #2a1a3a;
  --gradient-1: linear-gradient(120deg, #3a1f4f 39%, #4f2f6a 68%, #6a3f8f 97%);
  --gradient-user: linear-gradient(120deg, #7f4fa3 32%, #9f5fc7 89%);
  --glass: rgba(30, 20, 45, 0.82);
  --bubble-glow: 0 0 10px #d09cfdb1, 0 0 18px #9e64e040;
  --user-glow: 0 0 15px #9e64e055, 0 0 10px #b080ff70;
  --header-glass: rgba(26,10,42,0.92);
  --code-bg: linear-gradient(92deg,#2a1a3a 79%,#3a2a4a 120%);
  --code-border: #d09cfd;
  --code-text: #e0b0ff;
  --text-color: #fae0ff;
  --body-bg-radial-start: #28153a;
  --body-bg-radial-mid: #1a0a2a;
  --body-bg-radial-end: #2a1a3a;
  --body-bg-linear-1: #1a0a2a;
  --body-bg-linear-2: #1a0a2a;
  --body-bg-linear-3: #1a0a2a;
  --body-bg-linear-4: #2a1a3a;
  --body-bg-linear-5: #1a0a2a;
  --body-bg-linear-6: #2a1a3a;
}

/* --- GOLDEN HOUR THEME --- */
body.theme-gold {
  --primary-color: #ffd700;
  --secondary-color: #ffa500;
  --dark-bg: #2a1a0a;
  --fade-blue: #3a2a1a;
  --gradient-1: linear-gradient(120deg, #4f3a1f 39%, #6a4f2f 68%, #8f6a3f 97%);
  --gradient-user: linear-gradient(120deg, #a37f4f 32%, #c79f5f 89%);
  --glass: rgba(45, 30, 20, 0.82);
  --bubble-glow: 0 0 10px #ffd700b1, 0 0 18px #ffa50040;
  --user-glow: 0 0 15px #ffa50055, 0 0 10px #ffcc6670;
  --header-glass: rgba(42,26,10,0.92);
  --code-bg: linear-gradient(92deg,#3a2a1a 79%,#4a3a2a 120%);
  --code-border: #ffd700;
  --code-text: #ffeb99;
  --text-color: #fff8e6;
  --body-bg-radial-start: #3a2815;
  --body-bg-radial-mid: #2a1a0a;
  --body-bg-radial-end: #3a2a1a;
  --body-bg-linear-1: #2a1a0a;
  --body-bg-linear-2: #2a1a0a;
  --body-bg-linear-3: #2a1a0a;
  --body-bg-linear-4: #3a2a1a;
  --body-bg-linear-5: #2a1a0a;
  --body-bg-linear-6: #3a2a1a;
}

html, body {
  height: 100vh; width: 100vw; margin: 0; padding: 0;
  color: var(--text-color);
  background:
    radial-gradient(circle at 60% 45%, var(--body-bg-radial-start) 37%, var(--body-bg-radial-mid) 88%, var(--body-bg-radial-end) 100%) fixed,
    repeating-linear-gradient(100deg,var(--body-bg-linear-1) 0 9%,var(--body-bg-linear-2) 16% 19%,var(--body-bg-linear-3) 30% 41%,var(--body-bg-linear-4) 44% 62%,var(--body-bg-linear-5) 74% 89%,var(--body-bg-linear-6) 99% 100%);
  background-blend-mode: lighten, color-dodge;
  font-family: 'Roboto','Inter',system-ui,-apple-system,Segoe UI,sans-serif;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  transition: background-color 0.3s ease, color 0.3s ease; /* Smooth theme transitions */
}
body { overflow: hidden; min-height: 100vh; width: 100vw; }
#stars-container {
  pointer-events: none;
  position: fixed; left:0; top:0;right:0;bottom:0;
  width:100vw; height:100vh; z-index:1;
  overflow: hidden;
}
.star {
  position:absolute;
  background: var(--primary-color);
  box-shadow:0 0 12px var(--primary-color),0 0 22px var(--secondary-color);
  opacity: 0.23;
  border-radius: 50%;
  pointer-events: none;
  animation: star-twinkle 2.7s infinite alternate;
}
@keyframes star-twinkle {
  0% { opacity:.18; }
  41% { opacity:.88; }
  100%{ opacity:.09;}
}
.header-bar {
  position: fixed; top: 0; left: 0; width: 100vw;
  display: flex; align-items: center; justify-content: space-between;
  background: var(--header-glass);
  z-index: 1003;
  padding: 0;
  box-shadow: 0 7px 48px #00aaff27, 0 3px 41px #09fcfe15;
  border-radius: 0 0 22px 22px;
  height: 70px;
}
.menu-btn {
  background: none; border: none;
  color: var(--primary-color); font-size: 2em; cursor: pointer;
  border-radius: 14px; margin-left: 17px; margin-right: 3px;
  padding: 7px 11px;
}
.menu-btn:hover { background: #00eaff28; color: #fff; }
.site-heading {
  font-family: 'Orbitron',sans-serif;
  font-size: 1.28em; font-weight: 700;
  text-align: center; flex: 1;
  letter-spacing: .27px;
  white-space:nowrap;
  background: linear-gradient(90deg,var(--primary-color),var(--secondary-color) 40%,#fff 59%,var(--secondary-color) 89%,var(--primary-color) 100%);
  background-size: 250% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: neonglow 4.2s ease-in-out infinite alternate;
  text-shadow: 0 0 12px var(--primary-color), 0 0 27px var(--secondary-color);
  user-select: none; margin-left: 8px; margin-right: 10px;
}
@keyframes neonglow {
  0% { text-shadow: 0 0 17px var(--primary-color),0 0 30px var(--secondary-color);}
  100% { text-shadow: 0 0 29px var(--primary-color),0 0 44px var(--secondary-color);}
}
.header-welcome {
  color: var(--primary-color); font-size: .97em; margin: -2px 0 .7em 0; text-align: center;
  text-shadow: 0 0 14px var(--primary-color);
}
.main-content {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    overflow-y: hidden;
    position: relative;
    padding-top: 70px;
    padding-bottom: 86px;
    box-sizing: border-box;
}
.chat-box {
  flex: 1 1 0px; 
  overflow-y: auto;
  overflow-x: hidden;
  width: 100vw; max-width: 635px; margin: 0 auto;
  box-sizing: border-box;
  padding: 15px 8px 40px 8px;
  position: relative;
  z-index:3;
  scroll-behavior: smooth;
  display: flex;
  flex-direction: column;
}
.chat-message {
  width: 100%; display: flex; gap:9px; align-items: flex-end;
  margin: 8px 0; max-width:100vw;
  flex-shrink: 0;
}
.chat-message .msg {
  font-size: 1.01em; line-height: 1.58;
  max-width: 62vw; min-width:0; 
  padding: 11px 16px 12px 15px;
  border-radius: 16px 14px 11px 12px;
  word-break: break-word; white-space: pre-wrap; overflow-x: auto;
  background: var(--gradient-1); color: var(--text-color);
  text-shadow: 0 0 3px #23d8ff15;
  box-shadow: var(--bubble-glow);
  margin-right: auto; margin-left: 0;
  border: 1.2px solid var(--secondary-color); position:relative;
  transition:background .15s;
}
.chat-message.user { justify-content: flex-end; }
.chat-message.user .msg {
  background: var(--gradient-user);
  color: #141825; font-weight: 700;
  text-shadow: 0 0 5px var(--primary-color), 0 0 2px var(--primary-color);
  border-radius: 17px 13px 15px 11px;
  margin-left: auto; margin-right: 0;
  box-shadow: var(--user-glow);
  border: 1.2px solid var(--primary-color);
  max-width: 68vw;
}
@media (max-width:790px) {
  .chat-box { max-width:100vw; padding: 15px 4px 40px 4px; }
  .chat-message .msg { font-size: .97em; padding:9px 4vw 10px 5vw; max-width:80vw;}
  .chat-message.user .msg { max-width: 83vw; }
}
.typing-bubble {
  display: inline-flex;
  align-items: center;
  height: 28px;
  padding: 4px 12px;
  margin: 6px 4px;
  border-radius: 15px;
  background: linear-gradient(90deg,#0a4477dd 30%,var(--secondary-color) 95%);
  box-shadow: 0 2px 12px var(--primary-color);
  border: 1px solid var(--primary-color);
}
.dot-anim {
  display:inline-block;
  width: 8px; height: 8px;
  margin:0 3px; 
  background: var(--primary-color);
  border-radius: 50%;
  opacity: 0.85;
  animation: typing-blink 1.4s infinite both;
  box-shadow: 0 0 6px var(--primary-color);
}
.dot-anim:nth-child(2){animation-delay:.3s;}
.dot-anim:nth-child(3){animation-delay:.6s;}
@keyframes typing-blink {
  0%,100% {opacity:.25; transform: scale(0.8);}
  25%  {opacity:.95; transform: scale(1.1);}
  50%  {opacity:1; transform: scale(1.2);}
  75%  {opacity:.65; transform: scale(1);}
}
pre, code {
  font-family: 'JetBrains Mono','Fira Mono','Menlo',monospace;
  font-size: .99em;
  background: var(--code-bg);
  border-radius: 11px;
  border: 1.7px solid var(--code-border);
  color: var(--code-text);
  box-shadow: 0 0 19px var(--primary-color), 0 0 48px var(--primary-color) inset;
}
pre {
  overflow-x: auto;
  padding: 1.18em 1.3em 1.16em 1.13em;
  margin: 1.15em 0 1em 0; position: relative;
}
pre:before {
  content: "CODE";
  color: var(--primary-color);
  font-size: 0.82em;
  font-family: 'Orbitron', monospace;
  position: absolute; top: 5px; right: 29px; opacity: 0.17;
  letter-spacing: 0.13em; pointer-events: none;
}
.copy-btn {
  position: absolute; top: 10px; right: 13px; z-index: 3;
  border-radius: 8px; border: none; padding: 3px 15px;
  background: linear-gradient(95deg,var(--primary-color) 40%,var(--secondary-color) 120%);
  color: var(--dark-bg); font-size: .98em; font-family: 'Inter'; font-weight: bold;
  box-shadow: 0 2px 9px var(--primary-color),0 0 7px var(--primary-color);
  transition: background .15s, color .15s;
  cursor: pointer; outline: none; border: 1px solid var(--primary-color);
}
.copy-btn:hover { background: var(--secondary-color); color: #fff; }
.inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn {
  padding:4px 10px; border-radius:7px; border:none;
  background:linear-gradient(94deg,var(--primary-color),var(--secondary-color) 97%);
  color:var(--dark-bg); font-family:'Inter',Arial,sans-serif; font-size:.96em;
  font-weight:600; display:inline-flex; align-items:center; gap:4px; 
  margin-top:6px; margin-right: 3px; cursor:pointer;
  box-shadow:0 2px 7px var(--primary-color);transition:background .14s,color .13s;
}
.inline-copy-btn:hover, .inline-share-btn:hover, .regen-btn:hover, .inline-edit-btn:hover{background:var(--secondary-color); color:#fff;}
.file-attachments {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 8px 0;
    max-width: 100%;
}
.chat-media-preview {
  max-width: 100%;
  max-height: 250px;
  border-radius: 12px;
  display: block;
}
.image-preview-thumb, .video-preview-thumb {
  border: 2px solid var(--primary-color);
  box-shadow: 0 0 10px var(--primary-color);
}
.audio-preview-thumb {
  width: 90%;
  min-height: 40px;
  border-radius: 10px;
}
.file-link {
  display: inline-block;
  padding: 8px 12px;
  background: var(--fade-blue);
  border: 1px solid var(--primary-color);
  border-radius: 10px;
  color: var(--primary-color);
  text-decoration: none;
  font-size: 0.9em;
  font-weight: bold;
}
.file-link i { margin-right: 5px; }
.file-preview{
  display:none;
  background:rgba(15,36,65,0.98);
  border-radius:12px;color:#c4f2ff;font-size:.98em;
  box-shadow:0 3px 15px var(--secondary-color);
  margin:0 auto 10px auto;width:94vw;max-width:520px;
  padding:10px 14px 10px 15px;
  position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
  z-index: 1002;
  border: 1.5px solid var(--primary-color);
}
.file-preview img, .file-preview video {
  max-width:58px;max-height:41px;border-radius:6px;margin-right:6px;vertical-align: middle;
}
.file-preview audio { width:52px; margin-right:7px; }
.remove-file-btn {
  color: #fff !important; 
  background:#d23 !important;
  border:none !important; 
  border-radius:50% !important;
  padding:2px 6px !important; 
  cursor:pointer !important;
  font-size:1.2em !important; 
  font-weight:bold !important;
  margin-left:8px !important;
  transition: background .16s, color .16s !important;
  min-width: 24px !important;
  height: 24px !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}
.remove-file-btn:hover { 
  background:#ff4444 !important; 
  color:#fff !important;
  transform: scale(1.1) !important;
}

/* --- IMPROVED KEYBOARD FIT --- */
.chat-input-row {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 0;
  display: flex;
  align-items: stretch;
  gap: 8px;
  background: var(--header-glass);
  backdrop-filter: blur(8px);
  border: 1.5px solid var(--primary-color);
  border-radius: 23px 23px 0 0;
  width: 95vw;
  max-width: 900px;
  padding: 9px 12px 10px 13px;
  box-shadow: 0 0 39px var(--secondary-color), 0 11px 33px var(--primary-color);
  z-index: 1003;
}
@media (max-width: 920px) {
  .chat-input-row {
    width: 95vw;
    max-width: 100%;
    left: 50%;
    transform: translateX(-50%);
    border-radius: 22px 22px 8px 8px;
  }
}
.chat-input-row textarea{
  flex:1 1 auto;resize:none;min-height:36px;max-height:120px;
  background:var(--fade-blue);color:var(--text-color);font-size:1em;
  padding:10px 12px;border:none;border-radius:11px;
  box-shadow:0 1px 6px var(--primary-color);
}
.chat-input-row button, .chat-input-row label{
  background:none;border:none;color:var(--primary-color);font-size:1.21em;
  cursor:pointer;border-radius:10px;transition:color .13s,background .15s;padding:0;
  display:flex;align-items:center;justify-content:center;min-width:33px;
  box-shadow: 0 0 3px var(--primary-color);
}
.chat-input-row button:hover, .chat-input-row label:hover{color:#fff;background:var(--primary-color);}
#emojiPanel {
  display:none;
  position: fixed;
  left:10px;
  bottom:110px;
  z-index:2222;
  background: var(--fade-blue);
  border-radius: 15px;
  padding: 16px 15px 12px 15px;
  box-shadow: 0 5px 22px var(--primary-color);
  border: 1px solid var(--primary-color);
}
.emoji-pick {
  font-size:1.23em;
  cursor:pointer;
  padding:4px 8px;
  border-radius:10px;
  transition:background .13s;
  user-select:none;
}
.emoji-pick:hover { background:var(--primary-color); }
.status-message{padding:6px 13px;color:var(--primary-color);font-size:.98em;min-height:17px;text-align:center;margin:4px auto 0 auto;max-width:430px;word-break:break-word;}
.panel-bg {
  display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(13,20,52,0.86);z-index:1200;
}
.panel-bg.active{display:block;}
.side-panel{position:absolute;top:0;left:0;height:100vh;width:325px;background:linear-gradient(118deg,var(--dark-bg) 80%,var(--fade-blue) 200%);border-right:2.5px solid var(--primary-color);box-shadow:0 0 42px var(--primary-color);z-index:1212;
  padding:18px 16px 20px 15px;overflow-y:auto;border-radius:0 24px 32px 0;}
.side-panel .panel-header{text-align:center;margin:18px 0 13px 0;}
.side-panel img{width:56px;height:56px;border-radius:53%;margin-bottom:8px;border:2px solid var(--primary-color);}
.side-panel .username{font-weight:700;font-size:1.11em;color:var(--secondary-color);font-family:'Orbitron',sans-serif;text-shadow:0 0 8px var(--primary-color);}
.side-panel .email{font-size:.97em;color:var(--primary-color);}
.panel-links a{color:var(--primary-color);text-decoration:none;font-weight:500;font-size:1.08em;padding:8px 4px;display:flex;align-items:center;gap:12px;border-radius:9px;transition:background .14s;}
.panel-links a:hover{background:var(--primary-color);color:#f4fdff;}
.panel-links a i { width: 20px; text-align: center; }
#chatsList button{background:none;border:none;cursor:pointer;outline:none;font-size:1.11em;margin:0 5px;vertical-align:middle;border-radius:7px;padding:3px 5px;}
#chatsList .fa-pen{color:var(--primary-color);transition:color .13s;}
#chatsList .fa-pen:hover{color:#ffd800;}
#chatsList .fa-trash{color:#ff244e;transition:color .10s;}
#chatsList .fa-trash:hover{color:#fff900;}
#chatsList .fa-play{color:#04ea70;font-size:1.2em;}
#chatsList .fa-play:hover{color:var(--secondary-color);}
.edit-form label{display:block;margin-top:10px;font-size:.99em;color:var(--primary-color);text-shadow:0 1px 14px var(--secondary-color);}
.edit-form input, .edit-form textarea, .edit-form select{
  width:99%;padding:7px 11px;margin-top:5px;
  border:1.7px solid var(--primary-color);border-radius:9px;background:var(--dark-bg);color:#fff;font-size:1.02em;
  box-shadow:0 0 8px var(--primary-color) inset;transition:border-color .17s,box-shadow .17s;}
.edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus{border-color:var(--secondary-color);background:var(--fade-blue);color:#fff;}
.edit-form textarea { resize:vertical; min-height: 80px; }
.submit-btn{
  margin-top:14px; padding:10px 20px;
  background:linear-gradient(94deg,var(--primary-color),var(--secondary-color) 90%);
  border:none; border-radius:10px;
  color:var(--dark-bg); font-weight:bold; cursor:pointer; font-size:1.11em;
  box-shadow:0 2px 13px var(--primary-color); transition:background .14s,color .13s;}
.submit-btn:hover{background:var(--secondary-color);color:#fff;}
/* Spinner for loading states */
.spinner {
  display: inline-block;
  width: 20px; height: 20px;
  border: 3px solid rgba(0, 255, 247, 0.3);
  border-radius: 50%;
  border-top-color: var(--primary-color);
  animation: spin 1s ease-in-out infinite;
  margin-right: 8px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* --- THEME SWITCHER DROPDOWN --- */
.theme-switcher {
  position: relative;
  margin-right: 17px;
}
.theme-switcher #themeBtn {
  font-size: 1.8em;
  padding: 5px 9px;
  margin: 0;
  color: var(--primary-color);
}
.theme-switcher #themeBtn:hover {
  background: var(--primary-color);
  color: #fff;
}
#themeDropdown {
  display:none;
  position:absolute;
  right:0;
  top:calc(100% + 5px);
  background:var(--glass);
  border-radius:10px;
  padding:10px;
  box-shadow:0 5px 20px rgba(0,0,0,0.5);
  border: 1px solid var(--primary-color);
  display: flex;
  flex-direction: column;
  gap: 5px;
  z-index: 1005;
}
#themeDropdown .theme-option {
  background: var(--fade-blue);
  color: var(--primary-color);
  border: 1px solid var(--primary-color);
  border-radius: 7px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 0.95em;
  font-weight: 500;
  transition: background 0.2s, color 0.2s;
}
#themeDropdown .theme-option:hover {
  background: var(--primary-color);
  color: var(--dark-bg);
}

/* --- CALL OVERLAY STYLES --- */
#callOverlay {
  display:none;
  position:fixed; top:0; left:0;
  width:100vw; height:100vh;
  background:rgba(0,0,0,0.9);
  z-index:9999;
  display:flex; flex-direction:column; justify-content:center; align-items:center;
  backdrop-filter: blur(10px);
}
#botImageContainer {
  margin-bottom:20px;
  position:relative;
}
#botImageContainer img {
  width:150px; height:150px;
  border-radius:50%;
  border:3px solid var(--primary-color);
  box-shadow:0 0 20px var(--primary-color), 0 0 40px var(--secondary-color);
}
#ringingEffect {
  position:absolute; inset:0;
  border-radius:50%;
  border:2px solid var(--primary-color);
  animation:ring 1.5s infinite;
}
@keyframes ring {
  0% { transform: scale(0.9); opacity: 0.7; border-color: var(--primary-color); }
  50% { transform: scale(1.1); opacity: 0.3; border-color: var(--secondary-color); }
  100% { transform: scale(0.9); opacity: 0.7; border-color: var(--primary-color); }
}
#callOverlay.listening #ringingEffect {
  animation: ring-pulse 1.2s infinite alternate;
  border-color: #00ff73; /* Green for listening */
}
@keyframes ring-pulse {
  0% { transform: scale(1); opacity: 1; box-shadow:0 0 10px #00ff73; }
  100% { transform: scale(1.05); opacity: 0.8; box-shadow:0 0 20px #00ff73; }
}
#callStatus {
  color:var(--primary-color);
  font-family:'Orbitron',sans-serif;
  text-shadow:0 0 10px var(--primary-color);
  font-size: 1.8em;
  margin-top: 15px;
}
#userSpeechText {
  color:var(--primary-color);
  font-style:italic;
  margin-top:10px;
  font-size: 1.1em;
  max-width: 80%;
  text-align: center;
}
#endCallBtn {
  background:#ff4444;
  color:#fff;
  margin-top:30px;
}
  </style>
</head>
<body>
  <div id="stars-container"></div>

  <div class="main-content">
    
    <div class="header-bar">
      <button class="menu-btn" id="openProfileMenu" aria-label="Open profile menu"><i class="fa-solid fa-user"></i></button>
      <div class="header-titles">
        <span class="site-heading">ðŸ¦…Philadelphia AIðŸ¦…</span>
        <div class="header-welcome" id="headerWelcome"></div>
      </div>
      <!-- THEME SWITCHER -->
      <div class="theme-switcher">
        <button id="themeBtn" aria-label="Toggle theme"><i class="fa-solid fa-palette"></i></button>
        <div id="themeDropdown">
          <button class="theme-option" data-theme="default">Default</button>
          <button class="theme-option" data-theme="dark">Dark</button>
          <button class="theme-option" data-theme="forest">Forest Green</button>
          <button class="theme-option" data-theme="purple">Mystic Purple</button>
          <button class="theme-option" data-theme="gold">Golden Hour</button>
        </div>
      </div>
      <button class="menu-btn" id="openLinksMenu" aria-label="Open links menu"><i class="fa-solid fa-link"></i></button>
    </div>

    <div class="chat-box" id="chatBox"></div>

    <form class="chat-input-row" id="chatForm" autocomplete="off">
      <button type="button" id="emojiBtn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>
      <label for="chatFile" class="file-upload-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label>
      <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
      <textarea id="chatInput" placeholder="Type hereâ€¦ (Shift+Enter = new line)"></textarea>
      <!-- CALL BOT BUTTON -->
      <button type="button" id="callBtn" title="Call AI Assistant"><i class="fa-solid fa-phone"></i></button>
      <button type="button" id="toolBtn" title="Philadelphia Tools" aria-controls="toolMenu" aria-expanded="false"><i class="fa-solid fa-wrench"></i></button>
      <button type="submit" id="sendBtn" title="Send"><i class="fa-solid fa-paper-plane"></i></button>
    </form>
  </div>
  
  <div id="emojiPanel"></div>
  <div class="status-message" id="statusMsg"></div>
  <div id="filePreview" class="file-preview"></div>
  
  <div class="panel-bg" id="profileMenuBg">
    <nav class="side-panel" id="profileMenu">
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <span style="font-size:1.17em;font-weight:700;color:var(--primary-color);margin:18px 0 0 13px;">Chats</span>
        <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;"
          onclick="profileMenuBg.classList.remove('active');">&times;</button>
      </div>
      <div id="chatsList" style="margin:7px 0 8px 6px;max-height:161px;overflow-y:auto;"></div>
      <button id="newChatBtn" class="submit-btn" style="margin:0 0 12px 11px;"><i class="fa-solid fa-plus"></i> New Chat</button>
      <hr style="width:91%;margin:11px 0 7px 3%;border:1px solid var(--primary-color);">
      <div class="panel-header">
        <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
        <div class="username" id="profileMenuUser">User</div>
        <div class="email" id="profileMenuEmail">email@example.com</div>
      </div>
      <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;">
        <label for="edit-name">Name</label>
        <input type="text" id="edit-name" required>
        <label for="edit-photo">Photo URL</label>
        <input type="url" id="edit-photo" placeholder="Paste image link">
        <span style="font-size:0.83em;color:#aae;display:block;margin:5px 0 7px 2px;">
          Tip: <a href="https://postimg.cc/" target="_blank" style="color:var(--primary-color);">Upload at postimg.cc</a>
        </span>
        <button type="submit" class="submit-btn">Save</button>
        <div class="status-message" id="profileStatusMsg"></div>
      </form>
      <button class="submit-btn" id="logoutBtn" style="background:var(--dark-bg);color:var(--primary-color);margin:7px 7px 17px 7px;">Logout</button>
    </nav>
  </div>
  
  <div id="ai-image-preview" style="display:none;position:fixed;z-index:1210;right:22px;bottom:100px;max-width:320px;background:var(--fade-blue);padding:12px;border-radius:17px;box-shadow:0 2px 19px var(--primary-color);">
    <button id="ai-image-close" style="float:right;background:var(--dark-bg);border:none;border-radius:7px;color:var(--primary-color);font-size:1.5em;cursor:pointer;margin-left:5px;">&times;</button>
    <div id="ai-image-container"></div>
    <button id="ai-image-dl" style="margin-top:9px;padding:7px 20px;background:linear-gradient(90deg,var(--primary-color),var(--secondary-color));color:var(--dark-bg);border:none;border-radius:8px;box-shadow:0 2px 7px var(--primary-color);cursor:pointer;font-weight:bold;">Download</button>
  </div>
  
  <div class="panel-bg" id="linkMenuBg">
    <nav class="side-panel" id="linkMenu">
      <div class="panel-header">
        <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia logo">
        <div class="username">Philadelphia AI</div>
      </div>
      <div class="panel-links">
        <a href="philadelphia.html"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a>
        <a href="index.html"><i class="fa-solid fa-home"></i>Elvion Homepage</a>
        <a href="about.html"><i class="fa-solid fa-circle-info"></i> About US</a>
        <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
        <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms</a>
        <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Try Telegram Version</a>
      </div>
    </nav>
  </div>

  <div class="panel-bg" id="toolsMenuBg">
    <nav class="side-panel" id="toolsMenu">
        <div class="panel-header" style="text-align:left;">
            <div class="username" style="font-size:1.2em;margin-left:-8px;text-align:center;">Philadelphia AI Tools</div>
        </div>
        <div class="panel-links">
            <h3 style="color:var(--secondary-color);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Creative Suite</h3>
            <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
            <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
            <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a>
            <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a>
            <hr style="border-color: var(--primary-color); margin: 10px 0;">
            <h3 style="color:var(--secondary-color);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Audio & Video</h3>
            <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
            <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
            <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a>
            <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
            <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a>
            <hr style="border-color: var(--primary-color); margin: 10px 0;">
            <h3 style="color:var(--secondary-color);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Web & Research</h3>
            <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a>
            <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
            <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a>
            <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
        </div>
        <button class="submit-btn" style="margin-top:17px;" onclick="closeToolMenu();">Close</button>
    </nav>
  </div>

  <div class="panel-bg" id="toolFormModalBg">
    <nav class="side-panel" id="toolFormModal">
      <div class="panel-header">
        <div class="username" id="toolFormTitle">Tool Title</div>
      </div>
      <form class="edit-form" id="toolForm" style="padding:0 6px;"></form>
      <button id="toolFormBackBtn" class="submit-btn" style="background:var(--dark-bg);color:var(--primary-color);margin:7px 7px 17px 7px;">
          <i class="fa-solid fa-arrow-left"></i> Back to Tools
      </button>
      <div class="status-message" id="toolStatusMsg"></div>
    </nav>
  </div>

  <!-- CALL OVERLAY -->
  <div id="callOverlay">
    <div id="botImageContainer">
        <img src="https://i.postimg.cc/gcRyMxxy/IMG-20251106-090548-391.webp" alt="Philadelphia AI Bot">
        <div id="ringingEffect"></div>
    </div>
    <h2 id="callStatus">Calling...</h2>
    <p id="userSpeechText"></p>
    <button id="endCallBtn" class="submit-btn"><i class="fa-solid fa-phone-slash"></i> End Call</button>
  </div>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="module">
// --- START OF FULLY REVAMPED & FIXED JAVASCRIPT ---

// --- FIREBASE IMPORTS ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
import { getFirestore, collection, doc, query, orderBy, onSnapshot, addDoc, updateDoc, deleteDoc, getDocs } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";
import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-storage.js";

const firebaseConfig = {
  apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
  authDomain: "elvionai.firebaseapp.com",
  projectId: "elvionai",
  storageBucket: "elvionai.appspot.com",
  messagingSenderId: "161078300830",
  appId: "1:161078300830:web:f460df8591704eb0e96b8f"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app); // Initialize Firestore
const storage = getStorage(app); // Initialize Storage

// Short helper
const $ = id => document.getElementById(id);
const $$ = selector => document.querySelectorAll(selector);

// API Base URL
const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

// ---------- Global State Management & AbortController ----------
let userChatsRef = null; // Collection reference for current user's chats
let currentChatDocRef = null; // Document reference for the currently selected chat
let currentChatData = { id: null, name: 'Welcome Chat', history: [] }; // Stores current chat data, including messages
let chatsList = []; // Array of {id, name, createdAt} for sidebar/selector
let uploadedFiles = [];
let currentUser = null;
let typingNode = null;
let currentController = null;
let unsubscribeMessages = null; // Firestore real-time listener for messages

// Theme variables
let currentTheme = localStorage.getItem('philadelphia_theme') || 'default';

// Voice Call variables
let recognition = null; // For Web Speech API
let isCalling = false;
let audioQueue = [];
let isPlayingAudio = false;

window.addEventListener('DOMContentLoaded', () => {
  // ---------- Element Selectors ----------
  const starsContainer = $('stars-container');
  const profileMenuBg = $('profileMenuBg');
  const profileMenu = $('profileMenu');
  const linkMenuBg = $('linkMenuBg');
  const linkMenu = $('linkMenu');
  const toolsMenuBg = $('toolsMenuBg');
  const toolsMenu = $('toolsMenu');
  const toolBtn = $('toolBtn');
  const logoutBtn = $('logoutBtn');
  const headerWelcome = $('headerWelcome');
  const profileMenuUser = $('profileMenuUser');
  const profileMenuEmail = $('profileMenuEmail');
  const editName = $('edit-name');
  const editPhoto = $('edit-photo');
  const profilePicPreview = $('profilePicPreview');
  const profileForm = $('profileForm');
  const chatBox = $('chatBox');
  const chatForm = $('chatForm');
  const chatInput = $('chatInput');
  const sendBtn = $('sendBtn');
  const chatFile = $('chatFile');
  const filePreview = $('filePreview');
  const newChatBtn = $('newChatBtn');
  const chatsListEl = $('chatsList');
  const emojiPanel = $('emojiPanel');
  const emojiBtn = $('emojiBtn');
  const toolFormModalBg = $('toolFormModalBg');
  const toolForm = $('toolForm');
  const toolFormTitle = $('toolFormTitle');
  const toolFormBackBtn = $('toolFormBackBtn');
  const aiPrevBox = $('ai-image-preview');
  const aiPrevClose = $('ai-image-close');
  const aiPrevDLBtn = $('ai-image-dl');
  const aiPrevImgBox = $('ai-image-container');
  const statusMsg = $('statusMsg');

  // THEME ELEMENTS
  const themeBtn = $('themeBtn');
  const themeDropdown = $('themeDropdown');

  // CALL ELEMENTS
  const callBtn = $('callBtn');
  const callOverlay = $('callOverlay');
  const callStatus = $('callStatus');
  const userSpeechText = $('userSpeechText');
  const endCallBtn = $('endCallBtn');
  const ringingEffect = $('ringingEffect');


  if (!chatForm || !chatBox || !toolsMenu) {
    console.error("Essential UI elements are missing. App functionality will be limited.");
    return;
  }

  // --- INITIALIZE THEME ---
  document.body.className = `theme-${currentTheme}`;
  
  // --- STATUS MESSAGE HELPER ---
  function showStatusMessage(message, color = '#00eaff', duration = 3000) {
    if (statusMsg) {
      statusMsg.textContent = message;
      statusMsg.style.color = color;
      if (duration > 0) {
        setTimeout(() => { statusMsg.textContent = ''; }, duration);
      }
    }
  }


  // ---------- UI Initializers & Event Handlers ----------
  if (starsContainer) {
    starsContainer.innerHTML = '';
    for (let i = 0; i < 34; i++) {
      const s = document.createElement('div'); s.className = 'star';
      const z = Math.random() * 2.1 + 1; s.style.width = z + 'px'; s.style.height = z + 'px';
      s.style.left = Math.random() * 100 + '%'; s.style.top = Math.random() * 100 + '%';
      s.style.animationDelay = (Math.random() * 3.69) + 's';
      s.style.animationDuration = (2.2 + Math.random() * 1.1) + 's';
      starsContainer.appendChild(s);
    }
  }

  const emojis = ["ðŸ˜€","ðŸ˜‚","ðŸ˜","ðŸ¥°","ðŸ˜Ž","ðŸ‘","ðŸ™","ðŸ”¥","ðŸ’¯","ðŸŽ‰","ðŸ˜‡","ðŸ¤–","ðŸ‘€"];
  if (emojiBtn && emojiPanel && chatInput) {
    emojiBtn.addEventListener('click', (e) => {
      emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
      emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block';
      try {
        const rect = emojiBtn.getBoundingClientRect();
        emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
      } catch (e) { /* ignore positioning errors */ }
      emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
        span.addEventListener('click', function () {
          const text = this.textContent || '';
          const start = chatInput.selectionStart || 0;
          const end = chatInput.selectionEnd || 0;
          chatInput.value = chatInput.value.slice(0, start) + text + chatInput.value.slice(end);
          chatInput.focus();
          chatInput.selectionStart = chatInput.selectionEnd = start + text.length;
          emojiPanel.style.display = 'none';
          chatInput.dispatchEvent(new Event('input'));
        });
      });
    });
    document.addEventListener('click', e => {
      if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
        emojiPanel.style.display = 'none';
      }
    });
  }

  if (chatInput) {
    const autoResize = () => { chatInput.style.height = 'auto'; chatInput.style.height = Math.min(chatInput.scrollHeight, 168) + 'px'; };
    chatInput.addEventListener('input', autoResize);
    chatInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); chatForm.requestSubmit(); }});
    autoResize();
  }
  
  if (chatFile) {
      chatFile.addEventListener('change', function() {
          uploadedFiles = Array.from(this.files || []);
          renderFilePreview();
      });
  }
  
  if (aiPrevClose) aiPrevClose.addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
  if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
    const img = aiPrevImgBox.querySelector('img');
    if (img) {
      const a = document.createElement('a'); a.href = img.src; a.download = 'philadelphia_ai_image.png'; a.click();
    }
  });

  // --- THEME SWITCHER LOGIC ---
  if (themeBtn && themeDropdown) {
    themeBtn.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent document click from closing it immediately
      themeDropdown.style.display = themeDropdown.style.display === 'flex' ? 'none' : 'flex';
    });

    themeDropdown.querySelectorAll('.theme-option').forEach(button => {
      button.addEventListener('click', function(e) {
        e.stopPropagation();
        const newTheme = this.getAttribute('data-theme');
        document.body.className = `theme-${newTheme}`; // Apply theme class
        localStorage.setItem('philadelphia_theme', newTheme); // Save preference
        currentTheme = newTheme;
        themeDropdown.style.display = 'none'; // Close dropdown
      });
    });

    document.addEventListener('click', e => {
      if (themeDropdown && !themeDropdown.contains(e.target) && e.target !== themeBtn) {
        themeDropdown.style.display = 'none';
      }
    });
  }


  // ---------- Panel & Modal Management ----------
  window.closeToolMenu = () => { if (toolsMenuBg) toolsMenuBg.classList.remove('active'); };
  window.openToolMenu = () => { if (toolsMenuBg) toolsMenuBg.classList.add('active'); };

  if (profileMenuBg) {
    $('openProfileMenu').addEventListener('click', () => {
      profileMenuBg.classList.add('active');
      setTimeout(() => profileMenu.classList.add('active'), 10);
    });
    profileMenuBg.addEventListener('click', e => { if (e.target === profileMenuBg) { profileMenu.classList.remove('active'); setTimeout(() => profileMenuBg.classList.remove('active'), 110); } });
  }
  if (linkMenuBg) {
    $('openLinksMenu').addEventListener('click', () => {
      linkMenuBg.classList.add('active');
      setTimeout(() => linkMenu.classList.add('active'), 10);
    });
    linkMenuBg.addEventListener('click', e => { if (e.target === linkMenuBg) { linkMenu.classList.remove('active'); setTimeout(() => linkMenuBg.classList.remove('active'), 110); } });
  }
  if (toolBtn) toolBtn.addEventListener('click', openToolMenu);
  if (toolsMenuBg) toolsMenuBg.addEventListener('click', e => { if (e.target === toolsMenuBg) closeToolMenu(); });
  if (toolFormBackBtn) {
    toolFormBackBtn.addEventListener('click', () => {
      toolFormModalBg.classList.remove('active');
      openToolMenu();
    });
  }
  if (toolFormModalBg) toolFormModalBg.addEventListener('click', e => { if (e.target === toolFormModalBg) toolFormModalBg.classList.remove('active'); });
  if (logoutBtn) logoutBtn.addEventListener('click', () => {
      auth.signOut();
      window.location.href = 'signup-login.html';
  });


  // ---------- Authentication & Profile Management (UPDATED FOR FIRESTORE) ----------
  onAuthStateChanged(auth, async user => {
    if (!user) {
      try { window.location.href = "signup-login.html"; } catch (e) {}
      return;
    }
    currentUser = user;
    userChatsRef = collection(db, `users/${currentUser.uid}/chats`);

    if (headerWelcome) headerWelcome.textContent = "Welcome, " + (user.displayName || (user.email || '').split('@')[0]);
    if (profileMenuUser) profileMenuUser.textContent = user.displayName || "User";
    if (profileMenuEmail) profileMenuEmail.textContent = user.email || "";
    if (editName) editName.value = user.displayName || "";
    if (editPhoto) editPhoto.value = user.photoURL || "";
    if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

    // Set up real-time listener for user's chat list
    onSnapshot(query(userChatsRef, orderBy('updatedAt', 'desc')), async (snapshot) => {
      chatsList = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

      if (chatsList.length === 0) {
        // Create a default welcome chat if user has no chats
        await createNewChat("Welcome Chat");
      } else {
        // Try to restore last selected chat or pick the newest one
        const lastChatId = localStorage.getItem(`philadelphia_last_chat_${currentUser.uid}`);
        let initialChat = chatsList[0]; // Default to newest chat
        if (lastChatId) {
          const found = chatsList.find(c => c.id === lastChatId);
          if (found) initialChat = found;
        }
        currentChatDocRef = doc(db, `users/${currentUser.uid}/chats/${initialChat.id}`);
        localStorage.setItem(`philadelphia_last_chat_${currentUser.uid}`, initialChat.id);
        setupChatListener(); // Start listening to messages for the current chat
      }
      renderChatsListSidebar();
    }, (error) => {
      console.error("Error listening to chats list:", error);
      showStatusMessage('Error loading chat list.', '#ff6b6b');
    });
  });

  if (profileForm) {
    profileForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!currentUser) return;
      const status = $('profileStatusMsg');
      if (status) status.textContent = 'Saving...';
      try {
        await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
        // No need to reload auth.currentUser, onAuthStateChanged will update UI
        if (status) { status.textContent = "Profile updated!"; status.style.color = "#00ffff"; }
        setTimeout(() => { profileMenuBg?.classList.remove('active'); }, 800);
        if (headerWelcome) headerWelcome.textContent = "Welcome, " + (auth.currentUser?.displayName || 'User');
      } catch (err) {
        if (status) { status.textContent = err.message; status.style.color = "#ffd700"; }
      }
    });
  }

  // ---------- Chat History & Rendering Logic (UPDATED FOR FIRESTORE) ----------

  // Setup Firestore listener for the currently active chat's messages
  function setupChatListener() {
    if (unsubscribeMessages) {
      unsubscribeMessages(); // Detach previous listener if any
    }
    if (!currentChatDocRef) {
      renderChatBox([]); // Clear chat if no chat is selected
      return;
    }

    const messagesRef = collection(currentChatDocRef, 'messages');
    unsubscribeMessages = onSnapshot(query(messagesRef, orderBy('timestamp')), (snapshot) => {
      currentChatData = {
        id: currentChatDocRef.id,
        name: chatsList.find(c => c.id === currentChatDocRef.id)?.name || "Untitled Chat",
        history: snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
      };
      renderChatBox(currentChatData.history);
    }, (error) => {
      console.error("Error listening to messages:", error);
      showStatusMessage('Error loading chat messages.', '#ff6b6b');
    });
  }

  async function createNewChat(name = `Chat ${new Date().toLocaleString()}`) {
    if (!userChatsRef || !currentUser) return;
    showStatusMessage('Creating new chat...', '#00eaff');
    try {
      const newChatRef = await addDoc(userChatsRef, {
        name: name,
        createdAt: new Date(),
        updatedAt: new Date(),
        userId: currentUser.uid
      });
      currentChatDocRef = newChatRef;
      localStorage.setItem(`philadelphia_last_chat_${currentUser.uid}`, newChatRef.id);
      setupChatListener(); // Start listening to the new chat's messages
      renderChatBox([]); // Clear chat box for new chat
      await typeBotMessage("Hello! How can I help you today?");
      showStatusMessage('New chat created!', '#00ff73', 1500);
    } catch (e) {
      console.error("Error creating new chat:", e);
      showStatusMessage('Failed to create new chat.', '#ff6b6b');
    }
  }

  if (newChatBtn) {
    newChatBtn.addEventListener('click', () => createNewChat());
  }

  function renderChatsListSidebar() {
    if (!chatsListEl) return;
    chatsListEl.innerHTML = '';
    chatsList.forEach((chat) => {
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.marginBottom = '6px';
      container.classList.add('chat-list-item');
      if (currentChatDocRef && currentChatDocRef.id === chat.id) {
        container.style.fontWeight = 'bold';
        container.style.color = 'var(--primary-color)';
      }

      const titleSpan = document.createElement('span');
      titleSpan.textContent = chat.name || "Untitled Chat";
      titleSpan.style.flex = '1';
      titleSpan.style.cursor = 'pointer';
      titleSpan.onclick = () => {
        if (currentChatDocRef && currentChatDocRef.id === chat.id) {
            profileMenu?.classList.remove('active');
            profileMenuBg?.classList.remove('active');
            return; // Already selected
        }
        currentChatDocRef = doc(db, `users/${currentUser.uid}/chats/${chat.id}`);
        localStorage.setItem(`philadelphia_last_chat_${currentUser.uid}`, chat.id);
        setupChatListener(); // Start listening to messages for the selected chat
        renderChatsListSidebar(); // Re-render to highlight active chat
        profileMenu?.classList.remove('active');
        profileMenuBg?.classList.remove('active');
      };

      const renameBtn = document.createElement('button');
      renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
      renameBtn.title = 'Rename';
      renameBtn.style.margin = '0 6px 0 8px';
      renameBtn.onclick = async (e) => {
        e.stopPropagation();
        const newName = prompt("Rename chat:", chat.name);
        if (newName && newName.trim() !== chat.name) {
          try {
            await updateDoc(doc(db, `users/${currentUser.uid}/chats/${chat.id}`), { name: newName.trim(), updatedAt: new Date() });
            showStatusMessage('Chat renamed!', '#00ff73', 1500);
          } catch (error) {
            console.error("Error renaming chat:", error);
            showStatusMessage('Failed to rename chat.', '#ff6b6b');
          }
        }
      };

      const delBtn = document.createElement('button');
      delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
      delBtn.title = 'Delete';
      delBtn.style.marginLeft = '6px';
      delBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm("Delete this chat? This cannot be undone.")) return;

        try {
          // 1. Delete associated files from Storage
          const messagesSnapshot = await getDocs(collection(db, `users/${currentUser.uid}/chats/${chat.id}/messages`));
          const deleteFilePromises = [];
          for (const msgDoc of messagesSnapshot.docs) {
            const msgData = msgDoc.data();
            if (msgData.files && msgData.files.length > 0) {
              msgData.files.forEach(file => {
                if (file.storagePath) { // Ensure storagePath exists
                  const fileRef = ref(storage, file.storagePath);
                  deleteFilePromises.push(deleteObject(fileRef).catch(error => console.warn("Error deleting file from storage:", file.url, error)));
                }
              });
            }
          }
          await Promise.all(deleteFilePromises);

          // 2. Delete messages subcollection documents
          const deleteMessagePromises = messagesSnapshot.docs.map(msgDoc => deleteDoc(doc(db, `users/${currentUser.uid}/chats/${chat.id}/messages`, msgDoc.id)));
          await Promise.all(deleteMessagePromises);

          // 3. Delete the chat document itself
          await deleteDoc(doc(db, `users/${currentUser.uid}/chats/${chat.id}`));

          // If the current chat was deleted, switch to another or create new
          if (currentChatDocRef && currentChatDocRef.id === chat.id) {
              if (chatsList.length > 1) { // chatsList still contains the deleted chat at this point due to async Firestore update
                  const remainingChats = chatsList.filter(c => c.id !== chat.id);
                  currentChatDocRef = doc(db, `users/${currentUser.uid}/chats/${remainingChats[0].id}`);
                  localStorage.setItem(`philadelphia_last_chat_${currentUser.uid}`, remainingChats[0].id);
              } else { // No more chats, create a new one
                  currentChatDocRef = null;
                  await createNewChat("Welcome Chat"); // Create new chat directly
              }
              setupChatListener();
          }
          showStatusMessage('Chat deleted!', '#00ff73', 1500);
        } catch (error) {
          console.error("Error deleting chat:", error);
          showStatusMessage('Failed to delete chat.', '#ff6b6b');
        }
      };

      const openBtn = document.createElement('button');
      openBtn.innerHTML = '<i class="fa-solid fa-play"></i>';
      openBtn.title = 'Open Chat';
      openBtn.onclick = (e) => {
        e.stopPropagation();
        if (currentChatDocRef && currentChatDocRef.id === chat.id) {
            profileMenu?.classList.remove('active');
            profileMenuBg?.classList.remove('active');
            return; // Already selected
        }
        currentChatDocRef = doc(db, `users/${currentUser.uid}/chats/${chat.id}`);
        localStorage.setItem(`philadelphia_last_chat_${currentUser.uid}`, chat.id);
        setupChatListener();
        renderChatsListSidebar(); // Re-render to highlight active chat
        profileMenu?.classList.remove('active');
        profileMenuBg?.classList.remove('active');
      };

      container.appendChild(titleSpan);
      container.appendChild(renameBtn);
      container.appendChild(delBtn);
      container.appendChild(openBtn);
      chatsListEl.appendChild(container);
    });
  }

  // NOTE: chatSelector element and related logic are removed as sidebar now handles chat selection.

  const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

  function inlineMarkdown(t = '') {
    let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
    s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
    s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
    s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
    return s.replace(/\n/g, '<br>');
  }

  function renderMarkdown(text = '') {
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    let html = '';
    let lastIndex = 0;
    text = text || '';
    text.replace(codeBlockRegex, (match, lang, code, offset) => {
      const before = text.slice(lastIndex, offset);
      html += inlineMarkdown(before);
      const language = (lang || '').toLowerCase().trim();
      const safe = escapeHTML(code);
      html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safe}</code></pre>`;
      lastIndex = offset + match.length;
      return match;
    });
    html += inlineMarkdown(text.slice(lastIndex));
    return { html };
  }

  function enhanceCodeBlocks(container) {
    if (!container) return;
    container.querySelectorAll('pre').forEach(pre => {
      const codeEl = pre.querySelector('code');
      if (window.hljs && codeEl) {
        try { hljs.highlightElement(codeEl); } catch (e) { /* ignore */ }
      }
      const btn = pre.querySelector('.copy-btn');
      if (btn && codeEl) {
        btn.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(codeEl.innerText);
            const prev = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = prev, 800);
          } catch (e) { btn.textContent = 'Failed'; setTimeout(() => btn.textContent = 'Copy', 800); }
        });
      }
    });
  }

  function renderChatBox(messages = []) {
    if (!chatBox) return;
    chatBox.innerHTML = '';
    let aiMsgIdx = 0;

    (messages || []).forEach((msg, idx) => {
      const div = document.createElement('div');
      div.className = 'chat-message ' + (msg.role === 'user' ? 'user' : 'ai');

      let innerHtml = '';
      if (msg.role === 'user') {
        const fileHtml = (msg.files || [])
          .map(file => {
            if (file.type.startsWith('image/')) {
              return `<img src="${file.url}" alt="${file.name}" class="chat-media-preview image-preview-thumb">`;
            } else if (file.type.startsWith('video/')) {
              return `<video src="${file.url}" controls class="chat-media-preview video-preview-thumb"></video>`;
            } else if (file.type.startsWith('audio/')) {
              return `<audio src="${file.url}" controls class="chat-media-preview audio-preview-thumb"></audio>`;
            } else {
              return `<a href="${file.url}" target="_blank" class="chat-media-preview file-link"><i class="fa-solid fa-file"></i> ${escapeHTML(file.name)}</a>`;
            }
          })
          .join('');
        
        innerHtml = `<div class="msg">
          ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
          ${escapeHTML(msg.text || '')}
          <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
            <button class="inline-edit-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i></button>
            <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
          </div>
        </div>`;
        div.setAttribute('data-useridx', idx);
        div.setAttribute('data-message-id', msg.id); // Store Firestore message ID
      } else { // AI message
        const { html } = renderMarkdown(msg.text || '');
        innerHtml = `<div class="msg">${html}
          <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
            <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
            <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
            <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
          </div>
        </div>`;
        div.setAttribute('data-aiidx', aiMsgIdx++);
        div.setAttribute('data-message-id', msg.id); // Store Firestore message ID
      }
      
      div.innerHTML = innerHtml;
      chatBox.appendChild(div);
    });
    enhanceCodeBlocks(chatBox);
    hookAiMsgControls();
    hookUserMsgControls();
    setTimeout(() => {
      const last = chatBox.lastElementChild;
      if (last) last.scrollIntoView({ behavior: "smooth", block: "end" });
    }, 20);
  }

  function hookAiMsgControls() {
    if (!chatBox) return;
    chatBox.querySelectorAll('.chat-message.ai').forEach(div => {
      const messageId = div.getAttribute('data-message-id');
      const controls = div.querySelector('.ai-msg-controls');
      if (!controls) return;
      const copyBtn = controls.querySelector('.inline-copy-btn');
      const shareBtn = controls.querySelector('.inline-share-btn');
      const regenBtn = controls.querySelector('.regen-btn');

      if (copyBtn) copyBtn.onclick = () => {
        try {
          const msg = currentChatData.history.find(m => m.id === messageId);
          const text = msg?.text || "";
          navigator.clipboard.writeText(text.replace(/<\/?[^>]+(>|$)/g, ""));
          copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
          setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
        } catch (e) { console.warn('copy failed', e); }
      };

      if (shareBtn) shareBtn.onclick = () => {
        try {
          const msg = currentChatData.history.find(m => m.id === messageId);
          const text = msg?.text || "";
          const url = window.location.origin;
          const shareText = `${text.replace(/<\/?[^>]+(>|$)/g, "")}\n\nShared via Philadelphia AI: ${url}`;
          if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
          else prompt("Copy and share manually:", shareText);
        } catch (e) { console.warn('share failed', e); }
      };

      if (regenBtn) regenBtn.onclick = async () => {
        try {
          // Find the user message immediately preceding this AI message in history
          const aiMsgIndex = currentChatData.history.findIndex(m => m.id === messageId);
          if (aiMsgIndex === -1 || aiMsgIndex === 0) {
            showStatusMessage('Cannot regenerate: No preceding user message found.', '#ff6b6b');
            return;
          }
          const userMsgObj = currentChatData.history[aiMsgIndex - 1];
          if (!userMsgObj || userMsgObj.role !== "user") {
            showStatusMessage('Cannot regenerate: Preceding message is not a user message.', '#ff6b6b');
            return;
          }
          
          const userMsg = userMsgObj.text;
          const historyBeforeRegen = currentChatData.history.slice(0, aiMsgIndex - 1); // History up to the user message before the one being regenerated
          
          showTypingAtNext();
          try {
            const res = await fetch(`${API_BASE_URL}/chat`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message: userMsg, user_id: currentUser?.uid || "user", history: historyBeforeRegen.map(m => ({ role: m.role, content: m.text || '' })) })
            });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || 'Server error.');

            // Delete old AI message and add new one
            await deleteDoc(doc(db, `users/${currentUser.uid}/chats/${currentChatDocRef.id}/messages`, messageId));
            await addMessageToChat('ai', data.response);

            showStatusMessage('Response regenerated!', '#00ff73', 1500);
          } catch (err) {
            removeTyping();
            await addMessageToChat('ai', "âŒ Regeneration Error: " + (err.message || ''));
            showStatusMessage('Regeneration failed.', '#ff6b6b');
          }
        } catch (err) {
          console.warn('regen error', err);
          showStatusMessage('Error during regeneration setup.', '#ff6b6b');
        }
      };
    });
  }

  function hookUserMsgControls() {
    if (!chatBox) return;
    chatBox.querySelectorAll('.chat-message.user').forEach(div => {
      const messageId = div.getAttribute('data-message-id');
      const controls = div.querySelector('.user-msg-controls');
      if (!controls) return;
      const copyBtn = controls.querySelector('.inline-copy-btn');
      const editBtn = controls.querySelector('.inline-edit-btn');

      if (copyBtn) copyBtn.onclick = () => {
        try {
          const msg = currentChatData.history.find(m => m.id === messageId);
          const text = msg?.text || "";
          navigator.clipboard.writeText(text.replace(/<\/?[^>]+(>|$)/g, ""));
          copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
          setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
        } catch (e) { console.warn('copy failed', e); }
      };
      if (editBtn) editBtn.onclick = async () => {
        try {
          const msg = currentChatData.history.find(m => m.id === messageId);
          if (!msg || !msg.text) return;
          chatInput.value = msg.text;
          chatInput.focus();

          // Remove the edited message and subsequent AI messages
          const msgIndex = currentChatData.history.findIndex(m => m.id === messageId);
          if (msgIndex !== -1) {
            const messagesToDelete = currentChatData.history.slice(msgIndex).map(m => doc(db, `users/${currentUser.uid}/chats/${currentChatDocRef.id}/messages`, m.id));
            await Promise.all(messagesToDelete.map(deleteDoc));
            showStatusMessage('Message set for re-editing. Subsequent messages removed.', '#00ff73', 2500);
          }
        } catch (e) { console.warn('edit failed', e); showStatusMessage('Failed to edit message.', '#ff6b6b'); }
      };
    });
  }

  function showTypingAtNext() {
    removeTyping();
    if (!chatBox) return;
    typingNode = document.createElement('div');
    typingNode.className = 'chat-message ai';
    typingNode.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span></div>`;
    chatBox.appendChild(typingNode);
    setTimeout(() => {
      typingNode.scrollIntoView({ behavior: "smooth", block: "end" });
    }, 20);
  }

  function removeTyping() {
    if (typingNode && typingNode.parentNode) {
      typingNode.parentNode.removeChild(typingNode);
      typingNode = null;
    }
  }

  async function typeBotMessage(text) {
    removeTyping();
    if (!chatBox) return;

    const div = document.createElement('div');
    div.className = "chat-message ai";
    const msgdiv = document.createElement('div');
    msgdiv.className = 'msg';
    div.appendChild(msgdiv);
    chatBox.appendChild(div);

    let sofar = '';
    const words = text.split(' ');

    for (const word of words) {
      if (currentController?.signal.aborted) {
        break;
      }
      sofar += word + ' ';
      msgdiv.innerHTML = renderMarkdown(sofar).html;
      chatBox.scrollTop = chatBox.scrollHeight;
      await new Promise(res => setTimeout(res, 35 + Math.random() * 20));
    }
    
    msgdiv.innerHTML = renderMarkdown(text).html + `
      <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
          <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
          <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
          <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
      </div>
    `;
    enhanceCodeBlocks(msgdiv);
    chatBox.scrollTop = chatBox.scrollHeight;
    
    // Add message to Firestore
    await addMessageToChat('ai', text);
    hookAiMsgControls(); // Re-hook controls for new message
  }

  function renderFilePreview() {
    if (!filePreview) return;
    if (!uploadedFiles.length) {
      filePreview.style.display = 'none';
      filePreview.innerHTML = '';
      return;
    }
    filePreview.style.display = 'block';
    filePreview.innerHTML = uploadedFiles.map((file, idx) => {
      let preview = '';
      if (file.type.startsWith('image/')) {
        preview = `<img src="${URL.createObjectURL(file)}" style="max-width:58px;max-height:41px;vertical-align:middle;border-radius:8px;margin-right:6px;">`;
      } else if (file.type.startsWith('video/')) {
        preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:58px;height:41px;vertical-align:middle;border-radius:8px;margin-right:7px;"></video>`;
      } else if (file.type.startsWith('audio/')) {
        preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:52px;margin-right:7px;"></audio>`;
      } else if (file.type === 'application/pdf') {
        preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`;
      }
      return `
      <div style="display:flex;align-items:center;gap:7px;margin-bottom:1px;">
        ${preview}
        <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span>
        <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
      </div>`;
    }).join('');
    filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = parseInt(btn.getAttribute('data-idx'));
        uploadedFiles.splice(idx, 1);
        if (!uploadedFiles.length && chatFile) chatFile.value = '';
        renderFilePreview();
      });
    });
  }

  function showAIImagePreview(base64, caption = '') {
    if (!aiPrevBox || !aiPrevImgBox) return;
    aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:210px;max-height:210px;border-radius:12px;display:block;">` +
                              `<div style="color:#aee;font-size:.95em;margin-top:3px;text-align:center;">${caption}</div>`;
    aiPrevBox.style.display = 'block';
  }

  // UPDATED: Now adds message to Firestore
  async function addMessageToChat(role, text, files = []) {
      if (!currentChatDocRef) {
        showStatusMessage('No active chat selected. Creating a new one...', '#ffd700');
        await createNewChat("New Chat");
        // createNewChat will set currentChatDocRef and setupChatListener,
        // so the new message will be added after this.
      }
      try {
        await addDoc(collection(currentChatDocRef, 'messages'), {
          role: role,
          text: text,
          files: files, // files will contain {name, type, url, storagePath} objects
          timestamp: new Date(),
        });
        await updateDoc(currentChatDocRef, { updatedAt: new Date() }); // Update chat's timestamp for sorting
      } catch (e) {
        console.error("Error adding message to chat:", e);
        showStatusMessage('Failed to send message to database.', '#ff6b6b');
      }
  }

  function showTypingWithText(text) {
      removeTyping();
      if (!chatBox) return;
      typingNode = document.createElement('div');
      typingNode.className = 'chat-message ai';
      typingNode.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span> <span style="margin-left:8px; color:#a8eaff; font-style:italic;">${text}</span></div>`;
      chatBox.appendChild(typingNode);
      typingNode.scrollIntoView({ behavior: "smooth", block: "end" });
  }

  // Helper to upload files to Firebase Storage
  async function uploadFileToFirebase(file, chatId, messageId) {
    const storagePath = `chat_files/${currentUser.uid}/${chatId}/${messageId}/${file.name}`;
    const fileRef = ref(storage, storagePath);
    const uploadTask = uploadBytesResumable(fileRef, file);

    return new Promise((resolve, reject) => {
      uploadTask.on('state_changed',
        (snapshot) => {
          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          showStatusMessage(`Uploading ${file.name}: ${progress.toFixed(0)}%`, '#00eaff', 0); // Indefinite duration
        },
        (error) => {
          console.error("File upload failed:", error);
          reject(error);
        },
        async () => {
          const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
          resolve({ name: file.name, type: file.type, url: downloadURL, storagePath: storagePath });
        }
      );
    });
  }


  async function handleVideoGeneration(payload, isImageToVideo = false) {
    showTypingWithText('Submitting video generation job...');
    try {
        const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
        const options = isImageToVideo ? { method: 'POST', body: payload } : { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) };
        const startRes = await fetch(API_BASE_URL + endpoint, options);
        const startData = await startRes.json();
        if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to start video task.');
        
        removeTyping();
        await typeBotMessage(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. I'll notify you when it's ready. This can take a few minutes. Do not leave this page or send another message or task.`);
        
        const pollInterval = setInterval(async () => {
            try {
                const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                const statusData = await statusRes.json();
                if (statusRes.ok && statusData.url) {
                    clearInterval(pollInterval);
                    await typeBotMessage(`ðŸŽ‰ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`);
                } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                    clearInterval(pollInterval);
                    await typeBotMessage(`âŒ Video generation failed. Reason: ${statusData.error || 'Unknown error'}`);
                }
            } catch (pollErr) {
                clearInterval(pollInterval);
                await typeBotMessage(`âŒ Error checking video status.`);
            }
        }, 20000);
    } catch (err) {
        removeTyping();
        await typeBotMessage(`âŒ Could not start video generation: ${err.message}`);
    }
  }

  const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
  const toolDefinitions = {
    "image": {
        title: "Generate Image",
        description: "Create stunning visuals from a text prompt. Choose an image model for different results.",
        buildForm: () => `
            <label for="tool-provider">Image Model</label>
            <select id="tool-provider"><option value="thena">Version 1 (Stylized, Fast & Recommended)</option><option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option></select>
            <label for="tool-prompt">Image Prompt</label>
            <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required></textarea>
            <label for="tool-style">Style (for Version 1 only)</label>
            <select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate</button>`,
        handleSubmit: async (form) => {
            const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
            const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
            await addMessageToChat('user', `Image generation request: "${payload.prompt}"`);
            showTypingWithText('Generating your image...');
            try {
                const res = await fetch(`${API_BASE_URL}/generate-image`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || res.statusText);
                showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                return 'âœ… Image generated! Check the floating image box to view or download.';
            } catch (err) { return `âŒ Image generation failed: ${err.message}`; }
        }
    },
    "edit-photo": {
        title: "Edit Photo",
        description: "Upload a photo and describe the changes you want to make.",
        buildForm: () => `
            <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required></textarea>
            <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>`,
        handleSubmit: async (form) => {
            const file = form.querySelector('#tool-file').files[0];
            if (!file) return "Please select a file to edit.";
            await addMessageToChat('user', `Photo edit request for ${file.name}: "${form.querySelector('#tool-prompt').value}"`);
            showTypingWithText('Editing your photo...');
            const fd = new FormData(); fd.append('prompt', form.querySelector('#tool-prompt').value); fd.append('file', file);
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                if (!res.ok) throw new Error((await res.json()).error || 'Failed to edit photo.');
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                return `âœ… Photo edited successfully! <br><img src="${url}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
            } catch (err) { return `âŒ Photo edit failed: ${err.message}`; }
        }
    },
     "remove-bg": {
        title: "Remove Background",
        description: "Select an image file to automatically remove its background.",
        buildForm: () => `
            <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;">
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Remove Background</button>`,
        handleSubmit: async (form) => {
            const file = form.querySelector('#tool-file').files[0];
            if (!file) return "Please select a file.";
            await addMessageToChat('user', `Background removal request for: "${file.name}"`);
            showTypingWithText('Removing background...');
            const fd = new FormData(); fd.append('file', file);
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                if (!res.ok) throw new Error(res.statusText);
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                return `âœ… Background removed! <br><img src="${url}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
            } catch (err) { return `âŒ Background removal failed: ${err.message}`; }
        }
    },
    "comic": {
        title: "Create Comic",
        description: "Write a story and watch it transform into a comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.",
        buildForm: () => `
            <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required></textarea>
            <label for="tool-style">Comic Style</label><select id="tool-style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
            <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" />
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Create Comic</button>`,
        handleSubmit: async (form) => {
            const payload = { story: form.querySelector('#tool-story').value, style: form.querySelector('#tool-style').value, panels: parseInt(form.querySelector('#tool-panels').value, 10), user: currentUser?.displayName || "User" };
            await addMessageToChat('user', `Comic creation request with style: ${payload.style}.`);
            showTypingWithText('Generating your comic panels...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || res.statusText);
                const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb">`).join('');
                return `ðŸ–¼ï¸ Comic successfully created! <br>${imagesHtml}`;
            } catch (err) { return `âŒ Comic generation failed: ${err.message}`; }
        }
    },
    "voice-gen": {
        title: "Voice Generation",
        description: "Transform text into realistic speech. Choose a voice model and style.",
        buildForm: () => `
            <label for="tool-provider">Voice Model</label><select id="tool-provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
            <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required></textarea>
            <label for="tool-style">Voice Style</label><select id="tool-style"></select>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice</button>`,
        onFormReady: () => {
            const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
            const voices = { gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"], minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"] };
            const updateStyles = () => { styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join(''); };
            providerSelect.addEventListener('change', updateStyles);
            updateStyles();
        },
        handleSubmit: async (form) => {
            const provider = form.querySelector('#tool-provider').value, text = form.querySelector('#tool-prompt').value, style = form.querySelector('#tool-style').value;
            await addMessageToChat('user', `Voice generation request using ${provider}.`);
            showTypingWithText('Generating your audio...');
            try {
                let res;
                if (provider === 'gemini') {
                    const fd = new FormData(); fd.append('text', text); fd.append('style', style);
                    res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                } else {
                    res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ text, voice_id: style }) });
                }
                if (!res.ok) throw new Error(await res.text());
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                return `ðŸ—£ï¸ Voice generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
            } catch (err) { return `âŒ Voice generation failed: ${err.message}`; }
        }
    },
    "audio-narration": {
        title: "Audio Narration",
        description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.",
        buildForm: () => `
          <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;">
          <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>`,
        handleSubmit: async (form) => {
            const file = form.querySelector('#tool-file').files[0];
            if (!file) return "Please select a file.";
            await addMessageToChat('user', `Audio narration request for: "${file.name}"`);
            showTypingWithText('Analyzing and narrating document...');
            const fd = new FormData(); fd.append('file', file); fd.append('style', 'podcast');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                if (!res.ok) throw new Error(res.statusText);
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                return `ðŸ—£ï¸ Narration generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
            } catch (err) { return `âŒ Audio narration failed: ${err.message}`; }
        }
    },
    "video-text": {
        title: "Generate Video from Text",
        description: "Describe the video you want to create. This process can take a few minutes.",
        buildForm: () => `
            <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required></textarea>
            <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15">
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
        handleSubmit: async (form) => {
            const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
            await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
            handleVideoGeneration(payload);
            return null;
        }
    },
    "video-image": {
        title: "Generate Video from Image",
        description: "Upload a starting image and describe how you want to animate it.",
        buildForm: () => `
            <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required></textarea>
            <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
        handleSubmit: async (form) => {
            const file = form.querySelector('#video-image-file').files[0];
            if (!file) return "Please select an image.";
            await addMessageToChat('user', `Image-to-Video request for: ${file.name}`);
            const fd = new FormData(); fd.append('prompt', form.querySelector('#video-image-prompt').value); fd.append('file', file);
            handleVideoGeneration(fd, true);
            return null;
        }
    },
    "music": {
        title: "Generate Music",
        description: "Generate music from a prompt, lyrics, and optional reference audio. Powered by MiniMax.",
        buildForm: () => `
            <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required></textarea>
            <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..."></textarea>
            <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*">
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Music</button>`,
        handleSubmit: async (form) => {
            const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
            const refFile = form.querySelector('#music-ref').files[0];
            await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
            showTypingWithText('Composing your music...');
            try {
                if (refFile) {
                    showTypingWithText('Uploading reference audio first...');
                    const fd = new FormData(); fd.append('file', refFile);
                    const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                    const uploadData = await uploadRes.json();
                    if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed.");
                    if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                    if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                    showTypingWithText('Reference uploaded. Composing music...');
                }
                const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                return `ðŸŽµ Your music is ready! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
            } catch (err) { return `âŒ Music generation failed: ${err.message}`; }
        }
    },
    "website": {
        title: "Create Website",
        description: "Describe the website you want to build and get a live, working prototype.",
        buildForm: () => `
            <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required></textarea>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Website</button>`,
        handleSubmit: async (form) => {
            const prompt = form.querySelector('#website-prompt').value;
            await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`);
            showTypingWithText('Building and deploying your website...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ prompt, user_id: currentUser.uid }) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || res.statusText);
                return `ðŸŒ Website deployed successfully! [View here](${data.url})`;
            } catch (err) { return `âŒ Website creation failed: ${err.message}`; }
        }
    },
    "edit-website": {
        title: "Edit Last Website",
        description: "Provide an instruction to modify the most recent website you created.",
        buildForm: () => `
            <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required></textarea>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>`,
        handleSubmit: async (form) => {
            const instruction = form.querySelector('#edit-instruction').value;
            await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`);
            showTypingWithText('Editing and redeploying your website...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ instruction, user_id: currentUser.uid }) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || res.statusText);
                return `âœï¸ Website updated successfully! [View new version here](${data.url})`;
            } catch (err) { return `âŒ Website edit failed: ${err.message}`; }
        }
    },
    "my-sites": {
        isAction: true,
        runAction: async () => {
            await addMessageToChat('user', 'Show me a list of my websites.');
            showTypingWithText('Fetching your website list...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Could not fetch sites.');
                if (!data.sites || data.sites.length === 0) return "You haven't created any websites yet.";
                const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                return `Here are the websites you've created:\n${siteList}`;
            } catch (err) { return `âŒ Error fetching websites: ${err.message}`; }
        }
    },
    "research-report": {
        title: "Research Report",
        description: "Generate a comprehensive research report in PDF format on any topic.",
        buildForm: () => `
            <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>`,
        handleSubmit: async (form) => {
            const topic = form.querySelector('#research-topic').value;
            await addMessageToChat('user', `Research report request on: "${topic}"`);
            showTypingWithText('Conducting research and compiling report...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/research`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ topic }) });
                if (!res.ok) throw new Error(res.statusText);
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--primary-color);font-weight:bold;">Download PDF Report</a>`;
                return `âœ… Research report on **${topic}** is ready! ${downloadLink}`;
            } catch (err) { return `âŒ Research report failed: ${err.message}`; }
        }
    },
  };

  if (toolsMenu) {
    toolsMenu.addEventListener('click', async (e) => {
        const toolLink = e.target.closest('.tool-link');
        if (!toolLink) return;
        e.preventDefault();
        const toolKey = toolLink.getAttribute('data-tool');
        const tool = toolDefinitions[toolKey];
        if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);
        closeToolMenu();
        if (tool.isAction) {
            const result = await tool.runAction();
            removeTyping();
            await typeBotMessage(result);
        } else {
            displayToolForm(toolKey);
        }
    });
  }

  function displayToolForm(toolKey) {
    const tool = toolDefinitions[toolKey];
    if (!tool || !toolFormModalBg) return;
    toolFormTitle.textContent = tool.title;
    const descriptionHtml = tool.description ? `<div style="color:var(--primary-color);font-size:.9em;margin-bottom:12px;">${tool.description}</div>` : '';
    toolForm.innerHTML = descriptionHtml + tool.buildForm();
    if (typeof tool.onFormReady === 'function') tool.onFormReady();
    toolForm.onsubmit = async (e) => {
        e.preventDefault();
        const submitButton = toolForm.querySelector('button[type="submit"]');
        const originalButtonContent = submitButton.innerHTML;
        submitButton.innerHTML = `<div class="spinner"></div> Processing...`;
        submitButton.disabled = true;
        toolFormModalBg.classList.remove('active');
        const resultText = await tool.handleSubmit(toolForm);
        if (resultText) {
            removeTyping();
            await typeBotMessage(resultText);
        }
        submitButton.innerHTML = originalButtonContent;
        submitButton.disabled = false;
    };
    toolFormModalBg.classList.add('active');
  }

  /* ---------- MAIN CHAT SUBMIT HANDLER ---------- */
  chatForm.addEventListener('submit', async function (e) {
    e.preventDefault();
    if (!currentChatDocRef) {
      showStatusMessage('No active chat. Creating a new one...', '#ffd700');
      await createNewChat("New Chat"); // Ensure a chat exists
      if (!currentChatDocRef) { // If creation failed, stop
        showStatusMessage('Failed to create a chat. Please try again.', '#ff6b6b');
        return;
      }
    }

    const msgText = chatInput.value.trim();
    if (!msgText && uploadedFiles.length === 0) return;

    const stopButton = document.createElement('button');
    stopButton.type = 'button';
    stopButton.id = 'stopBtn';
    stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>';
    stopButton.style.color = '#ff6b6b';
    sendBtn.replaceWith(stopButton);

    currentController = new AbortController();
    const signal = currentController.signal;
    let finalResponse = '';

    stopButton.addEventListener('click', () => {
      if (currentController) {
        currentController.abort();
      }
    });
    
    // Generate a temporary message ID for Firebase Storage path BEFORE uploading files
    const tempMessageId = doc(collection(currentChatDocRef, 'messages')).id;

    const filesForHistory = [];
    if (uploadedFiles.length > 0) {
      showTypingWithText('Uploading file(s)...');
      try {
        for (const file of uploadedFiles) {
          const uploadedFileMetadata = await uploadFileToFirebase(file, currentChatDocRef.id, tempMessageId);
          filesForHistory.push(uploadedFileMetadata);
        }
        showStatusMessage('Files uploaded!', '#00ff73', 1500);
      } catch (error) {
        finalResponse = `âŒ File upload failed: ${error.message}. Message not sent.`;
        showStatusMessage(finalResponse, '#ff6b6b');
        removeTyping();
        stopButton.replaceWith(sendBtn);
        currentController = null;
        return;
      }
    }

    // Add user message to Firestore AFTER files are uploaded
    await addMessageToChat('user', msgText, filesForHistory);
    chatInput.value = ''; 
    uploadedFiles = []; 
    renderFilePreview();

    // Proceed with AI processing
    if (filesForHistory.length > 0) {
      const file = filesForHistory[0]; // For now, process first file
      let endpoint = '';
      if (file.type.startsWith('image/')) endpoint = '/understand-image';
      else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
      else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
      else if (file.type.startsWith('video/')) endpoint = '/understand-video';
      else { removeTyping(); finalResponse = "Sorry, I can't analyze that file type."; }
      
      try {
        if(endpoint) {
          showTypingWithText('Analyzing your file(s)...');
          const fd = new FormData();
          fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]}`);
          // Send the actual file object from the original upload (not the metadata)
          const originalFile = uploadedFiles.find(f => f.name === file.name); // This assumes name is unique, better to use an ID
          fd.append('file', originalFile || file); // Fallback to metadata if original not found
          const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Analysis failed.");
          finalResponse = data.response;
        }
      } catch (err) {
        finalResponse = err.name === 'AbortError' ? 'âŒ File analysis stopped.' : `âŒ File analysis failed: ${err.message}`;
      }
    } else if (msgText) {
      showTypingAtNext();
      try {
        // Use the actual current chat history from Firestore
        const historyForAPI = currentChatData.history.slice(0, -1).map(m => ({ role: m.role, content: m.text || '' }));
        const res = await fetch(`${API_BASE_URL}/chat`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: msgText, history: historyForAPI, user_id: currentUser?.uid || "user" }), signal });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || "Server error.");
        finalResponse = data.response;
      } catch (err) {
        finalResponse = err.name === 'AbortError' ? 'âŒ Response stopped.' : `âŒ An error occurred: ${err.message}`;
      }
    }

    removeTyping();
    if (finalResponse) {
      await typeBotMessage(finalResponse);
    }
    stopButton.replaceWith(sendBtn);
    currentController = null;
  });


  /* ---------- VOICE CALL FEATURE LOGIC ---------- */

  async function playAudioFromBase64(base64) {
      if (!base64) return;
      audioQueue.push(base64);
      if (!isPlayingAudio) {
          processAudioQueue();
      }
  }

  async function processAudioQueue() {
      if (audioQueue.length === 0 || isPlayingAudio) return;

      isPlayingAudio = true;
      const base64 = audioQueue.shift();
      const audio = new Audio(`data:audio/mp3;base64,${base64}`); // Assuming MP3, adjust if needed

      return new Promise(resolve => {
          audio.onended = () => {
              isPlayingAudio = false;
              processAudioQueue(); // Process next in queue
              if (isCalling && recognition && !isPlayingAudio) { // If call active and bot finished speaking
                  recognition.start(); // Restart listening for user
              }
              resolve();
          };
          audio.onerror = (e) => {
              console.error("Audio playback error:", e);
              isPlayingAudio = false;
              processAudioQueue(); // Try next in queue
              if (isCalling && recognition && !isPlayingAudio) {
                  recognition.start();
              }
              resolve();
          };
          audio.play().catch(e => {
              console.error("Audio play failed (user gesture required?):", e);
              isPlayingAudio = false;
              processAudioQueue();
              if (isCalling && recognition && !isPlayingAudio) {
                  recognition.start();
              }
              resolve();
          });
      });
  }

  async function startVoiceRecognition() {
      if (!('webkitSpeechRecognition' in window)) {
          alert("Sorry, your browser doesn't support Web Speech API. Please use Chrome for voice calls.");
          endCall();
          return;
      }

      recognition = new webkitSpeechRecognition();
      recognition.continuous = false; // Listen for one phrase
      recognition.interimResults = true;
      recognition.lang = 'en-US';

      let transcriptBuffer = '';

      recognition.onstart = () => {
          callStatus.textContent = "Listening...";
          callOverlay.classList.add('listening');
          userSpeechText.textContent = '';
      };

      recognition.onresult = (event) => {
          let interimTranscript = '';
          for (let i = event.resultIndex; i < event.results.length; ++i) {
              if (event.results[i].isFinal) {
                  transcriptBuffer += event.results[i][0].transcript;
              } else {
                  interimTranscript += event.results[i][0].transcript;
              }
          }
          userSpeechText.textContent = interimTranscript || transcriptBuffer;
      };

      recognition.onend = async () => {
          callOverlay.classList.remove('listening');
          callStatus.textContent = "Thinking...";

          if (transcriptBuffer.trim().length > 0) {
              await processUserVoiceInput(transcriptBuffer.trim());
          } else {
              callStatus.textContent = "Did not catch that.";
              setTimeout(() => {
                  if (isCalling && !isPlayingAudio) recognition.start(); // Restart listening if nothing was said and bot isn't speaking
              }, 1000);
          }
          transcriptBuffer = ''; // Reset buffer
      };

      recognition.onerror = (event) => {
          console.error("Speech recognition error:", event.error);
          userSpeechText.textContent = `Error: ${event.error}`;
          if (event.error === 'no-speech' || event.error === 'audio-capture') {
              callStatus.textContent = "Please speak clearly.";
              if (isCalling && !isPlayingAudio) recognition.start(); // Try again
          } else {
              endCall(); // End call on other errors
          }
      };

      if (isCalling) recognition.start(); // Start recognition only if call is active
  }

  async function processUserVoiceInput(text) {
      // Add user voice input to regular chat history
      await addMessageToChat('user', text);

      try {
          // Use the actual current chat history from Firestore for context
          const historyForAPI = currentChatData.history.map(m => ({ role: m.role, content: m.text || '' }));
          const chatRes = await fetch(`${API_BASE_URL}/chat`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message: text, history: historyForAPI, user_id: currentUser?.uid || "user" }),
          });
          const chatData = await chatRes.json();
          if (!chatRes.ok) throw new Error(chatData.error || "AI chat error.");

          const aiResponseText = chatData.response;
          // Add AI text response to regular chat history
          await addMessageToChat('ai', aiResponseText);

          // Now, convert AI text response to speech
          callStatus.textContent = "Speaking...";
          const voiceRes = await fetch(`${API_BASE_URL}/voicegen`, { // Using your gemini voicegen endpoint
              method: 'POST',
              headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
              body: new URLSearchParams({ text: aiResponseText, style: 'podcast' }) // Adjust style as desired
          });
          if (!voiceRes.ok) throw new Error("Voice generation failed.");
          const audioBlob = await voiceRes.blob();
          const reader = new FileReader();
          reader.readAsDataURL(audioBlob);
          reader.onloadend = async () => {
              const base64Audio = reader.result.split(',')[1];
              await playAudioFromBase64(base64Audio); // This will manage restarting recognition
          };

      } catch (err) {
          console.error("Voice chat processing error:", err);
          await playAudioFromBase64(""); // Placeholder for error audio if you have one
          if (isCalling && !isPlayingAudio) {
              recognition.start(); // Try listening again
          }
      }
  }


  function startCall() {
      if (!currentUser) {
        showStatusMessage('Please log in to use the call feature.', '#ffd700', 3000);
        return;
      }
      isCalling = true;
      callOverlay.style.display = 'flex';
      callStatus.textContent = "Calling...";
      ringingEffect.style.animation = 'ring 1.5s infinite'; // Start ringing animation
      userSpeechText.textContent = '';
      callOverlay.classList.remove('listening');
      callOverlay.classList.add('calling'); // Add class for ringing state

      setTimeout(() => { // Simulate bot "picking up"
          if (isCalling) {
              callStatus.textContent = "Connected. Speak now.";
              ringingEffect.style.animation = 'none'; // Stop ringing
              callOverlay.classList.remove('calling');
              startVoiceRecognition();
          }
      }, 3000); // 3-second ringing
  }

  function endCall() {
      isCalling = false;
      callOverlay.style.display = 'none';
      callOverlay.classList.remove('listening', 'calling');
      ringingEffect.style.animation = 'none';
      if (recognition) {
          recognition.stop();
          recognition = null;
      }
      audioQueue = []; // Clear any pending audio
      isPlayingAudio = false;
      showStatusMessage("Call ended.", '#00eaff', 1500);
  }

  if (callBtn) {
      callBtn.addEventListener('click', startCall);
  }
  if (endCallBtn) {
      endCallBtn.addEventListener('click', endCall);
  }

}); // end DOMContentLoaded
</script>
</body>
  </html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
