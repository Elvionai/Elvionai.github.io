<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Philadelphia AI - Cosmic AI Nexus</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css"/> <!-- A dark, vibrant theme for code -->
    <style>
        :root {
            /* --- THEME: COSMIC GLOW (Default) --- */
            --neon-blue: #00f2ff;
            --neon-purple: #bd00ff;
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            
            --glass-bg-strong: rgba(20, 20, 35, 0.7);
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            --text-color: #e0eaff;
            --subtle-text-color: #aeb8d0;
            --link-color: var(--neon-blue);
            --error-color: #ff4d4d;

            --glow-base: 0 0 10px rgba(0, 242, 255, 0.7), 0 0 20px rgba(189, 0, 255, 0.5);
            --glow-light: 0 0 15px rgba(0, 242, 255, 0.8), 0 0 25px rgba(189, 0, 255, 0.6);
            --glow-dark: 0 0 8px rgba(0, 242, 255, 0.5), 0 0 15px rgba(189, 0, 255, 0.3);

            --code-bg: rgba(30, 10, 50, 0.8);
            --code-border: var(--neon-blue);
            --code-text: #e1fffc;
            --code-shadow: 0 0 15px rgba(0, 242, 255, 0.4), inset 0 0 8px rgba(189, 0, 255, 0.2);

            --input-focus-border: var(--neon-blue);
            --input-focus-shadow: var(--glow-light);

            --thruster-hover-shadow: 0 0 30px rgba(189, 0, 255, 0.6);
            --thruster-base-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
            
            --radial-menu-bg: rgba(15, 15, 30, 0.9);
            --radial-item-hover-bg: rgba(0, 242, 255, 0.15);
        }

        /* --- THEME: GALACTIC TWILIGHT --- */
        .galactic-twilight-theme {
            --neon-blue: #ff6e00; /* Deep Orange */
            --neon-purple: #cc00ff; /* Violet */
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            
            --glass-bg-strong: rgba(25, 10, 20, 0.7);
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            --text-color: #ffeee0;
            --subtle-text-color: #d0b8a8;
            --link-color: var(--neon-blue);
            --error-color: #ff8c4d;

            --glow-base: 0 0 10px rgba(255, 110, 0, 0.7), 0 0 20px rgba(204, 0, 255, 0.5);
            --glow-light: 0 0 15px rgba(255, 110, 0, 0.8), 0 0 25px rgba(204, 0, 255, 0.6);
            --glow-dark: 0 0 8px rgba(255, 110, 0, 0.5), 0 0 15px rgba(204, 0, 255, 0.3);

            --code-bg: rgba(40, 15, 25, 0.8);
            --code-border: var(--neon-blue);
            --code-text: #fff6e0;
            --code-shadow: 0 0 15px rgba(255, 110, 0, 0.4), inset 0 0 8px rgba(204, 0, 255, 0.2);

            --input-focus-border: var(--neon-blue);
            --input-focus-shadow: var(--glow-light);

            --thruster-hover-shadow: 0 0 30px rgba(204, 0, 255, 0.6);
            --thruster-base-shadow: 0 0 20px rgba(255, 110, 0, 0.3);
            
            --radial-menu-bg: rgba(20, 5, 15, 0.9);
            --radial-item-hover-bg: rgba(255, 110, 0, 0.15);
        }

        /* --- THEME: NEBULA EMERALD --- */
        .nebula-emerald-theme {
            --neon-blue: #00e676; /* Emerald Green */
            --neon-purple: #00b8d4; /* Teal Blue */
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            
            --glass-bg-strong: rgba(10, 30, 20, 0.7);
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            --text-color: #e0fff0;
            --subtle-text-color: #a8d0b8;
            --link-color: var(--neon-blue);
            --error-color: #ff5252;

            --glow-base: 0 0 10px rgba(0, 230, 118, 0.7), 0 0 20px rgba(0, 184, 212, 0.5);
            --glow-light: 0 0 15px rgba(0, 230, 118, 0.8), 0 0 25px rgba(0, 184, 212, 0.6);
            --glow-dark: 0 0 8px rgba(0, 230, 118, 0.5), 0 0 15px rgba(0, 184, 212, 0.3);

            --code-bg: rgba(15, 45, 30, 0.8);
            --code-border: var(--neon-blue);
            --code-text: #e0ffee;
            --code-shadow: 0 0 15px rgba(0, 230, 118, 0.4), inset 0 0 8px rgba(0, 184, 212, 0.2);

            --input-focus-border: var(--neon-blue);
            --input-focus-shadow: var(--glow-light);

            --thruster-hover-shadow: 0 0 30px rgba(0, 184, 212, 0.6);
            --thruster-base-shadow: 0 0 20px rgba(0, 230, 118, 0.3);
            
            --radial-menu-bg: rgba(5, 20, 10, 0.9);
            --radial-item-hover-bg: rgba(0, 230, 118, 0.15);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            height: 100vh;
            overflow: hidden;
            font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, sans-serif;
            background-color: #050714; /* Base dark background */
            color: var(--text-color);
            display: flex;
            justify-content: center;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        /* --- COSMIC BACKGROUND ENGINE --- */
        #cosmos-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
            background: linear-gradient(to bottom right, #050714, #1a0a2e); /* Base gradient */
        }

        .nebula-layer {
            position: absolute; top: 0; left: 0; width: 200%; height: 200%;
            background-size: cover;
            background-repeat: no-repeat;
            opacity: 0.6;
            mix-blend-mode: screen; /* Lighten effect */
            animation: drift var(--duration) infinite linear;
        }

        .nebula-layer:nth-child(1) { /* More subtle */
            background-image: radial-gradient(circle at 50% 50%, rgba(76, 0, 255, 0.15), transparent 50%);
            --duration: 90s;
        }
        .nebula-layer:nth-child(2) { /* More vibrant */
            background-image: radial-gradient(circle at 80% 20%, var(--neon-blue), transparent 40%);
            --duration: 75s;
            animation-direction: reverse;
        }
        .nebula-layer:nth-child(3) { /* Deepest layer */
            background-image: radial-gradient(circle at 20% 80%, var(--neon-purple), transparent 50%);
            --duration: 100s;
            mix-blend-mode: overlay; /* Stronger blending */
            animation-direction: alternate;
        }
        .nebula-layer:nth-child(4) { /* Dynamic, smaller clouds */
            background-image: radial-gradient(circle at 10% 10%, var(--neon-blue), transparent 60%),
                              radial-gradient(circle at 90% 90%, var(--neon-purple), transparent 60%);
            --duration: 50s;
            animation-direction: reverse;
            mix-blend-mode: color-dodge;
        }

        @keyframes drift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-50%, -50%); }
        }

        .star, .stardust {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            background: white; /* Base color for stars */
            box-shadow: 0 0 5px white;
            animation: twinkle var(--duration) infinite ease-in-out alternate;
        }

        .star { z-index: 1; opacity: 0.8; }
        .stardust { z-index: 2; opacity: 0.4; background: var(--neon-blue); box-shadow: 0 0 3px var(--neon-blue); animation: floatUp var(--duration) infinite linear; }

        @keyframes twinkle { 0%, 100% { opacity: 0.3; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1.1); box-shadow: var(--glow-light); } }
        @keyframes floatUp { to { transform: translateY(-100vh) translateX(50vw); opacity: 0; } } /* Stardust drifts upward and sideways */

        .shooting-star {
            position: absolute;
            height: 2px;
            background: linear-gradient(-90deg, white, transparent);
            filter: drop-shadow(0 0 6px var(--neon-blue));
            animation: shoot var(--duration) ease-out; opacity: 0; z-index: 5;
            transform-origin: center left;
        }
        @keyframes shoot { 
            0% { transform: translate(var(--startX), var(--startY)) rotate(var(--angle, -35deg)); opacity: 1; width: 0; }
            20% { width: var(--length); }
            100% { transform: translate(var(--endX), var(--endY)) rotate(var(--angle, -35deg)); opacity: 0; width: 0; }
        }

        .cosmic-eagle {
            position: absolute;
            width: var(--size, 80px);
            height: var(--size, 80px);
            opacity: 0.7;
            filter: drop-shadow(0 0 10px var(--neon-blue));
            z-index: 10;
            animation: eagle-drift var(--duration) infinite linear;
            pointer-events: none;
            will-change: transform;
        }
        .cosmic-eagle.trail::after {
            content: '';
            position: absolute;
            top: 50%; left: 0;
            width: 100%; height: 2px;
            background: linear-gradient(90deg, var(--neon-blue), transparent);
            filter: blur(2px);
            opacity: 0.5;
            animation: eagle-trail-fade var(--duration) infinite linear;
        }
        @keyframes eagle-drift {
            0% { transform: translate(-10vw, 50vh) rotateY(0deg); }
            25% { transform: translate(30vw, 30vh) rotateY(0deg); }
            50% { transform: translate(70vw, 70vh) rotateY(180deg); } /* Flips horizontally */
            75% { transform: translate(40vw, 20vh) rotateY(180deg); }
            100% { transform: translate(-10vw, 50vh) rotateY(0deg); }
        }
        @keyframes eagle-trail-fade { /* Trail is more complex, might need JS for perfect sync */
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.6; }
        }


        /* --- UI MAIN STRUCTURE --- */
        .ui-container {
            width: 100%; max-width: 600px;
            height: 100%; display: flex; flex-direction: column;
            position: relative; z-index: 10;
            background: rgba(5, 7, 20, 0.3); /* Subtle darkening for readability */
        }

        /* Header */
        header {
            padding: 15px 20px;
            display: flex; justify-content: space-between; align-items: center;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            position: relative;
        }

        .brand-plasma {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem; font-weight: 700; letter-spacing: 1px;
            background: linear-gradient(90deg, #fff, var(--neon-blue), var(--neon-purple), #fff);
            background-size: 300% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: plasmaFlow 5s linear infinite;
            text-shadow: var(--glow-base);
            user-select: none;
        }
        @keyframes plasmaFlow { to { background-position: 300% center; } }

        /* Plasma Orb Menu */
        #plasmaOrb {
            width: 45px; height: 45px; border-radius: 50%;
            background: var(--plasma-gradient);
            display: flex; align-items: center; justify-content: center;
            font-size: 1.3rem; cursor: pointer;
            box-shadow: var(--thruster-base-shadow);
            transition: 0.3s ease;
            color: rgba(0,0,0,0.8);
            animation: orbPulse 2s infinite alternate;
            position: relative;
            z-index: 110;
        }
        #plasmaOrb:hover { transform: scale(1.1); box-shadow: var(--thruster-hover-shadow); }
        @keyframes orbPulse { 0% { transform: scale(1); opacity: 0.9; } 100% { transform: scale(1.05); opacity: 1; } }

        .radial-menu {
            position: absolute; top: 10px; right: 10px; /* Aligned with orb */
            width: 0; height: 0; border-radius: 50%;
            background: var(--radial-menu-bg);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glow-base);
            transition: width 0.3s ease-out, height 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 0; pointer-events: none; z-index: 100;
            display: flex; justify-content: center; align-items: center;
        }
        .radial-menu.active {
            width: 200px; height: 200px;
            opacity: 1; pointer-events: auto;
        }
        .radial-menu-items {
            position: relative; width: 100%; height: 100%;
            list-style: none; padding: 0; margin: 0;
            transform: rotate(0deg);
        }
        .radial-menu-item {
            position: absolute;
            opacity: 0; transform: scale(0.8);
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
        }
        .radial-menu.active .radial-menu-item {
            opacity: 1; transform: scale(1);
        }
        /* Item positioning (6 items for now) */
        .radial-menu.active .radial-menu-item:nth-child(1) { transform: translate(60px, -60px) scale(1); }
        .radial-menu.active .radial-menu-item:nth-child(2) { transform: translate(80px, 0px) scale(1); }
        .radial-menu.active .radial-menu-item:nth-child(3) { transform: translate(60px, 60px) scale(1); }
        .radial-menu.active .radial-menu-item:nth-child(4) { transform: translate(-60px, 60px) scale(1); }
        .radial-menu.active .radial-menu-item:nth-child(5) { transform: translate(-80px, 0px) scale(1); }
        .radial-menu.active .radial-menu-item:nth-child(6) { transform: translate(-60px, -60px) scale(1); }

        .radial-menu-item button {
            background: var(--glass-bg-light); border: 1px solid var(--glass-border);
            border-radius: 50%; width: 45px; height: 45px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2em; color: var(--text-color); cursor: pointer;
            box-shadow: var(--glow-dark); transition: 0.2s ease;
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .radial-menu-item button:hover {
            background: var(--radial-item-hover-bg);
            color: var(--neon-blue); transform: scale(1.1);
            box-shadow: var(--glow-base);
        }
        .radial-menu-item button i { text-shadow: var(--glow-dark); }
        .radial-menu-item button:hover i { text-shadow: var(--glow-light); }

        /* Chat Area */
        #chat-viewport {
            flex: 1; overflow-y: auto; padding: 20px 25px; display: flex; flex-direction: column; gap: 20px;
            scroll-behavior: smooth;
            scrollbar-width: none; -ms-overflow-style: none; /* Hide Scrollbar visually */
        }
        #chat-viewport::-webkit-scrollbar { display: none; }

        .message-group { display: flex; flex-direction: column; gap: 8px; max-width: 85%; position: relative; }
        .message-group.ai { align-self: flex-start; }
        .message-group.user { align-self: flex-end; align-items: flex-end; }

        .msg-bubble {
            padding: 16px 22px; border-radius: 24px;
            font-size: 1rem; line-height: 1.5;
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            color: var(--text-color);
        }
        @keyframes popIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }

        .ai .msg-bubble {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8));
            border-bottom-left-radius: 4px;
            box-shadow: inset 0 0 20px rgba(0, 242, 255, 0.05);
            text-shadow: 0 0 5px rgba(255,255,255,0.1);
        }

        .user .msg-bubble {
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.3), rgba(189, 0, 255, 0.3));
            border-bottom-right-radius: 4px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            box-shadow: var(--thruster-base-shadow);
            border: 1px solid rgba(255,255,255,0.3);
        }

        .typing-indicator-dot {
            display: inline-block;
            width: 8px; height: 8px; border-radius: 50%;
            background: var(--neon-blue);
            opacity: 0.6; margin: 0 2px;
            animation: dot-pulse 1s infinite alternate;
        }
        .typing-indicator-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes dot-pulse { 0% { opacity: 0.6; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1.1); } }

        /* Code Block Styling */
        .msg-bubble pre, .modal-content pre {
            background: var(--code-bg);
            border: 1px solid var(--code-border);
            box-shadow: var(--code-shadow);
            padding: 15px; margin: 15px 0;
            border-radius: 8px;
            overflow-x: auto;
            position: relative;
        }
        .msg-bubble code, .modal-content code {
            color: var(--code-text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            display: block; /* Ensure highlight.js applies */
        }
        .code-copy-btn {
            position: absolute; top: 8px; right: 8px;
            background: rgba(255,255,255,0.1); border: 1px solid var(--neon-blue);
            color: var(--neon-blue); padding: 5px 10px;
            font-size: 0.8em; cursor: pointer; border-radius: 5px;
            transition: 0.2s; opacity: 0.7;
            backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px);
        }
        .code-copy-btn:hover {
            opacity: 1; background: var(--neon-blue); color: #000;
            box-shadow: var(--glow-base);
        }

        /* Message Controls */
        .msg-controls {
            display: flex; gap: 8px; margin-top: 10px;
        }
        .msg-controls button {
            background: rgba(255,255,255,0.07); border: 1px solid var(--glass-border);
            color: var(--subtle-text-color); padding: 8px 12px; border-radius: 12px;
            font-size: 0.85em; cursor: pointer; transition: 0.2s;
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .msg-controls button:hover {
            background: rgba(0, 242, 255, 0.15); border-color: var(--neon-blue);
            color: var(--neon-blue);
            box-shadow: var(--glow-dark);
        }

        /* Holographic Suggestions */
        .suggestions-dock {
            display: flex; flex-wrap: wrap; justify-content: flex-end; gap: 10px; margin-top: 10px;
            opacity: 1; transition: opacity 0.5s ease;
        }
        .suggestions-dock.hidden { opacity: 0; pointer-events: none; height: 0; overflow: hidden; margin-top: 0;}

        .chip {
            padding: 12px 20px; border-radius: 16px; font-size: 0.9rem; cursor: pointer;
            background: rgba(255, 255, 255, 0.07);
            border: 1px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            transition: 0.3s; text-align: right; color: var(--subtle-text-color);
        }
        .chip:hover {
            background: rgba(0, 242, 255, 0.15);
            border-color: var(--neon-blue);
            box-shadow: var(--glow-dark);
            transform: translateY(-2px); color: var(--neon-blue);
        }
        .holo-shimmer { position: relative; overflow: hidden; }
        .holo-shimmer::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(120deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transform: skewX(-25deg); animation: holoSheen 3s infinite linear;
        }
        @keyframes holoSheen { 0% { left: -100%; } 50%, 100% { left: 200%; } }

        /* Stellar Stream Input History */
        #stellar-stream-history {
            position: absolute; bottom: calc(100% + 10px); left: 0; right: 0;
            background: rgba(10,10,20,0.8); backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border); border-radius: 8px;
            max-height: 150px; overflow-y: auto; z-index: 90;
            box-shadow: var(--glow-dark);
            display: none; /* Controlled by JS */
        }
        #stellar-stream-history.active { display: block; }
        #stellar-stream-history ul { list-style: none; padding: 5px; margin: 0; }
        #stellar-stream-history li {
            padding: 8px 10px; cursor: pointer;
            color: var(--subtle-text-color); font-size: 0.9rem;
            transition: background-color 0.1s, color 0.1s;
        }
        #stellar-stream-history li.selected,
        #stellar-stream-history li:hover {
            background-color: var(--glass-bg-light);
            color: var(--neon-blue);
        }


        /* Input Capsule */
        .input-dock {
            padding: 20px 25px;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            border-top: 1px solid var(--glass-border);
            display: flex; gap: 15px; align-items: flex-end; /* Align to bottom for textarea */
            position: relative; /* For history overlay */
        }

        .capsule-input {
            flex: 1; position: relative; min-height: 55px; max-height: 150px;
            background: var(--glass-bg-light);
            border-radius: 30px; border: 1px solid var(--glass-border);
            transition: 0.3s; display: flex; align-items: center;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
            overflow: hidden; /* For textarea to expand within */
        }
        .capsule-input:focus-within {
            border-color: var(--input-focus-border);
            box-shadow: var(--input-focus-shadow), inset 0 2px 10px rgba(0,0,0,0.2);
            background: rgba(0, 242, 255, 0.05);
        }
        .capsule-input textarea {
            width: 100%; height: 100%; background: transparent; border: none;
            padding: 15px 25px; color: var(--text-color); font-size: 1.05rem; outline: none;
            resize: none; line-height: 1.5;
        }

        .thruster-btn {
            width: 55px; height: 55px; border-radius: 50%; border: none; cursor: pointer;
            background: var(--plasma-gradient);
            display: flex; align-items: center; justify-content: center;
            box-shadow: var(--thruster-base-shadow); transition: 0.3s;
            color: #000; position: relative; overflow: hidden;
        }
        .thruster-btn:hover { transform: scale(1.05) rotate(-10deg); box-shadow: var(--thruster-hover-shadow); }
        .thruster-btn .particles {
            position: absolute; width: 5px; height: 5px; background: white;
            border-radius: 50%; opacity: 0;
            animation: particleBurst 0.8s forwards;
            filter: blur(1px);
        }
        @keyframes particleBurst {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--x), var(--y)) scale(0); opacity: 0; }
        }

        /* FILE PREVIEW */
        #filePreview {
            position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
            width: calc(100% - 50px); max-width: 500px;
            background: var(--glass-bg-strong); backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border); border-radius: 15px;
            padding: 15px; box-shadow: var(--glow-dark);
            z-index: 95; display: none;
        }
        #filePreview .file-item {
            display: flex; align-items: center; gap: 10px; margin-bottom: 8px;
            color: var(--subtle-text-color); font-size: 0.9rem;
        }
        #filePreview .file-item img, #filePreview .file-item video, #filePreview .file-item audio, #filePreview .file-item iframe {
            max-width: 60px; max-height: 45px; border-radius: 8px;
            border: 1px solid var(--glass-border);
        }
        #filePreview .file-item .remove-file-btn {
            background: var(--error-color); color: #fff; border: none;
            width: 25px; height: 25px; border-radius: 50%; cursor: pointer;
            font-size: 1.1rem; transition: 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        #filePreview .file-item .remove-file-btn:hover { background: #ff7777; transform: scale(1.1); }

        /* General UI Elements */
        .spinner {
            display: inline-block; width: 20px; height: 20px;
            border: 3px solid rgba(255,255,255,0.3); border-radius: 50%;
            border-top-color: var(--neon-blue); animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* MODALS (Full Screen Overlays) */
        .cosmic-modal {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(5, 7, 20, 0.9); backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px); z-index: 10000;
            display: none; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.3s ease;
        }
        .cosmic-modal.active { display: flex; opacity: 1; }

        .modal-content-wrapper {
            background: var(--glass-bg-strong); border: 1px solid var(--glass-border);
            border-radius: 20px; box-shadow: var(--glow-base);
            padding: 30px; max-width: 500px; width: 90%; max-height: 90vh;
            overflow-y: auto; position: relative;
            transform: translateY(20px) scale(0.95); opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        .cosmic-modal.active .modal-content-wrapper { transform: translateY(0) scale(1); opacity: 1; }

        .modal-title {
            font-family: 'Orbitron', sans-serif; font-size: 1.5rem;
            color: var(--neon-blue); text-shadow: var(--glow-base);
            text-align: center; margin-bottom: 25px;
        }
        .modal-close-btn {
            position: absolute; top: 15px; right: 15px;
            background: rgba(255,255,255,0.1); border: 1px solid var(--glass-border);
            color: var(--subtle-text-color); width: 35px; height: 35px;
            border-radius: 50%; font-size: 1.2rem; cursor: pointer; transition: 0.2s;
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .modal-close-btn:hover { background: var(--error-color); color: #fff; border-color: var(--error-color); }

        .profile-card {
            display: flex; flex-direction: column; align-items: center;
            margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--glass-border);
        }
        .profile-card img {
            width: 90px; height: 90px; border-radius: 50%;
            border: 3px solid var(--neon-blue); box-shadow: var(--glow-base);
            margin-bottom: 15px;
        }
        .profile-card .username { font-family: 'Orbitron', sans-serif; font-size: 1.2rem; color: var(--neon-blue); text-shadow: var(--glow-dark); }
        .profile-card .email { font-size: 0.9rem; color: var(--subtle-text-color); margin-top: 5px; }

        .form-group label {
            display: block; color: var(--neon-blue); font-size: 0.9rem; margin-top: 15px; margin-bottom: 8px;
        }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%; padding: 12px 15px; background: var(--glass-bg-light); border: 1px solid var(--glass-border);
            border-radius: 8px; color: var(--text-color); font-size: 1rem; outline: none;
            transition: 0.2s; -webkit-appearance: none;
        }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            border-color: var(--neon-blue); box-shadow: var(--glow-dark); background: rgba(0, 242, 255, 0.05);
        }
        .form-group textarea { min-height: 100px; resize: vertical; }

        .modal-action-btn {
            width: 100%; padding: 15px 20px; background: var(--plasma-gradient); border: none;
            border-radius: 12px; color: #000; font-size: 1.1rem; font-weight: bold; cursor: pointer;
            margin-top: 25px; box-shadow: var(--thruster-base-shadow); transition: 0.3s;
        }
        .modal-action-btn:hover { background: var(--neon-purple); box-shadow: var(--thruster-hover-shadow); transform: translateY(-2px); }
        .modal-action-btn.secondary {
            background: rgba(255,255,255,0.1); color: var(--neon-blue); border: 1px solid var(--neon-blue);
            box-shadow: none;
        }
        .modal-action-btn.secondary:hover { background: var(--neon-blue); color: #000; box-shadow: var(--glow-dark); }
        .modal-action-btn.logout { background: var(--error-color); color: #fff; }
        .modal-action-btn.logout:hover { background: #ff7777; box-shadow: 0 0 20px #ff7777; }
        .modal-status-message { color: var(--neon-blue); font-size: 0.9rem; text-align: center; margin-top: 15px; }
        .modal-status-message.error { color: var(--error-color); }

        .chat-list-modal { margin-top: 20px; }
        .chat-list-modal-item {
            display: flex; align-items: center; padding: 10px 0;
            border-bottom: 1px dashed rgba(255,255,255,0.1); cursor: pointer;
            transition: background-color 0.2s;
        }
        .chat-list-modal-item:hover, .chat-list-modal-item.active-chat { background-color: rgba(255,255,255,0.05); }
        .chat-list-modal-item .chat-name { flex-grow: 1; color: var(--text-color); font-size: 1rem; padding-left: 10px; }
        .chat-list-modal-item .chat-actions button {
            background: none; border: none; color: var(--subtle-text-color);
            padding: 5px; font-size: 1rem; cursor: pointer; transition: 0.2s;
        }
        .chat-list-modal-item .chat-actions button:hover { color: var(--neon-blue); }
        .chat-list-modal-item .chat-actions button.delete:hover { color: var(--error-color); }
        .modal-hr { border-color: var(--glass-border); margin: 25px 0; }

        .links-list a {
            display: block; padding: 12px 15px; background: rgba(255,255,255,0.07);
            border: 1px solid var(--glass-border); border-radius: 8px;
            color: var(--neon-blue); text-decoration: none; font-size: 1rem;
            margin-bottom: 10px; transition: 0.2s;
        }
        .links-list a:hover {
            background: rgba(0, 242, 255, 0.15); border-color: var(--neon-blue);
            box-shadow: var(--glow-dark); transform: translateX(5px);
        }

        /* --- MEDIA VIEWER --- */
        #mediaViewer {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 10000;
            display: none; justify-content: center; align-items: center;
        }
        #mediaViewer.active { display: flex; }
        #mediaViewer .media-content {
            background: var(--glass-bg-strong); border: 1px solid var(--neon-blue);
            box-shadow: var(--glow-base); padding: 25px;
            text-align: center; position: relative; max-width: 90vw; max-height: 90vh;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            border-radius: 15px;
        }
        #mediaViewer img, #mediaViewer video, #mediaViewer audio, #mediaViewer iframe {
            max-width: 100%; max-height: 80vh; display: block; margin: 0 auto 15px auto;
            border: 1px solid var(--glass-border); border-radius: 10px;
        }
        #mediaViewer audio { width: 100%; max-width: 400px; }
        #mediaViewer iframe { width: 80vw; height: 80vh; }
        #mediaViewer .media-caption { color: var(--subtle-text-color); font-size: 0.9rem; margin-top: 10px; }
        #mediaViewer .media-close-btn {
            position: absolute; top: 15px; right: 15px;
            background: rgba(255,255,255,0.1); border: 1px solid var(--error-color);
            color: var(--error-color); padding: 8px 12px; cursor: pointer;
            border-radius: 8px; font-size: 0.9rem; transition: 0.2s;
        }
        #mediaViewer .media-close-btn:hover { background: var(--error-color); color: #fff; }


        /* --- CALL MODAL --- */
        #callModal {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(5, 7, 20, 0.95); backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px); z-index: 20000;
            display: none; flex-direction: column; align-items: center; padding: 20px;
            opacity: 0; transition: opacity 0.3s ease;
        }
        #callModal.active { display: flex; opacity: 1; }

        #callHeader {
            font-family: 'Orbitron', sans-serif; font-size: 1.8rem;
            color: var(--neon-blue); text-shadow: var(--glow-base);
            margin-top: 15px; margin-bottom: 25px;
        }

        #botCallAvatar {
            width: 120px; height: 120px; border-radius: 50%;
            border: 3px solid var(--neon-blue); box-shadow: var(--glow-light);
            margin-bottom: 20px;
            transition: all 0.3s ease;
            position: relative; /* For speaking indicator */
        }
        #botCallAvatar.speaking {
            border-color: var(--neon-purple); box-shadow: var(--glow-light), 0 0 30px var(--neon-purple);
            transform: scale(1.05); animation: headBob 1.2s infinite alternate;
        }
        @keyframes headBob { 0% { transform: scale(1.05) translateY(0); } 50% { transform: scale(1.05) translateY(-5px); } 100% { transform: scale(1.05) translateY(0); } }

        .speaking-indicator-orb {
            position: absolute; top: -5px; left: -5px;
            width: 130px; height: 130px; border-radius: 50%;
            border: 3px solid transparent; animation: orbPulseCall 1.5s infinite ease-out;
            opacity: 0;
        }
        #botCallAvatar.speaking .speaking-indicator-orb { opacity: 1; border-color: var(--neon-purple); }
        @keyframes orbPulseCall {
            0% { transform: scale(1); opacity: 0.7; box-shadow: 0 0 10px var(--neon-purple); }
            50% { transform: scale(1.08); opacity: 1; box-shadow: 0 0 25px var(--neon-purple), 0 0 40px var(--neon-blue); }
            100% { transform: scale(1); opacity: 0.7; box-shadow: 0 0 10px var(--neon-purple); }
        }

        #callStatusMessage {
            color: var(--neon-blue); font-size: 1.1rem; text-align: center;
            height: 30px; margin-bottom: 10px;
            text-shadow: var(--glow-dark); animation: statusBlink 1s infinite alternate;
        }
        @keyframes statusBlink { to { opacity: 0.7; } }

        #tapToTalk {
            color: var(--neon-purple); font-size: 1.2rem; text-align: center;
            text-shadow: var(--glow-base); animation: pulseText 1.5s infinite alternate;
            cursor: pointer; display: none;
        }
        @keyframes pulseText { from { opacity: 0.8; transform: scale(1); } to { opacity: 1; transform: scale(1.02); } }

        #callConversationLog {
            flex-grow: 1; width: 100%; max-width: 500px;
            background: var(--glass-bg-light); border: 1px solid var(--glass-border);
            border-radius: 15px; padding: 15px; margin: 20px 0;
            overflow-y: auto; scroll-behavior: smooth;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
            scrollbar-width: none; -ms-overflow-style: none;
            font-size: 0.95rem; line-height: 1.6;
        }
        #callConversationLog::-webkit-scrollbar { display: none; }

        .call-log-entry {
            margin-bottom: 10px; padding: 8px 12px; border-radius: 12px;
            opacity: 0; animation: logEntryFadeIn 0.3s ease-out forwards;
        }
        @keyframes logEntryFadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .call-log-entry.user { background: rgba(0, 242, 255, 0.2); text-align: right; margin-left: auto; max-width: 90%; }
        .call-log-entry.ai { background: rgba(189, 0, 255, 0.2); margin-right: auto; max-width: 90%; }
        .call-log-entry.status { text-align: center; color: var(--subtle-text-color); font-style: italic; background: none; }

        #callControls {
            display: flex; gap: 20px; margin-top: auto; padding-bottom: 20px;
        }
        #muteCallBtn, #endCallBtn {
            padding: 12px 25px; border-radius: 12px; border: none;
            font-size: 1rem; font-weight: bold; cursor: pointer;
            box-shadow: var(--glow-dark); transition: 0.2s;
        }
        #muteCallBtn { background: var(--neon-blue); color: #000; }
        #muteCallBtn:hover { background: var(--neon-purple); color: #000; box-shadow: var(--glow-base); }
        #muteCallBtn.muted { background: var(--glass-bg-light); color: var(--subtle-text-color); border: 1px solid var(--glass-border); box-shadow: none; }
        #muteCallBtn.muted:hover { background: var(--error-color); color: #fff; border-color: var(--error-color); }
        #endCallBtn { background: var(--error-color); color: #fff; }
        #endCallBtn:hover { background: #ff7777; box-shadow: 0 0 20px #ff7777; }


        @media (max-width: 500px) {
            .ui-container { max-width: 100%; }
            header { padding: 10px 15px; }
            .brand-plasma { font-size: 1.1rem; }
            #plasmaOrb { width: 40px; height: 40px; font-size: 1.1rem; }
            .radial-menu.active { width: 160px; height: 160px; }
            .radial-menu-item button { width: 38px; height: 38px; font-size: 1rem; }
            .radial-menu.active .radial-menu-item:nth-child(1) { transform: translate(45px, -45px) scale(1); }
            .radial-menu.active .radial-menu-item:nth-child(2) { transform: translate(60px, 0px) scale(1); }
            .radial-menu.active .radial-menu-item:nth-child(3) { transform: translate(45px, 45px) scale(1); }
            .radial-menu.active .radial-menu-item:nth-child(4) { transform: translate(-45px, 45px) scale(1); }
            .radial-menu.active .radial-menu-item:nth-child(5) { transform: translate(-60px, 0px) scale(1); }
            .radial-menu.active .radial-menu-item:nth-child(6) { transform: translate(-45px, -45px) scale(1); }

            #chat-viewport { padding: 15px; gap: 15px; }
            .msg-bubble { padding: 12px 18px; font-size: 0.9rem; }
            .suggestions-dock { gap: 8px; justify-content: center; }
            .chip { padding: 10px 15px; font-size: 0.8rem; }
            .input-dock { padding: 15px; gap: 10px; }
            .capsule-input { min-height: 48px; }
            .capsule-input textarea { padding: 12px 20px; font-size: 0.95rem; }
            .thruster-btn { width: 48px; height: 48px; font-size: 1rem; }

            .modal-content-wrapper { padding: 20px; width: 95%; }
            .modal-title { font-size: 1.2rem; }
            .profile-card img { width: 80px; height: 80px; }
            .profile-card .username { font-size: 1.1rem; }
            .form-group input, .form-group textarea, .form-group select { padding: 10px 12px; font-size: 0.9rem; }
            .modal-action-btn { padding: 12px 15px; font-size: 1rem; }

            #callHeader { font-size: 1.5rem; }
            #botCallAvatar { width: 100px; height: 100px; }
            .speaking-indicator-orb { width: 110px; height: 110px; }
            #callStatusMessage { font-size: 1rem; }
            #tapToTalk { font-size: 1.1rem; }
            #callConversationLog { padding: 10px; max-width: 100%; font-size: 0.9rem; }
            #callControls { gap: 10px; }
            #muteCallBtn, #endCallBtn { padding: 10px 18px; font-size: 0.9rem; }
        }

    </style>
</head>
<body>

    <div id="cosmos-container">
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
        <div class="cosmic-eagle">
            <!-- SVG of a simple stylized eagle, glowing effect -->
            <svg viewBox="0 0 100 100" fill="var(--neon-blue)" stroke="var(--neon-blue)" stroke-width="2">
                <path d="M50,10 L70,30 L90,20 L75,50 L90,80 L70,70 L50,90 L30,70 L10,80 L25,50 L10,20 L30,30 Z" fill="var(--neon-blue)" filter="url(#glow)"/>
                <defs>
                    <filter id="glow">
                        <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur"></feGaussianBlur>
                        <feFlood flood-color="var(--neon-blue)" flood-opacity="0.8" result="color"></feFlood>
                        <feComposite in="color" in2="blur" operator="in" result="glow"></feComposite>
                        <feMerge>
                            <feMergeNode in="glow"></feMergeNode>
                            <feMergeNode in="SourceGraphic"></feMergeNode>
                        </feMerge>
                    </filter>
                </defs>
            </svg>
        </div>
    </div>

    <div class="ui-container">
        <header>
            <div class="brand-plasma">Philadelphia AI</div>
            <div id="plasmaOrb" title="Access Nexus Controls">
                <i class="fa-solid fa-brain"></i>
            </div>
            <ul class="radial-menu" id="radialMenu">
                <li class="radial-menu-item"><button id="openProfileModalBtn" title="User Profile & Chats"><i class="fa-solid fa-user"></i></button></li>
                <li class="radial-menu-item"><button id="openToolsModalBtn" title="AI Tool Nexus"><i class="fa-solid fa-wrench"></i></button></li>
                <li class="radial-menu-item"><button id="openLinksModalBtn" title="Nexus Protocols & Links"><i class="fa-solid fa-link"></i></button></li>
                <li class="radial-menu-item"><button id="themeCycleBtn" title="Cycle Plasma Theme"><i class="fa-solid fa-palette"></i></button></li>
                <li class="radial-menu-item"><button id="logoutBtn" title="Log Out from Nexus"><i class="fa-solid fa-right-from-bracket"></i></button></li>
                <li class="radial-menu-item"><button onclick="closeRadialMenu();" title="Close Menu"><i class="fa-solid fa-times"></i></button></li>
            </ul>
        </header>

        <div id="chat-viewport">
            <div class="message-group ai">
                <div class="msg-bubble">
                    <span class="ai-text">Greetings, traveler. ðŸ¦… The cosmos is aligned. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨</span>
                </div>
            </div>

            <div class="suggestions-dock" id="suggestions">
                <div class="chip holo-shimmer" data-suggestion="Create a comic. Style: Cyberpunk Anime.">Create a comic. Style: Cyberpunk Anime.</div>
                <div class="chip holo-shimmer" data-suggestion="Design a website landing page for 'Orbit'.">Design a website landing page for "Orbit".</div>
                <div class="chip holo-shimmer" data-suggestion="Generate a sci-fi short story prompt.">Generate a sci-fi short story prompt.</div>
            </div>
        </div>

        <div class="input-dock">
            <div id="stellar-stream-history"><ul></ul></div>
            <label for="fileAttachInput" class="icon-btn" title="Attach file" style="position:relative; top:2px;">
                <i class="fa-solid fa-paperclip" style="font-size:1.4rem;"></i>
                <input type="file" id="fileAttachInput" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none;">
            </label>
            <div class="capsule-input">
                <textarea id="userInput" placeholder="Broadcast your message..." autocomplete="off"></textarea>
            </div>
            <button id="callToggleBtn" class="thruster-btn icon-btn" title="Initiate Comms Link" style="background:var(--neon-blue); box-shadow:var(--thruster-base-shadow); color:#000;">
                <i class="fa-solid fa-phone"></i>
            </button>
            <button id="sendBtn" class="thruster-btn holo-shimmer" title="Transmit Message">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
            <button id="stopBtn" class="thruster-btn" title="Interrupt Transmission" style="display:none; background:var(--error-color); box-shadow:var(--glow-dark); color:#fff;">
                 <i class="fa-solid fa-stop"></i>
            </button>
        </div>
    </div>

    <!-- FILE PREVIEW -->
    <div id="filePreview"></div>

    <!-- Modals -->
    <div class="cosmic-modal" id="profileModal">
        <div class="modal-content-wrapper">
            <button class="modal-close-btn" onclick="profileModal.classList.remove('active');">X</button>
            <h2 class="modal-title">USER PROFILE & CHAT ARCHIVES</h2>

            <div class="profile-card">
                <img id="profilePicModal" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profileModalUser">COMMANDER_UNKNOWN</div>
                <div class="email" id="profileModalEmail">UNSET_EMAIL@SYSTEM.COM</div>
            </div>

            <div class="chat-list-modal">
                <h3 style="color:var(--neon-blue); font-size:1rem; margin-bottom:10px;">Chat Archives</h3>
                <div id="chatsListModal" style="max-height:180px;overflow-y:auto;">
                    <div class="spinner"></div> Loading Chat Logs...
                </div>
                <button id="newChatBtnModal" class="modal-action-btn secondary">
                    <i class="fa-solid fa-plus"></i> NEW ARCHIVE
                </button>
            </div>

            <hr class="modal-hr">

            <form class="form-group" id="profileForm" autocomplete="off">
                <label for="edit-name">COMMANDER NAME</label>
                <input type="text" id="edit-name" required>
                <label for="edit-photo">AVATAR URL</label>
                <input type="url" id="edit-photo" placeholder="http://link.to/avatar.jpg">
                <span style="font-size:0.8em;color:var(--subtle-text-color);display:block;margin:5px 0 10px 0;"> (Tip: <a href="https://postimg.cc/" target="_blank" style="color:var(--neon-blue);">Upload to postimg.cc</a> for direct link) </span>
                <button type="submit" class="modal-action-btn">UPDATE PROFILE</button>
                <div class="modal-status-message" id="profileStatusMsg"></div>
            </form>
            <button id="logoutBtnModal" class="modal-action-btn logout">LOGOUT FROM NEXUS</button>
        </div>
    </div>

    <div class="cosmic-modal" id="toolsModal">
        <div class="modal-content-wrapper">
            <button class="modal-close-btn" onclick="toolsModal.classList.remove('active');">X</button>
            <h2 class="modal-title" id="toolsModalTitle">AI TOOL NEXUS</h2>

            <div id="toolListDisplay" class="links-list">
                <h3 style="color:var(--neon-blue); font-size:1rem; margin-bottom:10px;">Creative Modules</h3>
                <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
                <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
                <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a>
                <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a>
                <hr class="modal-hr">
                <h3 style="color:var(--neon-blue); font-size:1rem; margin-bottom:10px;">Audio/Video Modules</h3>
                <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
                <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration (Document)</a>
                <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a>
                <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
                <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a>
                <hr class="modal-hr">
                <h3 style="color:var(--neon-blue); font-size:1rem; margin-bottom:10px;">Web/Research Modules</h3>
                <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a>
                <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
                <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a>
                <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
            </div>

            <form class="form-group" id="toolForm" style="display:none;"></form>
            <button id="toolFormBackBtn" class="modal-action-btn secondary" style="display:none;">
                <i class="fa-solid fa-arrow-left"></i> BACK TO NEXUS TOOLS
            </button>
            <div class="modal-status-message" id="toolStatusMsg"></div>
        </div>
    </div>

    <div class="cosmic-modal" id="linksModal">
        <div class="modal-content-wrapper">
            <button class="modal-close-btn" onclick="linksModal.classList.remove('active');">X</button>
            <h2 class="modal-title">NEXUS PROTOCOLS & LINKS</h2>
            <div class="links-list">
                <a href="philadelphia.html"><i class="fa-solid fa-house-chimney"></i> PHILADELPHIA NEXUS HOME</a>
                <a href="index.html"><i class="fa-solid fa-globe"></i> ELVION NETWORK HUB</a>
                <a href="about.html"><i class="fa-solid fa-circle-info"></i> ABOUT NEXUS OPERATIONS</a>
                <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> PRIVACY PROTOCOLS</a>
                <a href="terms.html"><i class="fa-solid fa-file-contract"></i> TERMS OF SERVICE</a>
                <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> ENGAGE TELEGRAM UNIT</a>
            </div>
        </div>
    </div>

    <!-- Media Viewer (for AI outputs that are links) -->
    <div id="mediaViewer">
        <div class="media-content">
            <button class="media-close-btn">CLOSE</button>
            <div id="mediaArea"></div>
            <span class="media-caption" id="mediaCaption"></span>
        </div>
    </div>

    <!-- Call Modal -->
    <div id="callModal">
        <h2 id="callHeader">SECURE COMMS LINK ACTIVE</h2>
        <div id="botCallAvatar">
            <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Philadelphia AI Avatar">
            <div class="speaking-indicator-orb"></div>
        </div>
        <div id="callStatusMessage">ESTABLISHING SECURE CHANNEL...</div>
        <div id="tapToTalk">ACTIVATE VOICE INPUT (TAP)</div>
        <div id="callConversationLog">
            <div class="call-log-entry status">INITIATING SECURE CHANNEL...</div>
        </div>
        <div id="callControls">
            <button id="muteCallBtn"><i class="fa-solid fa-microphone"></i> MUTE</button>
            <button id="endCallBtn"><i class="fa-solid fa-phone-slash"></i> TERMINATE</button>
        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile, signOut } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        // --- Firebase Config ---
        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- API Base URL ---
        const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

        // --- Global Variables ---
        let chats = [];
        let currentChatId = null;
        let currentMessages = []; // Full message objects from Firestore
        let currentMessagesTextOnly = []; // Simplified for AI history
        let uploadedFiles = [];
        let currentUser = null;
        let currentController = null; // For API abortion

        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;

        // --- DOM Selectors ---
        const $ = id => document.getElementById(id);
        const $$ = selector => document.querySelectorAll(selector);

        const cosmosContainer = $('cosmos-container');
        const chatViewport = $('chat-viewport');
        const userInput = $('userInput');
        const sendBtn = $('sendBtn');
        const stopBtn = $('stopBtn');
        const suggestionsDock = $('suggestions');
        const fileAttachInput = $('fileAttachInput');
        const filePreview = $('filePreview');
        const plasmaOrb = $('plasmaOrb');
        const radialMenu = $('radialMenu');

        const profileModal = $('profileModal');
        const openProfileModalBtn = $('openProfileModalBtn');
        const profilePicModal = $('profilePicModal');
        const profileModalUser = $('profileModalUser');
        const profileModalEmail = $('profileModalEmail');
        const profileForm = $('profileForm');
        const editName = $('edit-name');
        const editPhoto = $('edit-photo');
        const profileStatusMsg = $('profileStatusMsg');
        const chatsListModal = $('chatsListModal');
        const newChatBtnModal = $('newChatBtnModal');
        const logoutBtn = $('logoutBtn');
        const logoutBtnModal = $('logoutBtnModal');

        const toolsModal = $('toolsModal');
        const openToolsModalBtn = $('openToolsModalBtn');
        const toolsModalTitle = $('toolsModalTitle');
        const toolListDisplay = $('toolListDisplay');
        const toolForm = $('toolForm');
        const toolFormBackBtn = $('toolFormBackBtn');
        const toolStatusMsg = $('toolStatusMsg');

        const linksModal = $('linksModal');
        const openLinksModalBtn = $('openLinksModalBtn');

        const mediaViewer = $('mediaViewer');
        const mediaArea = $('mediaArea');
        const mediaCaption = $('mediaCaption');
        const mediaCloseBtn = mediaViewer.querySelector('.media-close-btn');

        const callToggleBtn = $('callToggleBtn');
        const callModal = $('callModal');
        const callHeader = $('callHeader');
        const botCallAvatar = $('botCallAvatar');
        const callStatusMessage = $('callStatusMessage');
        const tapToTalk = $('tapToTalk');
        const callConversationLog = $('callConversationLog');
        const muteCallBtn = $('muteCallBtn');
        const endCallBtn = $('endCallBtn');

        const themeCycleBtn = $('themeCycleBtn');

        const stellarStreamHistory = $('stellar-stream-history');

        // --- Initial DOM Setup & Event Listeners ---
        window.addEventListener('DOMContentLoaded', () => {
            igniteCosmos();
            setupBackgroundAnimations();

            // Auto-resize textarea
            userInput.addEventListener('input', autoResizeTextarea);
            userInput.addEventListener('keydown', handleUserInputKeyDown);
            userInput.focus(); // Focus on input at start

            // Send message on Enter (Shift+Enter for newline)
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            sendBtn.addEventListener('click', sendMessage);
            stopBtn.addEventListener('click', interruptTransmission);

            // File attachment
            fileAttachInput.addEventListener('change', handleFileAttach);

            // Radial Menu
            plasmaOrb.addEventListener('click', toggleRadialMenu);
            // Close radial menu if click outside
            document.addEventListener('click', (e) => {
                if (radialMenu.classList.contains('active') && !plasmaOrb.contains(e.target) && !radialMenu.contains(e.target)) {
                    closeRadialMenu();
                }
            });

            // Modal Toggles from Radial Menu
            openProfileModalBtn.addEventListener('click', () => { profileModal.classList.add('active'); closeRadialMenu(); });
            openToolsModalBtn.addEventListener('click', () => { toolsModal.classList.add('active'); closeRadialMenu(); });
            openLinksModalBtn.addEventListener('click', () => { linksModal.classList.add('active'); closeRadialMenu(); });
            logoutBtn.addEventListener('click', logoutFromNexus);
            themeCycleBtn.addEventListener('click', () => { cycleTheme(); closeRadialMenu(); });

            // Close buttons for modals
            $$('.modal-close-btn').forEach(btn => {
                btn.addEventListener('click', () => btn.closest('.cosmic-modal').classList.remove('active'));
            });
            // Click outside to close modals
            $$('.cosmic-modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('active');
                    }
                });
            });

            // Profile Form
            profileForm.addEventListener('submit', updateProfileData);
            logoutBtnModal.addEventListener('click', logoutFromNexus);
            newChatBtnModal.addEventListener('click', () => { createNewChat(currentUser.uid); profileModal.classList.remove('active'); });

            // Tool Form
            toolListDisplay.addEventListener('click', handleToolLinkClick);
            toolFormBackBtn.addEventListener('click', () => {
                toolForm.style.display = 'none';
                toolFormBackBtn.style.display = 'none';
                toolListDisplay.style.display = 'block';
                toolsModalTitle.textContent = "AI TOOL NEXUS";
                toolStatusMsg.textContent = '';
            });

            // Media Viewer
            mediaCloseBtn.addEventListener('click', () => mediaViewer.classList.remove('active'));

            // Call Features
            callToggleBtn.addEventListener('click', toggleCall);
            endCallBtn.addEventListener('click', endCall);
            muteCallBtn.addEventListener('click', toggleMute);
            callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
            callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);

            // Suggestion chips
            $$('.chip').forEach(chip => {
                chip.addEventListener('click', (e) => sendSuggestion(e.target));
            });

            // Theme loading
            loadSavedTheme();
        });


        // --- COSMOS BACKGROUND ENGINE FUNCTIONS ---
        function igniteCosmos() {
            // Stars
            for (let i = 0; i < 250; i++) {
                createParticle('star', 100, 30); // Slower twinkle for distant stars
            }
            // Stardust (closer, faster drift)
            for (let i = 0; i < 150; i++) {
               createParticle('stardust', 150, 25); // Wider spread, medium duration
            }
        }

        function createParticle(type, spread, maxDuration) {
            const particle = document.createElement('div');
            particle.className = type;
            const size = Math.random() * (type === 'star' ? 2 : 1.5) + 0.5;
            particle.style.width = `${size}px`; particle.style.height = `${size}px`;
            particle.style.left = `${Math.random() * spread}%`;
            particle.style.top = `${Math.random() * spread}%`;
            particle.style.setProperty('--duration', `${Math.random() * maxDuration + 15}s`); // More varied durations
            particle.style.opacity = Math.random();
            cosmosContainer.appendChild(particle);
        }

        function setupBackgroundAnimations() {
            // Shooting Stars
            const launchShootingStar = () => {
                const star = document.createElement('div');
                star.className = 'shooting-star';
                const startX = Math.random() * window.innerWidth * 1.5 - (window.innerWidth * 0.25); // Start off-screen
                const startY = Math.random() * window.innerHeight * 1.5 - (window.innerHeight * 0.25);
                const angle = Math.random() * 90 - 45; // Angle between -45 and 45 degrees
                const length = Math.random() * 150 + 50; // Length between 50px and 200px
                const duration = Math.random() * 3 + 2; // Duration between 2s and 5s

                star.style.setProperty('--startX', `${startX}px`);
                star.style.setProperty('--startY', `${startY}px`);
                star.style.setProperty('--endX', `${startX - 800}px`); // Consistent long path
                star.style.setProperty('--endY', `${startY + 500}px`);
                star.style.setProperty('--angle', `${angle}deg`);
                star.style.setProperty('--length', `${length}px`);
                star.style.setProperty('--duration', `${duration}s`);
                cosmosContainer.appendChild(star);
                star.addEventListener('animationend', () => star.remove());
            };
            setInterval(launchShootingStar, Math.random() * 3000 + 2000); // Between 2 and 5 seconds

            // Cosmic Eagle
            const cosmicEagle = document.querySelector('.cosmic-eagle');
            cosmicEagle.style.setProperty('--duration', `${Math.random() * 60 + 80}s`); // Slower drift
            cosmicEagle.style.setProperty('--size', `${Math.random() * 40 + 70}px`); // Vary size
            cosmicEagle.classList.add('trail'); // Add trail effect via CSS
        }

        // --- UI UTILITY FUNCTIONS ---

        // Firebase User Auth State
        onAuthStateChanged(auth, user => {
            if (!user) {
                window.location.href = "signup-login.html"; // Redirect to login
                return;
            }
            currentUser = user;
            updateProfileUI(user);
            loadUserChats(user.uid);
        });

        function updateProfileUI(user) {
            const displayName = user.displayName || 'Traveler';
            const email = user.email || 'unknown@galaxy.com';

            profileModalUser.textContent = displayName;
            profileModalEmail.textContent = email;
            profilePicModal.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

            editName.value = displayName;
            editPhoto.value = user.photoURL || "";
        }

        async function updateProfileData(e) {
            e.preventDefault();
            if (!currentUser) return;

            profileStatusMsg.textContent = 'Updating profile data...';
            profileStatusMsg.classList.remove('error');

            try {
                await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
                if (auth.currentUser) await auth.currentUser.reload();
                profileStatusMsg.textContent = 'Profile data updated!';
                updateProfileUI(auth.currentUser); // Update all UI elements

                setTimeout(() => {
                    profileModal.classList.remove('active');
                    profileStatusMsg.textContent = '';
                }, 1200);
            } catch (err) {
                profileStatusMsg.textContent = `Error: ${err.message}`;
                profileStatusMsg.classList.add('error');
            }
        }

        async function logoutFromNexus() {
            await signOut(auth);
            // Redirect handled by onAuthStateChanged
        }

        // --- THEME SWITCHING ---
        const themes = {
            'cosmic-glow': { /* default, no class needed */ },
            'galactic-twilight-theme': { /* defined as class */ },
            'nebula-emerald-theme': { /* defined as class */ }
        };
        let currentThemeIdx = 0;
        const themeKeys = Object.keys(themes);

        function applyTheme(themeName) {
            document.body.className = '';
            if (themeName !== 'cosmic-glow') {
                document.body.classList.add(themeName);
            }
            localStorage.setItem('philadelphia-cosmic-theme', themeName);
        }

        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('philadelphia-cosmic-theme');
            if (savedTheme && themes[savedTheme]) {
                currentThemeIdx = themeKeys.indexOf(savedTheme);
                applyTheme(savedTheme);
            } else {
                applyTheme('cosmic-glow'); // Default
            }
        }

        function cycleTheme() {
            currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
            applyTheme(themeKeys[currentThemeIdx]);
        }

        // --- RADIAL MENU ---
        function toggleRadialMenu() {
            radialMenu.classList.toggle('active');
            // Animate items
            const items = radialMenu.querySelectorAll('.radial-menu-item');
            items.forEach((item, index) => {
                item.style.transitionDelay = radialMenu.classList.contains('active') ? `${index * 0.05}s` : '0s';
            });
        }
        function closeRadialMenu() {
            radialMenu.classList.remove('active');
            radialMenu.querySelectorAll('.radial-menu-item').forEach(item => item.style.transitionDelay = '0s');
        }

        // --- CHAT MANAGEMENT ---
        async function loadUserChats(userId) {
            if (chatsUnsubscribe) chatsUnsubscribe();
            const chatsCol = collection(db, 'users', userId, 'chats');
            const q = query(chatsCol, orderBy('createdAt', 'desc'));
            chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                if (snapshot.empty) {
                    await createNewChat(userId);
                    return;
                }
                chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderChatsList(chatsListModal);
                if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                    currentChatId = chats.id;
                }
                subscribeToMessages(userId, currentChatId);
            }, (error) => {
                console.error("Error fetching chats: ", error);
                chatsListModal.innerHTML = `<div class="modal-status-message error">Error loading chat archives.</div>`;
            });
        }

        async function createNewChat(userId) {
            if (!userId) { console.error("User ID not available for chat creation."); return; }
            const chatsCol = collection(db, 'users', userId, 'chats');
            try {
                const newChatDoc = await addDoc(chatsCol, { name: "New Archive", createdAt: serverTimestamp() });
                currentChatId = newChatDoc.id;
                subscribeToMessages(userId, currentChatId);
            } catch (e) {
                console.error("Error creating new chat: ", e);
            }
        }

        function subscribeToMessages(userId, chatId) {
            if (messagesUnsubscribe) messagesUnsubscribe();
            if (!userId || !chatId) {
                chatViewport.innerHTML = `<div class="message-group ai"><div class="msg-bubble">Select or create a chat archive to begin your cosmic dialogue.</div></div>`;
                return;
            }
            const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
            const q = query(messagesCol, orderBy('createdAt'));
            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                currentMessagesTextOnly = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                renderChatHistory(currentMessages);
            }, (error) => {
                console.error("Error fetching messages: ", error);
                chatViewport.innerHTML = `<div class="message-group ai"><div class="msg-bubble" style="color:var(--error-color);">Error loading messages for this chat archive.</div></div>`;
            });
        }

        function renderChatsList(element) {
            if (!element) return;
            element.innerHTML = '';
            if (chats.length === 0) {
                element.innerHTML = `<div class="modal-status-message">No chat archives found.</div>`;
                return;
            }
            chats.forEach((chat) => {
                const item = document.createElement('div');
                item.classList.add('chat-list-modal-item');
                if (chat.id === currentChatId) item.classList.add('active-chat');

                const nameSpan = document.createElement('span');
                nameSpan.classList.add('chat-name');
                nameSpan.textContent = chat.name || 'Untitled Archive';
                nameSpan.title = `ID: ${chat.id}`;
                nameSpan.addEventListener('click', () => {
                    currentChatId = chat.id;
                    subscribeToMessages(currentUser.uid, currentChatId);
                    profileModal.classList.remove('active');
                    renderChatsList(chatsListModal); // Re-render to show active chat
                });

                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('chat-actions');

                const renameBtn = document.createElement('button');
                renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                renameBtn.title = 'Rename Archive';
                renameBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const newName = prompt(`Rename archive '${chat.name}':`);
                    if (newName && newName.trim()) {
                        await setDoc(doc(db, 'users', currentUser.uid, 'chats', chat.id), { name: newName.trim() }, { merge: true });
                    }
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                deleteBtn.title = 'Delete Archive';
                deleteBtn.classList.add('delete');
                deleteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    if (!confirm(`Confirm deletion of '${chat.name}' and all its messages? This cannot be undone.`)) return;

                    const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                    const messagesSnap = await getDocs(messagesCol);
                    const batch = writeBatch(db);
                    messagesSnap.docs.forEach(d => batch.delete(d.ref));
                    await batch.commit();

                    await deleteDoc(doc(db, 'users', currentUser.uid, 'chats', chat.id));
                    if (currentChatId === chat.id) currentChatId = null;
                });

                actionsDiv.appendChild(renameBtn);
                actionsDiv.appendChild(deleteBtn);
                item.appendChild(nameSpan);
                item.appendChild(actionsDiv);
                element.appendChild(item);
            });
        }


        // --- CHAT HISTORY & MESSAGE RENDERING ---
        function renderChatHistory(messages = []) {
            chatViewport.innerHTML = ''; // Clear existing
            messages.forEach(msg => {
                const group = document.createElement('div');
                group.className = `message-group ${msg.role}`;
                group.setAttribute('data-message-id', msg.id);

                let contentHTML = msg.text || '';
                // Handle markdown first
                const parsedMarkdown = renderMarkdown(contentHTML);
                contentHTML = parsedMarkdown.html;

                // Then handle special outputs like media links
                const mediaLinkRegex = /\[(IMAGE_OUTPUT|VIDEO_OUTPUT|AUDIO_OUTPUT|PDF_OUTPUT|LINK_OUTPUT): (.*?)\]\((.*?)\)/g;
                contentHTML = contentHTML.replace(mediaLinkRegex, (match, mediaType, displayName, url) => {
                    return `<a href="#" data-media-type="${mediaType.toLowerCase()}" data-media-url="${url}">${displayName || `[${mediaType.toUpperCase()}]`}</a>`;
                });

                let controlButtons = '';
                if (msg.role === 'user') {
                    controlButtons = `
                        <div class="msg-controls">
                            <button class="edit-msg-btn" title="Edit Message"><i class="fa-solid fa-pen-to-square"></i></button>
                            <button class="copy-msg-btn" title="Copy Message"><i class="fa-solid fa-copy"></i></button>
                        </div>
                    `;
                } else {
                    controlButtons = `
                        <div class="msg-controls">
                            <button class="copy-msg-btn" title="Copy Response"><i class="fa-solid fa-copy"></i></button>
                            <button class="share-msg-btn" title="Share Response"><i class="fa-solid fa-share-nodes"></i></button>
                            <button class="regen-msg-btn" title="Regenerate Response"><i class="fa-solid fa-rotate-right"></i></button>
                        </div>
                    `;
                }

                group.innerHTML = `<div class="msg-bubble"><span class="ai-text">${contentHTML}</span>${controlButtons}</div>`;

                chatViewport.appendChild(group);

                // Attach event listeners for media links
                group.querySelectorAll('a[data-media-type]').forEach(link => {
                    link.addEventListener('click', handleMediaLinkClick);
                });
                // Enhance code blocks for the newly added message
                enhanceCodeBlocks(group.querySelector('.msg-bubble'));

                // Attach message control listeners
                if (msg.role === 'user') {
                    group.querySelector('.edit-msg-btn').addEventListener('click', () => editChatMessage(msg.id, msg.text));
                    group.querySelector('.copy-msg-btn').addEventListener('click', () => copyChatMessage(msg.text));
                } else {
                    group.querySelector('.copy-msg-btn').addEventListener('click', () => copyChatMessage(msg.text));
                    group.querySelector('.share-msg-btn').addEventListener('click', () => shareChatMessage(msg.text));
                    group.querySelector('.regen-msg-btn').addEventListener('click', () => regenerateResponse(msg.id));
                }
            });
            chatViewport.appendChild(suggestionsDock); // Ensure suggestions always at bottom
            chatViewport.scrollTop = chatViewport.scrollHeight;
        }

        async function addMessageToChat(role, text, files = []) {
            if (!currentChatId || !currentUser) {
                console.error("No active chat ID or user for message logging.");
                return;
            }
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            try {
                await addDoc(messagesCol, { role, text, files, createdAt: serverTimestamp() });
            } catch (e) {
                console.error("Error adding message to Firestore: ", e);
            }
        }

        // --- MARKDOWN & CODE RENDERING ---
        const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

        function inlineMarkdown(t = '') {
            let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
            s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
            s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            return s.replace(/\n/g, '<br>');
        }

        function renderMarkdown(text = '') {
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            let html = '';
            let lastIndex = 0;
            text = text || ''; // Ensure text is string
            
            text.replace(codeBlockRegex, (match, lang, code, offset) => {
                const before = text.slice(lastIndex, offset);
                html += inlineMarkdown(before); // Process text before code block
                const language = (lang || '').toLowerCase().trim();
                const safeCode = escapeHTML(code);
                html += `<pre><button class="code-copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safeCode}</code></pre>`;
                lastIndex = offset + match.length;
                return match;
            });
            html += inlineMarkdown(text.slice(lastIndex)); // Process remaining text

            return { html };
        }

        function enhanceCodeBlocks(container) {
            if (!container) return;
            container.querySelectorAll('pre').forEach(pre => {
                const codeEl = pre.querySelector('code');
                if (window.hljs && codeEl) {
                    try { hljs.highlightElement(codeEl); } catch (e) { /* ignore */ }
                }
                const btn = pre.querySelector('.code-copy-btn');
                if (btn && codeEl) {
                    btn.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard.writeText(codeEl.innerText);
                            const prev = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => btn.textContent = prev, 800);
                        } catch (e) {
                            btn.textContent = 'Failed';
                            setTimeout(() => btn.textContent = 'Copy', 800);
                        }
                    });
                }
            });
        }
        
        // --- CHAT INTERACTION ---
        function autoResizeTextarea() {
            userInput.style.height = 'auto';
            userInput.style.height = Math.min(userInput.scrollHeight, 150) + 'px'; // Max 150px
        }

        let inputHistory = [];
        let historyCursor = -1;

        function handleUserInputKeyDown(e) {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyCursor < inputHistory.length - 1) {
                    historyCursor++;
                    userInput.value = inputHistory[historyCursor];
                    autoResizeTextarea();
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyCursor > 0) {
                    historyCursor--;
                    userInput.value = inputHistory[historyCursor];
                    autoResizeTextarea();
                } else if (historyCursor === 0) {
                    historyCursor = -1;
                    userInput.value = '';
                    autoResizeTextarea();
                }
            } else if (e.key === '/' && userInput.value === '/') {
                // Trigger Stellar Stream history
                renderStellarStreamHistory();
                stellarStreamHistory.classList.add('active');
            } else if (e.key === 'Escape' && stellarStreamHistory.classList.contains('active')) {
                stellarStreamHistory.classList.remove('active');
            }
        }

        function renderStellarStreamHistory() {
            stellarStreamHistory.innerHTML = '';
            if (inputHistory.length === 0) {
                stellarStreamHistory.innerHTML = `<ul><li>No recent commands.</li></ul>`;
                return;
            }
            const ul = document.createElement('ul');
            inputHistory.slice(0, 10).forEach((entry, index) => { // Show max 10 recent
                const li = document.createElement('li');
                li.textContent = entry;
                li.addEventListener('click', () => {
                    userInput.value = entry;
                    autoResizeTextarea();
                    stellarStreamHistory.classList.remove('active');
                    userInput.focus();
                    historyCursor = inputHistory.indexOf(entry); // Set cursor to selected item
                });
                ul.appendChild(li);
            });
            stellarStreamHistory.appendChild(ul);
        }

        function sendSuggestion(chipEl) {
            userInput.value = chipEl.dataset.suggestion;
            sendMessage();
        }

        // Main Send Message Function
        async function sendMessage() {
            const text = userInput.value.trim();
            if (!text && uploadedFiles.length === 0) return;

            // Add to input history
            if (text) {
                inputHistory.unshift(text);
                historyCursor = -1;
            }
            
            const userMessageContent = text;
            const filesToSend = [...uploadedFiles];

            // UI update: user message
            const userGroup = document.createElement('div');
            userGroup.className = `message-group user`;
            userGroup.innerHTML = `<div class="msg-bubble">${escapeHTML(userMessageContent)}</div>`;
            chatViewport.insertBefore(userGroup, suggestionsDock);

            if (filesToSend.length > 0) {
                const filePreviewHtml = filesToSend.map(file => {
                    let icon = 'fa-file';
                    if (file.type.startsWith('image/')) icon = 'fa-file-image';
                    else if (file.type.startsWith('video/')) icon = 'fa-file-video';
                    else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
                    else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                    return `<span style="color:var(--subtle-text-color);"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</span>`;
                }).join(' ');
                 const fileInfoSpan = document.createElement('div');
                 fileInfoSpan.style.fontSize = '0.85em';
                 fileInfoSpan.style.marginTop = '5px';
                 fileInfoSpan.style.textAlign = 'right';
                 fileInfoSpan.innerHTML = filePreviewHtml;
                 userGroup.querySelector('.msg-bubble').appendChild(fileInfoSpan);
            }

            userInput.value = '';
            autoResizeTextarea();
            uploadedFiles = [];
            filePreview.innerHTML = '';
            filePreview.style.display = 'none';
            chatViewport.scrollTop = chatViewport.scrollHeight;

            // Show typing indicator
            const typingGroup = document.createElement('div');
            typingGroup.className = 'message-group ai typing-indicator';
            typingGroup.innerHTML = `<div class="msg-bubble"><span class="typing-indicator-dot"></span><span class="typing-indicator-dot"></span><span class="typing-indicator-dot"></span> Transmitting...</div>`;
            chatViewport.insertBefore(typingGroup, suggestionsDock);
            chatViewport.scrollTop = chatViewport.scrollHeight;

            // Replace sendBtn with stopBtn
            sendBtn.style.display = 'none';
            stopBtn.style.display = 'flex';
            currentController = new AbortController(); // Reset controller

            let aiResponse = '';
            try {
                if (filesToSend.length > 0) {
                    aiResponse = await sendFileToAI(userMessageContent, filesToSend[0], currentController.signal);
                } else {
                    aiResponse = await sendTextToAI(userMessageContent, currentMessagesTextOnly, currentController.signal);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    aiResponse = "Transmission interrupted by user.";
                } else {
                    aiResponse = `Error: ${error.message}`;
                }
            } finally {
                // Remove typing indicator
                if (typingGroup.parentNode) typingGroup.remove();
                sendBtn.style.display = 'flex';
                stopBtn.style.display = 'none';
                currentController = null;

                if (aiResponse) {
                    await startTypewriterEffect(aiResponse); // Output AI response
                }
            }
        }

        async function interruptTransmission() {
            if (currentController) {
                currentController.abort();
                console.log("Transmission aborted.");
                // UI cleanup is handled in sendMessage finally block
            }
        }


        // --- API INTEGRATION ---
        async function sendTextToAI(message, history, signal) {
            try {
                const res = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message, history: history, user_id: currentUser?.uid || "user" }),
                    signal: signal
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || "AI Nexus transmission failed.");
                return data.response;
            } catch (error) {
                console.error("Error sending message to AI:", error);
                throw error;
            }
        }

        async function sendFileToAI(prompt, file, signal) {
            let endpoint = '';
            if (file.type.startsWith('image/')) endpoint = '/understand-image';
            else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
            else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
            else if (file.type.startsWith('video/')) endpoint = '/understand-video';
            else throw new Error("Unsupported file type for analysis.");

            try {
                const fd = new FormData();
                fd.append('prompt', prompt || `Analyze this ${file.type.split('/')[0]} artifact.`);
                fd.append('file', file);
                const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal: signal });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || "File analysis failed.");
                return data.response;
            } catch (error) {
                console.error("Error sending file to AI:", error);
                throw error;
            }
        }

        // --- TYPEWRITER EFFECT FOR AI RESPONSES ---
        async function startTypewriterEffect(text) {
            const aiGroup = document.createElement('div');
            aiGroup.className = 'message-group ai';
            const msgBubble = document.createElement('div');
            msgBubble.className = 'msg-bubble';
            const aiTextSpan = document.createElement('span');
            aiTextSpan.classList.add('ai-text');
            msgBubble.appendChild(aiTextSpan);
            aiGroup.appendChild(msgBubble);
            chatViewport.insertBefore(aiGroup, suggestionsDock);
            chatViewport.scrollTop = chatViewport.scrollHeight;

            let currentText = '';
            for (let i = 0; i < text.length; i++) {
                if (currentController && currentController.signal.aborted) {
                    text = currentText; // Stop typing, use current content
                    break;
                }
                currentText += text[i];
                aiTextSpan.innerHTML = escapeHTML(currentText); // Display raw text
                chatViewport.scrollTop = chatViewport.scrollHeight;
                await new Promise(res => setTimeout(res, 20)); // Typing speed
            }

            // Final render and post-processing (markdown, code highlighting, controls)
            const finalRenderedHTML = renderMarkdown(text).html;
            aiTextSpan.innerHTML = finalRenderedHTML;

            // Handle media links
            const mediaLinkRegex = /\[(IMAGE_OUTPUT|VIDEO_OUTPUT|AUDIO_OUTPUT|PDF_OUTPUT|LINK_OUTPUT): (.*?)\]\((.*?)\)/g;
            aiTextSpan.innerHTML = aiTextSpan.innerHTML.replace(mediaLinkRegex, (match, mediaType, displayName, url) => {
                return `<a href="#" data-media-type="${mediaType.toLowerCase()}" data-media-url="${url}">${displayName || `[${mediaType.toUpperCase()}]`}</a>`;
            });
            aiTextSpan.querySelectorAll('a[data-media-type]').forEach(link => {
                link.addEventListener('click', handleMediaLinkClick);
            });

            // Add AI controls (copy, share, regen)
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'msg-controls';
            controlsDiv.innerHTML = `
                <button class="copy-msg-btn" title="Copy Response"><i class="fa-solid fa-copy"></i></button>
                <button class="share-msg-btn" title="Share Response"><i class="fa-solid fa-share-nodes"></i></button>
                <button class="regen-msg-btn" title="Regenerate Response"><i class="fa-solid fa-rotate-right"></i></button>
            `;
            msgBubble.appendChild(controlsDiv);

            // Enhance code blocks and attach control listeners for the newly added message
            enhanceCodeBlocks(msgBubble);
            msgBubble.querySelector('.copy-msg-btn').addEventListener('click', () => copyChatMessage(text));
            msgBubble.querySelector('.share-msg-btn').addEventListener('click', () => shareChatMessage(text));
            msgBubble.querySelector('.regen-msg-btn').addEventListener('click', () => regenerateResponse(aiGroup.dataset.messageId));

            // Save to Firestore (after completion)
            await addMessageToChat('ai', text);
            chatViewport.scrollTop = chatViewport.scrollHeight;
        }

        // --- MESSAGE CONTROLS (Copy, Share, Edit, Regenerate) ---
        function copyChatMessage(text) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = renderMarkdown(text).html;
            const plainText = tempDiv.textContent || tempDiv.innerText || '';
            navigator.clipboard.writeText(plainText);
            // Optionally, visual feedback (e.g., button changes text to "Copied!")
        }

        function shareChatMessage(text) {
            const url = window.location.origin;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = renderMarkdown(text).html;
            const plainText = tempDiv.textContent || tempDiv.innerText || '';
            const shareText = `${plainText}\n\nShared via Philadelphia AI Nexus: ${url}`;
            if (navigator.share) {
                navigator.share({ title: "Philadelphia AI Nexus", text: shareText, url }).catch(() => {});
            } else {
                prompt("Copy and share manually:", shareText);
            }
        }

        async function editChatMessage(messageId, originalText) {
            // Find the message group
            const messageGroup = chatViewport.querySelector(`.message-group[data-message-id="${messageId}"]`);
            if (!messageGroup) return;

            // Populate input with original text
            userInput.value = originalText;
            autoResizeTextarea();
            userInput.focus();

            // Delete this message and subsequent AI response from Firestore
            const msgIndex = currentMessages.findIndex(m => m.id === messageId);
            if (msgIndex !== -1) {
                const batch = writeBatch(db);
                for (let i = msgIndex; i < currentMessages.length; i++) {
                    batch.delete(doc(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages', currentMessages[i].id));
                }
                await batch.commit();
            }
            // UI will re-render automatically via onSnapshot
        }

        async function regenerateResponse(aiMessageId) {
            const aiMsgIndex = currentMessages.findIndex(m => m.id === aiMessageId);
            if (aiMsgIndex < 1) return; // Need at least one user message before this AI message

            const userMessageToRegen = currentMessages[aiMsgIndex - 1];
            if (userMessageToRegen.role !== 'user') return; // Ensure it's a user message

            // Delete the AI message and any subsequent messages from Firestore
            const batch = writeBatch(db);
            for (let i = aiMsgIndex; i < currentMessages.length; i++) {
                batch.delete(doc(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages', currentMessages[i].id));
            }
            await batch.commit();
            // UI will re-render automatically via onSnapshot

            // Now re-send the user's message as if it's new
            userInput.value = userMessageToRegen.text;
            sendMessage();
        }

        // --- FILE ATTACHMENT & PREVIEW ---
        function handleFileAttach() {
            uploadedFiles = Array.from(fileAttachInput.files || []);
            renderFilePreview();
        }

        function renderFilePreview() {
            if (!filePreview) return;
            if (!uploadedFiles.length) {
                filePreview.style.display = 'none';
                filePreview.innerHTML = '';
                return;
            }
            filePreview.style.display = 'block';
            filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                let previewHtml = '';
                if (file.type.startsWith('image/')) {
                    previewHtml = `<img src="${URL.createObjectURL(file)}" alt="Preview">`;
                } else if (file.type.startsWith('video/')) {
                    previewHtml = `<video src="${URL.createObjectURL(file)}" controls></video>`;
                } else if (file.type.startsWith('audio/')) {
                    previewHtml = `<audio src="${URL.createObjectURL(file)}" controls></audio>`;
                } else if (file.type === 'application/pdf') {
                    previewHtml = `<iframe src="${URL.createObjectURL(file)}"></iframe>`;
                } else {
                    previewHtml = `<i class="fa-solid fa-file" style="font-size:24px;"></i>`;
                }
                return `
                    <div class="file-item">
                        ${previewHtml}
                        <span>${escapeHTML(file.name)}</span>
                        <button type="button" data-idx="${idx}" class="remove-file-btn">&times;</button>
                    </div>`;
            }).join('');

            filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.idx);
                    uploadedFiles.splice(idx, 1);
                    if (!uploadedFiles.length) fileAttachInput.value = '';
                    renderFilePreview();
                });
            });
        }

        // --- MEDIA VIEWER (for AI output links) ---
        function handleMediaLinkClick(e) {
            e.preventDefault();
            const link = e.target;
            const mediaType = link.dataset.mediaType;
            const mediaUrl = link.dataset.mediaUrl;
            const displayName = link.textContent;

            mediaArea.innerHTML = '';
            mediaCaption.textContent = `Displaying ${displayName}...`;

            let mediaElement;
            switch (mediaType) {
                case 'image_output':
                    mediaElement = document.createElement('img');
                    mediaElement.src = mediaUrl;
                    mediaElement.alt = displayName;
                    break;
                case 'video_output':
                    mediaElement = document.createElement('video');
                    mediaElement.src = mediaUrl;
                    mediaElement.controls = true;
                    break;
                case 'audio_output':
                    mediaElement = document.createElement('audio');
                    mediaElement.src = mediaUrl;
                    mediaElement.controls = true;
                    break;
                case 'pdf_output':
                    mediaElement = document.createElement('iframe');
                    mediaElement.src = mediaUrl;
                    mediaCaption.textContent = `Opening PDF: ${displayName}`;
                    break;
                case 'link_output':
                    window.open(mediaUrl, '_blank');
                    return; // Don't open media viewer for simple links
                default:
                    mediaCaption.textContent = `Error: Unsupported media type: ${mediaType}`;
                    return;
            }

            mediaArea.appendChild(mediaElement);
            mediaViewer.classList.add('active');
        }

        // --- UTILITY: BLOB TO BASE64 ---
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // --- AI TOOL NEXUS INTEGRATION ---
        const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
        const toolDefinitions = {
            "image": {
                title: "Generate Image",
                description: "Summon stunning visuals from the ether based on your description. Choose a model to fine-tune your cosmic creation.",
                buildForm: () => `
                    <label for="tool-provider">Generation Engine</label>
                    <select id="tool-provider" class="form-control"><option value="thena">Philadelphia (Stylized, Fast)</option><option value="minimax">Seraphina (Creative, Realistic)</option></select>
                    <label for="tool-prompt">Image Prompt</label>
                    <textarea id="tool-prompt" placeholder="A nebula in the shape of a majestic eagle, shimmering cosmic dust" required></textarea>
                    <label for="tool-style">Style (Philadelphia Engine only)</label>
                    <select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
                    <button type="submit" class="modal-action-btn">Manifest Image</button>`,
                handleSubmit: async (form) => {
                    const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                    const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
                    toolStatusMsg.textContent = 'Synthesizing image data...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        const res = await fetch(`${API_BASE_URL}/generate-image`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        toolStatusMsg.textContent = 'Image synthesis complete!';
                        return `Image synthesis complete! [IMAGE_OUTPUT: Generated Image](${data.image_b64})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Image synthesis failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err; // Propagate error for general handling
                    }
                }
            },
            "edit-photo": {
                title: "Edit Photo",
                description: "Upload a photo and articulate the cosmic alterations you wish to imbue.",
                buildForm: () => `
                    <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Transform the background into a galaxy with swirling nebulae" required></textarea>
                    <label for="tool-file">Image to Alter</label><input type="file" id="tool-file" accept="image/*" required>
                    <button type="submit" class="modal-action-btn">Apply Cosmic Edit</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    const prompt = form.querySelector('#tool-prompt').value;
                    if (!file) throw new Error("Please select an image file to channel your alterations.");
                    const fd = new FormData();
                    fd.append('file', file);
                    fd.append('prompt', prompt);
                    toolStatusMsg.textContent = 'Shaping your photo with ethereal energies...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error((await res.json()).error || 'Failed to imbue photo with cosmic edits.');
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob);
                        toolStatusMsg.textContent = 'Photo transfigured successfully!';
                        return `Photo transfigured successfully! [IMAGE_OUTPUT: Edited Photo](${base64String})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Photo transfiguration failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "remove-bg": {
                title: "Remove Background",
                description: "Select an image file to effortlessly sever its background, revealing pure essence.",
                buildForm: () => `
                    <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required>
                    <button type="submit" class="modal-action-btn">Sever Background</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    if (!file) throw new Error("Please select a file to sever its background.");
                    toolStatusMsg.textContent = 'Dissolving background elements...';
                    toolStatusMsg.classList.remove('error');
                    const fd = new FormData();
                    fd.append('file', file);
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob);
                        toolStatusMsg.textContent = 'Background successfully severed!';
                        return `Background successfully severed! [IMAGE_OUTPUT: BG Removed Image](${base64String})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Background severance failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "comic": {
                title: "Create Comic",
                description: "Weave a saga and watch it unfurl into a captivating comic strip. Employ cosmic tags like [DIALOGUE], [INSTRUCTION], and [NARRATION] to guide the epic.",
                buildForm: () => `
                    <label for="tool-story">Cosmic Storyline</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this, traveler?&#10;[NARRATION] Across the void, new realities unfolded..." required></textarea>
                    <label for="tool-style">Art Style</label><select id="tool-style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
                    <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" />
                    <button type="submit" class="modal-action-btn">Forge Comic</button>`,
                handleSubmit: async (form) => {
                    const payload = {
                        story: form.querySelector('#tool-story').value,
                        style: form.querySelector('#tool-style').value,
                        panels: parseInt(form.querySelector('#tool-panels').value, 10),
                        user: currentUser?.displayName || "User"
                    };
                    toolStatusMsg.textContent = 'Illustrating your saga across the cosmic panels...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        toolStatusMsg.textContent = 'Comic saga generation complete!';
                        const imagesLinks = data.images.map((img, idx) => `[IMAGE_OUTPUT: Panel ${idx+1}](${img})`).join('\n');
                        return `Your cosmic comic is complete!\n${imagesLinks}`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Comic saga generation failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "voice-gen": {
                title: "Voice Generation",
                description: "Transmute text into an auditory spectacle. Select a provider and voice style to bring your words to life.",
                buildForm: () => `
                    <label for="tool-provider">Voice Alchemist</label><select id="tool-provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
                    <label for="tool-prompt">Words to Echo</label><textarea id="tool-prompt" placeholder="The celestial spheres hum a silent melody..." required></textarea>
                    <label for="tool-style">Vocal Resonance</label><select id="tool-style"></select>
                    <button type="submit" class="modal-action-btn">Forge Voice</button>`,
                onFormReady: () => {
                    const providerSelect = toolsModal.querySelector('#tool-provider'), styleSelect = toolsModal.querySelector('#tool-style');
                    const voices = {
                        gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                        minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                    };
                    const updateStyles = () => {
                        styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                    };
                    providerSelect.addEventListener('change', updateStyles);
                    updateStyles();
                },
                handleSubmit: async (form) => {
                    const provider = form.querySelector('#tool-provider').value,
                        text = form.querySelector('#tool-prompt').value,
                        style = form.querySelector('#tool-style').value;
                    toolStatusMsg.textContent = 'Attuning vocal frequencies...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        let res;
                        if (provider === 'gemini') {
                            const fd = new FormData();
                            fd.append('text', text);
                            fd.append('style', style);
                            res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                        } else {
                            res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({ text, voice_id: style })
                            });
                        }
                        if (!res.ok) throw new Error(await res.text());
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        toolStatusMsg.textContent = 'Vocal resonance forged!';
                        return `Vocal resonance forged! [AUDIO_OUTPUT: Synthesized Voice](${url})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Voice generation faltered: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "audio-narration": {
                title: "Audio Narration",
                description: "Upload a parchment (PDF, TXT) to receive a podcast-style narrated cosmic summary.",
                buildForm: () => `
                    <label for="tool-file">Select Parchment for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required>
                    <button type="submit" class="modal-action-btn">Recite Narration</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    if (!file) throw new Error("Please select a parchment to recite.");
                    toolStatusMsg.textContent = 'Deciphering and reciting ancient texts...';
                    toolStatusMsg.classList.remove('error');
                    const fd = new FormData();
                    fd.append('file', file);
                    fd.append('style', 'podcast');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        toolStatusMsg.textContent = 'Cosmic narration complete!';
                        return `Cosmic narration complete! [AUDIO_OUTPUT: Document Narration](${url})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Audio narration lost in the void: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "video-text": {
                title: "Generate Video from Text",
                description: "Describe the astral phenomena you wish to visualize. This cosmic fabrication may take a few moments.",
                buildForm: () => `
                    <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A celestial garden, luminous flora blooming under three moons..." required></textarea>
                    <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15">
                    <button type="submit" class="modal-action-btn">Initiate Visualization</button>`,
                handleSubmit: async (form) => {
                    const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
                    toolStatusMsg.textContent = 'Initiating video rendering sequence...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        const startRes = await fetch(`${API_BASE_URL}/api/tools/generate-video-from-text`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const startData = await startRes.json();
                        if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to initiate video task.');
                        toolStatusMsg.textContent = `Video task queued. ID: \`${startData.task_id}\`. Awaiting completion...`;
                        const videoUrl = await pollVideoStatus(startData.task_id);
                        toolStatusMsg.textContent = 'Video rendering complete!';
                        return `Video rendering complete! [VIDEO_OUTPUT: Generated Video](${videoUrl})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Video task initiation failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "video-image": {
                title: "Generate Video from Image",
                description: "Present a starting image and unveil how you wish its cosmic dance to unfold.",
                buildForm: () => `
                    <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the nebulae swirl, with a gentle, slow zoom into a distant galaxy" required></textarea>
                    <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required>
                    <button type="submit" class="modal-action-btn">Begin Cosmic Motion</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#video-image-file').files[0];
                    if (!file) throw new Error("Please select a starting image for cosmic motion.");
                    toolStatusMsg.textContent = 'Initiating video rendering sequence (Image-to-Video)...';
                    toolStatusMsg.classList.remove('error');
                    const fd = new FormData();
                    fd.append('prompt', form.querySelector('#video-image-prompt').value);
                    fd.append('file', file);
                    fd.append('model', "MiniMax-Hailuo-02");
                    fd.append('duration', 6);
                    fd.append('resolution', "1080P");
                    try {
                        const startRes = await fetch(`${API_BASE_URL}/api/tools/generate-video-from-image`, { method: 'POST', body: fd });
                        const startData = await startRes.json();
                        if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to initiate video task.');
                        toolStatusMsg.textContent = `Video task queued. ID: \`${startData.task_id}\`. Awaiting completion...`;
                        const videoUrl = await pollVideoStatus(startData.task_id);
                        toolStatusMsg.textContent = 'Video rendering complete!';
                        return `Video rendering complete! [VIDEO_OUTPUT: Generated Video](${videoUrl})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Video task initiation failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "music": {
                title: "Generate Music",
                description: "Compose melodies from a prompt, lyrical verses, and optional auditory fragments. Powered by Seraphina's harmony engine.",
                buildForm: () => `
                    <label for="music-prompt">Melody Prompt / Description</label><textarea id="music-prompt" placeholder="An ethereal symphony echoing through ancient ruins..." required></textarea>
                    <label for="music-lyrics">Lyrical Verses (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1: Whispers of starlight fade...&#10;Chorus: A cosmic echo rings true..."></textarea>
                    <label for="music-ref">Auditory Fragment (Optional)</label><input type="file" id="music-ref" accept="audio/*">
                    <button type="submit" class="modal-action-btn">Harmonize Melody</button>`,
                handleSubmit: async (form) => {
                    const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
                    const refFile = form.querySelector('#music-ref').files[0];
                    toolStatusMsg.textContent = 'Composing your celestial symphony...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        if (refFile) {
                            toolStatusMsg.textContent = 'Uploading auditory fragment to the harmony engine...';
                            const fd = new FormData();
                            fd.append('file', refFile);
                            const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                            const uploadData = await uploadRes.json();
                            if (!uploadRes.ok) throw new Error(uploadData.error || "Auditory fragment upload failed.");
                            if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                            if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                            toolStatusMsg.textContent = 'Fragment harmonized. Composing music...';
                        }
                        const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (!res.ok) throw new Error((await res.json()).detail || 'Harmony engine failed.');
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        toolStatusMsg.textContent = 'Cosmic harmony complete!';
                        return `Cosmic harmony complete! [AUDIO_OUTPUT: Synthesized Track](${url})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Music harmonization failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "website": {
                title: "Create Website",
                description: "Describe the cosmic portal you envision, and receive a live, fully functional prototype woven from the digital ether.",
                buildForm: () => `
                    <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A dynamic star-mapping portfolio for a celestial cartographer..." required></textarea>
                    <button type="submit" class="modal-action-btn">Weave Website</button>`,
                handleSubmit: async (form) => {
                    const prompt = form.querySelector('#website-prompt').value;
                    toolStatusMsg.textContent = 'Spinning webs of digital light for your cosmic portal...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ prompt, user_id: currentUser.uid })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        toolStatusMsg.textContent = 'Cosmic portal deployed!';
                        return `Your cosmic portal is active! [LINK_OUTPUT: View Website](${data.url})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Website weaving failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "edit-website": {
                title: "Edit Last Website",
                description: "Whisper an instruction to subtly reshape the most recent digital realm you've created.",
                buildForm: () => `
                    <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Adjust the main constellation image to shimmer with a faint purple aura..." required></textarea>
                    <button type="submit" class="modal-action-btn">Reshape Digital Realm</button>`,
                handleSubmit: async (form) => {
                    const instruction = form.querySelector('#edit-instruction').value;
                    toolStatusMsg.textContent = 'Reshaping the digital fabric of your realm...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ instruction, user_id: currentUser.uid })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        toolStatusMsg.textContent = 'Digital realm updated!';
                        return `Digital realm updated! [LINK_OUTPUT: View New Version](${data.url})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Website reshaping failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "my-sites": {
                title: "My Websites",
                description: "Retrieve a manifest of all cosmic portals you have woven.",
                isAction: true,
                runAction: async () => {
                    toolStatusMsg.textContent = 'Scanning the digital constellations for your websites...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || 'Could not locate your cosmic portals.');
                        toolStatusMsg.textContent = 'Manifest retrieved.';
                        if (!data.sites || data.sites.length === 0) return "No cosmic portals currently woven.";
                        const siteList = data.sites.map(site => `- [LINK_OUTPUT: ${site.site_url}](${site.site_url}) (Woven: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                        return `Here are the cosmic portals you've woven:\n${siteList}`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Retrieving cosmic portals failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
            "research-report": {
                title: "Research Report",
                description: "Unravel a comprehensive research report in PDF format on any cosmic topic, distilled from the archives of universal knowledge.",
                buildForm: () => `
                    <label for="research-topic">Cosmic Research Topic</label><input type="text" id="research-topic" placeholder="The theoretical physics of warp drives" required>
                    <button type="submit" class="modal-action-btn">Generate Cosmic Report</button>`,
                handleSubmit: async (form) => {
                    const topic = form.querySelector('#research-topic').value;
                    toolStatusMsg.textContent = 'Diving into the archives of universal knowledge, compiling your report...';
                    toolStatusMsg.classList.remove('error');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ topic })
                        });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        toolStatusMsg.textContent = 'Cosmic research report complete!';
                        return `Cosmic research report on **${topic}** ready! [PDF_OUTPUT: Download Report](${url})`;
                    } catch (err) {
                        toolStatusMsg.textContent = `Error: Cosmic research report generation failed: ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        throw err;
                    }
                }
            },
        };

        async function pollVideoStatus(taskId) {
            return new Promise((resolve, reject) => {
                const pollInterval = setInterval(async () => {
                    try {
                        const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${taskId}`);
                        const statusData = await statusRes.json();

                        if (statusRes.ok && statusData.url) {
                            clearInterval(pollInterval);
                            resolve(statusData.url);
                        } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                            clearInterval(pollInterval);
                            reject(new Error(statusData.error || 'Video generation failed.'));
                        }
                    } catch (pollErr) {
                        clearInterval(pollInterval);
                        reject(new Error('Error checking video status.'));
                    }
                }, 20000); // Poll every 20 seconds
            });
        }


        function handleToolLinkClick(e) {
            e.preventDefault();
            const toolLink = e.target.closest('.tool-link');
            if (!toolLink) return;

            const toolKey = toolLink.dataset.tool;
            const tool = toolDefinitions[toolKey];

            if (!tool) {
                toolStatusMsg.textContent = `Error: Tool '${toolKey}' not found in Nexus.`;
                toolStatusMsg.classList.add('error');
                return;
            }

            if (tool.isAction) {
                toolStatusMsg.textContent = `Initiating tool: ${tool.title}...`;
                toolStatusMsg.classList.remove('error');
                (async () => {
                    try {
                        const result = await tool.runAction();
                        toolsModal.classList.remove('active'); // Close modal once action is done
                        await startTypewriterEffect(result);
                    } catch (err) {
                        toolStatusMsg.textContent = `Error executing tool '${tool.title}': ${err.message}`;
                        toolStatusMsg.classList.add('error');
                        toolsModal.classList.add('active'); // Keep modal open to show error
                    }
                })();
            } else {
                displayToolForm(toolKey, tool.title, tool.description, tool.buildForm(), tool.onFormReady, tool.handleSubmit);
            }
        }

        function displayToolForm(key, title, description, formBuilder, onFormReady, handleSubmit) {
            toolsModalTitle.textContent = title;
            toolListDisplay.style.display = 'none';
            toolForm.style.display = 'block';
            toolFormBackBtn.style.display = 'block';

            toolForm.innerHTML = `
                ${description ? `<p style="color:var(--subtle-text-color); font-size:0.9em; margin-bottom:15px;">${description}</p>` : ''}
                ${formBuilder()}
            `;
            // Re-apply styling to new form elements
            toolForm.querySelectorAll('input, textarea, select').forEach(el => {
                if (!el.classList.contains('form-control')) el.classList.add('form-control');
                el.classList.add('form-group'); // Add class for generic form styling
            });
            toolForm.querySelectorAll('label').forEach(el => el.classList.add('form-group'));

            if (typeof onFormReady === 'function') onFormReady();

            toolForm.onsubmit = async (e) => {
                e.preventDefault();
                const submitButton = toolForm.querySelector('button[type="submit"]');
                const originalButtonContent = submitButton.innerHTML;
                submitButton.innerHTML = `<span class="spinner"></span> PROCESSING...`;
                submitButton.disabled = true;

                toolStatusMsg.textContent = '';
                toolStatusMsg.classList.remove('error');

                try {
                    const result = await handleSubmit(toolForm);
                    toolsModal.classList.remove('active'); // Close modal once form is handled
                    if (result) {
                        await startTypewriterEffect(result);
                    }
                } catch (err) {
                    // Error message already set by handleSubmit
                    toolsModal.classList.add('active'); // Keep modal open to show error
                } finally {
                    submitButton.innerHTML = originalButtonContent;
                    submitButton.disabled = false;
                }
            };
        }


        // --- CALL MODAL FUNCTIONS ---
        let speechRecognition;
        let isCallActive = false;
        let callHistory = []; // Stores text of conversation for AI API
        let botIsSpeaking = false;
        let userSaidSomething = false; // Flag to ensure user actually spoke before processing
        let currentAudio = null;
        let isMuted = false;

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition) {
            speechRecognition = new SpeechRecognition();
            speechRecognition.continuous = true;
            speechRecognition.interimResults = true;
            speechRecognition.lang = 'en-US';

            speechRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                userSaidSomething = true;
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                let userMsgEl = callConversationLog.querySelector('.call-log-entry.user.interim');
                if (!userMsgEl) {
                    userMsgEl = document.createElement('div');
                    userMsgEl.className = 'call-log-entry user interim';
                    callConversationLog.appendChild(userMsgEl);
                }
                userMsgEl.textContent = finalTranscript || interimTranscript;
                callConversationLog.scrollTop = callConversationLog.scrollHeight;

                callStatusMessage.textContent = finalTranscript ? 'USER_TRANSMISSION_FINAL' : 'USER_TRANSMITTING...';
                tapToTalk.style.display = 'none';
            };

            speechRecognition.onspeechend = () => {
                if (!botIsSpeaking) {
                    speechRecognition.stop();
                }
            };

            speechRecognition.onend = () => {
                if (!isCallActive) return;
                if (isMuted) {
                    callStatusMessage.textContent = 'MIC_MUTED.';
                    tapToTalk.style.display = 'none';
                    return;
                }

                let finalTranscript = '';
                const userMsgEl = callConversationLog.querySelector('.call-log-entry.user.interim');
                if (userMsgEl) {
                    finalTranscript = userMsgEl.textContent.trim();
                    userMsgEl.classList.remove('interim');
                }

                if (botIsSpeaking) {
                    if (userMsgEl && finalTranscript === '') { // Clear if no actual speech
                        userMsgEl.remove();
                    }
                } else if (finalTranscript && userSaidSomething) {
                    userSaidSomething = false;
                    callHistory.push({ role: 'user', content: finalTranscript });
                    handleCallBotResponse();
                } else {
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'AWAITING_VOICE_INPUT... (TAP_TO_TRANSMIT)';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
                    }
                }
            };

            speechRecognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                if (event.error === 'no-speech' && isCallActive && !isMuted) {
                    userSaidSomething = false;
                    speechRecognition.stop();
                } else if (event.error === 'network' && isCallActive) {
                    callStatusMessage.textContent = 'NETWORK_ERROR. RECONNECTING...';
                    speechRecognition.stop();
                } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    callStatusMessage.textContent = 'MIC_ACCESS_DENIED. ALLOW_BROWSER_SETTINGS_FOR_COMMS.';
                    endCall();
                }
            };
        } else {
            callToggleBtn.style.display = 'none';
            console.warn("Speech Recognition not supported in this browser. Voice call unavailable.");
        }

        function appendCallLog(text, type = 'ai') {
            const entry = document.createElement('div');
            entry.className = `call-log-entry ${type}`;
            entry.textContent = text;
            callConversationLog.appendChild(entry);
            callConversationLog.scrollTop = callConversationLog.scrollHeight;
        }

        async function handleCallBotResponse() {
            if (!isCallActive) return;
            callStatusMessage.textContent = 'PHI_AI_PROCESSING_INPUT...';
            tapToTalk.style.display = 'none';

            let userMessageContent = '';
            if (callHistory.length > 0) {
                const lastUserMessage = callHistory.slice().reverse().find(m => m.role === 'user');
                if (lastUserMessage) {
                    userMessageContent = lastUserMessage.content;
                }
            }

            const historyForBotAPI = callHistory.map(m => ({ role: m.role, content: m.content }));

            try {
                speechRecognition.stop();

                const res = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: userMessageContent, history: historyForBotAPI.slice(0, -1), user_id: currentUser?.uid || "user" })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || "AI Nexus transmission failed.");

                const botResponseFullText = data.response;
                
                // --- BLUNT BOT RESPONSE LOGIC FOR CALL UI ---
                let botDisplayMessage = botResponseFullText;
                if (botResponseFullText.startsWith('Tool execution:')) {
                    const matchOutput = botResponseFullText.match(/"output":\s*"(.*?)"/);
                    if (matchOutput && matchOutput[1]) {
                        botDisplayMessage = `TOOL_EXEC: ${matchOutput[1].replace(/\\n/g, '. ')}`;
                        if (botDisplayMessage.length > 80) botDisplayMessage = botDisplayMessage.substring(0, 77) + '...';
                    } else {
                        botDisplayMessage = "TOOL_EXECUTION_INITIATED. STANDBY.";
                    }
                } else if (botResponseFullText.includes("Tool use:")) {
                    botDisplayMessage = "QUERYING_AI_PROTOCOLS.";
                } else if (botResponseFullText.includes("generate an image")) {
                    botDisplayMessage = "VISUAL_GEN_AVAILABLE. ACCESS_MAIN_INTERFACE.";
                } else if (botResponseFullText.includes("Download PDF Report")) {
                    botDisplayMessage = "REPORT_GENERATED. DOWNLOAD_VIA_MAIN_INTERFACE.";
                } else if (botResponseFullText.includes("Website deployed successfully!")) {
                    botDisplayMessage = "WEBSITE_DEPLOYED_SUCCESS. LINK_VIA_MAIN_INTERFACE.";
                } else if (botResponseFullText.includes("<img") || botResponseFullText.includes("<audio") || botResponseFullText.includes("<video")) {
                    botDisplayMessage = "MEDIA_CONTENT_GENERATED. VIEW_VIA_MAIN_INTERFACE.";
                } else if (botResponseFullText.length > 120) {
                    botDisplayMessage = botResponseFullText.substring(0, 117) + '...';
                }
                botDisplayMessage = botDisplayMessage.toUpperCase(); // Ensure all caps for terminal feel
                // --- END BLUNT BOT RESPONSE LOGIC ---

                callHistory.push({ role: 'ai', content: botResponseFullText });
                appendCallLog(botDisplayMessage, 'ai');
                speakBotResponse(botResponseFullText);
            } catch (err) {
                const errorMsg = `COMMS_ERROR: ${err.message}`.toUpperCase();
                appendCallLog(errorMsg, 'status');
                if (isCallActive && !isMuted) {
                    callStatusMessage.textContent = 'AWAITING_VOICE_INPUT... (TAP_TO_TRANSMIT)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
                }
            }
        }

        async function speakBotResponse(text) {
            if (!isCallActive) return;
            botIsSpeaking = true;
            botCallAvatar.classList.add('speaking');
            callStatusMessage.textContent = 'PHI_AI_TRANSMITTING_AUDIO...';
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ text: text, voice_id: 'elder' })
                });
                if (!res.ok) throw new Error(await res.text());
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                currentAudio = audio;
                audio.onended = audio.onerror = () => {
                    botIsSpeaking = false;
                    botCallAvatar.classList.remove('speaking');
                    currentAudio = null;
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'AWAITING_VOICE_INPUT... (TAP_TO_TRANSMIT)';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
                    } else if (isMuted) {
                        callStatusMessage.textContent = 'MIC_MUTED.';
                        tapToTalk.style.display = 'none';
                    }
                };
                audio.play();
            } catch (err) {
                console.error("Voice synthesis error:", err);
                botIsSpeaking = false;
                botCallAvatar.classList.remove('speaking');
                if (isCallActive && !isMuted) {
                    callStatusMessage.textContent = 'AWAITING_VOICE_INPUT (VOICE_SYSTEM_OFFLINE)...';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
                } else if (isMuted) {
                    callStatusMessage.textContent = 'MIC_MUTED.';
                    tapToTalk.style.display = 'none';
                }
            }
        }

        function stopBotSpeakingAndStartListening() {
            if (!isCallActive) return;
            if (botIsSpeaking && currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
                botIsSpeaking = false;
                botCallAvatar.classList.remove('speaking');
            }
            
            if (!isMuted) {
                callStatusMessage.textContent = 'AWAITING_VOICE_INPUT... (TAP_TO_TRANSMIT)';
                tapToTalk.style.display = 'block';
                try {
                    speechRecognition.stop();
                    speechRecognition.start();
                } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
            } else {
                callStatusMessage.textContent = 'MIC_MUTED.';
                tapToTalk.style.display = 'none';
            }
            const userMsgEl = callConversationLog.querySelector('.call-log-entry.user.interim');
            if (userMsgEl) userMsgEl.remove();
            userSaidSomething = false;
        }

        function toggleCall() {
            if (isCallActive) {
                endCall();
            } else {
                startCall();
            }
        }

        function startCall() {
            if (!SpeechRecognition) {
                appendCallLog("BROWSER_COMMS_LINK_UNSUPPORTED. VOICE_CALL_DISABLED.", 'status');
                return;
            }
            isCallActive = true;
            isMuted = false;
            muteCallBtn.classList.remove('muted');
            muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> MUTE';
            callModal.classList.add('active');
            callConversationLog.innerHTML = '';
            appendCallLog('ESTABLISHING SECURE CHANNEL...', 'status');
            callStatusMessage.textContent = 'ESTABLISHING SECURE LINK...';
            tapToTalk.style.display = 'none';
            callHistory = [];
            userSaidSomething = false;
            setTimeout(() => {
                if (!isCallActive) return;
                appendCallLog('SECURE_CHANNEL_ESTABLISHED. TRANSMIT_WHEN_READY.', 'status');
                callStatusMessage.textContent = 'AWAITING_VOICE_INPUT... (TAP_TO_TRANSMIT)';
                tapToTalk.style.display = 'block';
                try { speechRecognition.start(); } catch(e) { console.error("Speech recognition start failed", e); callStatusMessage.textContent = '[ERROR]: MIC_INIT_FAIL. CHECK_PERMISSIONS.'; }
            }, 1500);
        }

        function endCall() {
            isCallActive = false;
            botIsSpeaking = false;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            callModal.classList.remove('active');
            try { speechRecognition.stop(); } catch(e) {}
            botCallAvatar.classList.remove('speaking');
            tapToTalk.style.display = 'none';
            callStatusMessage.textContent = 'COMMS_LINK_TERMINATED.';
            // Optionally, add a log entry to main chat
            addMessageToChat('system', 'Secure comms link terminated.');
        }

        function toggleMute() {
            isMuted = !isMuted;
            if (isMuted) {
                muteCallBtn.classList.add('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> UNMUTE';
                speechRecognition.stop();
                callStatusMessage.textContent = 'MIC_MUTED.';
                tapToTalk.style.display = 'none';
            } else {
                muteCallBtn.classList.remove('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> MUTE';
                if (isCallActive && !botIsSpeaking) {
                    callStatusMessage.textContent = 'AWAITING_VOICE_INPUT... (TAP_TO_TRANSMIT)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
                } else if (isCallActive && botIsSpeaking) {
                    callStatusMessage.textContent = 'PHI_AI_TRANSMITTING_AUDIO...';
                    tapToTalk.style.display = 'none';
                }
            }
        }

        // Thruster button particle effect
        $$('.thruster-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const rect = btn.getBoundingClientRect();
                for (let i = 0; i < 5; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particles');
                    particle.style.left = `${e.clientX - rect.left}px`;
                    particle.style.top = `${e.clientY - rect.top}px`;
                    particle.style.setProperty('--x', `${(Math.random() - 0.5) * 80}px`);
                    particle.style.setProperty('--y', `${(Math.random() - 0.5) * 80}px`);
                    btn.appendChild(particle);
                    particle.addEventListener('animationend', () => particle.remove());
                }
            });
        });

        // Input capsule focus particles
        userInput.addEventListener('focus', () => {
            document.querySelector('.capsule-input').style.background = `radial-gradient(circle at center, rgba(0,242,255,0.08), rgba(0,242,255,0.02) 50%, transparent 100%)`;
        });
        userInput.addEventListener('blur', () => {
             document.querySelector('.capsule-input').style.background = `var(--glass-bg-light)`;
        });

        // Add form-group class to dynamically created forms
        $$('label, input, textarea, select').forEach(el => {
            if (!el.classList.contains('form-group') && el.closest('.form-group')) {
                el.classList.add('form-group');
            }
        });

        // Initial render for existing suggestions
        $$('.chip[data-suggestion]').forEach(chip => {
            chip.addEventListener('click', () => sendSuggestion(chip));
        });

        // Ensure current chat starts with basic greeting if no messages
        if (currentMessages.length === 0) {
            chatViewport.innerHTML = `<div class="message-group ai"><div class="msg-bubble"><span class="ai-text">Greetings, traveler. ðŸ¦… The cosmos is aligned. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨</span></div></div>`;
            chatViewport.appendChild(suggestionsDock);
            chatViewport.scrollTop = chatViewport.scrollHeight;
        }

        // Hide suggestions if chat starts filling up, show when empty
        const observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    const messagesCount = chatViewport.querySelectorAll('.message-group:not(.typing-indicator)').length;
                    if (messagesCount > 3) { // Hide after a few messages
                        suggestionsDock.classList.add('hidden');
                    } else {
                        suggestionsDock.classList.remove('hidden');
                    }
                }
            }
        });
        observer.observe(chatViewport, { childList: true });

        // Initial check for suggestions
        if (chatViewport.querySelectorAll('.message-group:not(.typing-indicator)').length > 3) {
            suggestionsDock.classList.add('hidden');
        } else {
            suggestionsDock.classList.remove('hidden');
        }

    </script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
