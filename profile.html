<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Philadelphia AI - Cosmic Interface</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
    <style>
        :root {
            /* Cosmic Plasma Theme (Default) */
            --neon-blue: #00f2ff;
            --neon-purple: #bd00ff;
            --neon-pink: #ff007f; /* For active/alert states */
            --plasma-gradient-btn: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            --plasma-gradient-bubble-ai: linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8));
            --plasma-gradient-bubble-user: linear-gradient(135deg, rgba(0, 242, 255, 0.3), rgba(189, 0, 255, 0.3));
            --glass-bg-strong: rgba(20, 20, 35, 0.7);
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            --text-glow: 0 0 10px rgba(0, 242, 255, 0.7), 0 0 20px rgba(189, 0, 255, 0.5);
            --box-glow-blue: 0 0 15px rgba(0, 242, 255, 0.4), 0 0 30px rgba(0, 242, 255, 0.2);
            --box-glow-purple: 0 0 15px rgba(189, 0, 255, 0.4), 0 0 30px rgba(189, 0, 255, 0.2);
            --header-glass: rgba(10, 10, 25, 0.85);
            --code-bg: rgba(10, 10, 30, 0.9);
            --code-border: var(--neon-blue);
            --code-text: #e0f8ff;
            --main-text: #e0f8ff;
            --link-text: var(--neon-blue);
            --input-bg: var(--glass-bg-light);
            --submit-bg: var(--plasma-gradient-btn);
            --submit-text: #000;
            --submit-hover-bg: linear-gradient(135deg, var(--neon-purple), var(--neon-blue));
            --submit-hover-text: #fff;
            --panel-bg: rgba(10, 10, 30, 0.9);
            --panel-border: var(--neon-blue);
            --panel-shadow: 0 0 40px rgba(0, 242, 255, 0.3);
            --button-glow-active: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple);
            --call-bg: linear-gradient(135deg, rgba(5, 7, 20, 0.95), rgba(10, 0, 30, 0.95));
        }

        /* Base Styles */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            color: var(--main-text);
            font-family: 'Roboto', 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: #050714; /* Fallback */
            position: relative;
        }

        /* --- COSMIC BACKGROUND ENGINE (Wow Feature 1) --- */
        #cosmos-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
            perspective: 1000px; /* For 3D parallax */
            background: linear-gradient(to bottom right, #050714, #1a0a2e); /* Base nebula color */
        }

        .nebula-layer {
            position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background-size: cover;
            animation: drift var(--duration, 60s) infinite linear;
        }

        .nebula-layer:nth-child(1) {
            background: radial-gradient(circle at 50% 50%, rgba(76, 0, 255, 0.15), transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.15), transparent 40%),
                        url('https://i.ibb.co/C5f4p3Z/galaxy-texture.png') no-repeat center center / contain; /* Faint galaxy texture */
            mix-blend-mode: screen;
            animation: drift 60s infinite linear, rotateGalaxy 120s infinite linear;
            transform: translateZ(-200px); /* Further back for parallax */
        }

        .nebula-layer:nth-child(2) {
            background: radial-gradient(circle at 20% 80%, rgba(189, 0, 255, 0.2), transparent 50%),
                        radial-gradient(circle at 60% 30%, rgba(255, 0, 127, 0.15), transparent 45%);
            animation: drift 45s infinite linear reverse;
            mix-blend-mode: overlay;
            transform: translateZ(-100px); /* Closer for parallax */
        }

        .nebula-layer:nth-child(3) { /* Closer, faster layer */
            background: radial-gradient(circle at 40% 40%, rgba(0, 255, 242, 0.1), transparent 60%),
                        radial-gradient(circle at 70% 70%, rgba(189, 0, 255, 0.1), transparent 55%);
            animation: drift 30s infinite linear;
            mix-blend-mode: screen;
            transform: translateZ(-50px);
        }

        @keyframes drift {
            0% { transform: translate(0, 0) translateZ(var(--z-pos, 0)); }
            100% { transform: translate(-50%, -50%) translateZ(var(--z-pos, 0)); }
        }
        @keyframes rotateGalaxy {
            0% { background-position: center center; }
            100% { background-position: calc(center + 20%) calc(center + 20%); } /* Subtle rotation */
        }

        .star, .shooting-star, .stardust {
            position: absolute;
            pointer-events: none;
            opacity: 0; /* Managed by JS for staggered appearance */
            will-change: transform, opacity;
        }

        .star {
            background: white; border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out;
            box-shadow: 0 0 5px #fff;
        }

        .stardust {
            background: var(--neon-blue); border-radius: 50%;
            width: 1px; height: 1px;
            opacity: 0.5;
            animation: floatUp var(--duration) infinite linear;
        }

        @keyframes twinkle { 0%, 100% { opacity: 0.3; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1.1); box-shadow: 0 0 8px #fff, 0 0 15px var(--neon-blue); } }
        @keyframes floatUp { to { transform: translateY(-100vh); opacity: 0; } }

        .shooting-star {
            height: 2px;
            background: linear-gradient(-90deg, white, transparent);
            filter: drop-shadow(0 0 6px var(--neon-blue));
            animation: shoot var(--duration) ease-out forwards;
            opacity: 0; z-index: 0;
            will-change: transform, opacity, width;
        }
        @keyframes shoot {
            0% { transform: translate(var(--startX), var(--startY)) rotate(-35deg); opacity: 1; width: 0; }
            20% { width: var(--length, 100px); }
            100% { transform: translate(calc(var(--startX) - var(--distX, 600px)), calc(var(--startY) + var(--distY, 400px))) rotate(-35deg); opacity: 0; width: 0; }
        }

        /* --- UI MAIN STRUCTURE --- */
        .ui-container {
            width: 100%; max-width: 600px;
            height: 100%; display: flex; flex-direction: column;
            position: relative; z-index: 10;
            background: rgba(5, 7, 20, 0.3); /* Subtle darkening for readability */
            margin: 0 auto;
            border-radius: 0 0 25px 25px;
            overflow: hidden;
        }
        @media (max-width: 600px) {
            .ui-container {
                max-width: 100%;
                border-radius: 0;
            }
        }

        /* Header */
        .header-bar {
            padding: 20px 25px;
            display: flex; justify-content: space-between; align-items: center;
            background: var(--header-glass);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            user-select: none;
        }

        .brand-plasma { /* Wow Feature 2 */
            font-family: 'Orbitron', sans-serif;
            font-size: 1.4rem; font-weight: 800; letter-spacing: 1px;
            background: linear-gradient(90deg, #fff, var(--neon-blue), var(--neon-purple), #fff);
            background-size: 300% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: plasmaFlow 5s linear infinite;
            text-shadow: var(--text-glow);
            margin-right: 8px; /* Offset for menu buttons */
            flex-grow: 1;
            text-align: center;
        }
        @keyframes plasmaFlow { to { background-position: 300% center; } }

        .header-actions { display: flex; gap: 15px; font-size: 1.4rem; }
        .icon-btn {
            background: none;
            border: none;
            color: var(--neon-blue);
            font-size: 1.3em;
            cursor: pointer;
            border-radius: 10px;
            padding: 7px 10px;
            opacity: 0.8;
            transition: 0.3s;
            position: relative;
        }
        .icon-btn:hover {
            opacity: 1;
            text-shadow: var(--text-glow);
            background: rgba(0, 242, 255, 0.1);
            transform: scale(1.05);
        }
        .icon-btn:active { transform: scale(0.95); }

        /* Dynamic AI Icon (Wow Feature 3) */
        .ai-icon-animated {
            animation: aiPulse 2s infinite ease-in-out;
        }
        .ai-icon-animated.active { /* For when AI is thinking/speaking */
            animation: aiThinking 1.5s infinite alternate;
        }
        @keyframes aiPulse {
            0%, 100% { text-shadow: var(--text-glow); transform: scale(1); }
            50% { text-shadow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple); transform: scale(1.07); }
        }
        @keyframes aiThinking {
            0% { text-shadow: 0 0 10px var(--neon-blue); transform: scale(1); }
            100% { text-shadow: 0 0 20px var(--neon-purple), 0 0 35px var(--neon-blue); transform: scale(1.1); }
        }

        /* Chat Area */
        #chatBox { /* Renamed from chat-viewport to match functionality */
            flex: 1; overflow-y: auto; padding: 20px 15px; display: flex; flex-direction: column; gap: 20px;
            scroll-behavior: smooth;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        #chatBox::-webkit-scrollbar { display: none; } /* Chrome, Safari, Opera */

        .chat-message { display: flex; flex-direction: column; gap: 8px; max-width: 85%; position: relative; }
        .chat-message.ai { align-self: flex-start; }
        .chat-message.user { align-self: flex-end; align-items: flex-end; }

        .msg {
            padding: 16px 22px; border-radius: 24px;
            font-size: 1rem; line-height: 1.5;
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            word-break: break-word;
            white-space: pre-wrap; /* Preserve whitespace and breaks */
            overflow-x: auto;
        }
        @keyframes popIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }

        .ai .msg {
            background: var(--plasma-gradient-bubble-ai);
            border-bottom-left-radius: 4px;
            box-shadow: inset 0 0 20px rgba(0, 242, 255, 0.05);
        }

        .user .msg {
            background: var(--plasma-gradient-bubble-user);
            border-bottom-right-radius: 4px;
            color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            box-shadow: var(--box-glow-blue);
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* Responsive chat bubbles */
        @media (max-width:790px) {
            .chat-box {
                max-width:100vw;
                padding: 15px 4px;
            }
            #typing-status {
                padding: 0 4px 10px 4px;
            }
            .chat-message .msg {
                font-size: .97em;
                padding:9px 4vw 10px 5vw;
                max-width:80vw;
            }
            .chat-message.user .msg {
                max-width: 83vw;
            }
        }

        /* Typing Indicator */
        #typing-status {
            display: none; /* Controlled by JS */
            max-width: 600px; /* Aligned with ui-container */
            margin: 0 auto;
            padding: 0 15px 10px 15px; /* Adjust padding */
            width: 100%;
            box-sizing: border-box;
            flex-shrink: 0;
            min-height: 20px;
            align-self: flex-start; /* AI always starts at left */
        }
        #typing-status .msg {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8));
            border-bottom-left-radius: 4px;
            box-shadow: inset 0 0 20px rgba(0, 242, 255, 0.05);
            max-width: fit-content;
            display: flex;
            align-items: center;
        }
        .dot-anim { /* Typing animation dots */
            display:inline-block;
            width: 8px;
            height: 8px;
            margin:0 3px;
            background: var(--neon-blue);
            border-radius: 50%;
            opacity: 0.85;
            animation: typing-blink 1.4s infinite both;
            box-shadow: 0 0 6px var(--neon-blue);
        }
        .dot-anim:nth-child(2){animation-delay:.3s;}
        .dot-anim:nth-child(3){animation-delay:.6s;}

        @keyframes typing-blink {
            0%,100% {opacity:.25; transform: scale(0.8);}
            25% {opacity:.95; transform: scale(1.1);}
            50% {opacity:1; transform: scale(1.2);}
            75% {opacity:.65; transform: scale(1);}
        }
        .spinner { /* General loading spinner */
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 247, 0.3);
            border-radius: 50%;
            border-top-color: var(--neon-blue);
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Code Blocks (Wow Feature 4 styling) */
        pre, code {
            font-family: 'JetBrains Mono','Fira Mono','Menlo',monospace;
            font-size: .99em;
            background: var(--code-bg);
            border-radius: 11px;
            border: 1.7px solid var(--code-border);
            color: var(--code-text);
            box-shadow: 0 0 19px rgba(0, 234, 255, 0.2), 0 0 48px rgba(11, 234, 255, 0.15) inset;
            transition: background 0.3s, border-color 0.3s, color 0.3s;
        }

        pre {
            overflow-x: auto;
            padding: 1.18em 1.3em 1.16em 1.13em;
            margin: 1.15em 0 1em 0;
            position: relative;
        }

        pre:before {
            content: "CODE";
            color: var(--neon-blue);
            font-size: 0.82em;
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 5px;
            right: 29px;
            opacity: 0.17;
            letter-spacing: 0.13em;
            pointer-events: none;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 13px;
            z-index: 3;
            border-radius: 8px;
            border: none;
            padding: 3px 15px;
            background: linear-gradient(95deg, var(--neon-blue) 40%, #0980ff 120%);
            color: #06182f;
            font-size: .98em;
            font-family: 'Inter';
            font-weight: bold;
            box-shadow: 0 2px 9px rgba(24, 227, 255, 0.7), 0 0 7px rgba(0, 255, 215, 0.6);
            transition: background .15s, color .15s;
            cursor: pointer;
            outline: none;
            border: 1px solid rgba(12, 243, 255, 0.2);
        }
        .copy-btn:hover {
            background: #008cee;
            color: #fff;
        }

        /* Inline message controls */
        .inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn {
            padding:8px 12px;
            border-radius:10px;
            border:none;
            background: var(--submit-bg);
            color: var(--submit-text);
            font-family:'Inter',Arial,sans-serif;
            font-size:.96em;
            font-weight:600;
            display:inline-flex;
            align-items:center;
            gap:6px;
            margin-top:6px;
            margin-right: 3px;
            cursor:pointer;
            box-shadow:0 2px 7px rgba(23, 246, 254, 0.3);
            transition:background .14s,color .13s, transform .1s;
        }
        .inline-copy-btn:hover, .inline-share-btn:hover, .regen-btn:hover, .inline-edit-btn:hover{
            background:var(--submit-hover-bg);
            color:var(--submit-hover-text);
            transform: translateY(-1px);
        }

        /* File previews in chat */
        .file-attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 8px 0;
            max-width: 100%;
        }
        .chat-media-preview {
            max-width: 100%;
            max-height: 250px;
            border-radius: 12px;
            display: block;
        }
        .image-preview-thumb, .video-preview-thumb {
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
        }
        .chat-message.ai .msg img.chat-media-preview {
            cursor: zoom-in;
        }
        .audio-preview-thumb {
            width: 90%;
            min-height: 40px;
            border-radius: 10px;
        }
        .file-link, .file-placeholder {
            display: inline-block;
            padding: 8px 12px;
            background: rgba(11, 36, 71, 0.6);
            border: 1px solid rgba(26, 248, 255, 0.3);
            border-radius: 10px;
            color: var(--neon-blue);
            text-decoration: none;
            font-size: 0.9em;
            font-weight: bold;
        }
        .file-link i, .file-placeholder i {
            margin-right: 5px;
        }

        /* File preview during upload */
        .file-preview{
            display:none; /* Controlled by JS */
            background:rgba(15,36,65,0.98);
            border-radius:12px;
            color:#c4f2ff;
            font-size:.98em;
            box-shadow:0 3px 15px rgba(0, 170, 192, 0.73);
            margin:0 auto 10px auto;
            width:94vw;
            max-width:520px;
            padding:10px 14px 10px 15px;
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            border: 1.5px solid rgba(0, 255, 255, 0.27);
        }

        .file-preview img, .file-preview video {
            max-width:58px;
            max-height:41px;
            border-radius:6px;
            margin-right:6px;
            vertical-align: middle;
        }
        .file-preview audio {
            width:52px;
            margin-right:7px;
        }
        .remove-file-btn {
            color: #fff !important;
            background:#d23 !important;
            border:none !important;
            border-radius:50% !important;
            padding:2px 6px !important;
            cursor:pointer !important;
            font-size:1.2em !important;
            font-weight:bold !important;
            margin-left:8px !important;
            transition: background .16s, color .16s !important;
            min-width: 24px !important;
            height: 24px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        .remove-file-btn:hover {
            background:#ff4444 !important;
            color:#fff !important;
            transform: scale(1.1) !important;
        }

        /* Input Dock */
        .input-dock {
            padding: 15px 25px;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(25px);
            border-top: 1px solid var(--glass-border);
            display: flex; gap: 15px; align-items: stretch; /* stretch to fill height */
            box-shadow: 0 -5px 20px rgba(0,0,0,0.2);
        }

        .capsule-input {
            flex: 1; position: relative;
            min-height: 55px; /* Minimum height for textarea */
            max-height: 120px; /* Max height for textarea before scroll */
            background: var(--glass-bg-light);
            border-radius: 30px; border: 1px solid var(--glass-border);
            transition: 0.3s; display: flex; align-items: center;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
            overflow: hidden; /* For glow effect */
        }
        .capsule-input::before { /* Input glow (Wow Feature 2) */
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 30px;
            pointer-events: none;
            box-shadow: inset 0 0 0px var(--neon-blue);
            transition: box-shadow 0.3s ease;
        }
        .capsule-input:focus-within {
            border-color: var(--neon-blue);
            box-shadow: var(--box-glow-blue), inset 0 2px 10px rgba(0,0,0,0.2);
            background: rgba(0, 242, 255, 0.05);
        }
        .capsule-input:focus-within::before {
            box-shadow: inset 0 0 10px var(--neon-blue), inset 0 0 20px var(--neon-purple); /* Energy flow glow */
        }

        .capsule-input textarea { /* Changed from input to textarea */
            width: 100%; height: 100%; background: transparent; border: none;
            padding: 15px 25px; color: #fff; font-size: 1.05rem; outline: none;
            resize: none; /* Disable manual resize */
            min-height: 55px;
            max-height: 120px;
            overflow-y: auto;
            line-height: 1.5;
        }
        .capsule-input textarea::-webkit-scrollbar { display: none; } /* Hide scrollbar */
        .capsule-input textarea { scrollbar-width: none; -ms-overflow-style: none; }

        .thruster-btn { /* Style for action buttons in input dock */
            width: 55px; height: 55px; border-radius: 50%; border: none; cursor: pointer;
            background: var(--plasma-gradient-btn);
            display: flex; align-items: center; justify-content: center;
            box-shadow: var(--box-glow-purple); transition: 0.3s;
            color: #000;
            font-size: 1.2em; /* For icons */
        }
        .thruster-btn:hover { transform: scale(1.05) rotate(-10deg); box-shadow: 0 0 30px rgba(189, 0, 255, 0.6); }

        /* Holo Shimmer Effect (Wow Feature 2) */
        .holo-shimmer {
            position: relative; overflow: hidden;
        }
        .holo-shimmer::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(
                120deg, transparent, rgba(255, 255, 255, 0.4), transparent
            );
            transform: skewX(-25deg);
            animation: holoSheen 3s infinite linear;
            pointer-events: none; /* Allow clicks on element below */
        }
        @keyframes holoSheen { 0% { left: -100%; } 50%, 100% { left: 200%; } }

        /* Stop button (replaces send button) */
        #stopBtn {
            background: #ff4d4d;
            color: white;
            font-size: 1.2em;
            border-radius: 50%; /* Match thruster-btn style */
            padding: 0;
            min-width: 55px; /* Match thruster-btn width */
            height: 55px; /* Match thruster-btn height */
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px #ff4d4d88;
            transition: background .1s, color .1s;
        }
        #stopBtn:hover {
            background: #ff7777;
        }

        /* General Panel Styles (for profile, links, tools) */
        .panel-bg {
            display:none; /* Controlled by JS */
            position:fixed;
            top:0;
            left:0;
            width:100vw;
            height:100vh;
            background:rgba(13,20,52,0.86);
            backdrop-filter: blur(8px);
            z-index:1200;
        }
        .panel-bg.active{
            display:block;
        }

        .side-panel{
            position:fixed; /* Changed to fixed for better responsiveness */
            top:0;
            left:-350px; /* Hidden by default (for left panels) */
            height:100vh;
            width:325px;
            background: var(--panel-bg);
            border-right:2.5px solid var(--panel-border);
            box-shadow: var(--panel-shadow);
            z-index:1212;
            padding:18px 16px 20px 15px;
            overflow-y:auto;
            border-radius:0 24px 32px 0;
            transition: left 0.3s ease-out, right 0.3s ease-out, background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        /* Active state for left panels */
        .side-panel.active {
            left:0;
        }
        /* Right-aligned panels */
        #linkMenu {
            left: auto; /* Override default left */
            right: -350px; /* Hidden by default */
            border-right: none;
            border-left: 2.5px solid var(--panel-border);
            border-radius: 24px 0 0 32px;
        }
        #linkMenu.active { /* Active state for right panels */
            right: 0;
        }

        @media (max-width: 400px) {
            .side-panel {
                width: 90vw; /* Adjust for smaller screens */
            }
        }

        .side-panel .panel-header{
            text-align:center;
            margin:18px 0 13px 0;
        }

        .side-panel img{
            width:56px;
            height:56px;
            border-radius:53%;
            margin-bottom:8px;
            border:2px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .side-panel .username{
            font-weight:700;
            font-size:1.11em;
            color:var(--neon-blue);
            font-family:'Orbitron',sans-serif;
            text-shadow:var(--text-glow);
        }

        .side-panel .email{
            font-size:.97em;
            color:#a8eaff;
        }

        .panel-links a{
            color: var(--link-text);
            text-decoration:none;
            font-weight:500;
            font-size:1.08em;
            padding:8px 4px;
            display:flex;
            align-items:center;
            gap:12px;
            border-radius:9px;
            transition:background .14s, color .14s;
        }
        .panel-links a:hover{
            background:rgba(0, 234, 255, 0.2);
            color:#f4fdff;
        }
        .panel-links a i {
            width: 20px;
            text-align: center;
        }

        #chatsList button{
            background:none;
            border:none;
            cursor:pointer;
            outline:none;
            font-size:1.11em;
            margin:0 5px;
            vertical-align:middle;
            border-radius:7px;
            padding:3px 5px;
        }
        #chatsList .fa-pen{
            color:var(--neon-blue);
            transition:color .13s;
        }
        #chatsList .fa-pen:hover{
            color:#ffd800;
        }
        #chatsList .fa-trash{
            color:#ff244e;
            transition:color .10s;
        }
        #chatsList .fa-trash:hover{
            color:#fff900;
        }
        #chatsList .fa-play{
            color:#04ea70;
            font-size:1.2em;
        }
        #chatsList .fa-play:hover{
            color:#31adff;
        }

        .edit-form label{
            display:block;
            margin-top:10px;
            font-size:.99em;
            color:var(--neon-blue);
            text-shadow:0 1px 14px rgba(17, 170, 255, 0.44);
        }

        .edit-form input, .edit-form textarea, .edit-form select{
            width:99%;
            padding:7px 11px;
            margin-top:5px;
            border:1.7px solid rgba(19, 240, 255, 0.58);
            border-radius:9px;
            background:rgba(7, 31, 53, 0.6);
            color:#fff;
            font-size:1.02em;
            box-shadow:0 0 8px rgba(4, 246, 253, 0.5);
            transition:border-color .17s,box-shadow .17s;
        }
        .edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus{
            border-color:var(--neon-blue);
            background:rgba(39, 63, 93, 0.8);
            color:#fff;
        }
        .edit-form textarea {
            resize:vertical;
            min-height: 80px;
        }

        .submit-btn{
            margin-top:14px;
            padding:10px 20px;
            background: var(--submit-bg);
            border:none;
            border-radius:10px;
            color: var(--submit-text);
            font-weight:bold;
            cursor:pointer;
            font-size:1.11em;
            box-shadow:0 2px 13px rgba(0, 255, 242, 0.57);
            transition:background .14s,color .13s;
        }
        .submit-btn:hover{
            background: var(--submit-hover-bg);
            color: var(--submit-hover-text);
        }

        /* AI Image Preview */
        #ai-image-preview {
            display:none; /* Controlled by JS */
            position:fixed;
            z-index:1210;
            right:22px;
            bottom:100px;
            max-width:320px;
            background:rgba(25, 26, 38, 0.9);
            padding:12px;
            border-radius:17px;
            box-shadow:0 2px 19px rgba(0, 255, 242, 0.72);
        }
        #ai-image-preview #ai-image-close {
            float:right;background:rgba(35, 35, 58, 0.8);border:none;border-radius:7px;color:var(--neon-blue);font-size:1.5em;cursor:pointer;margin-left:5px;
        }
        #ai-image-preview #ai-image-container img {
            max-width:210px;max-height:210px;border-radius:12px;display:block;
        }
        #ai-image-preview #ai-image-dl {
            margin-top:9px;padding:7px 20px;background:linear-gradient(90deg,var(--neon-blue),#0090ff);color:#222;border:none;border-radius:8px;box-shadow:0 2px 7px rgba(0, 255, 242, 0.78);cursor:pointer;font-weight:bold;
        }

        /* Lightbox for large images */
        #lightbox {
            display: none; /* Controlled by JS */
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(5px);
            z-index: 5000;
            justify-content: center;
            align-items: center;
        }
        #lightbox.active {
            display: flex;
        }
        #lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            box-shadow: 0 0 50px var(--neon-blue);
        }

        /* Call Modal (Improved UI) */
        #callModal {
            display: none; /* Controlled by JS */
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--call-bg); /* Darker, more immersive */
            backdrop-filter: blur(15px);
            z-index: 4000;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            color: var(--main-text);
            animation: fadeIn 0.3s ease-out;
        }
        #callModal.active {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; } to { opacity: 1; }
        }

        #callHeader {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em;
            text-shadow: var(--text-glow);
            margin-bottom: 25px;
            color: var(--neon-blue);
        }

        #botImageContainer {
            margin-top: 20px;
            position: relative;
            cursor: pointer; /* Tap to talk */
        }
        #botImageContainer img {
            width: 160px;
            height: 160px;
            border-radius: 50%;
            border: 5px solid var(--neon-blue);
            box-shadow: 0 0 35px var(--neon-blue);
            transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        @keyframes head-nod { /* Bot animation when speaking */
            0% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
            100% { transform: translateY(0); }
        }
        @keyframes speaking-glow { /* Audio Visualizer for Bot (Wow Feature 5) */
            0% { box-shadow: 0 0 15px var(--neon-blue); }
            50% { box-shadow: 0 0 35px var(--neon-purple), 0 0 55px var(--neon-blue); }
            100% { box-shadow: 0 0 15px var(--neon-blue); }
        }
        #botImageContainer.speaking img {
            border-color: var(--neon-pink);
            box-shadow: 0 0 35px var(--neon-pink);
            transform: scale(1.07);
            animation: head-nod 1.2s infinite ease-in-out;
        }
        #botImageContainer.speaking #botSpeakingIndicator {
            box-shadow: 0 0 35px var(--neon-pink);
            border-color: var(--neon-pink);
            animation: speaking-glow 1.7s infinite ease-in-out;
        }

        #botSpeakingIndicator {
            position: absolute;
            top: -8px;
            left: -8px;
            width: 176px;
            height: 176px;
            border-radius: 50%;
            border: 5px solid transparent;
            box-shadow: 0 0 20px var(--neon-blue);
            animation: pulse 1s infinite;
            display: none; /* Controlled by JS */
            z-index: -1;
        }
        #botImageContainer.speaking #botSpeakingIndicator {
            display: block;
        }

        #callStatusMessage {
            color: var(--neon-blue);
            font-size: 1.2em;
            margin-top: 20px;
            height: 30px;
            text-align: center;
            font-style: italic;
            text-shadow: 0 0 8px var(--neon-blue);
        }

        #tapToTalk {
            color: var(--neon-pink);
            font-size: 1.3em;
            margin-top: 10px;
            text-shadow: 0 0 10px var(--neon-pink);
            animation: neon-pulse 1.5s infinite alternate;
            display: none; /* Controlled by JS */
        }
        @keyframes neon-pulse {
            from { opacity: 0.7; transform: scale(1.0); }
            to { opacity: 1.0; transform: scale(1.02); }
        }

        @keyframes pulse {
            0% { opacity: 0; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0; transform: scale(1); }
        }

        #callConversation {
            flex-grow: 1;
            width: 95%;
            max-width: 550px;
            overflow-y: auto;
            margin: 20px 0;
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.1);
        }
        #callConversation::-webkit-scrollbar { display: none; }
        #callConversation { scrollbar-width: none; -ms-overflow-style: none; }

        .call-msg {
            padding: 10px 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            line-height: 1.5;
            word-break: break-word;
            animation: popIn 0.3s ease-out;
        }
        .call-msg.user {
            background: linear-gradient(90deg, var(--neon-blue) 0%, rgba(189, 0, 255, 0.7) 100%);
            color: #fff;
            text-align: right;
            margin-left: auto;
            max-width: 80%;
            border-bottom-right-radius: 4px;
        }
        .call-msg.bot {
            background: linear-gradient(90deg, rgba(30, 30, 60, 0.6) 0%, rgba(20, 20, 35, 0.8) 100%);
            color: var(--main-text);
            margin-right: auto;
            max-width: 80%;
            border-bottom-left-radius: 4px;
        }
        .call-msg.status {
            text-align: center;
            color: #888;
            font-style: italic;
            background: none;
            text-shadow: none;
        }
        /* Audio Visualizer for User (Wow Feature 5) */
        #userAudioVisualizer {
            position: absolute;
            bottom: 20px;
            width: 80%;
            max-width: 400px;
            height: 30px;
            background: rgba(0, 242, 255, 0.1);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0; /* Controlled by JS */
            transition: opacity 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
            pointer-events: none;
            z-index: 1; /* Above other elements in call modal */
        }
        #userAudioVisualizer.active {
            opacity: 1;
        }
        .audio-bar {
            width: 3px;
            height: 10px;
            background: var(--neon-blue);
            margin: 0 2px;
            border-radius: 2px;
            animation: visualize 0.8s infinite ease-in-out alternate;
            box-shadow: 0 0 5px var(--neon-blue);
        }
        .audio-bar:nth-child(2) { animation-delay: 0.1s; transform: scaleY(1.2); }
        .audio-bar:nth-child(3) { animation-delay: 0.2s; transform: scaleY(0.8); }
        .audio-bar:nth-child(4) { animation-delay: 0.3s; transform: scaleY(1.3); }
        .audio-bar:nth-child(5) { animation-delay: 0.4s; transform: scaleY(0.7); }
        .audio-bar:nth-child(6) { animation-delay: 0.5s; transform: scaleY(1.1); }
        .audio-bar:nth-child(7) { animation-delay: 0.6s; transform: scaleY(0.9); }
        @keyframes visualize {
            from { transform: scaleY(0.5); opacity: 0.7; }
            to { transform: scaleY(1.5); opacity: 1; }
        }

        #callControls {
            display: flex;
            gap: 20px;
            padding-bottom: 20px;
            margin-top: auto;
        }
        #endCallBtn, #muteCallBtn {
            font-size: 1.2em;
            padding: 12px 25px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 0 10px #d2388;
            transition: background .1s, box-shadow .1s;
            font-weight: 600;
        }
        #endCallBtn {
            background: #d23;
            color: white;
            box-shadow: 0 0 15px rgba(255, 77, 77, 0.5);
        }
        #endCallBtn:hover {
            background: #ff7777;
            box-shadow: 0 0 20px rgba(255, 119, 119, 0.7);
        }
        #muteCallBtn {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.5);
        }
        #muteCallBtn.muted {
            background: #555;
            color: #ccc;
            box-shadow: none;
        }
        #muteCallBtn.muted:hover {
            background: #777;
        }
        #muteCallBtn:hover {
            background: var(--neon-purple);
            color: #fff;
            box-shadow: 0 0 20px rgba(189, 0, 255, 0.7);
        }

    </style>
</head>
<body>
    <div id="cosmos-container">
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
    </div>

    <div class="ui-container" id="mainUiContainer">
        <header class="header-bar">
            <button class="icon-btn" id="openProfileMenu" aria-label="Open profile menu"><i class="fa-solid fa-user ai-icon-animated" id="headerAiIcon"></i></button>
            <div class="brand-plasma">Philadelphia AI</div>
            <div class="header-actions">
                <button class="icon-btn" id="themeBtn" aria-label="Change theme"><i class="fa-solid fa-star-and-moon"></i></button>
                <button class="icon-btn" id="openLinksMenu" aria-label="Open links menu"><i class="fa-solid fa-link"></i></button>
            </div>
        </header>

        <div class="chat-box" id="chatBox">
            <!-- Initial AI greeting. All other messages dynamically added by functionality.js -->
            <div class="chat-message ai">
                <div class="msg">
                    Greetings, traveler. ðŸ¦… The cosmos is aligned. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨
                </div>
            </div>
            <!-- Suggestions will be added here by functionality.js if needed -->
        </div>

        <div id="typing-status" class="chat-message ai" style="display: none;"></div>

        <form class="input-dock" id="chatForm" autocomplete="off">
            <button type="button" class="thruster-btn" id="emojiBtn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>
            <label for="chatFile" class="thruster-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label>
            <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
            <div class="capsule-input">
                <textarea id="chatInput" placeholder="Broadcast your message..." rows="1"></textarea>
            </div>
            <button type="button" class="thruster-btn" id="callBtn" title="Start Voice Call"><i class="fa-solid fa-phone"></i></button>
            <button type="button" class="thruster-btn" id="toolBtn" title="Philadelphia Tools" aria-controls="toolMenu" aria-expanded="false"><i class="fa-solid fa-wrench"></i></button>
            <button type="submit" class="thruster-btn holo-shimmer" id="sendBtn" title="Send">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
        </form>
    </div>

    <!-- Modals and Panels (Hidden by default, controlled by JS) -->
    <div id="emojiPanel"></div>
    <div class="status-message" id="statusMsg"></div>
    <div id="filePreview" class="file-preview"></div>

    <div class="panel-bg" id="profileMenuBg">
        <nav class="side-panel" id="profileMenu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:1.17em;font-weight:700;color:var(--neon-blue);margin:18px 0 0 13px;">Chats</span>
                <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;" onclick="profileMenuBg.classList.remove('active'); profileMenu.classList.remove('active');">&times;</button>
            </div>
            <div id="chatsList" style="margin:7px 0 8px 6px;max-height:161px;overflow-y:auto;">
                <div class="spinner" style="margin: 20px auto; display: block;"></div> <!-- Placeholder, real content loaded by JS -->
            </div>
            <button id="newChatBtn" class="submit-btn" style="margin:0 0 12px 11px;"><i class="fa-solid fa-plus"></i> New Chat</button>
            <hr style="width:91%;margin:11px 0 7px 3%;border:1px solid rgba(0, 255, 240, 0.19);">
            <div class="panel-header">
                <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profileMenuUser">User</div>
                <div class="email" id="profileMenuEmail">email@example.com</div>
            </div>
            <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;">
                <label for="edit-name">Name</label>
                <input type="text" id="edit-name" required>
                <label for="edit-photo">Photo URL</label>
                <input type="url" id="edit-photo" placeholder="Paste image link">
                <span style="font-size:0.83em;color:#aae;display:block;margin:5px 0 7px 2px;"> Tip: <a href="https://postimg.cc/" target="_blank" style="color:var(--link-text);">Upload at postimg.cc</a> </span>
                <button type="submit" class="submit-btn">Save</button>
                <div class="status-message" id="profileStatusMsg"></div>
            </form>
            <button class="submit-btn" id="logoutBtn" style="background:rgba(16, 33, 59, 0.8);color:var(--neon-blue);margin:7px 7px 17px 7px;">Logout</button>
        </nav>
    </div>

    <div id="ai-image-preview"></div>

    <div class="panel-bg" id="linkMenuBg">
        <nav class="side-panel" id="linkMenu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 0 0 13px;cursor:pointer;border-radius:7px;" onclick="linkMenuBg.classList.remove('active'); linkMenu.classList.remove('active');">&times;</button>
                <span style="font-size:1.17em;font-weight:700;color:var(--neon-blue);margin:18px 13px 0 0;">Links</span>
            </div>
            <div class="panel-header">
                <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia logo">
                <div class="username">Philadelphia AI</div>
            </div>
            <div class="panel-links">
                <a href="philadelphia.html"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a>
                <a href="index.html"><i class="fa-solid fa-home"></i>Elvion Homepage</a>
                <a href="about.html"><i class="fa-solid fa-circle-info"></i> About US</a>
                <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
                <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms</a>
                <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Try Telegram Version</a>
            </div>
            <button class="submit-btn" style="margin-top:17px; width: 100%;" onclick="linkMenuBg.classList.remove('active'); linkMenu.classList.remove('active');">Close</button>
        </nav>
    </div>

    <div class="panel-bg" id="toolsMenuBg">
        <nav class="side-panel" id="toolsMenu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:1.17em;font-weight:700;color:var(--neon-blue);margin:18px 0 0 13px;">AI Tools</span>
                <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;" onclick="toolsMenuBg.classList.remove('active'); toolsMenu.classList.remove('active');">&times;</button>
            </div>
            <div class="panel-links" style="margin-top: 10px;">
                <h3 style="color:var(--neon-blue);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Creative Suite</h3>
                <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
                <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
                <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a>
                <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a>
                <hr style="border-color: rgba(0, 234, 255, 0.19); margin: 10px 0;">
                <h3 style="color:var(--neon-blue);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Audio & Video</h3>
                <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
                <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
                <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a>
                <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
                <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a>
                <hr style="border-color: rgba(0, 234, 255, 0.19); margin: 10px 0;">
                <h3 style="color:var(--neon-blue);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Web & Research</h3>
                <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a>
                <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
                <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a>
                <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
            </div>
            <button class="submit-btn" style="margin-top:17px; width: 100%;" onclick="toolsMenuBg.classList.remove('active'); toolsMenu.classList.remove('active');">Close</button>
        </nav>
    </div>

    <div class="panel-bg" id="toolFormModalBg">
        <nav class="side-panel" id="toolFormModal">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <h2 class="username" id="toolFormTitle" style="margin:18px 0 0 13px;">Tool Title</h2>
                <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;" onclick="toolFormModalBg.classList.remove('active');">&times;</button>
            </div>
            <form class="edit-form" id="toolForm" style="padding:0 6px;"></form> <!-- Form fields dynamically added by JS -->
            <button id="toolFormBackBtn" class="submit-btn" style="background:rgba(16, 33, 59, 0.8);color:var(--neon-blue);margin:7px 7px 17px 7px; width: calc(100% - 14px);">
                <i class="fa-solid fa-arrow-left"></i> Back to Tools
            </button>
            <div class="status-message" id="toolStatusMsg"></div>
        </nav>
    </div>

    <div id="lightbox">
        <img src="" alt="Lightbox image">
    </div>

    <div id="callModal">
        <div id="callHeader">Philadelphia AI - Live Call</div>
        <div id="botImageContainer">
            <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Bot">
            <div id="botSpeakingIndicator"></div>
        </div>
        <div id="callStatusMessage">Connecting...</div>
        <div id="tapToTalk">Tap Anywhere to Speak</div>
        <div id="callConversation">
            <div class="call-msg status">Waiting for connection...</div> <!-- Initial status, real content loaded by JS -->
        </div>
        <div id="userAudioVisualizer">
            <div class="audio-bar"></div><div class="audio-bar"></div><div class="audio-bar"></div>
            <div class="audio-bar"></div><div class="audio-bar"></div><div class="audio-bar"></div>
            <div class="audio-bar"></div>
        </div>
        <div id="callControls">
            <button id="muteCallBtn"><i class="fa-solid fa-microphone"></i> Mute Microphone</button>
            <button id="endCallBtn"><i class="fa-solid fa-phone-slash"></i> End Call</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- External JavaScript for all functionality -->
    <script type="module" src="functionality.js"></script>

    <!-- Basic Cosmic Engine JS (purely for visual background - part of template) -->
    <script>
        const cosmos = document.getElementById('cosmos-container');
        const nebulaLayers = cosmos.querySelectorAll('.nebula-layer');

        function createParticle(type, count, spread, maxDuration, zOffset = 0) {
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = type;
                const size = Math.random() * (type === 'star' ? 2 : 1.5) + 0.5;
                particle.style.width = `${size}px`; particle.style.height = `${size}px`;
                particle.style.left = `${Math.random() * spread}%`;
                particle.style.top = `${Math.random() * spread}%`;
                particle.style.setProperty('--duration', `${Math.random() * maxDuration + 5}s`);
                particle.style.setProperty('--z-pos', `${zOffset}px`); // For parallax
                if(type === 'star') particle.style.opacity = Math.random();
                cosmos.appendChild(particle);
                setTimeout(() => particle.style.opacity = Math.random() * 0.7 + 0.3, Math.random() * 2000); // Staggered fadeIn
            }
        }

        function launchShootingStar() {
            const star = document.createElement('div');
            star.className = 'shooting-star';
            const startX = Math.random() * window.innerWidth * 1.5;
            const startY = -100;
            const duration = Math.random() * 2 + 1.5; // 1.5 to 3.5 seconds
            const length = Math.random() * 100 + 50; // 50px to 150px
            const distX = Math.random() * 800 + 400; // how far horizontally it travels
            const distY = Math.random() * 600 + 300; // how far vertically it travels

            star.style.setProperty('--startX', `${startX}px`);
            star.style.setProperty('--startY', `${startY}px`);
            star.style.setProperty('--duration', `${duration}s`);
            star.style.setProperty('--length', `${length}px`);
            star.style.setProperty('--distX', `${distX}px`);
            star.style.setProperty('--distY', `${distY}px`);

            cosmos.appendChild(star);
            setTimeout(() => star.remove(), duration * 1000);
        }

        // Parallax effect for nebula layers
        document.addEventListener('mousemove', (e) => {
            const x = (e.clientX / window.innerWidth - 0.5);
            const y = (e.clientY / window.innerHeight - 0.5);

            nebulaLayers.forEach((layer, index) => {
                const depth = index * 50 + 50; // Different depth for each layer
                const moveX = x * depth * 0.5;
                const moveY = y * depth * 0.5;
                layer.style.transform = `translate(${moveX}px, ${moveY}px) translateZ(${layer.style.getPropertyValue('--z-pos') || '0px'})`;
            });
        });

        document.addEventListener('DOMContentLoaded', () => {
            createParticle('star', 250, 100, 10); // More stars, slower twinkle
            createParticle('stardust', 120, 100, 15); // More stardust, slower float
            const randomLaunchInterval = () => {
                launchShootingStar();
                setTimeout(randomLaunchInterval, Math.random() * 5000 + 3000); // 3 to 8 seconds
            }
            setTimeout(randomLaunchInterval, 2000); // Initial delay
        });
    </script>
<script>
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

// --- Firebase Configuration ---
const firebaseConfig = {
    apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
    authDomain: "elvionai.firebaseapp.com",
    projectId: "elvionai",
    storageBucket: "elvionai.appspot.com",
    messagingSenderId: "161078300830",
    appId: "1:161078300830:web:f460df8591704eb0e96b8f"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

const $ = id => document.getElementById(id);
const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

// --- Global State Variables ---
let chats = [];
let currentChatId = null;
let currentMessages = [];
let uploadedFiles = [];
let currentUser = null;
let currentController = null; // For API call cancellation
let chatsUnsubscribe = null;
let messagesUnsubscribe = null;
let aiActivityTimeout = null; // For AI icon animation

// --- DOM Elements (referenced from index.html) ---
const chatInput = $('chatInput');
const chatBox = $('chatBox');
const typingStatus = $('typing-status');
const sendBtn = $('sendBtn');
const headerAiIcon = $('headerAiIcon');
const emojiPanel = $('emojiPanel');
const emojiBtn = $('emojiBtn');
const chatFile = $('chatFile');
const filePreview = $('filePreview');
const aiPrevBox = $('ai-image-preview');
const aiPrevClose = $('ai-image-close');
const aiPrevDLBtn = $('ai-image-dl');
const aiPrevImgBox = $('ai-image-container');
const lightbox = $('lightbox');
const callBtn = $('callBtn');
const callModal = $('callModal');
const endCallBtn = $('endCallBtn');
const muteCallBtn = $('muteCallBtn');
const callConversation = $('callConversation');
const botImageContainer = $('botImageContainer');
const callStatusMessage = $('callStatusMessage');
const tapToTalk = $('tapToTalk');
const chatForm = $('chatForm');
const profileMenuBg = $('profileMenuBg');
const profileMenu = $('profileMenu');
const linkMenuBg = $('linkMenuBg');
const linkMenu = $('linkMenu');
const toolsMenuBg = $('toolsMenuBg');
const toolsMenu = $('toolsMenu');
const toolBtn = $('toolBtn');
const logoutBtn = $('logoutBtn');
const profileMenuUser = $('profileMenuUser');
const profileMenuEmail = $('profileMenuEmail');
const editName = $('edit-name');
const editPhoto = $('edit-photo');
const profilePicPreview = $('profilePicPreview');
const profileForm = $('profileForm');
const newChatBtn = $('newChatBtn');
const chatsListEl = $('chatsList');
const toolFormModalBg = $('toolFormModalBg');
const toolForm = $('toolForm');
const toolFormTitle = $('toolFormTitle');
const toolFormBackBtn = $('toolFormBackBtn');
const themeBtn = $('themeBtn');
const userAudioVisualizer = $('userAudioVisualizer'); // For call UI visualizer

// --- Event Listeners and Initializations ---
document.addEventListener('DOMContentLoaded', () => {

    // --- Emoji Panel Logic ---
    const emojis = ["ðŸ˜€","ðŸ˜‚","ðŸ˜","ðŸ¥°","ðŸ˜Ž","ðŸ‘","ðŸ™","ðŸ”¥","ðŸ’¯","ðŸŽ‰","ðŸ˜‡","ðŸ¤–","ðŸ‘€"];
    if (emojiBtn && emojiPanel && chatInput) {
        emojiBtn.addEventListener('click', (e) => {
            emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
            emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block';
            try {
                const rect = emojiBtn.getBoundingClientRect();
                emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
                emojiPanel.style.bottom = `${rect.height + 10}px`; // Position above button
            } catch (e) { /* ignore positioning errors */ }
            emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
                span.addEventListener('click', function () {
                    const text = this.textContent || '';
                    const start = chatInput.selectionStart || 0;
                    const end = chatInput.selectionEnd || 0;
                    chatInput.value = chatInput.value.slice(0, start) + text + chatInput.value.slice(end);
                    chatInput.focus();
                    chatInput.selectionStart = chatInput.selectionEnd = start + text.length;
                    emojiPanel.style.display = 'none';
                    chatInput.dispatchEvent(new Event('input'));
                });
            });
        });
        document.addEventListener('click', e => {
            if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
                emojiPanel.style.display = 'none';
            }
        });
    }

    // --- Chat Input Auto-Resize & Enter Key Logic ---
    if (chatInput) {
        const autoResize = () => {
            chatInput.style.height = 'auto';
            chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px'; // Max height 120px
        };
        chatInput.addEventListener('input', autoResize);
        chatInput.addEventListener('keydown', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent new line in input
                chatForm.requestSubmit(); // Submit form
            } else if (e.key === 'Enter' && e.shiftKey) {
                // Allow shift+enter for new line within textarea
                const start = chatInput.selectionStart;
                const end = chatInput.selectionEnd;
                chatInput.value = chatInput.value.substring(0, start) + "\n" + chatInput.value.substring(end);
                chatInput.selectionStart = chatInput.selectionEnd = start + 1;
                autoResize();
            }
        });
        autoResize();
    }

    // --- File Attachments Logic ---
    if (chatFile) {
        chatFile.addEventListener('change', function() {
            uploadedFiles = Array.from(this.files || []);
            renderFilePreview();
        });
    }

    // --- AI Image Preview & Lightbox Logic ---
    if (aiPrevClose) aiPrevClose.addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
    if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
        const img = aiPrevImgBox.querySelector('img');
        if (img) {
            const a = document.createElement('a');
            a.href = img.src;
            a.download = 'philadelphia_ai_image.png';
            a.click();
        }
    });

    if (lightbox) {
        lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
    }

    if (chatBox) {
        chatBox.addEventListener('click', e => {
            if (e.target.tagName === 'IMG' && e.target.closest('.chat-message.ai .msg')) {
                e.preventDefault();
                const lbImg = lightbox.querySelector('img');
                if (lbImg) {
                    lbImg.src = e.target.src;
                    lightbox.classList.add('active');
                }
            }
        });
    }

    // --- Side Panel Controls Logic ---
    window.closeToolMenu = () => { // Made global for onclick in HTML
        if (toolsMenuBg) toolsMenuBg.classList.remove('active');
        if (toolsMenu) toolsMenu.classList.remove('active');
    };
    window.openToolMenu = () => { // Made global for onclick in HTML
        if (toolsMenuBg) toolsMenuBg.classList.add('active');
        if (toolsMenu) toolsMenu.classList.add('active');
    };

    if (profileMenuBg) {
        $('openProfileMenu').addEventListener('click', () => {
            profileMenuBg.classList.add('active');
            setTimeout(() => profileMenu.classList.add('active'), 10);
        });
        profileMenuBg.addEventListener('click', e => {
            if (e.target === profileMenuBg) {
                profileMenu.classList.remove('active');
                setTimeout(() => profileMenuBg.classList.remove('active'), 110);
            }
        });
    }

    if (linkMenuBg) {
        $('openLinksMenu').addEventListener('click', () => {
            linkMenuBg.classList.add('active');
            setTimeout(() => linkMenu.classList.add('active'), 10);
        });
        linkMenuBg.addEventListener('click', e => {
            if (e.target === linkMenuBg) {
                linkMenu.classList.remove('active');
                setTimeout(() => linkMenuBg.classList.remove('active'), 110);
            }
        });
    }

    if (toolBtn) toolBtn.addEventListener('click', openToolMenu);
    if (toolsMenuBg) toolsMenuBg.addEventListener('click', e => {
        if (e.target === toolsMenuBg) closeToolMenu();
    });

    if (toolFormBackBtn) {
        toolFormBackBtn.addEventListener('click', () => {
            toolFormModalBg.classList.remove('active');
            openToolMenu();
        });
    }

    if (toolFormModalBg) toolFormModalBg.addEventListener('click', e => {
        if (e.target === toolFormModalBg) toolFormModalBg.classList.remove('active');
    });

    // --- Auth & Profile Management Logic ---
    if (logoutBtn) logoutBtn.addEventListener('click', () => {
        auth.signOut();
        window.location.href = 'signup-login.html';
    });

    onAuthStateChanged(auth, user => {
        if (!user) {
            try {
                window.location.href = "signup-login.html";
            } catch (e) {} // Ensure redirection only happens once, ignore errors for already redirected pages
            return;
        }
        currentUser = user;
        if (profileMenuUser) profileMenuUser.textContent = user.displayName || "User";
        if (profileMenuEmail) profileMenuEmail.textContent = user.email || "";
        if (editName) editName.value = user.displayName || "";
        if (editPhoto) editPhoto.value = user.photoURL || "";
        if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";
        loadUserChats(user.uid);
    });

    if (profileForm) {
        profileForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!currentUser) return;
            const status = $('profileStatusMsg');
            if (status) status.textContent = 'Saving...';
            try {
                await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
                if (auth.currentUser) await auth.currentUser.reload();
                if (status) {
                    status.textContent = "Profile updated!";
                    status.style.color = "var(--neon-blue)";
                }
                setTimeout(() => {
                    profileMenuBg?.classList.remove('active');
                    profileMenu?.classList.remove('active');
                }, 800);
            } catch (err) {
                if (status) {
                    status.textContent = err.message;
                    status.style.color = "var(--neon-pink)";
                }
            }
        });
    }

    // --- Chat & Message Management Logic ---
    async function loadUserChats(userId) {
        if (chatsUnsubscribe) chatsUnsubscribe();
        const chatsCol = collection(db, 'users', userId, 'chats');
        const q = query(chatsCol, orderBy('createdAt', 'desc'));
        chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
            if (snapshot.empty) {
                await createNewChat(userId);
                return;
            }
            chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            renderChatsListSidebar();
            if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                currentChatId = chats[0].id; // Use [0].id to select the first chat
            }
            subscribeToMessages(userId, currentChatId);
        }, (error) => {
            console.error("Error fetching chats: ", error);
            chatsListEl.innerHTML = `<div style="color: var(--neon-pink);">Error loading chats.</div>`;
        });
    }

    async function createNewChat(userId) {
        if (!userId) userId = currentUser?.uid;
        if (!userId) return;
        const chatsCol = collection(db, 'users', userId, 'chats');
        try {
            const newChatDoc = await addDoc(chatsCol, { name: "New Chat", createdAt: serverTimestamp() });
            currentChatId = newChatDoc.id;
        } catch (e) {
            console.error("Error creating new chat: ", e);
        }
    }

    function subscribeToMessages(userId, chatId) {
        if (messagesUnsubscribe) messagesUnsubscribe();
        if (!userId || !chatId) {
            renderChatBox([]); // Clear chatbox if no user or chat
            return;
        }
        const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
        const q = query(messagesCol, orderBy('createdAt'));
        messagesUnsubscribe = onSnapshot(q, (snapshot) => {
            currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            renderChatBox(currentMessages);
        }, (error) => {
            console.error("Error fetching messages: ", error);
            chatBox.innerHTML = `<div style="color: var(--neon-pink); text-align: center; margin-top: 20px;">Error loading messages for this chat.</div>`;
        });
    }

    if (newChatBtn) {
        newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));
    }

    function renderChatsListSidebar() {
        if (!chatsListEl) return;
        chatsListEl.innerHTML = '';
        if (chats.length === 0) {
            chatsListEl.innerHTML = `<div style="padding: 10px; color: #a8eaff;">No chats yet.</div>`;
            return;
        }
        chats.forEach((chat) => {
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.alignItems = 'center';
            container.style.marginBottom = '6px';
            container.style.background = chat.id === currentChatId ? 'rgba(0, 234, 255, 0.15)' : 'transparent';
            container.style.borderRadius = '8px';

            const titleSpan = document.createElement('span');
            titleSpan.textContent = chat.name || `Chat`;
            titleSpan.style.flex = '1';
            titleSpan.style.cursor = 'pointer';
            titleSpan.style.padding = '8px 5px';
            titleSpan.onclick = () => {
                currentChatId = chat.id;
                subscribeToMessages(currentUser.uid, currentChatId);
                renderChatsListSidebar();
                profileMenu?.classList.remove('active');
                profileMenuBg?.classList.remove('active');
            };

            const renameBtn = document.createElement('button');
            renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
            renameBtn.title = 'Rename';
            renameBtn.style.margin = '0 6px 0 8px';
            renameBtn.onclick = async (e) => {
                e.stopPropagation();
                const newName = prompt("Rename chat:", chat.name);
                if (newName && newName.trim()) {
                    const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                    await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
                }
            };

            const delBtn = document.createElement('button');
            delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
            delBtn.title = 'Delete';
            delBtn.style.marginLeft = '6px';
            delBtn.onclick = async (e) => {
                e.stopPropagation();
                if (!confirm(`Delete "${chat.name}"? This will delete all messages.`)) return;

                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                const messagesSnap = await getDocs(messagesCol);
                const batch = writeBatch(db);
                messagesSnap.docs.forEach(d => batch.delete(d.ref));
                await batch.commit();

                const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                await deleteDoc(chatDoc);

                if (currentChatId === chat.id) {
                    currentChatId = null;
                }
            };

            container.appendChild(titleSpan);
            container.appendChild(renameBtn);
            container.appendChild(delBtn);
            chatsListEl.appendChild(container);
        });
    }

    // --- Markdown Rendering & Highlighting Logic ---
    const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

    function inlineMarkdown(t = '') {
        let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
        s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
        s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
        s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
        return s.replace(/\n/g, '<br>');
    }

    function renderMarkdown(text = '') {
        const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
        let html = '';
        let lastIndex = 0;
        text = text || '';
        text.replace(codeBlockRegex, (match, lang, code, offset) => {
            const before = text.slice(lastIndex, offset);
            html += inlineMarkdown(before);
            const language = (lang || '').toLowerCase().trim();
            const safe = escapeHTML(code);
            html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safe}</code></pre>`;
            lastIndex = offset + match.length;
            return match;
        });
        html += inlineMarkdown(text.slice(lastIndex));
        return { html };
    }

    function enhanceCodeBlocks(container) {
        if (!container) return;
        container.querySelectorAll('pre').forEach(pre => {
            const codeEl = pre.querySelector('code');
            if (window.hljs && codeEl) {
                try { hljs.highlightElement(codeEl); } catch (e) { console.warn("Highlight.js failed:", e); }
            }
            const btn = pre.querySelector('.copy-btn');
            if (btn && codeEl) {
                btn.addEventListener('click', async () => {
                    try {
                        await navigator.clipboard.writeText(codeEl.innerText);
                        const prev = btn.textContent;
                        btn.textContent = 'Copied!';
                        setTimeout(() => btn.textContent = prev, 800);
                    } catch (e) {
                        btn.textContent = 'Failed';
                        setTimeout(() => btn.textContent = 'Copy', 800);
                    }
                });
            }
        });
    }

    function renderChatBox(messages = []) {
        if (!chatBox) return;
        chatBox.innerHTML = ''; // Clear chat box first
        // Add initial AI greeting if no messages are loaded from DB
        if (messages.length === 0) {
            const initialGreetingDiv = document.createElement('div');
            initialGreetingDiv.className = 'chat-message ai';
            initialGreetingDiv.innerHTML = `<div class="msg">Greetings, traveler. ðŸ¦… The cosmos is aligned. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨</div>`;
            chatBox.appendChild(initialGreetingDiv);
        }

        (messages || []).forEach((msg) => {
            const div = document.createElement('div');
            div.className = 'chat-message ' + (msg.role === 'user' ? 'user' : 'ai');
            div.setAttribute('data-message-id', msg.id);
            let innerHtml = '';

            if (msg.role === 'user') {
                const fileHtml = (msg.files || [])
                    .map(file => {
                        let icon = 'fa-file';
                        if (file.type.startsWith('image/')) icon = 'fa-file-image';
                        else if (file.type.startsWith('video/')) icon = 'fa-file-video';
                        else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
                        else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                        return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                    })
                    .join('');

                innerHtml = `<div class="msg">
                    ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                    ${escapeHTML(msg.text || '')}
                    <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                        <button class="inline-edit-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i></button>
                        <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                    </div>
                </div>`;
            } else {
                let content;
                if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                    content = msg.text;
                } else {
                    content = renderMarkdown(msg.text || '').html;
                }
                innerHtml = `<div class="msg">${content}
                    <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                        <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                        <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                        <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                    </div>
                </div>`;
            }
            div.innerHTML = innerHtml;
            chatBox.appendChild(div);
        });
        enhanceCodeBlocks(chatBox);
        hookAiMsgControls();
        hookUserMsgControls();
        setTimeout(() => {
            chatBox.scrollTop = chatBox.scrollHeight;
        }, 50);
    }

    async function deleteMessagesFrom(messageId) {
        if (!currentChatId || !currentUser) return;
        const msgIndex = currentMessages.findIndex(m => m.id === messageId);
        if (msgIndex === -1) return;
        const batch = writeBatch(db);
        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
        for (let i = msgIndex; i < currentMessages.length; i++) {
            const msgToDel = currentMessages[i];
            const docRef = doc(messagesCol, msgToDel.id);
            batch.delete(docRef);
        }
        try {
            await batch.commit();
        } catch (e) {
            console.error("Error deleting messages: ", e);
        }
    }

    function hookAiMsgControls() {
        if (!chatBox) return;
        chatBox.querySelectorAll('.chat-message.ai').forEach(div => {
            const messageId = div.getAttribute('data-message-id');
            const msg = currentMessages.find(m => m.id === messageId);
            if (!msg) return;

            const controls = div.querySelector('.ai-msg-controls');
            if (!controls) return;

            const copyBtn = controls.querySelector('.inline-copy-btn');
            const shareBtn = controls.querySelector('.inline-share-btn');
            const regenBtn = controls.querySelector('.regen-btn');

            if (copyBtn) copyBtn.onclick = () => {
                try {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = msg.text;
                    const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                    navigator.clipboard.writeText(textToCopy);
                    copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                    setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                } catch (e) {
                    console.warn('copy failed', e);
                }
            };

            if (shareBtn) shareBtn.onclick = () => {
                try {
                    const url = window.location.origin;
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = msg.text;
                    const plainText = tempDiv.textContent || tempDiv.innerText || '';
                    const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;
                    if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
                    else prompt("Copy and share manually:", shareText);
                } catch (e) {
                    console.warn('share failed', e);
                }
            };

            if (regenBtn) regenBtn.onclick = async () => {
                const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                if (msgIndex < 1) return;
                const userMsg = currentMessages[msgIndex - 1];
                if (userMsg.role !== 'user') return;

                await deleteMessagesFrom(messageId);
                chatInput.value = userMsg.text;
                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
                uploadedFiles = [];
                renderFilePreview();

                activateAiActivity(true);
                showTypingAtNext(); // show typing animation

                const historyForRegen = currentMessages
                    .slice(0, msgIndex - 1)
                    .map(m => ({ role: m.role, content: m.text || '' }));

                try {
                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: userMsg.text, history: historyForRegen, user_id: currentUser?.uid || "user" })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "Server error.");
                    removeTyping();
                    await startTypewriter(data.response, false);
                } catch (err) {
                    removeTyping();
                    await startTypewriter(`âŒ Regeneration error: ${err.message}`, false);
                } finally {
                    activateAiActivity(false);
                }
            };
        });
    }

    function hookUserMsgControls() {
        if (!chatBox) return;
        chatBox.querySelectorAll('.chat-message.user').forEach(div => {
            const messageId = div.getAttribute('data-message-id');
            const msg = currentMessages.find(m => m.id === messageId);
            if (!msg) return;

            const controls = div.querySelector('.user-msg-controls');
            if (!controls) return;

            const copyBtn = controls.querySelector('.inline-copy-btn');
            const editBtn = controls.querySelector('.inline-edit-btn');

            if (copyBtn) copyBtn.onclick = () => {
                try {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = msg.text;
                    const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                    navigator.clipboard.writeText(textToCopy);
                    copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                    setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                } catch (e) {
                    console.warn('copy failed', e);
                }
            };

            if (editBtn) editBtn.onclick = async () => {
                try {
                    if (!msg.text) return;
                    chatInput.value = msg.text;
                    chatInput.focus();
                    chatInput.style.height = 'auto';
                    chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
                    await deleteMessagesFrom(messageId);
                } catch (e) {
                    console.warn('edit failed', e);
                }
            };
        });
    }

    function activateAiActivity(active) {
        if (headerAiIcon) {
            if (active) {
                headerAiIcon.classList.add('active');
                clearTimeout(aiActivityTimeout);
            } else {
                aiActivityTimeout = setTimeout(() => {
                    headerAiIcon.classList.remove('active');
                }, 500); // Keep active for a bit after processing finishes
            }
        }
    }

    function showTypingAtNext() {
        if (!typingStatus) return;
        typingStatus.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span></div>`;
        typingStatus.style.display = 'flex';
        chatBox.scrollTop = chatBox.scrollHeight;
        activateAiActivity(true);
    }

    function showTypingWithText(text) {
        if (!typingStatus) return;
        typingStatus.innerHTML = `<div class="msg" style="display:flex;align-items:center;"><span class="spinner"></span> <span style="margin-left:8px; color:var(--main-text); font-style:italic;">${text}</span></div>`;
        typingStatus.style.display = 'flex';
        chatBox.scrollTop = chatBox.scrollHeight;
        activateAiActivity(true);
    }

    function removeTyping() {
        if (!typingStatus) return;
        typingStatus.style.display = 'none';
        typingStatus.innerHTML = '';
        activateAiActivity(false);
    }

    // --- Advanced Code Typewriter (Wow Feature 4) Logic ---
    async function startTypewriter(text, saveToDb = true) {
        activateAiActivity(true); // AI is active during typing
        if (currentController?.signal.aborted) { // Check for immediate abort before starting
            activateAiActivity(false);
            return;
        }

        // Handle image/audio/video responses directly without typing animation
        if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) {
            if (saveToDb) {
                await addMessageToChat('ai', text);
            } else {
                const tempDiv = document.createElement('div');
                tempDiv.className = "chat-message ai";
                tempDiv.innerHTML = `<div class="msg">${text}</div>`;
                chatBox.appendChild(tempDiv);
                chatBox.scrollTop = chatBox.scrollHeight;

                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
                } catch (e) {
                    console.error("Error saving regenerated AI tool message: ", e);
                }
            }
            activateAiActivity(false);
            return;
        }

        if (!chatBox) { activateAiActivity(false); return; }

        const div = document.createElement('div');
        div.className = "chat-message ai";
        const msgdiv = document.createElement('div');
        msgdiv.className = 'msg';
        div.appendChild(msgdiv);
        chatBox.appendChild(div);

        const codeBlockRegex = /(```(\w+)?\n([\s\S]*?)```)/g;
        let lastIndex = 0;
        let currentContent = '';
        let match;

        while ((match = codeBlockRegex.exec(text)) !== null) {
            // Type content before the code block
            const preCodeText = text.slice(lastIndex, match.index);
            for (const char of preCodeText) {
                if (currentController?.signal.aborted) {
                    currentContent += '... (aborted)';
                    msgdiv.innerHTML = renderMarkdown(currentContent).html;
                    enhanceCodeBlocks(msgdiv);
                    chatBox.scrollTop = chatBox.scrollHeight;
                    activateAiActivity(false);
                    return;
                }
                currentContent += char;
                msgdiv.innerHTML = renderMarkdown(currentContent).html;
                chatBox.scrollTop = chatBox.scrollHeight;
                await new Promise(res => setTimeout(res, 10)); // Typing speed for text
            }

            // Type the code block itself
            const [fullMatch, , lang, codeContent] = match;
            const codeBlockStart = `\`\`\`${lang || ''}\n`;
            const codeBlockEnd = `\`\`\``;
            const lines = codeContent.split('\n');

            currentContent += codeBlockStart; // Start the code block visually
            msgdiv.innerHTML = renderMarkdown(currentContent).html;
            chatBox.scrollTop = chatBox.scrollHeight;
            await new Promise(res => setTimeout(res, 50)); // Pause after starting block

            for (const line of lines) {
                if (currentController?.signal.aborted) {
                    currentContent += '... (aborted)';
                    msgdiv.innerHTML = renderMarkdown(currentContent).html;
                    enhanceCodeBlocks(msgdiv);
                    chatBox.scrollTop = chatBox.scrollHeight;
                    activateAiActivity(false);
                    return;
                }
                for (const char of line) {
                    currentContent += char;
                    msgdiv.innerHTML = renderMarkdown(currentContent).html;
                    chatBox.scrollTop = chatBox.scrollHeight;
                    await new Promise(res => setTimeout(res, 5)); // Faster typing for code
                }
                currentContent += '\n'; // Add newline for the next line
                msgdiv.innerHTML = renderMarkdown(currentContent).html;
                chatBox.scrollTop = chatBox.scrollHeight;
                await new Promise(res => setTimeout(res, 20)); // Pause between lines
            }
            currentContent = currentContent.trimEnd() + codeBlockEnd; // Add closing block and ensure no trailing newline issues for highlight
            msgdiv.innerHTML = renderMarkdown(currentContent).html;
            enhanceCodeBlocks(msgdiv); // Apply highlighting after the block is "typed"
            chatBox.scrollTop = chatBox.scrollHeight;
            await new Promise(res => setTimeout(res, 100)); // Pause after block is done

            lastIndex = match.index + fullMatch.length;
        }

        // Type any remaining content after the last code block
        const remainingText = text.slice(lastIndex);
        for (const char of remainingText) {
            if (currentController?.signal.aborted) {
                currentContent += '... (aborted)';
                break;
            }
            currentContent += char;
            msgdiv.innerHTML = renderMarkdown(currentContent).html;
            chatBox.scrollTop = chatBox.scrollHeight;
            await new Promise(res => setTimeout(res, 10));
        }

        // Final render and controls
        msgdiv.innerHTML = renderMarkdown(currentContent).html + `
            <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
            </div>
        `;
        enhanceCodeBlocks(msgdiv);
        chatBox.scrollTop = chatBox.scrollHeight;

        if (saveToDb) {
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            try {
                await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
            } catch (e) {
                console.error("Error saving AI message: ", e);
                msgdiv.innerHTML += "<br><small style='color: var(--neon-pink);'>Failed to save message.</small>";
            }
        }
        activateAiActivity(false);
    }

    // --- File Preview Logic ---
    function renderFilePreview() {
        if (!filePreview) return;
        if (!uploadedFiles.length) {
            filePreview.style.display = 'none';
            filePreview.innerHTML = '';
            return;
        }
        filePreview.style.display = 'block';
        filePreview.innerHTML = uploadedFiles.map((file, idx) => {
            let preview = '';
            if (file.type.startsWith('image/')) {
                preview = `<img src="${URL.createObjectURL(file)}" style="max-width:58px;max-height:41px;vertical-align:middle;border-radius:8px;margin-right:6px;">`;
            } else if (file.type.startsWith('video/')) {
                preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:58px;height:41px;vertical-align:middle;border-radius:8px;margin-right:7px;"></video>`;
            } else if (file.type.startsWith('audio/')) {
                preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:52px;margin-right:7px;"></audio>`;
            } else if (file.type === 'application/pdf') {
                preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`;
            }
            return `
                <div style="display:flex;align-items:center;gap:7px;margin-bottom:1px;">
                    ${preview}
                    <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span>
                    <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
                </div>`;
        }).join('');

        filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const idx = parseInt(btn.getAttribute('data-idx'));
                uploadedFiles.splice(idx, 1);
                if (!uploadedFiles.length && chatFile) chatFile.value = '';
                renderFilePreview();
            });
        });
    }

    function showAIImagePreview(base64, caption = '') {
        if (!aiPrevBox || !aiPrevImgBox) return; // aiPrevImgBox is a child of aiPrevBox
        aiPrevBox.innerHTML = `
            <button id="ai-image-close" style="float:right;background:rgba(35, 35, 58, 0.8);border:none;border-radius:7px;color:var(--neon-blue);font-size:1.5em;cursor:pointer;margin-left:5px;">&times;</button>
            <div id="ai-image-container">
                <img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:210px;max-height:210px;border-radius:12px;display:block;">
                <div style="color:#aee;font-size:.95em;margin-top:3px;text-align:center;">${caption}</div>
            </div>
            <button id="ai-image-dl" style="margin-top:9px;padding:7px 20px;background:linear-gradient(90deg,var(--neon-blue),#0090ff);color:#222;border:none;border-radius:8px;box-shadow:0 2px 7px rgba(0, 255, 242, 0.78);cursor:pointer;font-weight:bold;">Download</button>
        `;
        aiPrevBox.style.display = 'block';

        // Re-attach event listeners as content is re-rendered
        $('ai-image-close').addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
        $('ai-image-dl').addEventListener('click', () => {
            const img = $('ai-image-container').querySelector('img');
            if (img) {
                const a = document.createElement('a');
                a.href = img.src;
                a.download = 'philadelphia_ai_image.png';
                a.click();
            }
        });
    }

    async function addMessageToChat(role, text, files = []) {
        if (!currentChatId || !currentUser) return;
        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
        try {
            await addDoc(messagesCol, { role, text, files, createdAt: serverTimestamp() });
        } catch (e) {
            console.error("Error adding message to Firestore: ", e);
        }
    }

    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    // --- AI Tool Definitions & Handlers ---
    async function handleVideoGeneration(payload, isImageToVideo = false) {
        activateAiActivity(true);
        showTypingWithText('Submitting video generation job...');
        try {
            const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
            const commonPayload = { model: "MiniMax-Hailuo-02", duration: payload.duration || 6, resolution: payload.resolution || "1080P" };
            let options;

            if (isImageToVideo) {
                payload.append('model', commonPayload.model);
                payload.append('duration', commonPayload.duration);
                payload.append('resolution', commonPayload.resolution);
                options = { method: 'POST', body: payload };
            } else {
                const finalPayload = { ...payload, ...commonPayload };
                options = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(finalPayload)
                };
            }

            const startRes = await fetch(API_BASE_URL + endpoint, options);
            const startData = await startRes.json();

            if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to start video task.');

            removeTyping();
            await startTypewriter(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. I'll notify you when it's ready. This can take a few minutes. Do not leave this page or send another message or task.`);

            const pollInterval = setInterval(async () => {
                try {
                    const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                    const statusData = await statusRes.json();

                    if (statusRes.ok && statusData.url) {
                        clearInterval(pollInterval);
                        const videoHtml = `ðŸŽ‰ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                        await addMessageToChat('ai', videoHtml);
                        activateAiActivity(false);
                    } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                        clearInterval(pollInterval);
                        await startTypewriter(`âŒ Video generation failed. Reason: ${statusData.error || 'Unknown error'}`);
                        activateAiActivity(false);
                    }
                } catch (pollErr) {
                    clearInterval(pollInterval);
                    await startTypewriter(`âŒ Error checking video status.`);
                    activateAiActivity(false);
                }
            }, 20000); // Poll every 20 seconds
        } catch (err) {
            removeTyping();
            await startTypewriter(`âŒ Could not start video generation: ${err.message}`);
            activateAiActivity(false);
        }
    }

    const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
    const toolDefinitions = {
        "image": {
            title: "Generate Image",
            description: "Create stunning visuals from a text prompt. Choose a model for different results.",
            buildForm: () => `
                <label for="tool-provider">Generation Model</label>
                <select id="tool-provider"><option value="thena">Version 1 (Stylized, Fast & Recommended)</option><option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option></select>
                <label for="tool-prompt">Image Prompt</label>
                <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required></textarea>
                <label for="tool-style">Style (for Version1 only)</label>
                <select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)';
                const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
                await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                showTypingWithText('Generating your image...');
                try {
                    const res = await fetch(`${API_BASE_URL}/generate-image`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || res.statusText);
                    showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                    removeTyping();
                    await addMessageToChat('ai', 'âœ… Image generated! Check the floating image box to view or download.');
                    return null;
                } catch (err) {
                    removeTyping();
                    return `âŒ Image generation failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "edit-photo": {
            title: "Edit Photo",
            description: "Upload a photo and describe the changes you want to make.",
            buildForm: () => `
                <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required></textarea>
                <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required>
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const file = form.querySelector('#tool-file').files[0];
                const prompt = form.querySelector('#tool-prompt').value;
                if (!file) { activateAiActivity(false); return "Please select a file to edit."; }
                const fd = new FormData();
                fd.append('file', file);
                fd.append('prompt', prompt);
                await addMessageToChat('user', `Photo edit request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                showTypingWithText('Editing your photo...');
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                    if (!res.ok) throw new Error((await res.json()).error || 'Failed to edit photo.');
                    const blob = await res.blob();
                    const base64String = await blobToBase64(blob);
                    const imgHtml = `âœ… Photo edited successfully! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
                    removeTyping();
                    await addMessageToChat('ai', imgHtml);
                    return null;
                } catch (err) {
                    removeTyping();
                    return `âŒ Photo edit failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "remove-bg": {
            title: "Remove Background",
            description: "Select an image file to automatically remove its background.",
            buildForm: () => `
                <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;">
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Remove Background</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const file = form.querySelector('#tool-file').files[0];
                if (!file) { activateAiActivity(false); return "Please select a file."; }
                await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                showTypingWithText('Removing background...');
                const fd = new FormData();
                fd.append('file', file);
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                    if (!res.ok) throw new Error(res.statusText);
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const imgHtml = `âœ… Background removed! <br><img src="${url}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                    removeTyping();
                    await addMessageToChat('ai', imgHtml);
                    return null;
                } catch (err) {
                    removeTyping();
                    return `âŒ Background removal failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "comic": {
            title: "Create Comic",
            description: "Write a story and watch it transform into a comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.",
            buildForm: () => `
                <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required></textarea>
                <label for="tool-style">Comic Style</label><select id="tool-style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
                <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" />
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Create Comic</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const payload = {
                    story: form.querySelector('#tool-story').value,
                    style: form.querySelector('#tool-style').value,
                    panels: parseInt(form.querySelector('#tool-panels').value, 10),
                    user: currentUser?.displayName || "User"
                };
                await addMessageToChat('user', `Comic creation request with style: ${payload.style}.`);
                showTypingWithText('Generating your comic panels...');
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || res.statusText);
                    const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join('');
                    const comicMessage = `ðŸ–¼ï¸ Comic successfully created! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                    removeTyping();
                    await addMessageToChat('ai', comicMessage);
                    return null;
                } catch (err) {
                    removeTyping();
                    return `âŒ Comic generation failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "voice-gen": {
            title: "Voice Generation",
            description: "Transform text into realistic speech. Choose a provider and voice style.",
            buildForm: () => `
                <label for="tool-provider">Voice Provider</label><select id="tool-provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
                <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required></textarea>
                <label for="tool-style">Voice Style</label><select id="tool-style"></select>
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice</button>`,
            onFormReady: () => {
                const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
                const voices = {
                    gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                    minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                };
                const updateStyles = () => {
                    styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                };
                providerSelect.addEventListener('change', updateStyles);
                updateStyles();
            },
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const provider = form.querySelector('#tool-provider').value,
                    text = form.querySelector('#tool-prompt').value,
                    style = form.querySelector('#tool-style').value;
                const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';
                await addMessageToChat('user', `Voice generation request using ${providerName}.`);
                showTypingWithText('Generating your audio...');
                try {
                    let res;
                    if (provider === 'gemini') {
                        const fd = new FormData();
                        fd.append('text', text);
                        fd.append('style', style);
                        res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                    } else {
                        res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ text, voice_id: style })
                        });
                    }
                    if (!res.ok) throw new Error(await res.text());
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const audioHtml = `ðŸ—£ï¸ Voice generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                    removeTyping();
                    await addMessageToChat('ai', audioHtml);
                    return null;
                } catch (err) {
                    removeTyping();
                    return `âŒ Voice generation failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "audio-narration": {
            title: "Audio Narration",
            description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.",
            buildForm: () => `
                <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;">
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const file = form.querySelector('#tool-file').files[0];
                if (!file) { activateAiActivity(false); return "Please select a file."; }
                await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                showTypingWithText('Analyzing and narrating document...');
                const fd = new FormData();
                fd.append('file', file);
                fd.append('style', 'podcast');
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                    if (!res.ok) throw new Error(res.statusText);
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const narrationHtml = `ðŸ—£ï¸ Narration generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                    removeTyping();
                    await addMessageToChat('ai', narrationHtml);
                    return null;
                } catch (err) {
                    removeTyping();
                    return `âŒ Audio narration failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "video-text": {
            title: "Generate Video from Text",
            description: "Describe the video you want to create. This process can take a few minutes.",
            buildForm: () => `
                <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required></textarea>
                <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15">
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
                await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
                handleVideoGeneration(payload); // handleVideoGeneration will deactivate activity
                return null;
            }
        },
        "video-image": {
            title: "Generate Video from Image",
            description: "Upload a starting image and describe how you want to animate it.",
            buildForm: () => `
                <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required></textarea>
                <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required>
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const file = form.querySelector('#video-image-file').files[0];
                if (!file) { activateAiActivity(false); return "Please select an image."; }
                await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{name: file.name, type: file.type}]);
                const fd = new FormData();
                fd.append('prompt', form.querySelector('#video-image-prompt').value);
                fd.append('file', file);
                handleVideoGeneration(fd, true); // handleVideoGeneration will deactivate activity
                return null;
            }
        },
        "music": {
            title: "Generate Music",
            description: "Generate music from a prompt, lyrics, and optional reference audio. Thanks to MiniMax.",
            buildForm: () => `
                <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required></textarea>
                <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..."></textarea>
                <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*">
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Music</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
                const refFile = form.querySelector('#music-ref').files[0];
                await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
                showTypingWithText('Composing your music...');
                try {
                    if (refFile) {
                        showTypingWithText('Uploading reference audio first...');
                        const fd = new FormData();
                        fd.append('file', refFile);
                        const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                        const uploadData = await uploadRes.json();
                        if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed.");
                        if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                        if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                        showTypingWithText('Reference uploaded. Composing music...');
                    }
                    const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const musicHtml = `ðŸŽµ Your music is ready! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                    removeTyping();
                    await addMessageToChat('ai', musicHtml);
                    return null;
                } catch (err) {
                    removeTyping();
                    return `âŒ Music generation failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "website": {
            title: "Create Website",
            description: "Describe the website you want to build and get a live, working prototype.",
            buildForm: () => `
                <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required></textarea>
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Website</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const prompt = form.querySelector('#website-prompt').value;
                await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`);
                showTypingWithText('Building and deploying your website...');
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt, user_id: currentUser.uid })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || res.statusText);
                    removeTyping();
                    return `ðŸŒ Website deployed successfully! [View here](${data.url})`;
                } catch (err) {
                    removeTyping();
                    return `âŒ Website creation failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "edit-website": {
            title: "Edit Last Website",
            description: "Provide an instruction to modify the most recent website you created.",
            buildForm: () => `
                <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required></textarea>
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const instruction = form.querySelector('#edit-instruction').value;
                await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`);
                showTypingWithText('Editing and redeploying your website...');
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ instruction, user_id: currentUser.uid })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || res.statusText);
                    removeTyping();
                    return `âœï¸ Website updated successfully! [View new version here](${data.url})`;
                } catch (err) {
                    removeTyping();
                    return `âŒ Website edit failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "my-sites": {
            isAction: true,
            runAction: async () => {
                activateAiActivity(true);
                await addMessageToChat('user', 'Show me a list of my websites.');
                showTypingWithText('Fetching your website list...');
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || 'Could not fetch sites.');
                    if (!data.sites || data.sites.length === 0) return "You haven't created any websites yet.";
                    const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                    removeTyping();
                    return `Here are the websites you've created:\n${siteList}`;
                } catch (err) {
                    removeTyping();
                    return `âŒ Error fetching websites: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
        "research-report": {
            title: "Research Report",
            description: "Generate a comprehensive research report in PDF format on any topic.",
            buildForm: () => `
                <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required>
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>`,
            handleSubmit: async (form) => {
                activateAiActivity(true);
                const topic = form.querySelector('#research-topic').value;
                await addMessageToChat('user', `Research report request on: "${topic}"`);
                showTypingWithText('Conducting research and compiling report...');
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ topic })
                    });
                    if (!res.ok) throw new Error(res.statusText);
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--link-text);font-weight:bold;">Download PDF Report</a>`;
                    removeTyping();
                    return `âœ… Research report on **${topic}** is ready! ${downloadLink}`;
                } catch (err) {
                    removeTyping();
                    return `âŒ Research report failed: ${err.message}`;
                } finally {
                    activateAiActivity(false);
                }
            }
        },
    };

    if (toolsMenu) {
        toolsMenu.addEventListener('click', async (e) => {
            const toolLink = e.target.closest('.tool-link');
            if (!toolLink) return;
            e.preventDefault();
            const toolKey = toolLink.getAttribute('data-tool');
            const tool = toolDefinitions[toolKey];
            if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);
            closeToolMenu();
            if (tool.isAction) {
                const result = await tool.runAction();
                removeTyping();
                if(result) await startTypewriter(result);
            } else {
                displayToolForm(toolKey);
            }
        });
    }

    function displayToolForm(toolKey) {
        const tool = toolDefinitions[toolKey];
        if (!tool || !toolFormModalBg) return;
        toolFormTitle.textContent = tool.title;
        const descriptionHtml = tool.description ? `<div style="color:#a8eaff;font-size:.9em;margin-bottom:12px;">${tool.description}</div>` : '';
        toolForm.innerHTML = descriptionHtml + tool.buildForm();
        if (typeof tool.onFormReady === 'function') tool.onFormReady();

        toolForm.onsubmit = async (e) => {
            e.preventDefault();
            const submitButton = toolForm.querySelector('button[type="submit"]');
            const originalButtonContent = submitButton.innerHTML;
            submitButton.innerHTML = `<div class="spinner"></div> Processing...`;
            submitButton.disabled = true;
            toolFormModalBg.classList.remove('active');
            const resultText = await tool.handleSubmit(toolForm);
            if (resultText) {
                removeTyping();
                await startTypewriter(resultText);
            }
            submitButton.innerHTML = originalButtonContent;
            submitButton.disabled = false;
        };
        toolFormModalBg.classList.add('active');
    }

    // --- Main Chat Form Submission Logic ---
    chatForm.addEventListener('submit', async function (e) {
        e.preventDefault();
        if (!currentChatId) {
            alert("Please select a chat or create a new one.");
            return;
        }
        const msgText = chatInput.value.trim();
        if (!msgText && uploadedFiles.length === 0) return;

        const stopButton = document.createElement('button');
        stopButton.type = 'button';
        stopButton.id = 'stopBtn';
        stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>';
        stopButton.className = 'thruster-btn'; // Apply thruster-btn styling
        sendBtn.replaceWith(stopButton);
        currentController = new AbortController();
        const signal = currentController.signal;
        let finalResponse = '';

        stopButton.addEventListener('click', () => {
            if (currentController) {
                currentController.abort();
            }
        });

        const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
        await addMessageToChat('user', msgText, filesForHistory);
        const localUploadedFiles = [...uploadedFiles];
        chatInput.value = '';
        uploadedFiles = [];
        renderFilePreview();
        chatInput.style.height = 'auto'; // Reset textarea height

        activateAiActivity(true);

        if (localUploadedFiles.length > 0) {
            showTypingWithText('Analyzing your file(s)...');
            let endpoint = '';
            const file = localUploadedFiles[0];
            if (file.type.startsWith('image/')) endpoint = '/understand-image';
            else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
            else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
            else if (file.type.startsWith('video/')) endpoint = '/understand-video';
            else {
                removeTyping();
                finalResponse = "Sorry, I can't analyze that file type.";
            }
            try {
                if(endpoint) {
                    const fd = new FormData();
                    fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]}`);
                    fd.append('file', file);
                    const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "Analysis failed.");
                    finalResponse = data.response;
                }
            } catch (err) {
                finalResponse = err.name === 'AbortError' ? 'âŒ File analysis stopped.' : `âŒ File analysis failed: ${err.message}`;
            }
        } else if (msgText) {
            showTypingAtNext();
            try {
                const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                const res = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }),
                    signal
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || "Server error.");
                finalResponse = data.response;
            } catch (err) {
                finalResponse = err.name === 'AbortError' ? 'âŒ Response stopped.' : `âŒ An error occurred: ${err.message}`;
            }
        }

        removeTyping();
        if (finalResponse) {
            await startTypewriter(finalResponse);
        }

        stopButton.replaceWith(sendBtn);
        currentController = null;
        activateAiActivity(false);
    });

    // --- Theme Switching Logic ---
    const themes = {
        cosmic: {
            '--neon-blue': '#00f2ff', '--neon-purple': '#bd00ff', '--neon-pink': '#ff007f',
            '--plasma-gradient-btn': 'linear-gradient(135deg, #00f2ff, #bd00ff)',
            '--plasma-gradient-bubble-ai': 'linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8))',
            '--plasma-gradient-bubble-user': 'linear-gradient(135deg, rgba(0, 242, 255, 0.3), rgba(189, 0, 255, 0.3))',
            '--glass-bg-strong': 'rgba(20, 20, 35, 0.7)', '--glass-bg-light': 'rgba(255, 255, 255, 0.08)',
            '--glass-border': 'rgba(255, 255, 255, 0.15)',
            '--text-glow': '0 0 10px rgba(0, 242, 255, 0.7), 0 0 20px rgba(189, 0, 255, 0.5)',
            '--box-glow-blue': '0 0 15px rgba(0, 242, 255, 0.4), 0 0 30px rgba(0, 242, 255, 0.2)',
            '--box-glow-purple': '0 0 15px rgba(189, 0, 255, 0.4), 0 0 30px rgba(189, 0, 255, 0.2)',
            '--header-glass': 'rgba(10, 10, 25, 0.85)',
            '--code-bg': 'rgba(10, 10, 30, 0.9)', '--code-border': '#00f2ff', '--code-text': '#e0f8ff',
            '--main-text': '#e0f8ff', '--link-text': '#00f2ff', '--input-bg': 'var(--glass-bg-light)',
            '--submit-bg': 'var(--plasma-gradient-btn)', '--submit-text': '#000',
            '--submit-hover-bg': 'linear-gradient(135deg, #bd00ff, #00f2ff)', '--submit-hover-text': '#fff',
            '--panel-bg': 'rgba(10, 10, 30, 0.9)', '--panel-border': '#00f2ff', '--panel-shadow': '0 0 40px rgba(0, 242, 255, 0.3)',
            '--button-glow-active': '0 0 15px #00f2ff, 0 0 25px #bd00ff',
            '--call-bg': 'linear-gradient(135deg, rgba(5, 7, 20, 0.95), rgba(10, 0, 30, 0.95))',
        },
        solar: {
            '--neon-blue': '#ffcc00', '--neon-purple': '#ff6600', '--neon-pink': '#ff0033',
            '--plasma-gradient-btn': 'linear-gradient(135deg, #ffcc00, #ff6600)',
            '--plasma-gradient-bubble-ai': 'linear-gradient(135deg, rgba(60, 40, 0, 0.6), rgba(40, 20, 0, 0.8))',
            '--plasma-gradient-bubble-user': 'linear-gradient(135deg, rgba(255, 204, 0, 0.3), rgba(255, 102, 0, 0.3))',
            '--glass-bg-strong': 'rgba(40, 20, 0, 0.7)', '--glass-bg-light': 'rgba(255, 255, 255, 0.08)',
            '--glass-border': 'rgba(255, 255, 255, 0.15)',
            '--text-glow': '0 0 10px rgba(255, 204, 0, 0.7), 0 0 20px rgba(255, 102, 0, 0.5)',
            '--box-glow-blue': '0 0 15px rgba(255, 204, 0, 0.4), 0 0 30px rgba(255, 204, 0, 0.2)',
            '--box-glow-purple': '0 0 15px rgba(255, 102, 0, 0.4), 0 0 30px rgba(255, 102, 0, 0.2)',
            '--header-glass': 'rgba(20, 10, 0, 0.85)',
            '--code-bg': 'rgba(30, 15, 0, 0.9)', '--code-border': '#ffcc00', '--code-text': '#fff8e0',
            '--main-text': '#fff8e0', '--link-text': '#ffcc00', '--input-bg': 'var(--glass-bg-light)',
            '--submit-bg': 'var(--plasma-gradient-btn)', '--submit-text': '#000',
            '--submit-hover-bg': 'linear-gradient(135deg, #ff6600, #ffcc00)', '--submit-hover-text': '#fff',
            '--panel-bg': 'rgba(30, 15, 0, 0.9)', '--panel-border': '#ffcc00', '--panel-shadow': '0 0 40px rgba(255, 204, 0, 0.3)',
            '--button-glow-active': '0 0 15px #ffcc00, 0 0 25px #ff6600',
            '--call-bg': 'linear-gradient(135deg, rgba(20, 10, 0, 0.95), rgba(30, 0, 0, 0.95))',
        },
        abyss: {
            '--neon-blue': '#00e6e6', '--neon-purple': '#009999', '--neon-pink': '#006666',
            '--plasma-gradient-btn': 'linear-gradient(135deg, #00e6e6, #009999)',
            '--plasma-gradient-bubble-ai': 'linear-gradient(135deg, rgba(0, 40, 40, 0.6), rgba(0, 20, 20, 0.8))',
            '--plasma-gradient-bubble-user': 'linear-gradient(135deg, rgba(0, 230, 230, 0.3), rgba(0, 153, 153, 0.3))',
            '--glass-bg-strong': 'rgba(0, 20, 20, 0.7)', '--glass-bg-light': 'rgba(255, 255, 255, 0.08)',
            '--glass-border': 'rgba(255, 255, 255, 0.15)',
            '--text-glow': '0 0 10px rgba(0, 230, 230, 0.7), 0 0 20px rgba(0, 153, 153, 0.5)',
            '--box-glow-blue': '0 0 15px rgba(0, 230, 230, 0.4), 0 0 30px rgba(0, 230, 230, 0.2)',
            '--box-glow-purple': '0 0 15px rgba(0, 153, 153, 0.4), 0 0 30px rgba(0, 153, 153, 0.2)',
            '--header-glass': 'rgba(0, 10, 10, 0.85)',
            '--code-bg': 'rgba(0, 15, 15, 0.9)', '--code-border': '#00e6e6', '--code-text': '#e0ffff',
            '--main-text': '#e0ffff', '--link-text': '#00e6e6', '--input-bg': 'var(--glass-bg-light)',
            '--submit-bg': 'var(--plasma-gradient-btn)', '--submit-text': '#000',
            '--submit-hover-bg': 'linear-gradient(135deg, #009999, #00e6e6)', '--submit-hover-text': '#fff',
            '--panel-bg': 'rgba(0, 15, 15, 0.9)', '--panel-border': '#00e6e6', '--panel-shadow': '0 0 40px rgba(0, 230, 230, 0.3)',
            '--button-glow-active': '0 0 15px #00e6e6, 0 0 25px #009999',
            '--call-bg': 'linear-gradient(135deg, rgba(0, 7, 7, 0.95), rgba(0, 10, 10, 0.95))',
        }
    };
    let currentThemeIdx = 0;
    const themeKeys = Object.keys(themes);

    function applyTheme(themeName) {
        const theme = themes[themeName];
        if (!theme) return;
        for (const key in theme) {
            document.documentElement.style.setProperty(key, theme[key]);
        }
        localStorage.setItem('philadelphia-theme', themeName);

        const icon = themeName === 'solar' ? 'fa-sun' : (themeName === 'abyss' ? 'fa-water' : 'fa-star-and-moon');
        themeBtn.innerHTML = `<i class="fa-solid ${icon}"></i>`;
    }

    themeBtn.addEventListener('click', () => {
        currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
        applyTheme(themeKeys[currentThemeIdx]);
    });

    const savedTheme = localStorage.getItem('philadelphia-theme');
    if (savedTheme && themes[savedTheme]) {
        currentThemeIdx = themeKeys.indexOf(savedTheme);
        applyTheme(savedTheme);
    } else {
        applyTheme('cosmic'); // Default theme
    }

    // --- Voice Call Functionality Logic ---
    let speechRecognition;
    let isCallActive = false;
    let callHistory = [];
    let botIsSpeaking = false;
    let userSaidSomething = false;
    let currentAudio = null;
    let isMuted = false;

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
        speechRecognition = new SpeechRecognition();
        speechRecognition.continuous = true;
        speechRecognition.interimResults = true;
        speechRecognition.lang = 'en-US';

        speechRecognition.onresult = (event) => {
            let interimTranscript = '';
            let finalTranscript = '';
            userSaidSomething = true;
            userAudioVisualizer.classList.add('active'); // Activate visualizer
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    finalTranscript += event.results[i][0].transcript;
                } else {
                    interimTranscript += event.results[i][0].transcript;
                }
            }

            let userMsgEl = callConversation.querySelector('.call-msg.user.interim');
            if (!userMsgEl) {
                userMsgEl = document.createElement('div');
                userMsgEl.className = 'call-msg user interim';
                callConversation.appendChild(userMsgEl);
            }
            userMsgEl.textContent = finalTranscript || interimTranscript;
            callConversation.scrollTop = callConversation.scrollHeight;

            callStatusMessage.textContent = finalTranscript ? 'User Speaking (Final)' : 'User Speaking...';
            tapToTalk.style.display = 'none';
        };

        speechRecognition.onspeechend = () => {};

        speechRecognition.onend = () => {
            userAudioVisualizer.classList.remove('active'); // Deactivate visualizer
            if (!isCallActive) return;
            if (isMuted) {
                callStatusMessage.textContent = 'Microphone Muted.';
                tapToTalk.style.display = 'none';
                return;
            }

            let finalTranscript = '';
            const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
            if (userMsgEl) {
                finalTranscript = userMsgEl.textContent.trim();
                userMsgEl.classList.remove('interim');
            }

            if (botIsSpeaking) {
                // Bot is speaking, just wait for it to finish and restart listening (in speakBotResponse)
            } else if (finalTranscript && userSaidSomething) {
                userSaidSomething = false;
                callHistory.push({ role: 'user', content: finalTranscript });
                handleCallBotResponse();
            } else {
                if (isCallActive && !isMuted) {
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
                }
            }
        };

        speechRecognition.onerror = (event) => {
            userAudioVisualizer.classList.remove('active');
            console.error('Speech recognition error', event.error);
            if (event.error === 'no-speech' && isCallActive && !isMuted) {
                userSaidSomething = false;
                speechRecognition.stop();
            } else if (event.error === 'network' && isCallActive) {
                callStatusMessage.textContent = 'Network error. Attempting restart...';
                speechRecognition.stop();
            } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                callStatusMessage.textContent = 'Microphone permission denied. Please allow in browser settings.';
                endCall();
            }
        };
    } else {
        callBtn.style.display = 'none';
        console.warn("Speech Recognition not supported in this browser.");
    }

    function addCallMessage(role, text) {
        const msgEl = document.createElement('div');
        msgEl.className = `call-msg ${role}`;
        msgEl.textContent = text;
        callConversation.appendChild(msgEl);
        callConversation.scrollTop = callConversation.scrollHeight;
    }

    async function handleCallBotResponse() {
        if (!isCallActive) return;
        activateAiActivity(true);
        callStatusMessage.textContent = 'Philadelphia AI is thinking...';
        tapToTalk.style.display = 'none';
        const historyForBot = callHistory.map(m => m);
        const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : "";

        try {
            speechRecognition.stop();
            const res = await fetch(`${API_BASE_URL}/chat`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: userMessage, history: historyForBot.slice(0, -1), user_id: currentUser?.uid || "user" })
            });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || "Server error.");
            const botResponse = data.response;
            callHistory.push({ role: 'ai', content: botResponse });
            addCallMessage('bot', botResponse);

            // Clean bot response for speech (remove markdown, "click here", etc. - for blunt responses)
            const speechText = botResponse.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '$1') // Remove markdown links, keep text
                                        .replace(/```[\s\S]*?```/g, 'code snippet') // Replace code blocks with "code snippet"
                                        .replace(/\*\*([^*]+?)\*\*/g, '$1') // Remove bold
                                        .replace(/\*([^*]+?)\*/g, '$1') // Remove italics
                                        .replace(/<br>/g, '. '); // Replace <br> with period for pauses
            speakBotResponse(speechText);
        } catch (err) {
            const errorMsg = `âŒ Call error: ${err.message}`;
            addCallMessage('bot', errorMsg);
            if (isCallActive && !isMuted) {
                callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                tapToTalk.style.display = 'block';
                try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
            }
        } finally {
            activateAiActivity(false);
        }
    }

    async function speakBotResponse(text) {
        if (!isCallActive) return;
        botIsSpeaking = true;
        botImageContainer.classList.add('speaking');
        callStatusMessage.textContent = 'Philadelphia AI is speaking...';
        try {
            const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ text: text, voice_id: 'elder' }) // Using 'elder' for Philadelphia AI's voice
            });
            if (!res.ok) throw new Error(await res.text());
            const blob = await res.blob();
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            currentAudio = audio;
            audio.onended = audio.onerror = () => {
                botIsSpeaking = false;
                botImageContainer.classList.remove('speaking');
                currentAudio = null;
                if (isCallActive && !isMuted) {
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
                } else if (isMuted) {
                    callStatusMessage.textContent = 'Microphone Muted.';
                    tapToTalk.style.display = 'none';
                }
            };
            audio.play();
        } catch (err) {
            console.error("Voice gen error:", err);
            botIsSpeaking = false;
            botImageContainer.classList.remove('speaking');
            if (isCallActive && !isMuted) {
                callStatusMessage.textContent = 'Listening (Voice Failed)...';
                tapToTalk.style.display = 'block';
                try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
            } else if (isMuted) {
                callStatusMessage.textContent = 'Microphone Muted.';
                tapToTalk.style.display = 'none';
            }
        }
    }

    function stopBotSpeakingAndStartListening() {
        if (!isCallActive || !botIsSpeaking) return;
        if (currentAudio) {
            currentAudio.pause();
            currentAudio.currentTime = 0;
            currentAudio = null;
        }
        botIsSpeaking = false;
        botImageContainer.classList.remove('speaking');
        if (!isMuted) {
            callStatusMessage.textContent = 'Listening... (Tap to Speak)';
            tapToTalk.style.display = 'block';
            try {
                speechRecognition.stop();
                speechRecognition.start();
            } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
        } else {
            callStatusMessage.textContent = 'Microphone Muted.';
            tapToTalk.style.display = 'none';
        }
        const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
        if (userMsgEl) userMsgEl.textContent = ''; // Clear interim text immediately
    }

    callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
    callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);

    callBtn.addEventListener('click', () => {
        if (!SpeechRecognition) {
            alert("Sorry, your browser doesn't support the Speech Recognition needed for this feature.");
            return;
        }
        isCallActive = true;
        isMuted = false;
        muteCallBtn.classList.remove('muted');
        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
        callModal.classList.add('active');
        callConversation.innerHTML = '<div class="call-msg status">Connecting to Philadelphia AI...</div>'; // Initial message
        callStatusMessage.textContent = 'Calling...';
        tapToTalk.style.display = 'none';
        callHistory = [];
        setTimeout(() => {
            if (!isCallActive) return;
            addCallMessage('status', 'Call Connected. Speak when ready.');
            callStatusMessage.textContent = 'Listening... (Tap to Speak)';
            tapToTalk.style.display = 'block';
            try { speechRecognition.start(); } catch(e) { console.error("Speech recognition start failed", e); callStatusMessage.textContent = 'Microphone error. Check permissions.'; }
        }, 1500);
    });

    function endCall() {
        isCallActive = false;
        botIsSpeaking = false;
        if (currentAudio) {
            currentAudio.pause();
            currentAudio.currentTime = 0;
            currentAudio = null;
        }
        callModal.classList.remove('active');
        try { speechRecognition.stop(); } catch(e) {}
        botImageContainer.classList.remove('speaking');
        tapToTalk.style.display = 'none';
        callStatusMessage.textContent = 'Call Ended.';
        userAudioVisualizer.classList.remove('active');
        activateAiActivity(false);
    }

    endCallBtn.addEventListener('click', endCall);

    if (muteCallBtn) {
        muteCallBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            if (isMuted) {
                muteCallBtn.classList.add('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute Microphone';
                speechRecognition.stop();
                callStatusMessage.textContent = 'Microphone Muted.';
                tapToTalk.style.display = 'none';
                userAudioVisualizer.classList.remove('active');
            } else {
                muteCallBtn.classList.remove('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
                if (isCallActive && !botIsSpeaking) {
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
                } else if (isCallActive && botIsSpeaking) {
                    callStatusMessage.textContent = 'Philadelphia AI is speaking...';
                    tapToTalk.style.display = 'none';
                }
            }
        });
    }

    // Set initial focus
    if(chatInput) chatInput.focus();
});
</script>
            </body>
            </html>


                <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
