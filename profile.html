<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Philadelphia AI Chat - The Future of Interaction</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <!-- Favicon for a professional touch -->
    <link rel="icon" href="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" type="image/jpeg">

    <!-- Google Fonts: Orbitron for techy titles, Inter/Roboto for modern readability, JetBrains Mono for code -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <!-- Font Awesome for sleek icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <!-- Highlight.js for beautiful code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>

    <style>
        /* --- Root Variables for Theming (Dynamic Theme Management) --- */
        :root {
            /* Default "Cyber" theme - Vibrant and futuristic */
            --cyan: #00fff7;
            --blue: #0a8afe;
            --dark-bg: #070b1a;
            --fade-blue: #133c8b;
            --gradient-1: linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%); /* AI message bubble */
            --gradient-user: linear-gradient(120deg, #0857ee 32%, #00fff0 89%); /* User message bubble */
            --glass: rgba(25, 38, 67, 0.82); /* General glass effect background */
            --bubble-glow: 0 0 13px #00d8ffb1, 0 0 24px #0197ff40; /* AI bubble shadow */
            --user-glow: 0 0 22px #0fffd555, 0 0 14px #36f9ff70; /* User bubble shadow */
            --header-glass: rgba(17,29,47,0.92); /* Header background */
            --code-bg: linear-gradient(92deg,#031d39 79%,#092ff8 120%); /* Code block background */
            --code-border: #15faff;
            --code-text: #17fafd;
            --main-text: #e1fafe; /* Primary text color */
            --link-text: #13efff;
            --input-bg: #09284c; /* Chat input background */
            --body-bg: radial-gradient(circle at 60% 45%, #112250 37%, #060e1e 88%, #1e0942 100%) fixed, repeating-linear-gradient(100deg,#061c4c 0 9%,#080e20 16% 19%,#030721 30% 41%,#052650 44% 62%,#050b16 74% 89%,#041048 99% 100%);
            --body-blend-mode: lighten, color-dodge;
            --panel-bg: linear-gradient(118deg,#131642 80%,#1629af 200%); /* Side panel background */
            --panel-border: #00fbffcb;
            --panel-shadow: 0 0 42px #25f8ffc9;
            --submit-bg: linear-gradient(94deg,#00ffff,#0090ff 90%); /* Submit button background */
            --submit-text: #102649;
            --submit-hover-bg: #008cff;
            --submit-hover-text: #fff;
            --header-text-glow: 0 0 12px #00ffe0cc, 0 0 27px #178fcf88; /* Header text glow static */
            --header-text-anim-glow-1: 0 0 17px #00e7ff70,0 0 30px #0b8fff44; /* Header text glow animation state 1 */
            --header-text-anim-glow-2: 0 0 29px #00ffe9ee,0 0 44px #31d2ff82; /* Header text glow animation state 2 */
            --header-text-fill: linear-gradient(90deg,#00fff1,#00b4ff 40%,#fff 59%,#1093f1 89%,#24e0fa 100%); /* Header text gradient */
        }

        /* --- Base & Layout Styles --- */
        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            color: var(--main-text);
            background: var(--body-bg);
            background-blend-mode: var(--body-blend-mode);
            font-family: 'Roboto', 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            transition: background 0.3s ease; /* Smooth theme transitions */
            overflow: hidden; /* Prevent body scroll, main-content handles it */
        }

        /* --- Starfield Background --- */
        #stars-container {
            pointer-events: none;
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1; /* Below content, above body bg */
            overflow: hidden;
        }

        .star {
            position: absolute;
            background: var(--cyan);
            box-shadow: 0 0 12px var(--cyan), 0 0 22px var(--cyan);
            opacity: 0.23;
            border-radius: 50%;
            pointer-events: none;
            animation: star-twinkle 2.7s infinite alternate;
        }

        @keyframes star-twinkle {
            0% { opacity: .18; }
            41% { opacity: .88; }
            100% { opacity: .09; }
        }

        /* --- Header Bar --- */
        .header-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--header-glass);
            z-index: 1003;
            padding: 0;
            box-shadow: 0 7px 48px #00aaff27, 0 3px 41px #09fcfe15;
            border-radius: 0 0 22px 22px;
            height: 70px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        .menu-btn {
            background: none;
            border: none;
            color: var(--cyan);
            font-size: 2em;
            cursor: pointer;
            border-radius: 14px;
            margin-left: 17px;
            margin-right: 3px;
            padding: 7px 11px;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .menu-btn:hover {
            background: #00eaff28;
            color: #fff;
        }

        /* Theme switcher button style - slightly smaller icon */
        #themeBtn {
            font-size: 1.6em;
            padding: 7px 12px;
            margin-left: -10px;
        }

        .header-titles {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1; /* Takes available space */
            padding-top: 5px; /* Adjust alignment with buttons */
        }

        .site-heading {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.28em;
            font-weight: 700;
            text-align: center;
            letter-spacing: .27px;
            white-space: nowrap;
            background: var(--header-text-fill);
            background-size: 250% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: neonglow 4.2s ease-in-out infinite alternate;
            text-shadow: var(--header-text-glow);
            user-select: none;
            margin-left: 8px;
            margin-right: 10px;
        }

        @keyframes neonglow {
            0% { text-shadow: var(--header-text-anim-glow-1); }
            100% { text-shadow: var(--header-text-anim-glow-2); }
        }

        .header-welcome {
            color: #68e6fd;
            font-size: .85em; /* Slightly smaller for secondary info */
            margin: 2px 0 .7em 0; /* Adjusted top margin */
            text-align: center;
            text-shadow: 0 0 10px #00bcb4a8; /* Softer glow */
            opacity: 0.9;
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }

        /* --- Main Content Area --- */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow-y: hidden; /* Handled by chat-box */
            position: relative;
            padding-top: 70px; /* Space for fixed header */
            padding-bottom: 86px; /* Space for input row */
            box-sizing: border-box;
        }

        .chat-box {
            flex: 1 1 0px; /* Allows chat-box to grow and shrink */
            overflow-y: auto;
            overflow-x: hidden;
            width: 100vw;
            max-width: 635px; /* Optimal reading width */
            margin: 0 auto;
            box-sizing: border-box;
            padding: 15px 8px; /* Padding for readability */
            position: relative;
            z-index: 3;
            scroll-behavior: smooth;
            display: flex;
            flex-direction: column;
        }

        /* Typing Indicator Container */
        #typing-status {
            display: none; /* Hidden by default */
            max-width: 635px;
            margin: 0 auto;
            padding: 0 8px 10px 8px; /* Consistent padding */
            width: 100vw;
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent it from collapsing */
            min-height: 20px; /* Give it some space */
        }

        /* --- Chat Messages --- */
        .chat-message {
            width: 100%;
            display: flex;
            gap: 9px;
            align-items: flex-end;
            margin: 8px 0;
            max-width: 100vw;
            flex-shrink: 0;
        }

        .chat-message .msg {
            font-size: 1.01em;
            line-height: 1.58;
            max-width: 62vw;
            min-width: 0;
            padding: 11px 16px 12px 15px;
            border-radius: 16px 14px 11px 12px;
            word-break: break-word;
            white-space: pre-wrap;
            overflow-x: auto;
            background: var(--gradient-1);
            color: var(--main-text);
            text-shadow: 0 0 3px #23d8ff15;
            box-shadow: var(--bubble-glow);
            margin-right: auto;
            margin-left: 0;
            border: 1.2px solid #0090ffa0;
            position: relative;
            transition: background 0.3s, color 0.3s, box-shadow 0.3s, border-color 0.3s;
        }

        .chat-message.user {
            justify-content: flex-end;
        }

        .chat-message.user .msg {
            background: var(--gradient-user);
            color: var(--submit-text); /* Often a dark contrast for user bubbles */
            font-weight: 700;
            text-shadow: 0 0 5px #00e0ff77, 0 0 2px #00ffe033;
            border-radius: 17px 13px 15px 11px;
            margin-left: auto;
            margin-right: 0;
            box-shadow: var(--user-glow);
            border: 1.2px solid #04eef4c9;
            max-width: 68vw;
        }

        /* --- Responsive Chat Bubbles --- */
        @media (max-width: 790px) {
            .chat-box {
                max-width: 100vw;
                padding: 15px 4px; /* More snug on mobile */
            }
            #typing-status {
                padding: 0 4px 10px 4px;
            }
            .chat-message .msg {
                font-size: .97em;
                padding: 9px 4vw 10px 5vw;
                max-width: 80vw;
            }
            .chat-message.user .msg {
                max-width: 83vw;
            }
        }

        /* --- Typing Indicator Animation --- */
        .typing-bubble {
            display: inline-flex;
            align-items: center;
            height: 28px;
            padding: 4px 12px;
            margin: 6px 4px;
            border-radius: 15px;
            background: linear-gradient(90deg, #0a4477dd 30%, #0ebfff88 95%);
            box-shadow: 0 2px 12px #0dfcff77;
            border: 1px solid #00ffff55;
        }

        .dot-anim {
            display: inline-block;
            width: 8px;
            height: 8px;
            margin: 0 3px;
            background: var(--cyan);
            border-radius: 50%;
            opacity: 0.85;
            animation: typing-blink 1.4s infinite both;
            box-shadow: 0 0 6px var(--cyan);
        }

        .dot-anim:nth-child(2) { animation-delay: .3s; }
        .dot-anim:nth-child(3) { animation-delay: .6s; }

        @keyframes typing-blink {
            0%, 100% { opacity: .25; transform: scale(0.8); }
            25% { opacity: .95; transform: scale(1.1); }
            50% { opacity: 1; transform: scale(1.2); }
            75% { opacity: .65; transform: scale(1); }
        }

        /* --- Code Blocks & Syntax Highlighting --- */
        pre, code {
            font-family: 'JetBrains Mono', 'Fira Mono', 'Menlo', monospace;
            font-size: .99em;
            background: var(--code-bg);
            border-radius: 11px;
            border: 1.7px solid var(--code-border);
            color: var(--code-text);
            box-shadow: 0 0 19px #00eaff38, 0 0 48px #0beaff38 inset;
            transition: background 0.3s, border-color 0.3s, color 0.3s;
        }

        pre {
            overflow-x: auto;
            padding: 1.18em 1.3em 1.16em 1.13em;
            margin: 1.15em 0 1em 0;
            position: relative;
        }

        pre:before {
            content: "CODE";
            color: var(--cyan);
            font-size: 0.82em;
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 5px;
            right: 29px;
            opacity: 0.17;
            letter-spacing: 0.13em;
            pointer-events: none;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 13px;
            z-index: 3;
            border-radius: 8px;
            border: none;
            padding: 3px 15px;
            background: linear-gradient(95deg, #0cf3ff 40%, #0980ff 120%);
            color: #06182f;
            font-size: .98em;
            font-family: 'Inter';
            font-weight: bold;
            box-shadow: 0 2px 9px #18e3ffc5, 0 0 7px #00ffd7a4;
            transition: background .15s, color .15s, box-shadow .15s;
            cursor: pointer;
            outline: none;
            border: 1px solid #0cf3ff35;
        }

        .copy-btn:hover {
            background: #008cee;
            color: #fff;
            box-shadow: 0 2px 12px #00d7ff, 0 0 9px #00f0ff;
        }

        /* --- Inline Action Buttons (Copy, Share, Regen, Edit) --- */
        .inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn {
            padding: 4px 10px;
            border-radius: 7px;
            border: none;
            background: var(--submit-bg);
            color: var(--submit-text);
            font-family: 'Inter', Arial, sans-serif;
            font-size: .96em;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-top: 6px;
            margin-right: 3px;
            cursor: pointer;
            box-shadow: 0 2px 7px #17f6fe51;
            transition: background .14s, color .13s, box-shadow .14s;
        }

        .inline-copy-btn:hover, .inline-share-btn:hover, .regen-btn:hover, .inline-edit-btn:hover {
            background: var(--submit-hover-bg);
            color: var(--submit-hover-text);
            box-shadow: 0 2px 10px var(--submit-hover-bg);
        }

        /* --- File Attachments & Previews --- */
        .file-attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 8px 0;
            max-width: 100%;
        }

        .chat-media-preview {
            max-width: 100%;
            max-height: 250px;
            border-radius: 12px;
            display: block;
            object-fit: contain; /* Ensures media fits without cropping */
        }

        .image-preview-thumb, .video-preview-thumb {
            border: 2px solid var(--cyan);
            box-shadow: 0 0 10px var(--cyan);
        }

        .chat-message.ai .msg img.chat-media-preview {
            cursor: zoom-in; /* Indicate clickable image for lightbox */
        }

        .audio-preview-thumb {
            width: 90%;
            min-height: 40px;
            border-radius: 10px;
        }

        .file-link, .file-placeholder {
            display: inline-block;
            padding: 8px 12px;
            background: #0b2447;
            border: 1px solid #1af8ff51;
            border-radius: 10px;
            color: var(--cyan);
            text-decoration: none;
            font-size: 0.9em;
            font-weight: bold;
            display: flex; /* Align icon and text */
            align-items: center;
        }

        .file-link i, .file-placeholder i {
            margin-right: 5px;
        }

        .file-preview {
            display: none;
            background: rgba(15, 36, 65, 0.98);
            border-radius: 12px;
            color: #c4f2ff;
            font-size: .98em;
            box-shadow: 0 3px 15px #00aac0bb;
            margin: 0 auto 10px auto;
            width: 94vw;
            max-width: 520px;
            padding: 10px 14px 10px 15px;
            position: fixed;
            bottom: 100px; /* Position above the input bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            border: 1.5px solid #00ffff44;
        }

        .file-preview img, .file-preview video {
            max-width: 58px;
            max-height: 41px;
            border-radius: 6px;
            margin-right: 6px;
            vertical-align: middle;
        }

        .file-preview audio {
            width: 52px;
            margin-right: 7px;
        }

        .remove-file-btn {
            color: #fff !important;
            background: #d23 !important;
            border: none !important;
            border-radius: 50% !important;
            padding: 2px 6px !important;
            cursor: pointer !important;
            font-size: 1.2em !important;
            font-weight: bold !important;
            margin-left: 8px !important;
            transition: background .16s, color .16s, transform .16s !important;
            min-width: 24px !important;
            height: 24px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .remove-file-btn:hover {
            background: #ff4444 !important;
            color: #fff !important;
            transform: scale(1.1) !important;
        }

        /* --- Chat Input Row --- */
        .chat-input-row {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 0;
            display: flex;
            align-items: stretch;
            gap: 8px;
            background: rgba(17, 29, 47, 0.94);
            backdrop-filter: blur(8px);
            border: 1.5px solid #1af8ff51;
            border-radius: 23px 23px 0 0; /* Rounded top, sharp bottom for sleek fit */
            width: 95vw;
            max-width: 900px;
            padding: 9px 12px 10px 13px;
            box-shadow: 0 0 39px #007fff22, 0 11px 33px #00fff014;
            z-index: 1003;
        }

        @media (max-width: 920px) {
            .chat-input-row {
                width: 95vw;
                max-width: 100%;
                left: 50%;
                transform: translateX(-50%);
                border-radius: 22px 22px 8px 8px; /* Slightly rounded bottom on smaller screens */
            }
        }

        .chat-input-row textarea {
            flex: 1 1 auto;
            resize: none;
            min-height: 36px;
            max-height: 120px; /* Limit height to prevent excessive scrolling */
            background: var(--input-bg);
            color: var(--main-text);
            font-size: 1em;
            padding: 10px 12px;
            border: none;
            border-radius: 11px;
            box-shadow: 0 1px 6px #00f2ff27;
            transition: background 0.3s, color 0.3s, box-shadow 0.3s;
        }

        .chat-input-row button, .chat-input-row label {
            background: none;
            border: none;
            color: var(--cyan);
            font-size: 1.21em;
            cursor: pointer;
            border-radius: 10px;
            transition: color .13s, background .15s, box-shadow .15s;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 33px;
            box-shadow: 0 0 3px #00eaff20;
        }

        .chat-input-row button:hover, .chat-input-row label:hover {
            color: #fff;
            background: #00cdf247;
            box-shadow: 0 0 7px #00eaff50;
        }

        /* Call button specific style */
        #callBtn {
            font-size: 1.1em;
        }

        #stopBtn {
            background: #ff4d4d;
            color: white;
            font-size: 1.2em;
            border-radius: 10px;
            padding: 0;
            min-width: 33px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px #ff4d4d88;
            transition: background .1s, color .1s, box-shadow .1s;
        }

        #stopBtn:hover {
            background: #ff7777;
            box-shadow: 0 0 15px #ff7777aa;
        }

        /* --- Emoji Panel --- */
        #emojiPanel {
            display: none;
            position: fixed;
            left: 10px;
            bottom: 110px; /* Position above input bar */
            z-index: 2222;
            background: #051f46f9;
            border-radius: 15px;
            padding: 16px 15px 12px 15px;
            box-shadow: 0 5px 22px #00fff194;
            border: 1px solid #00ffff66;
            animation: fadeIn 0.2s ease-out; /* Smooth entrance */
        }

        .emoji-pick {
            font-size: 1.23em;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 10px;
            transition: background .13s;
            user-select: none;
        }

        .emoji-pick:hover {
            background: #35cdfd66;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Status Messages (e.g., loading, errors) --- */
        .status-message {
            padding: 6px 13px;
            color: #12ffc7;
            font-size: .98em;
            min-height: 17px;
            text-align: center;
            margin: 4px auto 0 auto;
            max-width: 430px;
            word-break: break-word;
            opacity: 0.9;
        }

        /* --- Side Panels (Profile, Links, Tools) & Modals --- */
        .panel-bg {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(13, 20, 52, 0.86);
            z-index: 1200;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .panel-bg.active {
            display: block;
            opacity: 1;
        }

        .side-panel {
            position: absolute;
            top: 0;
            left: -325px; /* Hidden by default */
            height: 100vh;
            width: 325px;
            background: var(--panel-bg);
            border-right: 2.5px solid var(--panel-border);
            box-shadow: var(--panel-shadow);
            z-index: 1212;
            padding: 18px 16px 20px 15px;
            overflow-y: auto;
            border-radius: 0 24px 32px 0;
            transition: left 0.3s ease-out, background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .panel-bg.active .side-panel {
            left: 0; /* Slide in */
        }

        .side-panel .panel-header {
            text-align: center;
            margin: 18px 0 13px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        .side-panel img {
            width: 56px;
            height: 56px;
            border-radius: 53%;
            margin-bottom: 8px;
            border: 2px solid #31f6ffea;
            object-fit: cover;
        }

        .side-panel .username {
            font-weight: 700;
            font-size: 1.11em;
            color: #08d0fe;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 8px #00eaffbb;
        }

        .side-panel .email {
            font-size: .97em;
            color: #a8eaff;
        }

        .panel-links a {
            color: var(--link-text);
            text-decoration: none;
            font-weight: 500;
            font-size: 1.08em;
            padding: 8px 12px; /* Increased padding for easier clicking */
            display: flex;
            align-items: center;
            gap: 12px;
            border-radius: 9px;
            transition: background .14s, color .14s;
            margin-bottom: 5px; /* Spacing between links */
        }

        .panel-links a:hover {
            background: #00eaff55;
            color: #f4fdff;
        }

        .panel-links a i {
            width: 20px;
            text-align: center;
            font-size: 1.1em; /* Slightly larger icons */
        }

        /* Chat List in Profile Menu */
        #chatsList {
            margin: 7px 0 8px 6px;
            max-height: 161px;
            overflow-y: auto;
            padding-right: 5px; /* Prevent scrollbar from overlapping text */
        }

        #chatsList div {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            background: transparent;
            border-radius: 8px;
            transition: background 0.2s ease;
        }

        #chatsList div:hover {
            background: rgba(0, 234, 255, 0.08); /* Subtle hover */
        }

        #chatsList .selected-chat {
            background: rgba(0, 234, 255, 0.15); /* Highlight selected chat */
        }

        #chatsList span {
            flex: 1;
            cursor: pointer;
            padding: 8px 5px;
            color: var(--main-text);
            font-size: 1.05em;
        }

        #chatsList button {
            background: none;
            border: none;
            cursor: pointer;
            outline: none;
            font-size: 1.11em;
            margin: 0 5px;
            vertical-align: middle;
            border-radius: 7px;
            padding: 3px 5px;
            transition: color .13s, background .13s;
        }

        #chatsList .fa-pen { color: #0fe0ee; }
        #chatsList .fa-pen:hover { color: #ffd800; background: rgba(255, 215, 0, 0.1); }
        #chatsList .fa-trash { color: #ff244e; }
        #chatsList .fa-trash:hover { color: #fff900; background: rgba(255, 0, 0, 0.1); }
        /* Removed fa-play as it was unused and confusing for chat list */

        /* Edit Forms (Profile, Tool) */
        .edit-form label {
            display: block;
            margin-top: 10px;
            font-size: .99em;
            color: #38e4ff;
            text-shadow: 0 1px 14px #11aaff71;
        }

        .edit-form input, .edit-form textarea, .edit-form select {
            width: 99%;
            padding: 7px 11px;
            margin-top: 5px;
            border: 1.7px solid #13f0ff95;
            border-radius: 9px;
            background: #071f35;
            color: #fff;
            font-size: 1.02em;
            box-shadow: 0 0 8px #04f6fd81 inset;
            transition: border-color .17s, box-shadow .17s, background .17s;
        }

        .edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus {
            border-color: #27eeff;
            background: #273f5d;
            color: #fff;
            outline: none;
            box-shadow: 0 0 12px #27eeff80 inset;
        }

        .edit-form textarea {
            resize: vertical;
            min-height: 80px;
        }

        .submit-btn {
            margin-top: 14px;
            padding: 10px 20px;
            background: var(--submit-bg);
            border: none;
            border-radius: 10px;
            color: var(--submit-text);
            font-weight: bold;
            cursor: pointer;
            font-size: 1.11em;
            box-shadow: 0 2px 13px #00fff292;
            transition: background .14s, color .13s, box-shadow .14s, transform .1s;
        }

        .submit-btn:hover {
            background: var(--submit-hover-bg);
            color: var(--submit-hover-text);
            box-shadow: 0 2px 16px var(--submit-hover-bg);
            transform: translateY(-1px);
        }

        .submit-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #555 !important;
            box-shadow: none;
            transform: none;
        }

        /* --- Lightbox for Images --- */
        #lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            z-index: 5000;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #lightbox.active {
            display: flex;
            opacity: 1;
        }

        #lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            border: 2px solid var(--cyan);
            border-radius: 10px;
            box-shadow: 0 0 50px var(--cyan);
            object-fit: contain;
            transition: transform 0.2s ease;
        }

        /* --- AI Image Preview (Floating) --- */
        #ai-image-preview {
            display: none;
            position: fixed;
            z-index: 1210;
            right: 22px;
            bottom: 100px; /* Above input bar */
            max-width: 320px;
            background: #191a26e9;
            padding: 12px;
            border-radius: 17px;
            box-shadow: 0 2px 19px #00fff2b8;
            border: 1px solid rgba(0, 255, 247, 0.3);
            animation: slideInUp 0.3s ease-out;
        }

        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #ai-image-preview #ai-image-close {
            float: right;
            background: #23233a;
            border: none;
            border-radius: 7px;
            color: #00ffff;
            font-size: 1.5em;
            cursor: pointer;
            margin-left: 5px;
            transition: background 0.2s, color 0.2s;
        }

        #ai-image-preview #ai-image-close:hover {
            background: #00aaff;
            color: #fff;
        }

        #ai-image-preview #ai-image-container img {
            max-width: 100%; /* Fill container */
            height: auto;
            border-radius: 12px;
            display: block;
            margin: 0 auto;
            border: 1px solid var(--cyan);
            box-shadow: 0 0 10px var(--cyan);
        }

        #ai-image-preview #ai-image-dl {
            margin-top: 9px;
            padding: 7px 20px;
            background: linear-gradient(90deg, #00ffff, #0090ff);
            color: #222;
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 7px #00fff2c7;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        #ai-image-preview #ai-image-dl:hover {
            background: linear-gradient(90deg, #00d7ff, #007bff);
            box-shadow: 0 2px 10px #00bfff;
        }

        /* --- Voice Call Modal --- */
        #callModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--dark-bg);
            z-index: 4000;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Space out header, conversation, controls */
            padding: 20px;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #callModal.active {
            display: flex;
            opacity: 1;
        }

        #callHeader {
            color: var(--cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            text-shadow: 0 0 10px var(--cyan), 0 0 20px rgba(0, 255, 247, 0.4);
            margin-bottom: 20px;
            animation: neon-pulse 2s infinite alternate;
        }

        #botImageContainer {
            margin-top: 20px;
            position: relative;
        }

        #botImageContainer img {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid var(--cyan);
            box-shadow: 0 0 30px var(--cyan);
            transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            object-fit: cover;
        }

        @keyframes head-nod {
            0% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
            100% { transform: translateY(0); }
        }

        @keyframes glow-spread {
            0% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; }
            50% { box-shadow: 0 0 30px #00ff00, 0 0 50px #00ff0088; opacity: 1; }
            100% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; }
        }

        #botImageContainer.speaking img {
            border-color: #00ff00; /* Green border when speaking */
            box-shadow: 0 0 30px #00ff00, 0 0 50px rgba(0, 255, 0, 0.5);
            transform: scale(1.05);
            animation: head-nod 1.2s infinite ease-in-out;
        }

        #botSpeakingIndicator {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 160px;
            height: 160px;
            border-radius: 50%;
            border: 5px solid transparent;
            box-shadow: 0 0 20px var(--cyan);
            animation: pulse 1s infinite;
            display: none;
            z-index: -1;
        }

        #botImageContainer.speaking #botSpeakingIndicator {
            box-shadow: 0 0 30px #00ff00, 0 0 50px rgba(0, 255, 0, 0.5);
            border-color: #00ff00;
            display: block;
            animation: glow-spread 1.7s infinite ease-in-out;
        }

        #callStatusMessage {
            color: var(--cyan);
            font-size: 1.1em;
            margin-top: 15px;
            height: 30px;
            text-align: center;
            font-style: italic;
            text-shadow: 0 0 5px #00aaff;
            opacity: 0.8;
        }

        #tapToTalk {
            color: #ff00ff;
            font-size: 1.2em;
            margin-top: 5px;
            text-shadow: 0 0 8px #ff00ff, 0 0 15px rgba(255, 0, 255, 0.4);
            animation: neon-pulse 1.5s infinite alternate;
            display: none;
        }

        @keyframes neon-pulse {
            from { opacity: 0.7; transform: scale(1.0); }
            to { opacity: 1.0; transform: scale(1.02); }
        }

        @keyframes pulse {
            0% { opacity: 0; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0; transform: scale(1); }
        }

        #callConversation {
            flex-grow: 1;
            width: 100%;
            max-width: 600px;
            overflow-y: auto;
            margin: 20px 0;
            border: 1px solid var(--fade-blue);
            border-radius: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            box-shadow: inset 0 0 15px rgba(0, 255, 247, 0.1);
        }

        .call-msg {
            padding: 8px 12px;
            border-radius: 10px;
            margin-bottom: 10px;
            line-height: 1.5;
            word-break: break-word;
            opacity: 0.9;
            animation: messageFadeIn 0.3s ease-out;
        }

        @keyframes messageFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .call-msg.user {
            background: var(--gradient-user);
            color: var(--submit-text);
            text-align: right;
            margin-left: auto;
            max-width: 80%;
            box-shadow: 0 2px 8px rgba(8, 87, 238, 0.3);
        }

        .call-msg.bot {
            background: var(--gradient-1);
            color: var(--main-text);
            margin-right: auto;
            max-width: 80%;
            box-shadow: 0 2px 8px rgba(16, 191, 255, 0.2);
        }

        .call-msg.status {
            text-align: center;
            color: #888;
            font-style: italic;
            background: none;
            box-shadow: none;
        }

        #callControls {
            display: flex;
            gap: 20px;
            padding-bottom: 20px;
            margin-top: auto; /* Push controls to bottom */
        }

        #endCallBtn, #muteCallBtn {
            background: #d23;
            color: white;
            font-size: 1.2em;
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 10px #d2388;
            transition: background .1s, box-shadow .1s;
        }

        #endCallBtn:hover, #muteCallBtn:hover {
            background: #ff7777;
            box-shadow: 0 0 15px #ff7777aa;
        }

        #muteCallBtn {
            background: #007bff; /* Default blue for unmute */
            box-shadow: 0 0 10px #007bff88;
        }

        #muteCallBtn:hover {
            background: #0069d9;
        }

        #muteCallBtn.muted {
            background: #555; /* Grey when muted */
            box-shadow: none;
            color: #ccc;
        }

        #muteCallBtn.muted:hover {
            background: #777;
        }

        /* Spinner for loading states */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 247, 0.3);
            border-radius: 50%;
            border-top-color: var(--cyan);
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Starfield Background for immersive experience -->
    <div id="stars-container" aria-hidden="true"></div>

    <!-- Main Application Structure -->
    <div class="app-container">
        <!-- Header Bar with Navigation and User Info -->
        <header class="header-bar">
            <button class="menu-btn" id="openProfileMenu" aria-label="Open profile and chat history menu">
                <i class="fa-solid fa-user"></i>
            </button>
            <div class="header-titles">
                <h1 class="site-heading">ðŸ¦…Philadelphia AIðŸ¦…</h1>
                <p class="header-welcome" id="headerWelcome" aria-live="polite">Welcome, User</p>
            </div>
            <button class="menu-btn" id="themeBtn" aria-label="Change theme"><i class="fa-solid fa-moon"></i></button>
            <button class="menu-btn" id="openLinksMenu" aria-label="Open navigation links menu">
                <i class="fa-solid fa-link"></i>
            </button>
        </header>

        <!-- Main Content Area: Chat, Tools, etc. -->
        <main class="main-content">
            <!-- Chat Display Area -->
            <section class="chat-box" id="chatBox" role="log" aria-live="polite" aria-atomic="false"></section>

            <!-- Typing Status Indicator -->
            <div id="typing-status" class="chat-message ai" style="display: none;" aria-live="assertive" aria-atomic="true"></div>

            <!-- Chat Input Form -->
            <form class="chat-input-row" id="chatForm" autocomplete="off" aria-label="Chat input form">
                <button type="button" id="emojiBtn" title="Open emoji panel" aria-controls="emojiPanel" aria-expanded="false">
                    <i class="fa-regular fa-face-smile"></i>
                </button>
                <label for="chatFile" class="file-upload-btn" title="Attach file">
                    <i class="fa-solid fa-paperclip"></i>
                </label>
                <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none" aria-label="Attach files">
                <textarea id="chatInput" placeholder="Type hereâ€¦ (Shift+Enter = new line)" aria-label="Chat message input"></textarea>
                <button type="button" id="callBtn" title="Start Voice Call" aria-label="Start voice call">
                    <i class="fa-solid fa-phone"></i>
                </button>
                <button type="button" id="toolBtn" title="Open Philadelphia Tools" aria-controls="toolsMenu" aria-expanded="false">
                    <i class="fa-solid fa-wrench"></i>
                </button>
                <button type="submit" id="sendBtn" title="Send message" aria-label="Send message">
                    <i class="fa-solid fa-paper-plane"></i>
                </button>
            </form>
        </main>

        <!-- Dynamic UI Overlays and Modals -->

        <!-- Emoji Panel -->
        <div id="emojiPanel" role="menu" aria-labelledby="emojiBtn" style="display:none;"></div>

        <!-- Global Status Message (e.g., connection status) -->
        <div class="status-message" id="statusMsg" aria-live="assertive"></div>

        <!-- File Preview for Attachments -->
        <div id="filePreview" class="file-preview" aria-live="polite"></div>

        <!-- Profile & Chat History Side Panel -->
        <div class="panel-bg" id="profileMenuBg">
            <nav class="side-panel" id="profileMenu" role="navigation" aria-label="Profile and Chat History">
                <div style="display:flex;align-items:center;justify-content:space-between;padding-bottom:10px;border-bottom:1px solid rgba(0,255,247,0.2);">
                    <h2 style="font-size:1.17em;font-weight:700;color:#00ffff;margin:18px 0 0 13px;">Chats</h2>
                    <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;" onclick="profileMenuBg.classList.remove('active');" aria-label="Close profile menu">&times;</button>
                </div>
                <section id="chatsList" role="list" aria-label="Your chat history"></section>
                <button id="newChatBtn" class="submit-btn" style="margin:0 0 12px 11px;"><i class="fa-solid fa-plus"></i> New Chat</button>
                <hr style="width:91%;margin:11px 0 7px 3%;border:1px solid #00fff031;">
                <div class="panel-header">
                    <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Your profile photo">
                    <div class="username" id="profileMenuUser">User</div>
                    <div class="email" id="profileMenuEmail">email@example.com</div>
                </div>
                <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;" aria-label="Edit profile information">
                    <label for="edit-name">Name</label>
                    <input type="text" id="edit-name" required aria-label="Your name">
                    <label for="edit-photo">Photo URL</label>
                    <input type="url" id="edit-photo" placeholder="Paste image link" aria-label="URL for profile photo">
                    <span style="font-size:0.83em;color:#aae;display:block;margin:5px 0 7px 2px;">
                        Tip: <a href="https://postimg.cc/" target="_blank" rel="noopener noreferrer" style="color:#19fcff;">Upload at postimg.cc</a>
                    </span>
                    <button type="submit" class="submit-btn">Save Profile</button>
                    <div class="status-message" id="profileStatusMsg" aria-live="polite"></div>
                </form>
                <button class="submit-btn" id="logoutBtn" style="background:#10213b;color:#00eefd;margin:7px 7px 17px 7px;">Logout</button>
            </nav>
        </div>

        <!-- AI Image Floating Preview (for generated images) -->
        <aside id="ai-image-preview">
            <button id="ai-image-close" aria-label="Close image preview">&times;</button>
            <div id="ai-image-container"></div>
            <button id="ai-image-dl" aria-label="Download image">Download</button>
        </aside>

        <!-- Quick Links Side Panel -->
        <div class="panel-bg" id="linkMenuBg">
            <nav class="side-panel" id="linkMenu" role="navigation" aria-label="Quick Links">
                <div class="panel-header">
                    <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia AI logo">
                    <div class="username">Philadelphia AI</div>
                </div>
                <div class="panel-links">
                    <a href="philadelphia.html"><i class="fa-solid fa-home"></i> Philadelphia Homepage</a>
                    <a href="index.html"><i class="fa-solid fa-home"></i> Elvion Homepage</a>
                    <a href="about.html"><i class="fa-solid fa-circle-info"></i> About Us</a>
                    <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
                    <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms</a>
                    <a href="https://t.me/writingurubot" target="_blank" rel="noopener noreferrer"><i class="fab fa-telegram"></i> Try Telegram Version</a>
                </div>
            </nav>
        </div>

        <!-- Tools Menu Side Panel -->
        <div class="panel-bg" id="toolsMenuBg">
            <nav class="side-panel" id="toolsMenu" role="navigation" aria-label="Philadelphia AI Tools">
                <div class="panel-header" style="text-align:left;">
                    <h2 class="username" style="font-size:1.2em;margin-left:-8px;text-align:center;">Philadelphia AI Tools</h2>
                </div>
                <div class="panel-links">
                    <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Creative Suite</h3>
                    <a href="#" class="tool-link" data-tool="image" role="menuitem"><i class="fa-solid fa-image"></i> Generate Image</a>
                    <a href="#" class="tool-link" data-tool="edit-photo" role="menuitem"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
                    <a href="#" class="tool-link" data-tool="remove-bg" role="menuitem"><i class="fa-solid fa-scissors"></i> Remove Background</a>
                    <a href="#" class="tool-link" data-tool="comic" role="menuitem"><i class="fa-solid fa-book-open"></i> Create Comic</a>
                    <hr style="border-color: #00eaff30; margin: 10px 0;">
                    <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Audio & Video</h3>
                    <a href="#" class="tool-link" data-tool="voice-gen" role="menuitem"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
                    <a href="#" class="tool-link" data-tool="audio-narration" role="menuitem"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
                    <a href="#" class="tool-link" data-tool="video-text" role="menuitem"><i class="fa-solid fa-film"></i> Text-to-Video</a>
                    <a href="#" class="tool-link" data-tool="video-image" role="menuitem"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
                    <a href="#" class="tool-link" data-tool="music" role="menuitem"><i class="fa-solid fa-music"></i> Generate Music</a>
                    <hr style="border-color: #00eaff30; margin: 10px 0;">
                    <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Web & Research</h3>
                    <a href="#" class="tool-link" data-tool="website" role="menuitem"><i class="fa-solid fa-globe"></i> Create Website</a>
                    <a href="#" class="tool-link" data-tool="edit-website" role="menuitem"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
                    <a href="#" class="tool-link" data-tool="my-sites" role="menuitem"><i class="fa-solid fa-list-check"></i> My Websites</a>
                    <a href="#" class="tool-link" data-tool="research-report" role="menuitem"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
                </div>
                <button class="submit-btn" style="margin-top:17px;" onclick="closeToolMenu();" aria-label="Close tools menu">Close</button>
            </nav>
        </div>

        <!-- Tool Form Modal (appears when a tool is selected) -->
        <div class="panel-bg" id="toolFormModalBg">
            <nav class="side-panel" id="toolFormModal" role="dialog" aria-modal="true" aria-labelledby="toolFormTitle">
                <div class="panel-header">
                    <h2 class="username" id="toolFormTitle">Tool Title</h2>
                </div>
                <form class="edit-form" id="toolForm" style="padding:0 6px;" aria-label="Tool input form"></form>
                <button id="toolFormBackBtn" class="submit-btn" style="background:#10213b;color:#00eefd;margin:7px 7px 17px 7px;">
                    <i class="fa-solid fa-arrow-left"></i> Back to Tools
                </button>
                <div class="status-message" id="toolStatusMsg" aria-live="polite"></div>
            </nav>
        </div>

        <!-- Image Lightbox for large previews -->
        <div id="lightbox" role="dialog" aria-modal="true" aria-label="Image preview">
            <img src="" alt="Lightbox image">
        </div>

        <!-- Voice Call Modal -->
        <div id="callModal" role="dialog" aria-modal="true" aria-labelledby="callHeader">
            <h2 id="callHeader">Philadelphia AI - Live Call</h2>
            <div id="botImageContainer" role="status" aria-label="AI assistant status">
                <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="AI Bot Avatar">
                <div id="botSpeakingIndicator"></div>
            </div>
            <p id="callStatusMessage" aria-live="polite">Connecting...</p>
            <p id="tapToTalk" aria-live="polite">Tap Anywhere to Speak</p>
            <div id="callConversation" role="log" aria-live="polite">
                <div class="call-msg status">Waiting for connection...</div>
            </div>
            <div id="callControls">
                <button id="muteCallBtn" class="submit-btn" aria-label="Mute microphone"><i class="fa-solid fa-microphone"></i> Mute Microphone</button>
                <button id="endCallBtn" class="submit-btn" style="background: #d23;" aria-label="End call"><i class="fa-solid fa-phone-slash"></i> End Call</button>
            </div>
        </div>
    </div> <!-- .app-container end -->

    <!-- External Libraries (Keep at end of body for faster page load) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        // --- START OF FULLY REVAMPED & FIRESTORE-INTEGRATED JAVASCRIPT ---

        // =========================================================================
        // 1. Firebase Initialization & Configuration
        // =========================================================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        // Firebase configuration details - Replace with your actual project details
        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // API Base URL for backend services
        const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

        // =========================================================================
        // 2. Global State Management & Helper Functions
        // =========================================================================
        let chats = []; // Stores user's chat list: {id, name, createdAt}
        let currentChatId = null; // ID of the currently active chat
        let currentMessages = []; // Messages for the current chat: {id, role, text, files, createdAt}
        let uploadedFiles = []; // Files attached to the current message being composed
        let currentUser = null; // Firebase user object
        let currentController = null; // AbortController for cancelling ongoing API requests

        // Firestore listener unsubscribers to prevent memory leaks
        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;

        // Simple DOM element selector helper
        const $ = id => document.getElementById(id);

        // Utility to escape HTML for safe rendering
        const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

        // =========================================================================
        // 3. UI Element Selection (Centralized for clarity)
        // =========================================================================
        const UI = {
            starsContainer: $('stars-container'),
            profileMenuBg: $('profileMenuBg'),
            profileMenu: $('profileMenu'),
            linkMenuBg: $('linkMenuBg'),
            linkMenu: $('linkMenu'),
            toolsMenuBg: $('toolsMenuBg'),
            toolsMenu: $('toolsMenu'),
            toolBtn: $('toolBtn'),
            logoutBtn: $('logoutBtn'),
            headerWelcome: $('headerWelcome'),
            profileMenuUser: $('profileMenuUser'),
            profileMenuEmail: $('profileMenuEmail'),
            editName: $('edit-name'),
            editPhoto: $('edit-photo'),
            profilePicPreview: $('profilePicPreview'),
            profileForm: $('profileForm'),
            chatBox: $('chatBox'),
            chatForm: $('chatForm'),
            chatInput: $('chatInput'),
            sendBtn: $('sendBtn'),
            chatFile: $('chatFile'),
            filePreview: $('filePreview'),
            newChatBtn: $('newChatBtn'),
            chatsListEl: $('chatsList'),
            emojiPanel: $('emojiPanel'),
            emojiBtn: $('emojiBtn'),
            toolFormModalBg: $('toolFormModalBg'),
            toolForm: $('toolForm'),
            toolFormTitle: $('toolFormTitle'),
            toolFormBackBtn: $('toolFormBackBtn'),
            aiPrevBox: $('ai-image-preview'),
            aiPrevClose: $('ai-image-close'),
            aiPrevDLBtn: $('ai-image-dl'),
            aiPrevImgBox: $('ai-image-container'),
            themeBtn: $('themeBtn'),
            lightbox: $('lightbox'),
            callBtn: $('callBtn'),
            callModal: $('callModal'),
            endCallBtn: $('endCallBtn'),
            muteCallBtn: $('muteCallBtn'),
            callConversation: $('callConversation'),
            botImageContainer: $('botImageContainer'),
            callStatusMessage: $('callStatusMessage'),
            tapToTalk: $('tapToTalk'),
            typingStatus: $('typing-status'),
            statusMsg: $('statusMsg') // Global status message
        };

        // Ensure critical UI elements are present
        if (!UI.chatForm || !UI.chatBox || !UI.toolsMenu || !UI.typingStatus) {
            console.error("Essential UI elements are missing. App functionality will be limited.");
            // Potentially display a user-friendly error message on the page
        }

        // =========================================================================
        // 4. Initial UI Setup & Event Listeners (DOMContentLoaded)
        // =========================================================================
        window.addEventListener('DOMContentLoaded', () => {

            // --- Starfield Initialization ---
            if (UI.starsContainer) {
                UI.starsContainer.innerHTML = '';
                for (let i = 0; i < 34; i++) {
                    const s = document.createElement('div');
                    s.className = 'star';
                    const z = Math.random() * 2.1 + 1;
                    s.style.width = z + 'px';
                    s.style.height = z + 'px';
                    s.style.left = Math.random() * 100 + '%';
                    s.style.top = Math.random() * 100 + '%';
                    s.style.animationDelay = (Math.random() * 3.69) + 's';
                    s.style.animationDuration = (2.2 + Math.random() * 1.1) + 's';
                    UI.starsContainer.appendChild(s);
                }
            }

            // --- Emoji Panel Setup ---
            const emojis = ["ðŸ˜€", "ðŸ˜‚", "ðŸ˜", "ðŸ¥°", "ðŸ˜Ž", "ðŸ‘", "ðŸ™", "ðŸ”¥", "ðŸ’¯", "ðŸŽ‰", "ðŸ˜‡", "ðŸ¤–", "ðŸ‘€"];
            if (UI.emojiBtn && UI.emojiPanel && UI.chatInput) {
                UI.emojiBtn.addEventListener('click', (e) => {
                    UI.emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button" aria-label="${em}">${em}</span>`).join('');
                    UI.emojiPanel.style.display = UI.emojiPanel.style.display === 'block' ? 'none' : 'block';
                    try {
                        const rect = UI.emojiBtn.getBoundingClientRect();
                        // Position emoji panel relative to the emoji button
                        UI.emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
                    } catch (e) { /* ignore positioning errors in rare cases */ }

                    UI.emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
                        span.addEventListener('click', function () {
                            const text = this.textContent || '';
                            const start = UI.chatInput.selectionStart || 0;
                            const end = UI.chatInput.selectionEnd || 0;
                            UI.chatInput.value = UI.chatInput.value.slice(0, start) + text + UI.chatInput.value.slice(end);
                            UI.chatInput.focus();
                            UI.chatInput.selectionStart = UI.chatInput.selectionEnd = start + text.length;
                            UI.emojiPanel.style.display = 'none';
                            UI.chatInput.dispatchEvent(new Event('input')); // Trigger input event for auto-resize
                        });
                    });
                });
                // Close emoji panel if clicking outside
                document.addEventListener('click', e => {
                    if (UI.emojiPanel && !UI.emojiPanel.contains(e.target) && e.target !== UI.emojiBtn) {
                        UI.emojiPanel.style.display = 'none';
                    }
                });
            }

            // --- Chat Input Auto-Resize & Keyboard Shortcuts ---
            if (UI.chatInput) {
                const autoResize = () => {
                    UI.chatInput.style.height = 'auto';
                    UI.chatInput.style.height = Math.min(UI.chatInput.scrollHeight, 168) + 'px';
                };
                UI.chatInput.addEventListener('input', autoResize);
                UI.chatInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Prevent default Enter (which often submits)
                        const start = UI.chatInput.selectionStart;
                        const end = UI.chatInput.selectionEnd;
                        // Insert newline at cursor position
                        UI.chatInput.value = UI.chatInput.value.substring(0, start) + "\n" + UI.chatInput.value.substring(end);
                        UI.chatInput.selectionStart = UI.chatInput.selectionEnd = start + 1;
                        autoResize(); // Adjust height after adding new line
                    } else if (e.key === 'Enter' && e.shiftKey) {
                        e.preventDefault(); // Prevent default Shift+Enter
                        UI.chatForm.requestSubmit(); // Submit on Shift+Enter for explicit sending
                    }
                });
                autoResize(); // Initial resize
            }

            // --- File Attachment Handler ---
            if (UI.chatFile) {
                UI.chatFile.addEventListener('change', function() {
                    uploadedFiles = Array.from(this.files || []);
                    renderFilePreview();
                });
            }

            // --- AI Image Preview Handlers ---
            if (UI.aiPrevClose) UI.aiPrevClose.addEventListener('click', () => { UI.aiPrevBox.style.display = 'none'; });
            if (UI.aiPrevDLBtn) UI.aiPrevDLBtn.addEventListener('click', () => {
                const img = UI.aiPrevImgBox.querySelector('img');
                if (img) {
                    const a = document.createElement('a');
                    a.href = img.src;
                    a.download = 'philadelphia_ai_image.png'; // Suggest a default filename
                    a.click();
                }
            });

            // --- Image Lightbox Activation ---
            if (UI.lightbox) {
                UI.lightbox.addEventListener('click', () => UI.lightbox.classList.remove('active'));
            }
            // Delegate click listener for AI generated images within chat
            if (UI.chatBox) {
                UI.chatBox.addEventListener('click', e => {
                    if (e.target.tagName === 'IMG' && e.target.closest('.chat-message.ai .msg')) {
                        e.preventDefault();
                        const lbImg = UI.lightbox.querySelector('img');
                        if (lbImg) {
                            lbImg.src = e.target.src;
                            UI.lightbox.classList.add('active');
                        }
                    }
                });
            }

            // =========================================================================
            // 5. Panel & Modal Management (Unified Functions)
            // =========================================================================
            const openPanel = (panelBg, panel) => {
                panelBg.classList.add('active');
                // Timeout ensures the background fades in before panel slides for a smoother effect
                setTimeout(() => panel.classList.add('active'), 10);
            };

            const closePanel = (panelBg, panel) => {
                panel.classList.remove('active');
                // Timeout ensures panel slides out before background fades for a smoother effect
                setTimeout(() => panelBg.classList.remove('active'), 110);
            };

            // Global functions for convenience
            window.closeToolMenu = () => closePanel(UI.toolsMenuBg, UI.toolsMenu);
            window.openToolMenu = () => openPanel(UI.toolsMenuBg, UI.toolsMenu);

            // Profile Menu
            if (UI.profileMenuBg) {
                UI.openProfileMenu.addEventListener('click', () => openPanel(UI.profileMenuBg, UI.profileMenu));
                UI.profileMenuBg.addEventListener('click', e => {
                    if (e.target === UI.profileMenuBg) closePanel(UI.profileMenuBg, UI.profileMenu);
                });
            }

            // Links Menu
            if (UI.linkMenuBg) {
                UI.openLinksMenu.addEventListener('click', () => openPanel(UI.linkMenuBg, UI.linkMenu));
                UI.linkMenuBg.addEventListener('click', e => {
                    if (e.target === UI.linkMenuBg) closePanel(UI.linkMenuBg, UI.linkMenu);
                });
            }

            // Tools Menu activation
            if (UI.toolBtn) UI.toolBtn.addEventListener('click', openToolMenu);
            if (UI.toolsMenuBg) UI.toolsMenuBg.addEventListener('click', e => {
                if (e.target === UI.toolsMenuBg) closeToolMenu();
            });

            // Tool Form Modal navigation
            if (UI.toolFormBackBtn) {
                UI.toolFormBackBtn.addEventListener('click', () => {
                    closePanel(UI.toolFormModalBg, UI.toolFormModal);
                    openToolMenu(); // Go back to the main tools list
                });
            }
            if (UI.toolFormModalBg) UI.toolFormModalBg.addEventListener('click', e => {
                if (e.target === UI.toolFormModalBg) closePanel(UI.toolFormModalBg, UI.toolFormModal);
            });

            // Logout functionality
            if (UI.logoutBtn) UI.logoutBtn.addEventListener('click', () => {
                auth.signOut();
                // Redirect to login page upon logout
                window.location.href = 'signup-login.html';
            });

            // =========================================================================
            // 6. Authentication & User Profile Management
            // =========================================================================
            onAuthStateChanged(auth, user => {
                if (!user) {
                    // Redirect unauthenticated users
                    try { window.location.href = "signup-login.html"; } catch (e) {}
                    return;
                }
                currentUser = user;
                // Update header welcome message
                if (UI.headerWelcome) UI.headerWelcome.textContent = "Welcome, " + (user.displayName || (user.email || '').split('@')[0]);
                // Populate profile menu details
                if (UI.profileMenuUser) UI.profileMenuUser.textContent = user.displayName || "User";
                if (UI.profileMenuEmail) UI.profileMenuEmail.textContent = user.email || "";
                if (UI.editName) UI.editName.value = user.displayName || "";
                if (UI.editPhoto) UI.editPhoto.value = user.photoURL || "";
                // Update profile picture, fallback to a default image
                if (UI.profilePicPreview) UI.profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

                // Load user chats from Firestore once authenticated
                loadUserChats(user.uid);
            });

            // Profile Form Submission Handler
            if (UI.profileForm) {
                UI.profileForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!currentUser) return;

                    if (UI.profileStatusMsg) UI.profileStatusMsg.textContent = 'Saving...';
                    try {
                        await updateProfile(currentUser, {
                            displayName: UI.editName.value,
                            photoURL: UI.editPhoto.value
                        });
                        // Reload auth user to get updated data immediately
                        if (auth.currentUser) await auth.currentUser.reload();

                        if (UI.profileStatusMsg) {
                            UI.profileStatusMsg.textContent = "Profile updated!";
                            UI.profileStatusMsg.style.color = "#00ffff";
                        }
                        // Close profile menu after successful update
                        setTimeout(() => { closePanel(UI.profileMenuBg, UI.profileMenu); }, 800);
                        if (UI.headerWelcome) UI.headerWelcome.textContent = "Welcome, " + (auth.currentUser?.displayName || 'User');
                    } catch (err) {
                        console.error("Profile update error: ", err);
                        if (UI.profileStatusMsg) {
                            UI.profileStatusMsg.textContent = err.message;
                            UI.profileStatusMsg.style.color = "#ffd700";
                        }
                    }
                });
            }

            // =========================================================================
            // 7. Firestore Chat Management Logic
            // =========================================================================

            /**
             * Loads and subscribes to real-time updates for user's chats.
             * Creates a new chat if none exist.
             * @param {string} userId - The ID of the current user.
             */
            async function loadUserChats(userId) {
                if (chatsUnsubscribe) chatsUnsubscribe(); // Unsubscribe from previous listener

                const chatsCol = collection(db, 'users', userId, 'chats');
                const q = query(chatsCol, orderBy('createdAt', 'desc'));

                chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                    if (snapshot.empty) {
                        // If no chats, create a default one
                        console.log("No chats found, creating a new one...");
                        await createNewChat(userId);
                        return; // The listener will re-run with the new chat
                    }

                    chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatsListSidebar();

                    // If no chat is selected or the selected chat was deleted, select the newest one
                    if (!currentChatId || !chats.some(c => c.id === currentChatId)) {
                        currentChatId = chats[0].id;
                    }
                    // Subscribe to messages for the currently selected chat
                    subscribeToMessages(userId, currentChatId);
                }, (error) => {
                    console.error("Error fetching chats: ", error);
                    if (UI.chatsListEl) UI.chatsListEl.innerHTML = `<div style="color: #f44; padding: 10px;">Error loading chats.</div>`;
                });
            }

            /**
             * Subscribes to real-time updates for messages within a specific chat.
             * @param {string} userId - The ID of the current user.
             * @param {string} chatId - The ID of the selected chat.
             */
            function subscribeToMessages(userId, chatId) {
                if (messagesUnsubscribe) messagesUnsubscribe(); // Unsubscribe from old messages

                if (!userId || !chatId) {
                    renderChatBox([]); // Clear chat box if no chat is selected
                    return;
                }

                const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
                const q = query(messagesCol, orderBy('createdAt'));

                messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                    currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatBox(currentMessages);
                }, (error) => {
                    console.error("Error fetching messages: ", error);
                    if (UI.chatBox) UI.chatBox.innerHTML = `<div style="color: #f44; text-align: center; margin-top: 20px;">Error loading messages for this chat.</div>`;
                });
            }

            /**
             * Creates a new chat document in Firestore.
             * @param {string} userId - The ID of the current user.
             */
            async function createNewChat(userId) {
                if (!userId) userId = currentUser?.uid;
                if (!userId) {
                    console.error("Cannot create chat: User ID is missing.");
                    return;
                }
                const chatsCol = collection(db, 'users', userId, 'chats');
                try {
                    // Add a new chat with a default name and timestamp
                    const newChatDoc = await addDoc(chatsCol, {
                        name: "New Chat",
                        createdAt: serverTimestamp()
                    });
                    currentChatId = newChatDoc.id; // Set as current chat
                    // The onSnapshot listener in loadUserChats will automatically update the UI
                } catch (e) {
                    console.error("Error creating new chat: ", e);
                }
            }

            // New Chat Button Handler
            if (UI.newChatBtn) {
                UI.newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));
            }

            /**
             * Renders the list of chats in the sidebar.
             */
            function renderChatsListSidebar() {
                if (!UI.chatsListEl) return;

                UI.chatsListEl.innerHTML = ''; // Clear existing list

                if (chats.length === 0) {
                    UI.chatsListEl.innerHTML = `<div style="padding: 10px; color: #a8eaff;">No chats yet. Start a new one!</div>`;
                    return;
                }

                chats.forEach((chat) => {
                    const container = document.createElement('div');
                    container.classList.add('chat-list-item'); // Add class for styling
                    if (chat.id === currentChatId) {
                        container.classList.add('selected-chat'); // Highlight selected chat
                    }

                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = chat.name || `Chat`;
                    titleSpan.onclick = () => {
                        currentChatId = chat.id;
                        subscribeToMessages(currentUser.uid, currentChatId);
                        renderChatsListSidebar(); // Re-render to show selection
                        closePanel(UI.profileMenuBg, UI.profileMenu); // Close menu after selection
                    };

                    const renameBtn = document.createElement('button');
                    renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                    renameBtn.title = 'Rename Chat';
                    renameBtn.onclick = async (e) => {
                        e.stopPropagation();
                        const newName = prompt("Rename chat:", chat.name);
                        if (newName && newName.trim()) {
                            const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                            await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
                            // The listener will automatically update the UI
                        }
                    };

                    const delBtn = document.createElement('button');
                    delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                    delBtn.title = 'Delete Chat';
                    delBtn.onclick = async (e) => {
                        e.stopPropagation();
                        if (!confirm(`Are you sure you want to delete "${chat.name}"? This will delete all messages permanently.`)) return;

                        // Delete all messages in subcollection using a batch write for efficiency
                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                        const messagesSnap = await getDocs(messagesCol);
                        const batch = writeBatch(db);
                        messagesSnap.docs.forEach(d => batch.delete(d.ref));
                        await batch.commit();

                        // Delete the chat document itself
                        const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                        await deleteDoc(chatDoc);

                        // If the deleted chat was the currently selected one, reset currentChatId
                        if (currentChatId === chat.id) {
                            currentChatId = null;
                        }
                        // The onSnapshot listener for chats will update the sidebar automatically
                    };

                    container.appendChild(titleSpan);
                    container.appendChild(renameBtn);
                    container.appendChild(delBtn);
                    UI.chatsListEl.appendChild(container);
                });
            }

            // =========================================================================
            // 8. Chat Message Rendering & Markdown Processing
            // =========================================================================

            /**
             * Converts inline markdown (like `code`, **bold**, *italic*, [link](url)) to HTML.
             * @param {string} text - The input text.
             * @returns {string} HTML string with inline markdown converted.
             */
            function inlineMarkdown(t = '') {
                let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
                s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
                s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
                s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                return s.replace(/\n/g, '<br>'); // Convert newlines to <br> for inline display
            }

            /**
             * Renders markdown, including code blocks, to HTML.
             * @param {string} text - The full message text.
             * @returns {{html: string}} Object containing the rendered HTML.
             */
            function renderMarkdown(text = '') {
                const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
                let html = '';
                let lastIndex = 0;

                text = text || ''; // Ensure text is a string

                // Process code blocks first
                text.replace(codeBlockRegex, (match, lang, code, offset) => {
                    // Add content before the code block
                    const before = text.slice(lastIndex, offset);
                    html += inlineMarkdown(before);

                    const language = (lang || '').toLowerCase().trim();
                    const safeCode = escapeHTML(code); // Escape HTML inside code blocks
                    html += `<pre><button class="copy-btn" aria-label="Copy code block">Copy</button><code class="language-${language || 'plaintext'}">${safeCode}</code></pre>`;
                    lastIndex = offset + match.length;
                    return match; // Return original match to keep replace function happy
                });

                // Add any remaining content after the last code block
                html += inlineMarkdown(text.slice(lastIndex));
                return { html };
            }

            /**
             * Applies syntax highlighting and adds copy buttons to code blocks.
             * @param {HTMLElement} container - The DOM element containing the code blocks.
             */
            function enhanceCodeBlocks(container) {
                if (!container) return;

                container.querySelectorAll('pre').forEach(pre => {
                    const codeEl = pre.querySelector('code');
                    if (window.hljs && codeEl) {
                        try {
                            hljs.highlightElement(codeEl); // Apply syntax highlighting
                        } catch (e) { console.warn("Highlight.js failed to highlight:", e); }
                    }

                    const btn = pre.querySelector('.copy-btn');
                    if (btn && codeEl) {
                        btn.addEventListener('click', async () => {
                            try {
                                await navigator.clipboard.writeText(codeEl.innerText);
                                const prev = btn.innerHTML;
                                btn.innerHTML = '<i class="fa-solid fa-copy"></i> Copied!'; // Visual feedback
                                setTimeout(() => btn.innerHTML = prev, 800);
                            } catch (e) {
                                console.warn('Failed to copy code:', e);
                                btn.innerHTML = '<i class="fa-solid fa-times"></i> Failed'; // Error feedback
                                setTimeout(() => btn.innerHTML = '<i class="fa-solid fa-copy"></i> Copy', 800);
                            }
                        });
                    }
                });
            }

            /**
             * Renders all messages in the chat box and scrolls to the bottom.
             * @param {Array<Object>} messages - Array of message objects to render.
             */
            function renderChatBox(messages = []) {
                if (!UI.chatBox) return;

                UI.chatBox.innerHTML = ''; // Clear existing messages

                (messages || []).forEach((msg) => {
                    const div = document.createElement('div');
                    div.className = 'chat-message ' + (msg.role === 'user' ? 'user' : 'ai');
                    div.setAttribute('data-message-id', msg.id); // Store message ID for controls

                    let innerHtml = '';
                    if (msg.role === 'user') {
                        // Render attached files for user messages
                        const fileHtml = (msg.files || [])
                            .map(file => {
                                let icon = 'fa-file';
                                if (file.type.startsWith('image/')) icon = 'fa-file-image';
                                else if (file.type.startsWith('video/')) icon = 'fa-file-video';
                                else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
                                else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                                return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                            })
                            .join('');

                        innerHtml = `
                            <div class="msg">
                                ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                                ${escapeHTML(msg.text || '')}
                                <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                                    <button class="inline-edit-btn" title="Edit message"><i class="fa-solid fa-pen-to-square"></i> Edit</button>
                                    <button class="inline-copy-btn" title="Copy message"><i class="fa-solid fa-copy"></i> Copy</button>
                                </div>
                            </div>`;
                    } else { // AI message
                        // Check if message contains HTML content (like tool results with images/audio/video)
                        let content;
                        if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                            content = msg.text; // Render raw HTML for tool outputs
                        } else {
                            content = renderMarkdown(msg.text || '').html; // Render markdown for regular text
                        }
                        innerHtml = `
                            <div class="msg">
                                ${content}
                                <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                                    <button class="inline-copy-btn" title="Copy response"><i class="fa-solid fa-copy"></i> Copy</button>
                                    <button class="inline-share-btn" title="Share response"><i class="fa-solid fa-share"></i> Share</button>
                                    <button class="regen-btn" title="Regenerate response"><i class="fa-solid fa-rotate-right"></i> Regenerate</button>
                                </div>
                            </div>`;
                    }
                    div.innerHTML = innerHtml;
                    UI.chatBox.appendChild(div);
                });

                enhanceCodeBlocks(UI.chatBox); // Apply highlighting and copy buttons
                hookAiMsgControls(); // Attach event listeners for AI message controls
                hookUserMsgControls(); // Attach event listeners for user message controls

                // Scroll to bottom after rendering messages
                setTimeout(() => { UI.chatBox.scrollTop = UI.chatBox.scrollHeight; }, 50);
            }

            // =========================================================================
            // 9. Chat Message Controls (Edit, Copy, Share, Regenerate)
            // =========================================================================

            /**
             * Deletes a message and all subsequent messages from Firestore.
             * Used for editing or regenerating.
             * @param {string} messageId - The ID of the message to start deletion from.
             */
            async function deleteMessagesFrom(messageId) {
                if (!currentChatId || !currentUser) return;

                const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                if (msgIndex === -1) {
                    console.warn(`Message with ID ${messageId} not found for deletion.`);
                    return;
                }

                const batch = writeBatch(db);
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');

                // Delete the target message and all messages that came after it
                for (let i = msgIndex; i < currentMessages.length; i++) {
                    const msgToDel = currentMessages[i];
                    const docRef = doc(messagesCol, msgToDel.id);
                    batch.delete(docRef);
                }

                try {
                    await batch.commit();
                    // The onSnapshot listener will automatically update the UI after commit
                } catch (e) {
                    console.error("Error deleting messages in batch: ", e);
                    if (UI.statusMsg) UI.statusMsg.textContent = `Error deleting messages: ${e.message}`;
                    UI.statusMsg.style.color = "#ffd700";
                }
            }

            /**
             * Attaches event listeners to AI message controls (copy, share, regenerate).
             */
            function hookAiMsgControls() {
                if (!UI.chatBox) return;

                UI.chatBox.querySelectorAll('.chat-message.ai').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;

                    const controls = div.querySelector('.ai-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const shareBtn = controls.querySelector('.inline-share-btn');
                    const regenBtn = controls.querySelector('.regen-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            // Create a temporary div to strip HTML tags for cleaner copy
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy", 950);
                        } catch (e) {
                            console.warn('Copy failed:', e);
                            copyBtn.innerHTML = "<i class='fa-solid fa-times'></i> Failed";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy", 950);
                        }
                    };

                    if (shareBtn) shareBtn.onclick = () => {
                        try {
                            const url = window.location.origin;
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const plainText = tempDiv.textContent || tempDiv.innerText || '';
                            const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;

                            // Use Web Share API if available
                            if (navigator.share) {
                                navigator.share({ title: "Philadelphia AI Chat", text: shareText, url }).catch((e) => {
                                    console.warn('Web Share API cancelled or failed:', e);
                                });
                            } else {
                                // Fallback to prompt for manual copy
                                prompt("Copy and share manually:", shareText);
                            }
                        } catch (e) {
                            console.warn('Share failed:', e);
                        }
                    };

                    if (regenBtn) regenBtn.onclick = async () => {
                        // Find the index of the AI message
                        const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                        if (msgIndex < 1) { // Can't regenerate the very first message
                            if (UI.statusMsg) UI.statusMsg.textContent = "Can't regenerate the first message in a chat.";
                            UI.statusMsg.style.color = "#ffd700";
                            return;
                        }

                        // The message before the AI response must be the user's prompt
                        const userMsg = currentMessages[msgIndex - 1];
                        if (userMsg.role !== 'user') {
                            if (UI.statusMsg) UI.statusMsg.textContent = "Cannot regenerate: The preceding message was not a user prompt.";
                            UI.statusMsg.style.color = "#ffd700";
                            return;
                        }

                        // Delete this AI message and all subsequent messages
                        await deleteMessagesFrom(messageId);

                        // Prepare to re-send the user message
                        UI.chatInput.value = userMsg.text;
                        UI.chatInput.style.height = 'auto'; // Reset height
                        UI.chatInput.style.height = Math.min(UI.chatInput.scrollHeight, 168) + 'px'; // Auto-resize
                        uploadedFiles = []; // Clear files, as they are part of the original message entry
                        renderFilePreview();

                        showTypingAtNext(); // Show "thinking..." immediately

                        // Build history for regeneration (all messages *before* the user's prompt)
                        const historyForRegen = currentMessages
                            .slice(0, msgIndex - 1)
                            .map(m => ({ role: m.role, content: m.text || '' }));

                        try {
                            const res = await fetch(`${API_BASE_URL}/chat`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    message: userMsg.text,
                                    history: historyForRegen,
                                    user_id: currentUser?.uid || "user"
                                })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Server error during regeneration.");

                            removeTyping();
                            await startTypewriter(data.response, false); // Typewriter effect, don't save to DB directly (done by Typewriter)
                        } catch (err) {
                            console.error("Regeneration failed:", err);
                            removeTyping();
                            await startTypewriter(`âŒ Regeneration error: ${err.message}`, false);
                        }
                    };
                });
            }

            /**
             * Attaches event listeners to user message controls (copy, edit).
             */
            function hookUserMsgControls() {
                if (!UI.chatBox) return;

                UI.chatBox.querySelectorAll('.chat-message.user').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;

                    const controls = div.querySelector('.user-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const editBtn = controls.querySelector('.inline-edit-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy", 950);
                        } catch (e) {
                            console.warn('Copy failed:', e);
                            copyBtn.innerHTML = "<i class='fa-solid fa-times'></i> Failed";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy", 950);
                        }
                    };

                    if (editBtn) editBtn.onclick = async () => {
                        try {
                            if (!msg.text) return;

                            UI.chatInput.value = msg.text; // Populate input with message text
                            UI.chatInput.focus();
                            // If the original message had files, ideally we would reload them,
                            // but due to security (file paths are local), this is often not feasible.
                            // We clear `uploadedFiles` to avoid confusion.
                            uploadedFiles = [];
                            renderFilePreview();

                            // Delete this message and all subsequent messages
                            await deleteMessagesFrom(messageId);
                            // UI will automatically update via the onSnapshot listener
                        } catch (e) {
                            console.warn('Edit failed:', e);
                            if (UI.statusMsg) UI.statusMsg.textContent = `Error editing message: ${e.message}`;
                            UI.statusMsg.style.color = "#ffd700";
                        }
                    };
                });
            }

            // =========================================================================
            // 10. Typing Indicator Management
            // =========================================================================

            /** Shows the animated typing dots indicator. */
            function showTypingAtNext() {
                if (!UI.typingStatus) return;
                UI.typingStatus.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span></div>`;
                UI.typingStatus.style.display = 'flex';
                UI.chatBox.scrollTop = UI.chatBox.scrollHeight; // Scroll to bottom to ensure visibility
            }

            /**
             * Shows a spinner with a custom text message.
             * @param {string} text - The message to display next to the spinner.
             */
            function showTypingWithText(text) {
                if (!UI.typingStatus) return;
                UI.typingStatus.innerHTML = `<div class="msg" style="display:flex;align-items:center;"><span class="spinner"></span> <span style="margin-left:8px; color:var(--main-text); font-style:italic;">${text}</span></div>`;
                UI.typingStatus.style.display = 'flex';
                UI.chatBox.scrollTop = UI.chatBox.scrollHeight;
            }

            /** Hides the typing indicator. */
            function removeTyping() {
                if (!UI.typingStatus) return;
                UI.typingStatus.style.display = 'none';
                UI.typingStatus.innerHTML = '';
            }

            // =========================================================================
            // 11. Typewriter Effect (for streaming AI responses)
            // =========================================================================

            /**
             * Simulates typing out an AI response, supporting real-time rendering and saving to DB.
             * @param {string} text - The full text of the AI response.
             * @param {boolean} saveToDb - Whether to save the final message to Firestore (true for new messages, false for regeneration).
             */
            async function startTypewriter(text, saveToDb = true) {
                if (!UI.chatBox) return;

                // If the response is primarily rich media (images, audio, video),
                // skip the character-by-character typewriter effect and render directly.
                if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) {
                    if (saveToDb) {
                        await addMessageToChat('ai', text); // Save full HTML to DB
                    } else {
                        // For regeneration, if we skip typewriter, we still need to add it to the chatbox
                        // and manually save it as the regen logic relies on it being *not* saved to DB yet (saveToDb=false)
                        const tempDiv = document.createElement('div');
                        tempDiv.className = "chat-message ai";
                        tempDiv.innerHTML = `<div class="msg">${text}</div>`;
                        UI.chatBox.appendChild(tempDiv);
                        UI.chatBox.scrollTop = UI.chatBox.scrollHeight;

                        // Manually save the regenerated rich media response
                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                        try {
                            await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
                        } catch (e) {
                            console.error("Error saving regenerated AI tool message: ", e);
                        }
                    }
                    return;
                }

                // Standard Typewriter (for text/markdown)
                const div = document.createElement('div');
                div.className = "chat-message ai";
                const msgdiv = document.createElement('div');
                msgdiv.className = 'msg';
                div.appendChild(msgdiv);
                UI.chatBox.appendChild(div);

                let sofar = '';
                const words = text.split(/(\s+)/); // Split on spaces, keeping them for natural pacing
                let tempText = '';

                for (const word of words) {
                    // Check for abortion signal from AbortController (e.g., if user clicks stop)
                    if (currentController?.signal.aborted) {
                        text = tempText; // Use the text typed so far as the final text
                        break;
                    }

                    tempText += word;
                    // Render the current segment, ensuring full code blocks are rendered
                    // This is a basic approach; more advanced streaming might involve smarter markdown parsing
                    if (tempText.includes('```')) {
                        const parts = tempText.split('```');
                        sofar = parts.slice(0, parts.length - 1).join('```');
                        if (parts.length % 2 === 0) sofar += '```'; // Re-add the last separator if inside a block
                    } else {
                        sofar = tempText;
                    }

                    msgdiv.innerHTML = renderMarkdown(sofar).html; // Render with markdown
                    UI.chatBox.scrollTop = UI.chatBox.scrollHeight; // Keep scrolling to the bottom

                    // Adjust typing speed: faster for symbols/spaces, slower for words
                    const delay = word.match(/[\s.,!?;:]/) ? 10 : 30;
                    await new Promise(res => setTimeout(res, delay));
                }

                // Final render (full text or aborted text) and attach controls
                const finalRenderText = text;
                msgdiv.innerHTML = renderMarkdown(finalRenderText).html + `
                    <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                        <button class="inline-copy-btn" title="Copy response"><i class="fa-solid fa-copy"></i> Copy</button>
                        <button class="inline-share-btn" title="Share response"><i class="fa-solid fa-share"></i> Share</button>
                        <button class="regen-btn" title="Regenerate response"><i class="fa-solid fa-rotate-right"></i> Regenerate</button>
                    </div>`;
                enhanceCodeBlocks(msgdiv); // Apply highlighting and copy buttons to final content
                UI.chatBox.scrollTop = UI.chatBox.scrollHeight;

                // Save the final (potentially aborted) message to Firestore
                if (saveToDb) {
                    const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                    try {
                        await addDoc(messagesCol, {
                            role: 'ai',
                            text: finalRenderText,
                            createdAt: serverTimestamp()
                        });
                        // The onSnapshot listener will now fire, replacing our temporary node with the
                        // permanent, DB-driven one. This creates a seamless experience.
                    } catch (e) {
                        console.error("Error saving AI message to Firestore: ", e);
                        msgdiv.innerHTML += "<br><small style='color: #f44;'>Failed to save message.</small>";
                    }
                }
            }

            // =========================================================================
            // 12. File Attachment Preview Logic
            // =========================================================================

            /** Renders a preview of currently uploaded files. */
            function renderFilePreview() {
                if (!UI.filePreview) return;

                if (!uploadedFiles.length) {
                    UI.filePreview.style.display = 'none';
                    UI.filePreview.innerHTML = '';
                    return;
                }

                UI.filePreview.style.display = 'block';
                UI.filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                    let preview = '';
                    if (file.type.startsWith('image/')) {
                        preview = `<img src="${URL.createObjectURL(file)}" alt="Image preview" style="max-width:58px;max-height:41px;vertical-align:middle;border-radius:8px;margin-right:6px;">`;
                    } else if (file.type.startsWith('video/')) {
                        preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:58px;height:41px;vertical-align:middle;border-radius:8px;margin-right:7px;"></video>`;
                    } else if (file.type.startsWith('audio/')) {
                        preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:52px;margin-right:7px;"></audio>`;
                    } else if (file.type === 'application/pdf') {
                        preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`;
                    }
                    return `
                        <div style="display:flex;align-items:center;gap:7px;margin-bottom:1px;">
                            ${preview}
                            <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span>
                            <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file: ${escapeHTML(file.name)}">&times;</button>
                        </div>`;
                }).join('');

                UI.filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const idx = parseInt(btn.getAttribute('data-idx'));
                        uploadedFiles.splice(idx, 1);
                        if (!uploadedFiles.length && UI.chatFile) UI.chatFile.value = ''; // Clear file input if no files left
                        renderFilePreview();
                    });
                });
            }

            /**
             * Shows a floating preview for AI-generated images.
             * @param {string} base64 - Base64 encoded image data.
             * @param {string} [caption=''] - Optional caption for the image.
             */
            function showAIImagePreview(base64, caption = '') {
                if (!UI.aiPrevBox || !UI.aiPrevImgBox) return;

                UI.aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:210px;max-height:210px;border-radius:12px;display:block;margin: 0 auto;">` +
                                           `<div style="color:#aee;font-size:.95em;margin-top:8px;text-align:center;">${escapeHTML(caption)}</div>`;
                UI.aiPrevBox.style.display = 'block';
            }

            // =========================================================================
            // 13. Message Persistence (Firestore) & File Upload Helpers
            // =========================================================================

            /**
             * Adds a message to the current chat in Firestore.
             * @param {'user' | 'ai'} role - The role of the sender.
             * @param {string} text - The message content.
             * @param {Array<Object>} [files=[]] - Optional array of file objects ({name, type}).
             */
            async function addMessageToChat(role, text, files = []) {
                if (!currentChatId || !currentUser) return;

                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesCol, {
                        role,
                        text,
                        files, // Store file metadata
                        createdAt: serverTimestamp()
                    });
                    // The onSnapshot listener will handle the UI update automatically
                } catch (e) {
                    console.error("Error adding message to Firestore: ", e);
                    if (UI.statusMsg) UI.statusMsg.textContent = `Error saving message: ${e.message}`;
                    UI.statusMsg.style.color = "#ffd700";
                }
            }

            /**
             * Converts a Blob object (like a file) to a Base64 string.
             * Useful for embedding images/audio/video in Firestore messages.
             * @param {Blob} blob - The Blob to convert.
             * @returns {Promise<string>} A promise that resolves with the Base64 data URL.
             */
            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            // =========================================================================
            // 14. Tool Management & Execution
            // =========================================================================

            /**
             * Handles the video generation process, including polling for status.
             * @param {Object | FormData} payload - The request payload (JSON object for text-to-video, FormData for image-to-video).
             * @param {boolean} [isImageToVideo=false] - True if generating video from an image.
             * @returns {Promise<void>}
             */
            async function handleVideoGeneration(payload, isImageToVideo = false) {
                showTypingWithText('Submitting video generation job...');
                try {
                    const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
                    const commonVideoParams = {
                        model: "MiniMax-Hailuo-02", // Explicitly set a default model
                        duration: payload.duration || 6, // Default duration if not provided
                        resolution: payload.resolution || "1080P" // Default resolution
                    };

                    let fetchOptions;
                    if (isImageToVideo) {
                        // For image upload, append common parameters to FormData
                        payload.append('model', commonVideoParams.model);
                        payload.append('duration', commonVideoParams.duration);
                        payload.append('resolution', commonVideoParams.resolution);
                        fetchOptions = { method: 'POST', body: payload };
                    } else {
                        // For text, merge common parameters into JSON payload
                        const finalPayload = { ...payload, ...commonVideoParams };
                        fetchOptions = {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(finalPayload)
                        };
                    }

                    const startRes = await fetch(API_BASE_URL + endpoint, fetchOptions);
                    const startData = await startRes.json();

                    if (!startRes.ok || !startData.task_id) {
                        throw new Error(startData.detail || 'Failed to start video task.');
                    }

                    removeTyping();
                    await startTypewriter(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. I'll notify you when it's ready. This can take a few minutes. Please avoid leaving this page or sending another message/task until it's done.`);

                    // Poll for video status
                    const pollInterval = setInterval(async () => {
                        try {
                            const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                            const statusData = await statusRes.json();

                            if (statusRes.ok && statusData.url) {
                                clearInterval(pollInterval); // Stop polling
                                const videoHtml = `ðŸŽ‰ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                                await addMessageToChat('ai', videoHtml); // Save HTML directly
                            } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                                clearInterval(pollInterval); // Stop polling
                                await startTypewriter(`âŒ Video generation failed. Reason: ${statusData.error || 'Unknown error'}`);
                            }
                        } catch (pollErr) {
                            clearInterval(pollInterval); // Stop polling on error
                            await startTypewriter(`âŒ Error checking video status: ${pollErr.message}`);
                        }
                    }, 20000); // Poll every 20 seconds
                } catch (err) {
                    removeTyping();
                    await startTypewriter(`âŒ Could not start video generation: ${err.message}`);
                }
            }

            // Definitions for all AI tools with their forms and submission logic
            const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
            const toolDefinitions = {
                "image": {
                    title: "Generate Image",
                    description: "Create stunning visuals from a text prompt. Choose a model for different results.",
                    buildForm: () => `
                        <label for="tool-provider">Generation Model</label>
                        <select id="tool-provider" aria-label="Image generation model">
                            <option value="thena">Version 1 (Stylized, Fast & Recommended)</option>
                            <option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option>
                        </select>
                        <label for="tool-prompt">Image Prompt</label>
                        <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required aria-label="Image prompt"></textarea>
                        <label for="tool-style">Style (for Version 1 only)</label>
                        <select id="tool-style" aria-label="Image style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate Image</button>
                    `,
                    handleSubmit: async (form) => {
                        const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                        const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)';
                        const payload = {
                            prompt: form.querySelector('#tool-prompt').value,
                            model: form.querySelector('#tool-style').value,
                            use_minimax
                        };
                        await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                        showTypingWithText('Generating your image...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/generate-image`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                            removeTyping();
                            // For image generation, the image appears in the floating preview,
                            // and a text message confirms it.
                            await addMessageToChat('ai', 'âœ… Image generated! Check the floating image box to view or download.');
                            return null; // No further text needed for typewriter
                        } catch (err) {
                            removeTypying();
                            return `âŒ Image generation failed: ${err.message}`;
                        }
                    }
                },
                "edit-photo": {
                    title: "Edit Photo",
                    description: "Upload a photo and describe the changes you want to make.",
                    buildForm: () => `
                        <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required aria-label="Edit instruction"></textarea>
                        <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required aria-label="Image file to edit">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>
                    `,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        const prompt = form.querySelector('#tool-prompt').value;
                        if (!file) return "Please select a file to edit.";

                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('prompt', prompt);

                        await addMessageToChat('user', `Photo edit request for ${file.name}: "${prompt}"`, [{ name: file.name, type: file.type }]);
                        showTypingWithText('Editing your photo...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, {
                                method: 'POST',
                                body: fd
                            });
                            if (!res.ok) throw new Error((await res.json()).error || 'Failed to edit photo.');
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob); // Convert to base64 for persistence
                            const imgHtml = `âœ… Photo edited successfully! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Photo edit failed: ${err.message}`;
                        }
                    }
                },
                "remove-bg": {
                    title: "Remove Background",
                    description: "Select an image file to automatically remove its background.",
                    buildForm: () => `
                        <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;" aria-label="Image file for background removal">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Remove Background</button>
                    `,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        if (!file) return "Please select a file.";

                        await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{ name: file.name, type: file.type }]);
                        showTypingWithText('Removing background...');
                        const fd = new FormData();
                        fd.append('file', file);
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, {
                                method: 'POST',
                                body: fd
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const imgHtml = `âœ… Background removed! <br><img src="${base64String}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Background removal failed: ${err.message}`;
                        }
                    }
                },
                "comic": {
                    title: "Create Comic",
                    description: "Write a story and watch it transform into a comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.",
                    buildForm: () => `
                        <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required aria-label="Comic story script"></textarea>
                        <label for="tool-style">Comic Style</label><select id="tool-style" aria-label="Comic art style">
                            <option value="anime">Anime</option>
                            <option value="american">American Comic</option>
                            <option value="manga">Manga</option>
                        </select>
                        <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" aria-label="Number of comic panels"/>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Create Comic</button>
                    `,
                    handleSubmit: async (form) => {
                        const payload = {
                            story: form.querySelector('#tool-story').value,
                            style: form.querySelector('#tool-style').value,
                            panels: parseInt(form.querySelector('#tool-panels').value, 10),
                            user: currentUser?.displayName || "User"
                        };
                        await addMessageToChat('user', `Comic creation request with style: ${payload.style}.`);
                        showTypingWithText('Generating your comic panels...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            // Ensure base64 images are included directly in the chat message for persistence
                            const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx + 1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join('');
                            const comicMessage = `ðŸ–¼ï¸ Comic successfully created! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                            removeTyping();
                            await addMessageToChat('ai', comicMessage); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Comic generation failed: ${err.message}`;
                        }
                    }
                },
                "voice-gen": {
                    title: "Voice Generation",
                    description: "Transform text into realistic speech. Choose a provider and voice style.",
                    buildForm: () => `
                        <label for="tool-provider">Voice Provider</label><select id="tool-provider" aria-label="Voice provider">
                            <option value="gemini">Philadelphia (Styles)</option>
                            <option value="minimax">Seraphina (Characters)</option>
                        </select>
                        <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required aria-label="Text to convert to speech"></textarea>
                        <label for="tool-style">Voice Style</label><select id="tool-style" aria-label="Voice style"></select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice</button>
                    `,
                    onFormReady: () => {
                        const providerSelect = UI.toolForm.querySelector('#tool-provider');
                        const styleSelect = UI.toolForm.querySelector('#tool-style');
                        const voices = {
                            gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                            minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                        };
                        const updateStyles = () => {
                            styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                        };
                        providerSelect.addEventListener('change', updateStyles);
                        updateStyles(); // Initialize styles for the default provider
                    },
                    handleSubmit: async (form) => {
                        const provider = form.querySelector('#tool-provider').value;
                        const text = form.querySelector('#tool-prompt').value;
                        const style = form.querySelector('#tool-style').value;
                        const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';

                        await addMessageToChat('user', `Voice generation request using ${providerName} with style "${style}".`);
                        showTypingWithText('Generating your audio...');
                        try {
                            let res;
                            if (provider === 'gemini') {
                                const fd = new FormData();
                                fd.append('text', text);
                                fd.append('style', style);
                                res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                            } else { // Minimax
                                res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ text, voice_id: style })
                                });
                            }
                            if (!res.ok) throw new Error(await res.text());
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const audioHtml = `ðŸ—£ï¸ Voice generated! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', audioHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Voice generation failed: ${err.message}`;
                        }
                    }
                },
                "audio-narration": {
                    title: "Audio Narration",
                    description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.",
                    buildForm: () => `
                        <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;" aria-label="Document file for narration">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>
                    `,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        if (!file) return "Please select a file.";

                        await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{ name: file.name, type: file.type }]);
                        showTypingWithText('Analyzing and narrating document...');
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('style', 'podcast'); // Assuming a default style for narration
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const narrationHtml = `ðŸ—£ï¸ Narration generated! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', narrationHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Audio narration failed: ${err.message}`;
                        }
                    }
                },
                "video-text": {
                    title: "Generate Video from Text",
                    description: "Describe the video you want to create. This process can take a few minutes.",
                    buildForm: () => `
                        <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required aria-label="Video generation prompt"></textarea>
                        <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15" aria-label="Video duration in seconds">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>
                    `,
                    handleSubmit: async (form) => {
                        const payload = {
                            prompt: form.querySelector('#video-prompt').value,
                            duration: parseInt(form.querySelector('#video-duration').value, 10),
                            resolution: "1080P"
                        };
                        await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
                        handleVideoGeneration(payload); // This function manages its own typing indicators and messages
                        return null;
                    }
                },
                "video-image": {
                    title: "Generate Video from Image",
                    description: "Upload a starting image and describe how you want to animate it.",
                    buildForm: () => `
                        <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required aria-label="Image animation prompt"></textarea>
                        <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required aria-label="Starting image file">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>
                    `,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#video-image-file').files[0];
                        if (!file) return "Please select an image.";

                        await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{ name: file.name, type: file.type }]);
                        const fd = new FormData();
                        fd.append('prompt', form.querySelector('#video-image-prompt').value);
                        fd.append('file', file);
                        handleVideoGeneration(fd, true); // This function manages its own typing indicators and messages
                        return null;
                    }
                },
                "music": {
                    title: "Generate Music",
                    description: "Generate music from a prompt, lyrics, and optional reference audio. Thanks to MiniMax.",
                    buildForm: () => `
                        <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required aria-label="Music prompt or description"></textarea>
                        <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..." aria-label="Lyrics (optional)"></textarea>
                        <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*" aria-label="Reference audio file (optional)">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Music</button>
                    `,
                    handleSubmit: async (form) => {
                        const payload = {
                            prompt: form.querySelector('#music-prompt').value,
                            lyrics: form.querySelector('#music-lyrics').value,
                            model: 'music-1.5' // Assuming a default model
                        };
                        const refFile = form.querySelector('#music-ref').files[0];

                        await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
                        showTypingWithText('Composing your music...');
                        try {
                            if (refFile) {
                                showTypingWithText('Uploading reference audio first...');
                                const fd = new FormData();
                                fd.append('file', refFile);
                                const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                                const uploadData = await uploadRes.json();
                                if (!uploadRes.ok) throw new Error(uploadData.error || "Reference audio upload failed.");
                                if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                                if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                                showTypingWithText('Reference uploaded. Composing music...');
                            }
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const musicHtml = `ðŸŽµ Your music is ready! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', musicHtml); // Save HTML directly
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Music generation failed: ${err.message}`;
                        }
                    }
                },
                "website": {
                    title: "Create Website",
                    description: "Describe the website you want to build and get a live, working prototype.",
                    buildForm: () => `
                        <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required aria-label="Website description"></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Website</button>
                    `,
                    handleSubmit: async (form) => {
                        const prompt = form.querySelector('#website-prompt').value;
                        await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`);
                        showTypingWithText('Building and deploying your website...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt, user_id: currentUser.uid })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return `ðŸŒ Website deployed successfully! [View here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Website creation failed: ${err.message}`;
                        }
                    }
                },
                "edit-website": {
                    title: "Edit Last Website",
                    description: "Provide an instruction to modify the most recent website you created.",
                    buildForm: () => `
                        <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required aria-label="Website edit instruction"></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>
                    `,
                    handleSubmit: async (form) => {
                        const instruction = form.querySelector('#edit-instruction').value;
                        await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`);
                        showTypingWithText('Editing and redeploying your website...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ instruction, user_id: currentUser.uid })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return `âœï¸ Website updated successfully! [View new version here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Website edit failed: ${err.message}`;
                        }
                    }
                },
                "my-sites": {
                    isAction: true, // This tool performs an action directly without a form
                    runAction: async () => {
                        await addMessageToChat('user', 'Show me a list of my websites.');
                        showTypingWithText('Fetching your website list...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || 'Could not fetch sites.');
                            if (!data.sites || data.sites.length === 0) return "You haven't created any websites yet.";
                            const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank" rel="noopener noreferrer">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                            removeTyping();
                            return `Here are the websites you've created:\n${siteList}`;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Error fetching websites: ${err.message}`;
                        }
                    }
                },
                "research-report": {
                    title: "Research Report",
                    description: "Generate a comprehensive research report in PDF format on any topic.",
                    buildForm: () => `
                        <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required aria-label="Research topic">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>
                    `,
                    handleSubmit: async (form) => {
                        const topic = form.querySelector('#research-topic').value;
                        await addMessageToChat('user', `Research report request on: "${topic}"`);
                        showTypingWithText('Conducting research and compiling report...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ topic })
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--link-text);font-weight:bold;">Download PDF Report</a>`;
                            removeTyping();
                            return `âœ… Research report on **${topic}** is ready! ${downloadLink}`;
                        } catch (err) {
                            removeTyping();
                            return `âŒ Research report failed: ${err.message}`;
                        }
                    }
                },
            };

            // Event listener for tool menu clicks
            if (UI.toolsMenu) {
                UI.toolsMenu.addEventListener('click', async (e) => {
                    const toolLink = e.target.closest('.tool-link');
                    if (!toolLink) return;
                    e.preventDefault();

                    const toolKey = toolLink.getAttribute('data-tool');
                    const tool = toolDefinitions[toolKey];
                    if (!tool) {
                        console.error(`Tool "${toolKey}" is not defined.`);
                        if (UI.statusMsg) UI.statusMsg.textContent = `Error: Tool "${toolKey}" not found.`;
                        UI.statusMsg.style.color = "#ffd700";
                        return;
                    }

                    closeToolMenu(); // Close the main tools menu

                    if (tool.isAction) {
                        // If it's a direct action (e.g., "My Websites"), run it
                        const result = await tool.runAction();
                        removeTyping();
                        if (result) await startTypewriter(result); // Display result using typewriter
                    } else {
                        // If it requires a form, display the form modal
                        displayToolForm(toolKey);
                    }
                });
            }

            /**
             * Displays the form for a selected tool in a modal.
             * @param {string} toolKey - The key of the tool to display the form for.
             */
            function displayToolForm(toolKey) {
                const tool = toolDefinitions[toolKey];
                if (!tool || !UI.toolFormModalBg) return;

                UI.toolFormTitle.textContent = tool.title;
                const descriptionHtml = tool.description ? `<div style="color:#a8eaff;font-size:.9em;margin-bottom:12px;">${tool.description}</div>` : '';
                UI.toolForm.innerHTML = descriptionHtml + tool.buildForm();

                if (typeof tool.onFormReady === 'function') tool.onFormReady(); // Call any post-render setup for the form

                UI.toolForm.onsubmit = async (e) => {
                    e.preventDefault();
                    const submitButton = UI.toolForm.querySelector('button[type="submit"]');
                    const originalButtonContent = submitButton.innerHTML;
                    submitButton.innerHTML = `<div class="spinner"></div> Processing...`;
                    submitButton.disabled = true;

                    closePanel(UI.toolFormModalBg, UI.toolFormModal); // Close the tool form modal

                    const resultText = await tool.handleSubmit(UI.toolForm);
                    // If handleSubmit returns a string (e.g., a link or an error), use typewriter
                    if (resultText) {
                        removeTyping();
                        await startTypewriter(resultText);
                    }

                    // Reset button state
                    submitButton.innerHTML = originalButtonContent;
                    submitButton.disabled = false;
                };

                openPanel(UI.toolFormModalBg, UI.toolFormModal); // Open the tool form modal
            }

            // =========================================================================
            // 15. Main Chat Submission Handler (User Input & File Uploads)
            // =========================================================================
            if (UI.chatForm) {
                UI.chatForm.addEventListener('submit', async function (e) {
                    e.preventDefault();
                    if (!currentUser) {
                        if (UI.statusMsg) UI.statusMsg.textContent = "Please log in to send messages.";
                        UI.statusMsg.style.color = "#ffd700";
                        return;
                    }
                    if (!currentChatId) {
                        if (UI.statusMsg) UI.statusMsg.textContent = "Please select a chat or create a new one.";
                        UI.statusMsg.style.color = "#ffd700";
                        return;
                    }

                    const msgText = UI.chatInput.value.trim();
                    if (!msgText && uploadedFiles.length === 0) return; // Don't send empty messages

                    // 1. Replace Send button with Stop button for ongoing operations
                    const stopButton = document.createElement('button');
                    stopButton.type = 'button';
                    stopButton.id = 'stopBtn';
                    stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>';
                    UI.sendBtn.replaceWith(stopButton);

                    currentController = new AbortController(); // Initialize AbortController for this request
                    const signal = currentController.signal;
                    let finalResponse = '';

                    stopButton.addEventListener('click', () => {
                        if (currentController) {
                            currentController.abort(); // Cancel the ongoing fetch request
                        }
                    });

                    // 2. Save user message to Firestore immediately
                    const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
                    await addMessageToChat('user', msgText, filesForHistory);

                    const localUploadedFiles = [...uploadedFiles]; // Copy files for processing
                    UI.chatInput.value = ''; // Clear input field
                    uploadedFiles = []; // Clear uploaded files array
                    renderFilePreview(); // Clear file preview UI
                    UI.chatInput.style.height = 'auto'; // Reset input height

                    // Handle file uploads/analysis first if files are present
                    if (localUploadedFiles.length > 0) {
                        showTypingWithText('Analyzing your file(s)...');
                        let endpoint = '';
                        const file = localUploadedFiles[0]; // Assuming single file processing for now

                        if (file.type.startsWith('image/')) endpoint = '/understand-image';
                        else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                        else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                        else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                        else {
                            removeTyping();
                            finalResponse = "Sorry, I can't analyze that file type.";
                        }

                        try {
                            if (endpoint) {
                                const fd = new FormData();
                                fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]}`); // Include text prompt with file
                                fd.append('file', file);
                                const res = await fetch(API_BASE_URL + endpoint, {
                                    method: 'POST',
                                    body: fd,
                                    signal // Pass the AbortController signal
                                });
                                const data = await res.json();
                                if (!res.ok) throw new Error(data.error || "File analysis failed.");
                                finalResponse = data.response;
                            }
                        } catch (err) {
                            finalResponse = err.name === 'AbortError' ? 'âŒ File analysis stopped by user.' : `âŒ File analysis failed: ${err.message}`;
                        }
                    } else if (msgText) {
                        // If no files, send text message to chat API
                        showTypingAtNext(); // Show "..." typing indicator
                        try {
                            // Build history from currentMessages (excluding the message just sent, as it's for Firebase)
                            const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                            const res = await fetch(`${API_BASE_URL}/chat`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }),
                                signal // Pass the AbortController signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Server error.");
                            finalResponse = data.response;
                        } catch (err) {
                            finalResponse = err.name === 'AbortError' ? 'âŒ Response stopped by user.' : `âŒ An error occurred: ${err.message}`;
                        }
                    }

                    // 3. Handle the final response and cleanup
                    removeTyping();
                    if (finalResponse) {
                        await startTypewriter(finalResponse); // Use typewriter for AI response
                    }

                    // 4. Restore Send button and clear AbortController
                    stopButton.replaceWith(UI.sendBtn);
                    currentController = null;
                });
            }

            // =========================================================================
            // 16. Theme Switcher Logic
            // =========================================================================
            const themes = {
                cyber: {
                    '--cyan': '#00fff7', '--blue': '#0a8afe', '--dark-bg': '#070b1a', '--fade-blue': '#133c8b',
                    '--gradient-1': 'linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #0857ee 32%, #00fff0 89%)',
                    '--bubble-glow': '0 0 13px #00d8ffb1, 0 0 24px #0197ff40', '--user-glow': '0 0 22px #0fffd555, 0 0 14px #36f9ff70',
                    '--header-glass': 'rgba(17,29,47,0.92)', '--code-bg': 'linear-gradient(92deg,#031d39 79%,#092ff8 120%)',
                    '--code-border': '#15faff', '--code-text': '#17fafd', '--main-text': '#e1fafe', '--link-text': '#13efff',
                    '--input-bg': '#09284c',
                    '--body-bg': 'radial-gradient(circle at 60% 45%, #112250 37%, #060e1e 88%, #1e0942 100%) fixed, repeating-linear-gradient(100deg,#061c4c 0 9%,#080e20 16% 19%,#030721 30% 41%,#052650 44% 62%,#050b16 74% 89%,#041048 99% 100%)',
                    '--body-blend-mode': 'lighten, color-dodge',
                    '--panel-bg': 'linear-gradient(118deg,#131642 80%,#1629af 200%)', '--panel-border': '#00fbffcb',
                    '--panel-shadow': '0 0 42px #25f8ffc9', '--submit-bg': 'linear-gradient(94deg,#00ffff,#0090ff 90%)',
                    '--submit-text': '#102649', '--submit-hover-bg': '#008cff', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 12px #00ffe0cc, 0 0 27px #178fcf88',
                    '--header-text-anim-glow-1': '0 0 17px #00e7ff70,0 0 30px #0b8fff44',
                    '--header-text-anim-glow-2': '0 0 29px #00ffe9ee,0 0 44px #31d2ff82',
                    '--header-text-fill': 'linear-gradient(90deg,#00fff1,#00b4ff 40%,#fff 59%,#1093f1 89%,#24e0fa 100%)'
                },
                celestial: {
                    '--cyan': '#ff00ff', '--blue': '#8a2be2', '--dark-bg': '#0f001a', '--fade-blue': '#2b003e',
                    '--gradient-1': 'linear-gradient(120deg, #2b003e 39%, #580080 68%, #ff00ff 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #8a2be2 32%, #ff00ff 89%)',
                    '--bubble-glow': '0 0 15px #ff00ffb1', '--user-glow': '0 0 25px #ff66ff55, 0 0 16px #cc00cc70',
                    '--header-glass': 'rgba(25,0,35,0.92)', '--code-bg': 'linear-gradient(92deg,#2b003e 79%,#8a2be2 120%)',
                    '--code-border': '#ff00ff', '--code-text': '#f0e6ff', '--main-text': '#f0e6ff', '--link-text': '#ff66ff',
                    '--input-bg': '#2b003e',
                    '--body-bg': 'radial-gradient(circle at 50% 50%, #1a0033 0%, #0f001a 100%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#2b003e 80%,#580080 200%)', '--panel-border': '#ff00ffcb',
                    '--panel-shadow': '0 0 45px #ff00ffc9', '--submit-bg': 'linear-gradient(94deg,#ff00ff,#8a2be2 90%)',
                    '--submit-text': '#0f001a', '--submit-hover-bg': '#8a2be2', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 15px #ff00ffcc', '--header-text-anim-glow-1': '0 0 20px #ff00ff70',
                    '--header-text-anim-glow-2': '0 0 35px #ff00ffee',
                    '--header-text-fill': 'linear-gradient(90deg,#ff00ff,#8a2be2 40%,#fff 59%,#8a2be2 89%,#ff00ff 100%)'
                },
                starlight: {
                    '--cyan': '#a6faff', '--blue': '#00c3ff', '--dark-bg': '#030010', '--fade-blue': '#100c25',
                    '--gradient-1': 'linear-gradient(120deg, #100c25 39%, #1c153f 68%, #3f337f 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #00c3ff 32%, #a6faff 89%)',
                    '--bubble-glow': '0 0 13px #00c3ffb1', '--user-glow': '0 0 22px #a6faff55',
                    '--header-glass': 'rgba(16,12,37,0.92)', '--code-bg': 'linear-gradient(92deg,#100c25 79%,#3f337f 120%)',
                    '--code-border': '#a6faff', '--code-text': '#a6faff', '--main-text': '#f0faff', '--link-text': '#a6faff',
                    '--input-bg': '#100c25',
                    '--body-bg': 'radial-gradient(ellipse at bottom, #0d0920 0%, #030010 70%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#100c25 80%,#1c153f 200%)', '--panel-border': '#a6faffcb',
                    '--panel-shadow': '0 0 42px #a6faffc9', '--submit-bg': 'linear-gradient(94deg,#a6faff,#00c3ff 90%)',
                    '--submit-text': '#030010', '--submit-hover-bg': '#00c3ff', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 12px #a6faffcc', '--header-text-anim-glow-1': '0 0 17px #a6faff70',
                    '--header-text-anim-glow-2': '0 0 29px #a6faffee',
                    '--header-text-fill': 'linear-gradient(90deg,#a6faff,#00c3ff 40%,#fff 59%,#00f2ff 89%,#a6faff 100%)'
                },
                midnight: {
                    '--cyan': '#3391ff', '--blue': '#007bff', '--dark-bg': '#121212', '--fade-blue': '#282828',
                    '--gradient-1': 'linear-gradient(120deg, #282828 39%, #333 68%, #444 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #007bff 32%, #3391ff 89%)',
                    '--bubble-glow': '0 0 8px #007bff44', '--user-glow': '0 0 12px #3391ff44',
                    '--header-glass': 'rgba(18,18,18,0.92)', '--code-bg': 'linear-gradient(92deg,#222 79%,#333 120%)',
                    '--code-border': '#444', '--code-text': '#f1f1f1', '--main-text': '#f1f1f1', '--link-text': '#3391ff',
                    '--input-bg': '#282828',
                    '--body-bg': 'linear-gradient(180deg, #181818 0%, #121212 100%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#1e1e1e 80%,#282828 200%)', '--panel-border': '#444',
                    '--panel-shadow': '0 0 20px #000000c9', '--submit-bg': 'linear-gradient(94deg,#007bff,#3391ff 90%)',
                    '--submit-text': '#fff', '--submit-hover-bg': '#0069d9', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 10px #3391ffaa', '--header-text-anim-glow-1': '0 0 12px #3391ff70',
                    '--header-text-anim-glow-2': '0 0 15px #3391ffee',
                    '--header-text-fill': 'linear-gradient(90deg,#3391ff,#007bff 40%,#fff 59%,#3391ff 89%,#aaccff 100%)'
                },
                forest: {
                    '--cyan': '#99cc99', '--blue': '#669966', '--dark-bg': '#2a362a', '--fade-blue': '#4a5a4a',
                    '--gradient-1': 'linear-gradient(120deg, #3a473a 39%, #5a6b5a 68%, #99cc99 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #669966 32%, #99cc99 89%)',
                    '--bubble-glow': '0 0 10px #99cc99b1', '--user-glow': '0 0 18px #99cc9955',
                    '--header-glass': 'rgba(42,54,42,0.92)', '--code-bg': 'linear-gradient(92deg,#3a473a 79%,#5a6b5a 120%)',
                    '--code-border': '#99cc99', '--code-text': '#e0ffe0', '--main-text': '#e0ffe0', '--link-text': '#99cc99',
                    '--input-bg': '#4a5a4a',
                    '--body-bg': 'linear-gradient(180deg, #3a473a 0%, #2a362a 100%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#3a473a 80%,#4a5a4a 200%)', '--panel-border': '#99cc99cb',
                    '--panel-shadow': '0 0 35px #99cc99c9', '--submit-bg': 'linear-gradient(94deg,#99cc99,#669966 90%)',
                    '--submit-text': '#2a362a', '--submit-hover-bg': '#669966', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 10px #99cc99cc', '--header-text-anim-glow-1': '0 0 15px #99cc9970',
                    '--header-text-anim-glow-2': '0 0 25px #99cc99ee',
                    '--header-text-fill': 'linear-gradient(90deg,#99cc99,#669966 40%,#fff 59%,#669966 89%,#99cc99 100%)'
                },
                volcano: {
                    '--cyan': '#ff7043', '--blue': '#bf360c', '--dark-bg': '#3e1a0b', '--fade-blue': '#5e2a1b',
                    '--gradient-1': 'linear-gradient(120deg, #4e2211 39%, #6e3a2c 68%, #ff7043 97%)',
                    '--gradient-user': 'linear-gradient(120deg, #bf360c 32%, #ff7043 89%)',
                    '--bubble-glow': '0 0 12px #ff7043b1', '--user-glow': '0 0 20px #ff704355',
                    '--header-glass': 'rgba(62,26,11,0.92)', '--code-bg': 'linear-gradient(92deg,#4e2211 79%,#6e3a2c 120%)',
                    '--code-border': '#ff7043', '--code-text': '#fff0e0', '--main-text': '#fff0e0', '--link-text': '#ff7043',
                    '--input-bg': '#5e2a1b',
                    '--body-bg': 'radial-gradient(circle at 50% 50%, #6e3a2c 0%, #3e1a0b 100%)',
                    '--body-blend-mode': 'normal',
                    '--panel-bg': 'linear-gradient(118deg,#4e2211 80%,#5e2a1b 200%)', '--panel-border': '#ff7043cb',
                    '--panel-shadow': '0 0 40px #ff7043c9', '--submit-bg': 'linear-gradient(94deg,#ff7043,#bf360c 90%)',
                    '--submit-text': '#3e1a0b', '--submit-hover-bg': '#bf360c', '--submit-hover-text': '#fff',
                    '--header-text-glow': '0 0 12px #ff7043cc', '--header-text-anim-glow-1': '0 0 17px #ff704370',
                    '--header-text-anim-glow-2': '0 0 29px #ff7043ee',
                    '--header-text-fill': 'linear-gradient(90deg,#ff7043,#bf360c 40%,#fff 59%,#bf360c 89%,#ff7043 100%)'
                }
            };
            let currentThemeIdx = 0;
            const themeKeys = Object.keys(themes);

            /**
             * Applies a theme by setting CSS custom properties.
             * @param {string} themeName - The name of the theme to apply.
             */
            function applyTheme(themeName) {
                const theme = themes[themeName];
                if (!theme) return;

                for (const key in theme) {
                    document.documentElement.style.setProperty(key, theme[key]);
                }
                localStorage.setItem('philadelphia-theme', themeName); // Persist theme preference

                // Update theme button icon based on the applied theme
                let iconClass = 'fa-solid fa-moon'; // Default
                if (themeName === 'forest') iconClass = 'fa-solid fa-leaf';
                else if (themeName === 'volcano') iconClass = 'fa-solid fa-fire';
                else if (themeName === 'starlight') iconClass = 'fa-solid fa-star';
                else if (themeName === 'celestial') iconClass = 'fa-solid fa-galaxy'; // Example unique icon
                UI.themeBtn.innerHTML = `<i class="${iconClass}"></i>`;
            }

            // Theme switcher button click handler
            if (UI.themeBtn) {
                UI.themeBtn.addEventListener('click', () => {
                    currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
                    applyTheme(themeKeys[currentThemeIdx]);
                });
            }

            // Load saved theme on startup, or apply default
            const savedTheme = localStorage.getItem('philadelphia-theme');
            if (savedTheme && themes[savedTheme]) {
                currentThemeIdx = themeKeys.indexOf(savedTheme);
                applyTheme(savedTheme);
            } else {
                applyTheme('cyber'); // Default theme
            }

            // =========================================================================
            // 17. Voice Call Logic
            // =========================================================================
            let speechRecognition;
            let isCallActive = false;
            let callHistory = []; // Stores text of call conversation for bot context
            let botIsSpeaking = false;
            let userSaidSomething = false; // Flag to track if user spoke during a recognition session
            let currentAudio = null; // Reference to currently playing bot audio
            let isMuted = false; // Microphone mute state

            // Check for Speech Recognition API support
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = true; // Keep listening
                speechRecognition.interimResults = true; // Provide interim results
                speechRecognition.lang = 'en-US';

                speechRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    userSaidSomething = true; // User is speaking

                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }

                    // Update user's interim speech in the call conversation
                    let userMsgEl = UI.callConversation.querySelector('.call-msg.user.interim');
                    if (!userMsgEl) {
                        userMsgEl = document.createElement('div');
                        userMsgEl.className = 'call-msg user interim';
                        UI.callConversation.appendChild(userMsgEl);
                    }
                    userMsgEl.textContent = finalTranscript || interimTranscript;
                    UI.callConversation.scrollTop = UI.callConversation.scrollHeight;

                    // Update status message
                    UI.callStatusMessage.textContent = finalTranscript ? 'User Speaking (Final)' : 'User Speaking...';
                    UI.tapToTalk.style.display = 'none';
                };

                speechRecognition.onspeechend = () => {
                    // This event fires when speech is detected and then stops.
                    // The onend event will handle the final processing.
                };

                speechRecognition.onend = () => {
                    if (!isCallActive) return; // If call ended, do nothing

                    let finalTranscript = '';
                    const userMsgEl = UI.callConversation.querySelector('.call-msg.user.interim');
                    if (userMsgEl) {
                        finalTranscript = userMsgEl.textContent.trim();
                        userMsgEl.classList.remove('interim'); // Remove interim class once final
                    }

                    if (botIsSpeaking) {
                        // If bot is still speaking, we just wait for it to finish.
                        // The `speakBotResponse` function will restart recognition.
                    } else if (isMuted) {
                        UI.callStatusMessage.textContent = 'Microphone Muted.';
                        UI.tapToTalk.style.display = 'none';
                    } else if (finalTranscript && userSaidSomething) {
                        // User finished speaking and actually said something
                        userSaidSomething = false; // Reset flag
                        callHistory.push({ role: 'user', content: finalTranscript });
                        handleCallBotResponse();
                    } else {
                        // User didn't say anything, or it was too short. Restart listening.
                        if (isCallActive && !isMuted) {
                            UI.callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            UI.tapToTalk.style.display = 'block';
                            try {
                                speechRecognition.start(); // Restart recognition
                            } catch (e) { console.warn("Speech recognition failed to start automatically:", e); }
                        }
                    }
                };

                speechRecognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    if (event.error === 'no-speech' && isCallActive && !isMuted) {
                        userSaidSomething = false; // Reset flag if no speech was detected
                        // Force restart listening if no speech was detected and not muted
                        speechRecognition.stop(); // Stop might trigger onend, which then restarts
                    } else if (event.error === 'network' && isCallActive) {
                        UI.callStatusMessage.textContent = 'Network error during call. Attempting restart...';
                        speechRecognition.stop();
                    } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                        UI.callStatusMessage.textContent = 'Microphone permission denied. Please allow in browser settings.';
                        endCall(); // End call if permission is permanently denied
                    }
                };
            } else {
                if (UI.callBtn) UI.callBtn.style.display = 'none'; // Hide call button if not supported
                console.warn("Speech Recognition API not supported in this browser. Voice call feature disabled.");
            }

            /**
             * Adds a message to the call conversation UI.
             * @param {'user' | 'bot' | 'status'} role - The role of the message sender.
             * @param {string} text - The message content.
             */
            function addCallMessage(role, text) {
                const msgEl = document.createElement('div');
                msgEl.className = `call-msg ${role}`;
                msgEl.textContent = text;
                UI.callConversation.appendChild(msgEl);
                UI.callConversation.scrollTop = UI.callConversation.scrollHeight;
            }

            /** Handles sending user's speech to the bot and receiving its response. */
            async function handleCallBotResponse() {
                if (!isCallActive) return;

                UI.callStatusMessage.textContent = 'Philadelphia AI is thinking...';
                UI.tapToTalk.style.display = 'none';

                const historyForBot = [...callHistory]; // Clone history for API call
                const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : "";

                try {
                    speechRecognition.stop(); // Stop recognition while bot is thinking/speaking

                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: userMessage,
                            history: historyForBot.slice(0, -1), // Send history *before* the last user message
                            user_id: currentUser?.uid || "user"
                        })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "Server error.");

                    const botResponse = data.response;
                    callHistory.push({ role: 'ai', content: botResponse }); // Add bot response to history
                    addCallMessage('bot', botResponse); // Display bot response in UI
                    speakBotResponse(botResponse); // Convert bot's text to speech
                } catch (err) {
                    console.error("Error during call bot response:", err);
                    const errorMsg = `âŒ Call error: ${err.message}`;
                    addCallMessage('bot', errorMsg);
                    // Restart listening if call is still active and not muted, even after error
                    if (isCallActive && !isMuted) {
                        UI.callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                        UI.tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch (e) { console.warn("Speech recognition failed to start after error:", e); }
                    }
                }
            }

            /**
             * Converts bot's text response to speech and plays it.
             * @param {string} text - The text for the bot to speak.
             */
            async function speakBotResponse(text) {
                if (!isCallActive) return;

                botIsSpeaking = true;
                UI.botImageContainer.classList.add('speaking');
                UI.callStatusMessage.textContent = 'Philadelphia AI is speaking...';

                try {
                    // Using Minimax "elder" voice specifically for a distinctive AI voice
                    const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: text, voice_id: 'elder' })
                    });
                    if (!res.ok) throw new Error(await res.text());

                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    currentAudio = audio; // Store reference to allow stopping audio

                    audio.onended = audio.onerror = () => {
                        botIsSpeaking = false;
                        UI.botImageContainer.classList.remove('speaking');
                        currentAudio = null; // Clear audio reference

                        // Restart listening for user input if call is active and not muted
                        if (isCallActive && !isMuted) {
                            UI.callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            UI.tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch (e) { console.warn("Speech recognition failed to start after speaking:", e); }
                        } else if (isMuted) {
                            UI.callStatusMessage.textContent = 'Microphone Muted.';
                            UI.tapToTalk.style.display = 'none';
                        }
                    };
                    audio.play();
                } catch (err) {
                    console.error("Voice generation for bot response failed:", err);
                    botIsSpeaking = false;
                    UI.botImageContainer.classList.remove('speaking');
                    // If speaking failed, restart listening
                    if (isCallActive && !isMuted) {
                        UI.callStatusMessage.textContent = 'Listening (Voice Failed)...';
                        UI.tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch (e) { console.warn("Speech recognition failed to start after voice error:", e); }
                    } else if (isMuted) {
                        UI.callStatusMessage.textContent = 'Microphone Muted.';
                        UI.tapToTalk.style.display = 'none';
                    }
                }
            }

            /** Allows user to interrupt bot and start speaking. */
            function stopBotSpeakingAndStartListening() {
                if (!isCallActive || !botIsSpeaking) return; // Only act if call is active and bot is speaking

                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                botIsSpeaking = false;
                UI.botImageContainer.classList.remove('speaking');

                if (!isMuted) {
                    UI.callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    UI.tapToTalk.style.display = 'block';
                    // Restart listening for user input
                    try { speechRecognition.stop(); speechRecognition.start(); } catch (e) { console.warn("Could not restart speech recognition immediately:", e); }
                } else {
                    UI.callStatusMessage.textContent = 'Microphone Muted.';
                    UI.tapToTalk.style.display = 'none';
                }
                // Clear any interim user message that might be lingering
                const userMsgEl = UI.callConversation.querySelector('.call-msg.user.interim');
                if (userMsgEl) userMsgEl.textContent = '';
            }

            // Event listeners to interrupt bot
            UI.callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
            UI.callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);

            // Start Call Button
            if (UI.callBtn) {
                UI.callBtn.addEventListener('click', () => {
                    if (!SpeechRecognition) {
                        alert("Sorry, your browser doesn't support the Speech Recognition needed for this feature.");
                        return;
                    }
                    isCallActive = true;
                    isMuted = false; // Reset mute state
                    if (UI.muteCallBtn) {
                        UI.muteCallBtn.classList.remove('muted');
                        UI.muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
                    }
                    UI.callModal.classList.add('active');
                    UI.callConversation.innerHTML = ''; // Clear old call conversation
                    addCallMessage('status', 'Connecting to Philadelphia AI...');
                    UI.callStatusMessage.textContent = 'Calling...';
                    UI.tapToTalk.style.display = 'none';
                    callHistory = []; // Reset call history

                    // Simulate connection delay, then start listening
                    setTimeout(() => {
                        if (!isCallActive) return; // Check if call was ended during delay
                        addCallMessage('status', 'Call Connected. Speak when ready.');
                        UI.callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                        UI.tapToTalk.style.display = 'block';
                        try {
                            speechRecognition.start();
                        } catch (e) {
                            console.error("Speech recognition start failed:", e);
                            UI.callStatusMessage.textContent = 'Microphone error. Check permissions.';
                        }
                    }, 1500);
                });
            }

            /** Ends the ongoing voice call and resets state. */
            function endCall() {
                isCallActive = false;
                botIsSpeaking = false;
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                if (UI.callModal) UI.callModal.classList.remove('active');
                try { speechRecognition.stop(); } catch (e) { /* ignore if already stopped */ }
                if (UI.botImageContainer) UI.botImageContainer.classList.remove('speaking');
                if (UI.tapToTalk) UI.tapToTalk.style.display = 'none';
                if (UI.callStatusMessage) UI.callStatusMessage.textContent = 'Call Ended.';
            }

            // End Call Button
            if (UI.endCallBtn) UI.endCallBtn.addEventListener('click', endCall);

            // Mute/Unmute Button
            if (UI.muteCallBtn) {
                UI.muteCallBtn.addEventListener('click', () => {
                    isMuted = !isMuted;
                    if (isMuted) {
                        UI.muteCallBtn.classList.add('muted');
                        UI.muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute Microphone';
                        speechRecognition.stop(); // Stop listening when muted
                        UI.callStatusMessage.textContent = 'Microphone Muted.';
                        UI.tapToTalk.style.display = 'none';
                    } else {
                        UI.muteCallBtn.classList.remove('muted');
                        UI.muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
                        if (isCallActive && !botIsSpeaking) {
                            // Only restart if call is active and bot isn't speaking
                            UI.callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            UI.tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch (e) { console.warn("Speech recognition failed to start after unmute:", e); }
                        } else if (isCallActive && botIsSpeaking) {
                            // If bot is speaking, just update status
                            UI.callStatusMessage.textContent = 'Philadelphia AI is speaking...';
                            UI.tapToTalk.style.display = 'none';
                        }
                    }
                });
            }

            // Final UI focus on chat input
            if (UI.chatInput) UI.chatInput.focus();
        }); // end DOMContentLoaded
    </script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
