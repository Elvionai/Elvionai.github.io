<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Philadelphia AI - Chat </title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
    <style>
        /* Define global CSS variables for Cosmic Plasma Theme */
        :root {
            --neon-blue: #00f2ff;
            --neon-purple: #bd00ff;
            --neon-green: #00ff88; /* Accent for success/active states */
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple), var(--neon-green));
            --plasma-gradient-dark: linear-gradient(135deg, #00b0ff, #8a00b0);

            --glass-bg-strong: rgba(20, 20, 35, 0.8); /* Even more opaque */
            --glass-bg-light: rgba(255, 255, 255, 0.12); /* Even more opaque */
            --glass-border: rgba(255, 255, 255, 0.25); /* Stronger border */

            --text-glow: 0 0 12px rgba(0, 242, 255, 0.8), 0 0 20px rgba(189, 0, 255, 0.6); /* Stronger glow */
            --box-glow: 0 0 20px rgba(0, 242, 255, 0.25); /* Stronger glow */
            --user-bubble-glow: 0 0 15px rgba(0, 242, 255, 0.5), 0 0 25px rgba(189, 0, 255, 0.4); /* Stronger glow */
            --ai-bubble-glow: 0 0 10px rgba(0, 242, 255, 0.3), 0 0 18px rgba(0, 255, 136, 0.15); /* Stronger glow */

            --main-text-color: #e0f0ff;
            --input-focus-bg: rgba(0, 242, 255, 0.12); /* Slightly more opaque */
            --code-bg: rgba(10, 10, 20, 0.98); /* More opaque */
            --code-border: rgba(0, 242, 255, 0.6); /* Stronger border */

            --panel-bg: linear-gradient(118deg, rgba(10, 10, 30, 0.99), rgba(25, 5, 40, 0.99)); /* More opaque */
            --panel-border: var(--neon-purple);
            --panel-shadow: 0 0 45px rgba(189, 0, 255, 0.5); /* Stronger shadow */

            /* Call Modal Specifics - REVAMPED */
            --call-bg-gradient: linear-gradient(180deg, #000000, #0c001a); /* Even deeper, more dramatic */
            --call-header-glow: 0 0 20px var(--neon-blue), 0 0 35px var(--neon-purple); /* Intense glow */
            --call-bot-speaking-glow: 0 0 30px var(--neon-green), 0 0 50px rgba(0, 255, 136, 0.8); /* Super prominent */
            --call-control-bg: rgba(20, 20, 35, 0.95); /* More opaque */
            --call-control-border: rgba(255, 255, 255, 0.3); /* Stronger border */
            --call-text-color: var(--main-text-color);
            --call-user-text-color: #f0faff; /* Even lighter blue for user speech */
            --call-ai-text-color: var(--neon-green); /* Distinct green for AI speech */

            --body-base-bg: #000205; /* Even darker base */
            --current-bg-blend-mode: screen;
        }

        /* --- GLOBAL RESET & BASE STYLES --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }

        html {
            -webkit-tap-highlight-color: transparent; /* Disable tap highlight on mobile */
            height: 100%;
            width: 100%;
        }
        
        body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Prevent body scroll, custom scroll for chat */
            font-family: 'Segoe UI', 'Roboto', 'Inter', Helvetica, sans-serif;
            background-color: var(--body-base-bg);
            color: var(--main-text-color);
            display: flex;
            justify-content: center;
            align-items: center; /* Center the UI container */
        }

        /* --- COSMIC BACKGROUND ENGINE - ENHANCED --- */
        #cosmos-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1; /* Behind UI */
            overflow: hidden;
            background-color: var(--body-base-bg);
        }

        .nebula-layer {
            position: absolute; top: 0; left: 0; width: 400%; height: 400%; /* Even Larger to allow more drift */
            background:
                radial-gradient(circle at 50% 50%, rgba(76, 0, 255, 0.22), transparent 70%), /* Stronger core */
                radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.25), transparent 60%), 
                linear-gradient(to bottom right, rgba(5, 7, 20, 0.25), rgba(26, 10, 46, 0.25)); /* Deeper contrast */
            mix-blend-mode: var(--current-bg-blend-mode);
            animation: drift 110s infinite linear alternate; /* Slower, more majestic drift */
            will-change: transform;
        }

        .nebula-layer:nth-child(2) {
            background: radial-gradient(circle at 20% 80%, rgba(189, 0, 255, 0.35), transparent 70%), /* Stronger purple */
                        radial-gradient(circle at 70% 30%, rgba(0, 255, 136, 0.25), transparent 65%); /* More green spread */
            animation: drift 95s infinite linear reverse alternate; /* Varied speed */
            mix-blend-mode: overlay;
        }
        .nebula-layer:nth-child(3) {
            background: radial-gradient(circle at 30% 10%, rgba(0, 242, 255, 0.2), transparent 80%), /* Subtle blue */
                        radial-gradient(circle at 90% 90%, rgba(189, 0, 255, 0.2), transparent 75%); /* Subtle purple */
            animation: drift 130s infinite linear; /* Very slow drift */
            mix-blend-mode: soft-light;
        }

        @keyframes drift {
            0% { transform: translate(0, 0) rotate(0deg); }
            100% { transform: translate(-90%, -90%) rotate(30deg); } /* Larger movement, more rotation */
        }

        .star {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            background: var(--neon-blue); /* More integrated color */
            animation: twinkle var(--duration) infinite ease-in-out alternate;
            box-shadow: 0 0 8px rgba(0, 242, 255, 0.9), 0 0 15px rgba(0, 242, 255, 0.7); /* Stronger glow */
            will-change: transform, opacity;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.15; transform: scale(0.4); } /* Softer start/end */
            50% { opacity: 1.2; transform: scale(1.6); } /* Brighter, larger peak - more lively */
        }

        .shooting-star {
            position: absolute;
            height: 5px; /* Thicker trail */
            background: linear-gradient(-90deg, var(--neon-blue), transparent); /* Use neon blue for shooting stars */
            filter: drop-shadow(0 0 15px var(--neon-blue)); /* Stronger shadow */
            animation: shoot var(--duration) ease-out forwards; /* forwards to ensure full animation */
            opacity: 0;
            z-index: 0;
            will-change: transform, opacity, width;
        }
        @keyframes shoot {
            0% { transform: translate(var(--startX), var(--startY)) rotate(-50deg); opacity: 0; width: 0; } /* Steeper angle */
            5% { opacity: 1; width: var(--initialWidth); }
            95% { opacity: 0.5; width: 0; }
            100% { transform: translate(calc(var(--startX) + var(--travelX)), calc(var(--startY) + var(--travelY))) rotate(-50deg); opacity: 0; width: 0; }
        }

        .cosmic-eagle {
            position: absolute;
            width: 140px; height: auto; /* Slightly larger eagle */
            opacity: 0.18; /* More visible */
            filter: blur(0.9px); /* Slightly more blur */
            animation: eagleFlight 220s infinite linear; /* Even slower, more majestic flight */
            mix-blend-mode: screen;
            pointer-events: none;
            will-change: transform, opacity;
        }
        @keyframes eagleFlight {
            0% { transform: translate(-50vw, 50vh) scale(1) rotateY(0deg); opacity: 0.12; }
            25% { transform: translate(150vw, 30vh) scale(1.2) rotateY(0deg); opacity: 0.25; }
            26% { transform: translate(150vw, 30vh) scale(1.2) rotateY(180deg); opacity: 0.25; } /* Flip */
            50% { transform: translate(-50vw, 70vh) scale(1.1) rotateY(180deg); opacity: 0.15; }
            51% { transform: translate(-50vw, 70vh) scale(1.1) rotateY(0deg); opacity: 0.15; } /* Flip */
            75% { transform: translate(150vw, 10vh) scale(1.3) rotateY(0deg); opacity: 0.3; }
            100% { transform: translate(-50vw, 50vh) scale(1) rotateY(0deg); opacity: 0.12; }
        }

        /* --- UI MAIN STRUCTURE - REVAMPED FOR 95% FLOATING VIEW --- */
        .ui-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10;
            background: rgba(5, 7, 20, 0.6);
            border-left: 1px solid rgba(255,255,255,0.15);
            border-right: 1px solid rgba(255,255,255,0.15);
            max-width: 950px;
        }
        
        @media (min-width: 1024px) {
            .ui-container {
                border-radius: 25px; /* Rounded corners on desktop */
                height: 95vh; /* 95% of viewport height */
                width: 95vw; /* 95% of viewport width */
                max-width: 1400px; /* Wider max-width */
                box-shadow: 0 0 60px rgba(0, 242, 255, 0.25), 0 0 80px rgba(189, 0, 255, 0.2);
                border: 1px solid var(--glass-border);
                overflow: hidden; /* Hide anything that might spill out from rounded corners */
            }
        }


        /* Header */
        header {
            padding: 25px 35px; /* Increased padding */
            display: flex; justify-content: space-between; align-items: center;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(30px); /* Stronger blur */
            -webkit-backdrop-filter: blur(30px);
            border-bottom: 1.5px solid var(--glass-border);
            box-shadow: 0 7px 20px rgba(0,0,0,0.5); /* Stronger shadow */
            position: sticky; top: 0; z-index: 100;
            flex-shrink: 0;
        }

        .header-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
        }

        .brand-plasma {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem; font-weight: 800; letter-spacing: 4px; /* Increased size and spacing */
            background: linear-gradient(90deg, #fff, var(--neon-blue), var(--neon-purple), #fff);
            background-size: 300% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: plasmaFlow 3.5s linear infinite; /* Faster flow */
            text-shadow: var(--text-glow);
            white-space: nowrap;
            user-select: none;
            transition: all 0.3s ease;
        }
        @keyframes plasmaFlow { to { background-position: 300% center; } }

        .header-welcome {
            font-size: 1em; /* Slightly larger */
            color: rgba(255, 255, 255, 0.85); /* Brighter */
            margin-top: 8px; /* More spacing */
            text-shadow: 0 0 10px var(--neon-blue); /* Stronger glow */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 220px; /* Increased width */
        }

        .header-actions { display: flex; gap: 30px; font-size: 1.7rem; } /* Increased gap and size */
        .icon-btn { cursor: pointer; opacity: 0.9; transition: 0.3s; position: relative; color: var(--neon-blue); }
        .icon-btn:hover { opacity: 1; text-shadow: var(--text-glow); transform: scale(1.25); color: #fff; } /* More pronounced hover */

        /* Chat Area */
        #chat-viewport {
            flex: 1; overflow-y: auto; padding: 35px; display: flex; flex-direction: column; gap: 35px; /* Increased padding and gap */
            scroll-behavior: smooth;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
            position: relative;
        }
        #chat-viewport::-webkit-scrollbar { display: none; } /* Chrome, Safari, Opera */

        .message-group { display: flex; flex-direction: column; gap: 15px; max-width: 85%; position: relative; } /* Increased gap and max-width */
        .message-group.ai { align-self: flex-start; }
        .message-group.user { align-self: flex-end; align-items: flex-end; }
        .message-group.system { align-self: center; text-align: center; font-style: italic; opacity: 0.8; font-size: 1em; }
        
        .msg-bubble {
            padding: 22px 30px; border-radius: 32px; /* Larger padding and radius */
            font-size: 1.15rem; line-height: 1.7; /* Slightly larger text and line height */
            backdrop-filter: blur(22px); /* Stronger blur */
            -webkit-backdrop-filter: blur(22px);
            border: 2px solid var(--glass-border); /* Thicker border */
            animation: popIn 0.45s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow-wrap: break-word;
            word-break: break-word;
        }
        @keyframes popIn { from { opacity: 0; transform: translateY(35px) scale(0.85); } to { opacity: 1; transform: translateY(0) scale(1); } } /* More pronounced pop-in */

        .ai .msg-bubble {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.75), rgba(20, 20, 35, 0.9);); /* Slightly more opaque */
            border-bottom-left-radius: 12px; /* Larger corner radius */
            box-shadow: inset 0 0 22px rgba(0, 242, 255, 0.12); /* Stronger inset glow */
        }
        .ai .msg-bubble img.chat-media-preview,
        .ai .msg-bubble video.chat-media-preview,
        .ai .msg-bubble audio.chat-media-preview {
            max-width: 100%; border-radius: 20px; margin-top: 18px; border: 3.5px solid var(--neon-blue); box-shadow: var(--box-glow);
            display: block;
        }

        .user .msg-bubble {
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.45), rgba(189, 0, 255, 0.45)); /* Slightly more opaque */
            border-bottom-right-radius: 12px; /* Larger corner radius */
            color: var(--main-text-color); text-shadow: 0 1px 5px rgba(0,0,0,0.7); /* Stronger text shadow */
            box-shadow: var(--user-bubble-glow);
            border: 2px solid rgba(255,255,255,0.45);
        }
        .user .msg-bubble .file-attachments {
            display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 18px; /* Increased spacing */
            justify-content: flex-end;
        }
        .user .msg-bubble .file-placeholder {
            display: inline-flex; align-items: center; padding: 12px 18px; /* Larger padding */
            background: rgba(255,255,255,0.18); border-radius: 15px; /* Larger radius */
            border: 2px solid var(--neon-blue); color: var(--neon-blue);
            font-size: 1em; /* Slightly larger */
        }
        .user .msg-bubble .file-placeholder i { margin-right: 10px; }


        pre {
            background: var(--code-bg);
            border-radius: 20px; /* Larger radius */
            border: 3px solid var(--code-border); /* Thicker border */
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.4), inset 0 0 35px rgba(0, 242, 255, 0.2); /* Stronger glow */
            margin: 1.4em 0 1.35em 0; /* Adjusted margin */
            padding: 1.45em 1.6em 1.4em 1.4em; /* Adjusted padding */
            overflow-x: auto;
            position: relative;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1em; /* Slightly larger */
            color: rgba(255, 255, 255, 0.99); /* Brighter */
            white-space: pre-wrap;
            word-break: break-word;
        }
        pre:before {
            content: "CODE // " attr(data-lang);
            color: var(--neon-green);
            font-size: 0.95em; /* Slightly larger */
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 15px; right: 35px; /* Adjusted position */
            opacity: 0.6; /* Slightly more opaque */
            letter-spacing: 0.2em; /* More spacing */
        }
        pre.highlighted code {
            text-shadow: 0 0 5px rgba(0,242,255,0.9); /* Stronger glow for highlighted text */
        }
        
        /* Always visible controls */
        .ai-msg-controls, .user-msg-controls {
            opacity: 1; /* Always visible now */
            display: flex; /* Ensure it's always laid out */
            transition: none; /* No transition on opacity anymore */
            margin-top: 8px; /* Maintain spacing */
            justify-content: flex-end; /* Align right */
            gap: 10px; /* Space between icons */
            align-items: center; /* Vertically center icons */
        }
        
        .copy-btn, .inline-copy-btn, .inline-share-btn, .inline-regen-btn, .inline-edit-btn, .switch-model-btn {
            padding: 8px 12px; border-radius: 12px; font-size: 0.8em; cursor: pointer; /* Smaller, more subtle */
            background: rgba(255, 255, 255, 0.1); color: var(--main-text-color); font-weight: bold;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: none;
            transition: all 0.2s ease;
            display: inline-flex; align-items: center; gap: 8px; 
            user-select: none;
            position: relative; /* For model switch popup */
        }
        .copy-btn:hover, .inline-copy-btn:hover, .inline-share-btn:hover, .inline-regen-btn:hover, .inline-edit-btn:hover, .switch-model-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.5);
            color: #fff;
            background: var(--plasma-gradient-dark);
        }
        /* Specific styling for switch model button icon */
        .switch-model-btn i.fa-sitemap {
            margin-right: 0; /* No margin as it's the primary icon */
        }

        /* --- NEW: Model Switch Popup Menu --- */
        .model-switch-popup {
            display: none;
            position: absolute;
            bottom: calc(100% + 10px); /* Position above the button */
            right: 0;
            background: var(--panel-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 15px;
            box-shadow: var(--panel-shadow);
            z-index: 1000;
            overflow: hidden;
            flex-direction: column;
            animation: popIn 0.2s ease-out;
            width: 260px;
        }
        .switch-model-btn:hover .model-switch-popup,
        .model-switch-popup:hover {
             display: flex;
        }
        .model-switch-popup button {
            background: transparent;
            border: none;
            border-radius: 0;
            color: var(--main-text-color);
            padding: 12px 20px;
            font-size: 0.9em;
            text-align: left;
            width: 100%;
            margin: 0;
            box-shadow: none;
            gap: 8px;
            display: flex;
            align-items: center;
        }
        .model-switch-popup button:hover {
            background: rgba(0, 242, 255, 0.2);
            color: #fff;
            transform: none; /* Override default button hover */
        }
        .model-switch-popup button:not(:last-child) {
            border-bottom: 1px solid var(--glass-border);
        }

        /* --- UPGRADED --- Typing & Processing Status Styles */
        .message-group.ai .msg-bubble .ai-content-area {
            min-height: 1.15rem; /* Ensure minimum height for typing */
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        /* This is the live typewriter cursor */
        .typewriter-cursor {
            display: inline-block;
            width: 10px;
            height: 1.2em;
            background: var(--neon-green);
            animation: cursor-blink 0.8s infinite;
            margin-left: 2px;
            vertical-align: bottom;
            border-radius: 2px;
            box-shadow: 0 0 8px var(--neon-green);
        }
        @keyframes cursor-blink {
            50% { opacity: 0; }
        }

        /* New "thinking" animation before stream starts */
        .thinking-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
        }
        .thinking-indicator .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--neon-blue);
            animation: thinking-wave 1.0s infinite ease-in-out; /* IMPROVEMENT: Animation speed increased from 1.5s */
            box-shadow: 0 0 10px var(--neon-blue);
        }
        .thinking-indicator .dot:nth-child(2) { animation-delay: -0.8s; }
        .thinking-indicator .dot:nth-child(3) { animation-delay: -0.6s; }
        @keyframes thinking-wave {
            0%, 60%, 100% { transform: scale(0.6); opacity: 0.5; }
            30% { transform: scale(1.4); opacity: 1; }
        }

        /* General Spinner (for 'Generating...' type messages) */
        .spinner {
            display: inline-block;
            width: 25px; height: 25px; /* Smaller spinner for inline use */
            border: 4px solid rgba(0, 255, 247, 0.6);
            border-radius: 50%;
            border-top-color: var(--neon-green);
            animation: spin 0.6s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }


        /* --- Input Dock - REVAMPED & WIDER --- */
        .input-dock {
            padding: 20px 35px;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(35px);
            -webkit-backdrop-filter: blur(35px);
            border-top: 1.5px solid var(--glass-border);
            display: flex;
            gap: 20px; /* Increased gap for new layout */
            align-items: center;
            position: sticky;
            bottom: 0;
            z-index: 100;
            min-height: 100px;
            flex-shrink: 0;
        }

        .capsule-input {
            flex: 1; /* Allows it to take up available space */
            position: relative; 
            min-height: 60px; /* Taller */
            background: var(--glass-bg-light);
            border-radius: 30px; /* More rectangular */
            border: 2px solid var(--glass-border);
            transition: 0.3s; 
            display: flex;
            align-items: center;
            box-shadow: inset 0 5px 18px rgba(0,0,0,0.5);
            padding: 0 15px;
            padding-right: calc(15px + (38px * 3) + (8px * 2)); /* Make space for internal buttons */
            overflow: hidden;
        }
        .capsule-input:focus-within {
            border-color: var(--neon-blue);
            box-shadow: 0 0 40px rgba(0, 242, 255, 0.5), inset 0 5px 18px rgba(0,0,0,0.5);
            background: var(--input-focus-bg);
        }

        .capsule-input textarea {
            flex: 1; 
            width: 100%;
            height: 55px;
            max-height: 220px;
            background: transparent; border: none;
            padding: 15px 0; /* More vertical padding */
            color: var(--main-text-color); font-size: 1.2rem; outline: none; /* Larger font */
            resize: none;
            scrollbar-width: thin;
            scrollbar-color: var(--neon-blue) transparent;
            -ms-overflow-style: -ms-autohiding-scrollbar;
            position: relative; z-index: 1;
            line-height: 1.5;
        }
        .capsule-input textarea::-webkit-scrollbar { width: 8px; }
        .capsule-input textarea::-webkit-scrollbar-thumb { background: var(--neon-blue); border-radius: 10px; }
        .capsule-input textarea::-webkit-scrollbar-track { background: rgba(0, 242, 255, 0.1); }

        .main-action-buttons {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 8px; /* More space between buttons */
            z-index: 2;
        }
        .main-action-buttons button,
        .main-action-buttons label {
            background: none; border: none; color: var(--neon-blue); font-size: 1.3em; /* Larger icons */
            cursor: pointer; border-radius: 12px; 
            transition: color 0.15s, background 0.15s;
            padding: 5px; width: 38px; height: 38px; /* Larger buttons */
            display: flex; align-items: center; justify-content: center;
            user-select: none;
        }
        .main-action-buttons button:hover,
        .main-action-buttons label:hover {
            color: #fff; background: rgba(0, 242, 255, 0.3);
        }

        .thruster-btn {
            width: 60px; height: 60px; /* Larger */
            border-radius: 50%; border: none; cursor: pointer;
            background: var(--plasma-gradient);
            display: flex; align-items: center; justify-content: center;
            box-shadow: var(--box-glow); transition: 0.3s transform, 0.3s box-shadow, 0.3s background;
            color: #000;
            position: relative; z-index: 1;
            user-select: none;
            flex-shrink: 0;
        }
        .thruster-btn:hover { transform: scale(1.09) rotate(-25deg); box-shadow: 0 0 45px rgba(189, 0, 255, 0.9); }
        .thruster-btn svg { width: 28px; height: 28px; }
        .thruster-btn i { font-size: 1.5em; color: #fff; }
        #stopBtn i { color: #fff; }

        /* Side Panels (Profile, Links, Tools, Tool Form) */
        .panel-bg {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(13, 20, 52, 0.98); z-index: 1200; /* More opaque */
            backdrop-filter: blur(18px); /* Stronger blur */
            -webkit-backdrop-filter: blur(18px);
            opacity: 0;
            transition: opacity 0.45s ease-out;
        }
        .panel-bg.active { display: block; opacity: 1; }

        .side-panel {
            position: fixed; top: 0; left: -420px; /* Hidden off-screen, wider panel */
            height: 100vh; width: 400px; /* Wider */
            background: var(--panel-bg);
            border-right: 4px solid var(--panel-border); /* Thicker border */
            box-shadow: var(--panel-shadow);
            z-index: 1212;
            padding: 30px 25px 35px 25px; /* Increased padding */
            overflow-y: auto;
            border-radius: 0 35px 45px 0; /* Larger radius */
            transition: left 0.4s cubic-bezier(0.25, 1, 0.5, 1); /* Only left for slide animation */
        }
        .side-panel.active { left: 0; } /* Slides in from the left */

        .side-panel .panel-header {
            text-align: center; margin: 30px 0 20px 0; /* Increased margin */
        }
        .side-panel img {
            width: 70px; height: 70px; border-radius: 50%; /* Larger image */
            margin-bottom: 15px; border: 4px solid var(--neon-blue); /* Thicker border */
            box-shadow: 0 0 20px var(--neon-blue); /* Stronger glow */
        }
        .side-panel .username {
            font-weight: 700; font-size: 1.3em; color: var(--neon-blue); /* Larger font */
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 15px var(--neon-blue); /* Stronger glow */
        }
        .side-panel .email {
            font-size: 1.1em; color: rgba(168, 234, 255, 0.98); /* Brighter */
        }
        .panel-links a, .side-panel .submit-btn {
            color: var(--neon-blue); text-decoration: none; font-weight: 500;
            font-size: 1.2em; padding: 16px 22px; display: flex; /* Larger padding, font size */
            align-items: center; gap: 20px; border-radius: 15px; /* Larger radius, gap */
            transition: background .18s, color .18s, transform .18s;
            margin-bottom: 15px; /* Increased margin */
            user-select: none;
            background: rgba(16,33,59,0.65); /* Default button-like background for panel links/buttons */
            border: 2px solid rgba(0, 242, 255, 0.4); /* Stronger border */
        }
        .panel-links a:hover, .side-panel .submit-btn:hover {
            background: rgba(0, 234, 255, 0.35); color: #faffff; transform: translateX(10px); /* More pronounced hover */
        }

        #chatsList button {
            background: none; border: none; cursor: pointer; outline: none;
            font-size: 1.3em; margin: 0 8px; vertical-align: middle; /* Larger font */
            border-radius: 10px; padding: 6px 8px; /* Larger padding */
        }
        #chatsList .fa-pen { color: var(--neon-green); transition: color .15s; }
        #chatsList .fa-pen:hover { color: #ffd800; }
        #chatsList .fa-trash { color: #ff244e; transition: color .12s; }
        #chatsList .fa-trash:hover { color: #fff900; }

        .edit-form label {
            display: block; margin-top: 18px; font-size: 1.15em; color: var(--neon-green); /* Larger font */
            text-shadow: 0 1px 18px rgba(17, 170, 255, 0.8); /* Stronger glow */
        }
        .edit-form input, .edit-form textarea, .edit-form select {
            width: 99%; padding: 12px 16px; margin-top: 10px; /* Larger padding */
            border: 3px solid var(--neon-blue); border-radius: 15px; /* Thicker border, larger radius */
            background: rgba(7, 31, 53, 0.9); color: var(--main-text-color); /* More opaque */
            font-size: 1.15em; box-shadow: 0 0 15px rgba(4, 246, 253, 0.98) inset; /* Stronger glow */
            transition: border-color .2s, box-shadow .2s, background .2s;
        }
        .edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus {
            border-color: var(--neon-green); background: rgba(39, 63, 93, 0.95); color: var(--main-text-color); /* More opaque */
        }
        .edit-form textarea { resize: vertical; min-height: 110px; } /* Taller */

        .status-message {
            padding: 12px 20px; color: var(--neon-green); font-size: 1.1em; /* Larger padding and font size */
            min-height: 30px; text-align: center; margin: 10px auto 0 auto;
            max-width: 500px; overflow-wrap: break-word;
        }

        #lightbox {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.98); z-index: 5000; justify-content: center; /* Darker background */
            align-items: center;
        }
        #lightbox.active { display: flex; }
        #lightbox img {
            max-width: 98vw; max-height: 98vh; border: 4px solid var(--neon-blue); /* Thicker border, larger image */
            border-radius: 18px; box-shadow: 0 0 80px var(--neon-blue); /* Stronger glow */
            object-fit: contain;
        }
        #ai-image-preview, #ai-comic-preview {
            display:none;
            position:fixed; z-index:1210; right:35px; bottom:150px; max-width:400px; /* Adjusted position and size */
            background:rgba(25,26,38,1); padding:20px; border-radius:25px; /* Larger, more opaque, larger radius */
            box-shadow:0 2px 28px var(--neon-blue); border: 2.5px solid var(--neon-blue); /* Stronger shadow */
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        #ai-image-preview.active, #ai-comic-preview.active { display:block; opacity: 1; transform: translateY(0); }
        #ai-image-preview #ai-image-close, #ai-comic-preview #ai-comic-close {
            position: absolute; top: 15px; right: 15px; /* Adjusted position */
            background:rgba(35,35,58,0.9);border:none;border-radius:12px; /* More opaque, larger radius */
            color:var(--neon-blue);font-size:1.8em;cursor:pointer;
        }
        #ai-image-preview #ai-image-container img, #ai-comic-preview #ai-comic-container img {
            max-width:340px;max-height:340px;border-radius:20px;display:block; /* Larger image, radius */
            border: 3px solid var(--neon-green); box-shadow: 0 0 18px var(--neon-green); /* Stronger glow */
            object-fit: contain;
        }
        #ai-comic-preview .comic-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 18px; /* Increased margin */
        }
        #ai-comic-preview .comic-nav button {
             background:var(--plasma-gradient-dark); color:var(--main-text-color);
             border: 2.5px solid var(--neon-blue); border-radius: 15px; padding: 10px 18px; cursor:pointer; /* Larger padding, radius */
        }
        #ai-comic-preview #ai-comic-dl, #ai-image-preview #ai-image-dl {
            margin-top:18px;padding:12px 30px;background:var(--plasma-gradient); /* Larger padding, margin */
            color:#222;border:none;border-radius:15px;box-shadow:0 2px 12px var(--neon-blue); /* Larger radius, stronger shadow */
            cursor:pointer;font-weight:bold; width: 100%;
        }
        /* REFINED FILE PREVIEW STYLES */
        #filePreview.file-preview-floating {
            display: none;
            position: absolute; /* Changed to absolute to position relative to ui-container */
            bottom: 120px; /* Position above the input dock */
            left: 50%;
            transform: translateX(-50%);
            max-width: 500px; /* Wider */
            width: calc(100% - 70px); /* For responsiveness */
            padding: 18px; /* Increased padding */
            border-radius: 20px; /* Larger radius */
            background: rgba(13, 20, 52, 0.99); /* More opaque */
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
            border: 2.5px solid var(--glass-border); /* Thicker border */
            z-index: 1210;
            box-shadow: 0 2px 28px var(--neon-blue); /* Stronger shadow */
            flex-direction: column;
            gap: 10px; /* Increased gap */
            overflow-y: auto;
            max-height: 280px; /* Taller */
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        #filePreview.file-preview-floating.active { display: flex; opacity: 1; transform: translateX(-50%) translateY(0); }

        /* Style for individual file items inside preview */
        #filePreview.file-preview-floating > div {
            display: flex;
            align-items: center;
            gap: 12px; /* Increased gap */
            background: rgba(25, 36, 65, 0.99); /* More opaque */
            border-radius: 15px; /* Larger radius */
            padding: 10px 15px; /* Increased padding */
            border: 3px solid rgba(0, 242, 255, 0.4); /* Thicker border */
        }
        #filePreview.file-preview-floating .remove-file-btn {
            background:#d23; color:#fff; border-radius:50%; width:30px; height:30px; font-size:1.3em; /* Larger button */
            display:flex; align-items:center; justify-content:center; margin-left:auto; cursor:pointer;
            flex-shrink: 0;
            transition: background 0.1s, transform 0.1s;
        }
        #filePreview.file-preview-floating .remove-file-btn:hover {
            background: #ff4d4d;
            transform: scale(1.2); /* More pronounced hover */
        }
        #filePreview.file-preview-floating img,
        #filePreview.file-preview-floating video,
        #filePreview.file-preview-floating audio {
            max-width: 55px; /* Larger preview */
            max-height: 45px;
            border-radius: 8px;
            object-fit: cover;
        }
        #filePreview.file-preview-floating span {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 1.05em; /* Slightly larger */
        }


        /* Voice Call Interface - TOTALLY REVAMPED */
        #callModal {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: var(--call-bg-gradient); z-index: 4000;
            flex-direction: column; align-items: center; justify-content: space-between; /* Space out elements */
            padding: 50px; box-sizing: border-box; /* Increased padding */
            opacity: 0;
            transition: opacity 0.6s ease-out; /* Slower transition */
        }
        #callModal.active { display: flex; opacity: 1; }

        #callHeader {
            color: var(--neon-blue); font-family: 'Orbitron', sans-serif;
            font-size: 2.8em; text-shadow: var(--call-header-glow); /* Larger, stronger glow */
            letter-spacing: 4px; /* More spacing */
            user-select: none;
            flex-shrink: 0;
            margin-top: 20px; /* Ensure some space from top */
        }

        /* Call conversation area */
        #callConversation {
            flex-grow: 1;
            width: 100%;
            max-width: 850px; /* Wider conversation area */
            overflow-y: auto;
            margin: 25px 0; /* Adjusted margins to give space */
            border: 2.5px solid var(--glass-border);
            border-radius: 30px; /* Thicker border, larger radius */
            padding: 30px;
            background: rgba(0, 0, 0, 0.4); /* More opaque */
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            position: relative;
            padding-bottom: 70px; /* Space for userSpeechWave */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        #callConversation::-webkit-scrollbar { display: none; }

        .call-msg {
            padding: 18px 25px; border-radius: 20px; /* Larger padding, radius */
            margin-bottom: 18px; line-height: 1.8; font-size: 1.2em; overflow-wrap: break-word; /* Larger text, more spacing */
            user-select: text;
        }
        .call-msg.user {
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.35), rgba(189, 0, 255, 0.35)); /* More opaque */
            color: var(--call-user-text-color); text-align: right; margin-left: auto; max-width: 75%; /* Wider message */
            border-bottom-right-radius: 12px; box-shadow: 0 0 18px rgba(0,242,255,0.5); /* Stronger glow */
        }
        .call-msg.bot {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.8), rgba(20, 20, 35, 0.95)); /* More opaque */
            color: var(--call-ai-text-color); margin-right: auto; max-width: 75%; /* Wider message */
            border-bottom-left-radius: 12px; box-shadow: 0 0 15px rgba(0,242,255,0.25); /* Stronger glow */
        }
        .call-msg.user.interim {
            opacity: 0.95; /* More visible interim */
            font-style: italic;
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.25), rgba(189, 0, 255, 0.25)); /* More opaque */
            border-color: rgba(0, 242, 255, 0.6);
            box-shadow: 0 0 12px rgba(0,242,255,0.3); /* Stronger glow */
        }
        .call-msg.status {
            text-align: center; color: rgba(136, 136, 136, 0.98); /* Brighter */
            font-style: italic; background: none; font-size: 1.1em; /* Larger font */
            user-select: none;
        }

        #userSpeechWave {
            position: absolute;
            bottom: 20px; left: 5%; /* Adjusted position */
            width: 90%; height: 40px; /* Taller wave */
            background: linear-gradient(90deg, transparent, rgba(0, 242, 255, 0.5), transparent); /* Stronger color */
            border-radius: 20px; /* Larger radius */
            animation: speechWave 0.5s infinite alternate; /* Faster wave */
            opacity: 0.95; /* More opaque */
            display: none;
            will-change: transform, opacity;
            pointer-events: none; /* Make sure it doesn't block clicks */
        }
        #userSpeechWave.active { display: block; }
        @keyframes speechWave {
            0% { transform: scaleX(0.6); opacity: 0.7; } /* Softer start */
            100% { transform: scaleX(1); opacity: 1; } /* Stronger peak */
        }

        /* Bot Image and Status */
        #botImageContainer {
            position: relative;
            margin: 25px 0; /* Centralize it between controls and settings */
            flex-shrink: 0;
        }
        #botImageContainer img {
            width: 220px; height: 220px; border-radius: 50%; /* Larger image */
            border: 7px solid var(--neon-blue); /* Thicker border */
            box-shadow: 0 0 60px var(--neon-blue); /* Stronger glow */
            transition: transform 0.35s ease, border-color 0.35s ease, box-shadow 0.35s ease;
        }
        #botImageContainer.speaking img {
            border-color: var(--neon-green);
            box-shadow: 0 0 60px var(--neon-green); /* Stronger glow */
            transform: scale(1.1); /* More pronounced scale */
            animation: head-nod 0.8s infinite ease-in-out; /* Faster nod */
        }
        @keyframes head-nod { 0% { transform: translateY(0) scale(1.1); } 50% { transform: translateY(-7px) scale(1.1); } 100% { transform: translateY(0) scale(1.1); } }

        #botSpeakingIndicator {
            position: absolute; top: -12px; left: -12px; /* Larger offset */
            width: 244px; height: 244px; border-radius: 50%; /* Larger indicator */
            border: 8px solid transparent; /* Thicker border */
            box-shadow: 0 0 35px var(--neon-blue);
            animation: pulse 0.9s infinite; /* Faster pulse */
            display: none; z-index: -1;
        }
        #botImageContainer.speaking #botSpeakingIndicator {
            box-shadow: var(--call-bot-speaking-glow);
            border-color: var(--neon-green);
            display: block;
            animation: glow-spread 1.2s infinite ease-in-out; /* Faster spread */
        }
        @keyframes glow-spread {
            0% { box-shadow: 0 0 30px var(--neon-green); opacity: 0.9; }
            50% { box-shadow: var(--call-bot-speaking-glow); opacity: 1; }
            100% { box-shadow: 0 0 30px var(--neon-green); opacity: 0.9; }
        }
        @keyframes pulse {
            0% { opacity: 0.2; transform: scale(0.9); } /* Softer start */
            50% { opacity: 0.95; transform: scale(1.1); } /* Stronger peak */
            100% { opacity: 0.2; transform: scale(0.9); }
        }

        #callStatusMessage {
            color: var(--neon-blue); font-size: 1.5em; margin-top: 30px; /* Larger, more spacing */
            height: 45px; text-align: center; font-style: italic;
            text-shadow: 0 0 15px var(--neon-blue); /* Stronger glow */
            user-select: none;
            flex-shrink: 0;
        }

        #tapToTalk {
            color: var(--neon-purple); font-size: 1.6em; margin-top: 18px; /* Larger, more spacing */
            text-shadow: 0 0 15px var(--neon-purple); /* Stronger glow */
            animation: neon-pulse 0.9s infinite alternate; /* Faster pulse */
            display: none; cursor: pointer;
            user-select: none;
            flex-shrink: 0;
        }
        @keyframes neon-pulse { from { opacity: 0.9; transform: scale(1.0); } to { opacity: 1.0; transform: scale(1.05); } } /* More pronounced pulse */

        #callSettings {
            display: flex; gap: 25px; margin-bottom: 30px; /* Increased gap and margin */
            align-items: center; justify-content: center;
            background: rgba(25, 25, 40, 0.85); /* More opaque */
            padding: 18px 30px; /* Increased padding */
            border-radius: 18px; /* Larger radius */
            border: 2px solid rgba(255,255,255,0.25); /* Stronger border */
            max-width: 90%; /* Wider */
            flex-wrap: wrap; /* Allow wrapping on small screens */
            flex-shrink: 0;
        }
        #callSettings label {
            color: var(--main-text-color);
            font-size: 1.1em; /* Larger font */
        }
        #callSettings select {
            background: rgba(10, 10, 20, 0.9); /* More opaque */
            color: var(--main-text-color);
            border: 2.5px solid var(--neon-blue); /* Thicker border */
            border-radius: 10px; /* Larger radius */
            padding: 10px 15px; /* Larger padding */
            font-size: 1.1em; /* Larger font */
            outline: none;
            cursor: pointer;
            box-shadow: inset 0 0 10px rgba(0,242,255,0.25); /* Stronger inset glow */
        }
        #callSettings select:hover {
            border-color: var(--neon-green);
            box-shadow: inset 0 0 15px rgba(0,255,136,0.35); /* Stronger glow */
        }

        #callControls {
            display: flex; gap: 35px; padding-bottom: 25px; /* Increased gap and padding */
            flex-shrink: 0;
            margin-top: 25px; /* Space from callSettings */
        }
        #endCallBtn, #muteCallBtn {
            background: var(--call-control-bg); color: var(--call-text-color);
            font-size: 1.5em; padding: 18px 35px; border: 2.5px solid var(--call-control-border); /* Larger padding, font size, thicker border */
            border-radius: 18px; cursor: pointer; box-shadow: 0 0 18px rgba(255, 77, 77, 0.8); /* Stronger shadow */
            transition: background .15s, box-shadow .15s, color .15s;
            user-select: none;
        }
        #endCallBtn {
            background: #d23;
        }
        #endCallBtn:hover { background: #ff7777; box-shadow: 0 0 25px #ff7777cc; color: #fff; } /* Stronger hover */
        #muteCallBtn {
            box-shadow: 0 0 18px rgba(0, 123, 255, 0.8); /* Stronger shadow */
        }
        #muteCallBtn:hover { background: #008cee; box-shadow: 0 0 25px rgba(0, 123, 255, 0.95); color: #fff; } /* Stronger hover */
        #muteCallBtn.muted {
            background: #555; box-shadow: none; color: #ccc;
        }
        #muteCallBtn.muted:hover { background: #777; box-shadow: none; color: #fff; }

        .chat-controls-menu {
            position: absolute;
            bottom: 120px; /* Position above the input dock */
            left: 25px;
            background: var(--panel-bg);
            border: 2px solid var(--glass-border);
            border-radius: 18px; /* Larger radius */
            padding: 18px; /* Increased padding */
            box-shadow: var(--box-glow);
            z-index: 101;
            display: none;
            flex-direction: column;
            gap: 12px; /* Increased gap */
            min-width: 210px; /* Wider */
            max-height: 280px; /* Taller */
            overflow-y: auto;
        }
        .chat-controls-menu.active { display: flex; }
        .chat-controls-menu button, .chat-controls-menu .emoji-pick {
            background: none; border: none; color: var(--main-text-color);
            padding: 12px 18px; border-radius: 15px; /* Larger padding, radius */
            text-align: left;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
            user-select: none;
            font-size: 1.4em; /* Larger font */
            text-align: center;
        }
        .chat-controls-menu button:hover, .chat-controls-menu .emoji-pick:hover {
            background: rgba(0, 242, 255, 0.25); /* More opaque hover */
            color: var(--neon-blue);
        }

        /* Responsive Adjustments */
        @media (max-width: 1023px) {
            body { padding: 0; } /* No padding on body for small screens */
            .ui-container {
                max-width: 100%;
                border-radius: 0;
                margin: 0;
                height: 100%;
                width: 100%;
            }
            header { padding: 15px 15px; }
            .brand-plasma { font-size: 1.2rem; letter-spacing: 1px;}
            .header-actions { gap: 10px; font-size: 1.2rem; }
            .header-welcome { font-size: 0.75em; margin-top: 3px; max-width: 100px; }

            #chat-viewport { padding: 15px; gap: 15px; }
            .message-group { max-width: 95%; }
            .msg-bubble { padding: 10px 15px; font-size: 0.95rem; border-radius: 20px;}
            .ai .msg-bubble, .user .msg-bubble { border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; }
            
            /* Typing dots on mobile */
            .thinking-indicator .dot { width: 8px; height: 8px; }
            .spinner { width: 18px; height: 18px; margin-right: 6px; }

            pre {
                padding: 0.8em 1em;
                font-size: 0.85em;
                border-radius: 12px;
            }
            .copy-btn, .inline-copy-btn, .inline-share-btn, .inline-regen-btn, .inline-edit-btn, .switch-model-btn {
                padding: 6px 10px;
                font-size: 0.75em;
                border-radius: 8px;
            }
            
            .input-dock { padding: 10px 15px; gap: 8px; min-height: 80px;}
            
            .main-action-buttons {
                right: 10px;
                gap: 5px;
            }
            .main-action-buttons button, .main-action-buttons label { width: 30px; height: 30px; font-size: 1em; padding: 0;}

            .capsule-input { 
                min-height: 40px; border-radius: 25px;
                padding-right: calc(10px + (30px * 3) + (5px * 2) + 10px); 
            }
            .capsule-input textarea { font-size: 0.9rem; padding: 8px 0; max-height: 120px; height: auto;}
            
            .thruster-btn {
                width: 45px; height: 45px;
            }
            .thruster-btn svg {
                width: 18px; height: 18px;
            }
            .thruster-btn i { font-size: 1.1em; }


            .side-panel { width: 100vw; border-radius: 0; left: -100vw; }
            .side-panel.active { left: 0; }
            #filePreview.file-preview-floating { width: calc(100% - 20px); bottom: 95px; padding: 10px; border-radius: 12px;}
            #filePreview.file-preview-floating > div { padding: 5px 8px; border-radius: 8px; }
            #filePreview.file-preview-floating .remove-file-btn { width: 22px; height: 22px; font-size: 0.9em; }
            #ai-image-preview, #ai-comic-preview { right: 10px; bottom: 95px; max-width: 280px; padding: 12px; border-radius: 15px;}
            #ai-image-preview #ai-image-container img, #ai-comic-preview #ai-comic-container img { max-width: 240px; max-height: 240px; border-radius: 12px;}
            .chat-controls-menu { left: 10px; bottom: 95px; width: calc(100% - 20px); max-height: 150px; padding: 10px; border-radius: 12px;}
            .chat-controls-menu button, .chat-controls-menu .emoji-pick { font-size: 1.1em; padding: 8px 10px; border-radius: 8px;}

            /* Call Modal Adjustments for mobile */
            #callModal { padding: 20px; }
            #callHeader { font-size: 1.8em; letter-spacing: 1px; margin-top: 0;}
            #callConversation { padding: 15px; margin: 15px 0; max-width: 100%; border-radius: 15px; }
            .call-msg { font-size: 1em; padding: 10px 15px; margin-bottom: 10px; border-radius: 12px; }
            #botImageContainer img { width: 140px; height: 140px; border: 4px solid var(--neon-blue); }
            #botSpeakingIndicator { width: 156px; height: 156px; top: -8px; left: -8px; border: 5px solid transparent; }
            #callStatusMessage, #tapToTalk { font-size: 1.1em; margin-top: 15px; }
            #callSettings { flex-direction: column; gap: 8px; margin-bottom: 15px; padding: 10px 15px; border-radius: 10px;}
            #callSettings label, #callSettings select { font-size: 0.95em; }
            #callControls { gap: 15px; padding-bottom: 15px; margin-top: 15px;}
            #endCallBtn, #muteCallBtn { font-size: 1.1em; padding: 10px 18px; border-radius: 10px;}
            #userSpeechWave { bottom: 10px; height: 30px; border-radius: 15px; }
        }

    </style>
</head>
<body>

    <div id="cosmos-container">
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
        <img class="cosmic-eagle" src="https://i.imgur.com/gK6w74X.png" alt="Cosmic Eagle">
    </div>

    <div class="ui-container">
        <header>
            <div class="header-actions">
                <div class="icon-btn" id="openProfileMenu" title="Profile & Chats" role="button" aria-label="Open profile and chats menu"><i class="fa-solid fa-user"></i></div>
            </div>
            <div class="header-center">
                <div class="brand-plasma" id="brandTitle">Philadelphia AI</div>
                <div class="header-welcome" id="headerWelcome"></div>
            </div>
            <div class="header-actions">
                <div class="icon-btn" id="openLinksMenu" title="Links" role="button" aria-label="Open links menu"><i class="fa-solid fa-link"></i></div>
            </div>
        </header>

        <div id="chat-viewport">
            <!-- Messages are dynamically injected here -->
        </div>

        <!-- WIDER & REVAMPED INPUT DOCK -->
        <div class="input-dock" id="inputDock">
            <button class="thruster-btn" id="callBtn" title="Start Voice Call" aria-label="Start voice call">
                <i class="fa-solid fa-phone"></i>
            </button>

            <div class="capsule-input" id="capsuleInputContainer">
                <textarea id="userInput" placeholder="Broadcast your message to the cosmos..." autocomplete="off" aria-label="Chat input"></textarea>
                <div class="main-action-buttons">
                    <label for="chatFile" class="file-upload-btn" title="Attach file" aria-label="Attach file"><i class="fa-solid fa-paperclip"></i></label>
                    <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
                    <button type="button" id="emojiBtn" title="Emoji" aria-label="Open emoji panel"><i class="fa-regular fa-face-smile"></i></button>
                    <button type="button" id="toolBtn" title="Philadelphia Tools" aria-label="Open AI tools menu"><i class="fa-solid fa-wrench"></i></button>
                </div>
            </div>

            <button class="thruster-btn" id="sendBtn" onclick="sendMessage()" title="Send message" aria-label="Send message">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
            
            <button class="thruster-btn" id="stopBtn" title="Stop AI Response" style="background: #ff4d4d; display: none;" aria-label="Stop AI response">
                <i class="fa-solid fa-stop"></i>
            </button>
        </div>
    </div>

    <div id="emojiPanel" class="chat-controls-menu"></div>
    <div id="filePreview" class="file-preview-floating"></div>

    <div class="panel-bg" id="profileMenuBg">
        <nav class="side-panel" id="profileMenu" role="menu" aria-label="Profile and Chat Menu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:1.25em;font-weight:700;color:var(--neon-blue);margin:20px 0 0 15px;">Chats</span>
                <button type="button" class="icon-btn" style="font-size:1.6em;color:#f44;background:transparent;border:none;margin:15px 12px 0 0;cursor:pointer;border-radius:8px;" onclick="closeProfileMenu()" aria-label="Close menu">&times;</button>
            </div>
            <div id="chatsList" style="margin:8px 0 10px 8px;max-height:180px;overflow-y:auto;">
                <div class="spinner" style="margin: 25px auto; display: block;"></div>
            </div>
            <button type="button" id="newChatBtn" class="submit-btn"><i class="fa-solid fa-plus"></i> New Chat</button>
            <hr style="width:92%;margin:12px 0 8px 4%;border:1.5px solid rgba(0, 242, 255, 0.35);">
            <div class="panel-header">
                <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profileMenuUser">User</div>
                <div class="email" id="profileMenuEmail">email@example.com</div>
            </div>
            <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 8px;">
                <label for="edit-name">Name</label>
                <input type="text" id="edit-name" required aria-label="Edit name">
                <label for="edit-photo">Photo URL</label>
                <input type="url" id="edit-photo" placeholder="Paste image link" aria-label="Edit photo URL">
                <span style="font-size:0.88em;color:#aae;display:block;margin:6px 0 8px 3px;"> Tip: <a href="https://postimg.cc/" target="_blank" style="color:var(--neon-blue);">Upload at postimg.cc</a> </span>
                <button type="submit" class="submit-btn">Save</button>
                <div class="status-message" id="profileStatusMsg"></div>
            </form>
            <button type="button" class="submit-btn" id="logoutBtn" style="background:rgba(16,33,59,0.7);color:var(--neon-blue);margin:8px 8px 20px 8px;">Logout</button>
        </nav>
    </div>

    <!-- Single Image Preview Box -->
    <div id="ai-image-preview">
        <button type="button" id="ai-image-close" aria-label="Close image preview">&times;</button>
        <div id="ai-image-container"></div>
        <button type="button" id="ai-image-dl">Download</button>
    </div>

    <!-- Comic Viewer Preview Box -->
    <div id="ai-comic-preview">
        <button type="button" id="ai-comic-close" aria-label="Close comic preview">&times;</button>
        <div id="ai-comic-container" style="text-align: center;"></div>
        <div class="comic-nav">
             <button id="comic-prev-btn"><i class="fa-solid fa-arrow-left"></i></button>
             <span id="comic-panel-indicator"></span>
             <button id="comic-next-btn"><i class="fa-solid fa-arrow-right"></i></button>
        </div>
        <button type="button" id="ai-comic-dl">Download This Panel</button>
    </div>

    <div class="panel-bg" id="linksMenuBg">
        <nav class="side-panel" id="linksMenu" role="menu" aria-label="Main Navigation Menu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <div class="panel-header" style="margin:0;">
                    <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia logo">
                    <div class="username">Menu</div>
                </div>
                <button type="button" class="icon-btn" style="font-size:1.6em;color:#f44;background:transparent;border:none;margin:15px 12px 0 0;cursor:pointer;border-radius:8px;" onclick="closeLinksMenu()" aria-label="Close menu">&times;</button>
            </div>
            <div class="panel-links">
                <a href="philadelphia.html" role="menuitem"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a>
                <a href="index.html" role="menuitem"><i class="fa-solid fa-home"></i>Elvion Homepage</a>
                <a href="about.html" role="menuitem"><i class="fa-solid fa-circle-info"></i> About US</a>
                <a href="privacy.html" role="menuitem"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
                <a href="terms.html" role="menuitem"><i class="fa-solid fa-file-contract"></i> Terms</a>
                <a href="https://t.me/writingurubot" target="_blank" rel="noopener noreferrer" role="menuitem"><i class="fab fa-telegram"></i> Try Telegram Version</a>
            </div>
            <button type="button" class="submit-btn" style="background:rgba(16,33,59,0.7);color:var(--neon-blue);margin-top:25px;" onclick="closeLinksMenu();">Close</button>
        </nav>
    </div>


    <div class="panel-bg" id="toolsMenuBg">
        <nav class="side-panel" id="toolsMenu" role="menu" aria-label="AI Tools Menu">
            <div class="panel-header" style="text-align:left;">
                <div class="username" id="toolMenuTitle" style="font-size:1.3em;margin-left:-10px;text-align:center;">Philadelphia AI Tools</div>
            </div>
            <div class="panel-links">
                <h3 style="color:var(--neon-blue);margin:12px 0 6px 5px;font-size:0.95em;text-transform:uppercase;">Creative Suite</h3>
                <a href="#" class="tool-link" data-tool="image" role="menuitem"><i class="fa-solid fa-image"></i> Generate Image</a>
                <a href="#" class="tool-link" data-tool="edit-photo" role="menuitem"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
                <a href="#" class="tool-link" data-tool="remove-bg" role="menuitem"><i class="fa-solid fa-scissors"></i> Remove Background</a>
                <a href="#" class="tool-link" data-tool="comic" role="menuitem"><i class="fa-solid fa-book-open"></i> Create Comic</a>
                <hr style="border-color: rgba(0, 234, 255, 0.4); margin: 12px 0;">
                <h3 style="color:var(--neon-blue);margin:12px 0 6px 5px;font-size:0.95em;text-transform:uppercase;">Audio & Video</h3>
                <a href="#" class="tool-link" data-tool="voice-gen" role="menuitem"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
                <a href="#" class="tool-link" data-tool="audio-narration" role="menuitem"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
                <a href="#" class="tool-link" data-tool="video-text" role="menuitem"><i class="fa-solid fa-film"></i> Text-to-Video</a>
                <a href="#" class="tool-link" data-tool="video-image" role="menuitem"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
                <a href="#" class="tool-link" data-tool="music" role="menuitem"><i class="fa-solid fa-music"></i> Generate Music</a>
                <hr style="border-color: rgba(0, 234, 255, 0.4); margin: 12px 0;">
                <h3 style="color:var(--neon-blue);margin:12px 0 6px 5px;font-size:0.95em;text-transform:uppercase;">Web & Research</h3>
                <a href="#" class="tool-link" data-tool="website" role="menuitem"><i class="fa-solid fa-globe"></i> Create Website</a>
                <a href="#" class="tool-link" data-tool="edit-website" role="menuitem"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
                <a href="#" class="tool-link" data-tool="my-sites" role="menuitem"><i class="fa-solid fa-list-check"></i> My Websites</a>
                <a href="#" class="tool-link" data-tool="research-report" role="menuitem"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
            </div>
            <button type="button" class="submit-btn" style="background:rgba(16,33,59,0.7);color:var(--neon-blue);margin-top:20px;" onclick="closeToolMenu();">Close</button>
        </nav>
    </div>

    <div class="panel-bg" id="toolFormModalBg">
        <nav class="side-panel" id="toolFormModal" role="dialog" aria-modal="true" aria-labelledby="toolFormTitle">
            <div class="panel-header">
                <div class="username" id="toolFormTitle">Tool Title</div>
            </div>
            <form class="edit-form" id="toolForm" style="padding:0 8px;"></form>
            <button type="button" id="toolFormBackBtn" class="submit-btn" style="background:rgba(16,33,59,0.7);color:var(--neon-blue);margin:8px 8px 20px 8px;">
                <i class="fa-solid fa-arrow-left"></i> Back to Tools
            </button>
            <div class="status-message" id="toolStatusMsg"></div>
        </nav>
    </div>

    <div id="lightbox" role="dialog" aria-modal="true" aria-label="Image viewer">
        <img src="" alt="Lightbox image">
    </div>

    <!-- Call Modal - REVAMPED -->
    <div id="callModal">
        <div id="callHeader">Philadelphia AI - Live Call</div>
        
        <div id="callConversation">
            <!-- User and Bot messages will appear here -->
            <div class="call-msg status">Connecting...</div>
            <div id="userSpeechWave"></div>
        </div>

        <div id="callSettings">
            <label for="callVoiceModel">Voice Model:</label>
            <select id="callVoiceModel" aria-label="Select voice model for call">
                <option value="gemini">Philadelphia (Styles)</option>
                <option value="minimax">Seraphina (Characters)</option>
            </select>
            <label for="callVoiceStyle" id="callVoiceStyleLabel">Style:</label>
            <select id="callVoiceStyle" aria-label="Select voice style/character"></select>
        </div>

        <div id="botImageContainer">
            <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Bot">
            <div id="botSpeakingIndicator"></div>
        </div>

        <div id="callStatusMessage">Connecting...</div>
        <div id="tapToTalk">Tap Anywhere to Speak</div>

        <div id="callControls">
            <button type="button" id="muteCallBtn" class="submit-btn" aria-label="Mute microphone"><i class="fa-solid fa-microphone"></i> Mute</button>
            <button type="button" id="endCallBtn" class="submit-btn" aria-label="End call"><i class="fa-solid fa-phone-slash"></i> End Call</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/css.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const $ = id => document.getElementById(id);

        // --- API ENDPOINT MANAGEMENT ---
        const API_BASE_URL = 'https://web-production-9a18.up.railway.app';
        const API_ENDPOINTS = {
            gemini: `${API_BASE_URL}/chat`, // Philadelphia
            perplexity: `${API_BASE_URL}/api/seraphina/chat`, // Seraphina
            llama: `${API_BASE_URL}/api/llama/chat` // NEW: Llama Chat
        };


        let chats = [];
        let currentChatId = null;
        let currentMessages = [];
        let uploadedFiles = [];
        let currentUser = null;
        let currentController = null; // Used for aborting fetch requests
        let fileObjectURLs = []; // To manage created object URLs for file previews

        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;

        const cosmos = $('cosmos-container');

        // Call-related state variables
        let speechRecognition;
        let isCallActive = false;
        let callHistory = [];
        let botIsSpeaking = false;
        let userSaidSomething = false;
        let currentAudio = null;
        let isMuted = false;
        let isRecognizing = false;
        let selectedCallVoiceId = 'elder'; // Default for minimax (Seraphina)
        let selectedCallVoiceProvider = 'minimax'; // Default provider

        // Comic viewer state
        let comicPanels = [];
        let currentComicPanelIndex = 0;
        
        // --- MODEL STATE ---
        let currentModel = 'gemini'; // Default to 'gemini' for Philadelphia
        
        // --- UPGRADED: STREAMING & TYPEWRITER STATE ---
        let typewriterInterval = null;      // Holds the setInterval ID for the typewriter effect
        let isAIResponding = false;         // A master flag to indicate any AI activity (chat or tool)
        
        // References to the elements of the message currently being streamed
        let currentAIMessageElement = null; 
        let currentAIContentElement = null; 
        let currentAIControlsElement = null; 
        let currentCursorElement = null;

        // Accumulator for the streaming response text
        let fullResponseContent = '';
        // Index for the typewriter effect to track progress
        let typewriterIndex = 0;
        
        // Reference to any active tool processing message (e.g., "Generating image...")
        let currentProcessingMessageElement = null; 

        // Cosmic background animations
        function igniteCosmos() {
            if (cosmos) {
                cosmos.querySelectorAll('.star').forEach(p => p.remove());
                for (let i = 0; i < 400; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'star';
                    const size = Math.random() * 3 + 0.5;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    particle.style.left = `${Math.random() * 100}%`;
                    particle.style.top = `${Math.random() * 100}%`;
                    particle.style.setProperty('--duration', `${Math.random() * 7 + 4}s`);
                    particle.style.opacity = Math.random() * 0.9 + 0.1;
                    cosmos.appendChild(particle);
                }
            }
        }

        function launchShootingStar() {
            if (!cosmos) return;
            const star = document.createElement('div');
            star.className = 'shooting-star';
            const startX = Math.random() * window.innerWidth * 2 - window.innerWidth / 2;
            const startY = Math.random() * window.innerHeight / 2 - window.innerHeight / 4;
            const travelX = -Math.random() * 1200 - 600;
            const travelY = Math.random() * 1000 + 500;
            const duration = Math.random() * 5 + 3;
            const initialWidth = Math.random() * 120 + 40;

            star.style.setProperty('--startX', `${startX}px`);
            star.style.setProperty('--startY', `${startY}px`);
            star.style.setProperty('--travelX', `${travelX}px`);
            star.style.setProperty('--travelY', `${travelY}px`);
            star.style.setProperty('--duration', `${duration}s`);
            star.style.setProperty('--initialWidth', `${initialWidth}px`);

            cosmos.appendChild(star);
            setTimeout(() => star.remove(), duration * 1000);
        }

        igniteCosmos();
        setInterval(() => {
             if (Math.random() < 0.4) launchShootingStar();
        }, 2500);


        window.addEventListener('DOMContentLoaded', () => {
            const profileMenuBg = $('profileMenuBg');
            const profileMenu = $('profileMenu');
            const linksMenuBg = $('linksMenuBg');
            const linksMenu = $('linksMenu');
            const toolsMenuBg = $('toolsMenuBg');
            const toolsMenu = $('toolsMenu');
            const toolBtn = $('toolBtn');
            const logoutBtn = $('logoutBtn');
            const headerWelcome = $('headerWelcome');
            const profileMenuUser = $('profileMenuUser');
            const profileMenuEmail = $('profileMenuEmail');
            const editName = $('edit-name');
            const editPhoto = $('edit-photo');
            const profilePicPreview = $('profilePicPreview');
            const profileForm = $('profileForm');
            const chatViewport = $('chat-viewport');
            const userInput = $('userInput');
            const sendBtn = $('sendBtn');
            const stopBtn = $('stopBtn');
            const chatFile = $('chatFile');
            const filePreview = $('filePreview');
            const newChatBtn = $('newChatBtn');
            const chatsListEl = $('chatsList');
            const emojiPanel = $('emojiPanel');
            const emojiBtn = $('emojiBtn');
            const toolFormModalBg = $('toolFormModalBg');
            const toolFormModal = $('toolFormModal');
            const toolForm = $('toolForm');
            const toolFormTitle = $('toolFormTitle');
            const toolFormBackBtn = $('toolFormBackBtn');
            const lightbox = $('lightbox');
            const inputDock = $('inputDock'); 
            const brandTitle = $('brandTitle');
            
            // Image Preview Elements
            const aiPrevBox = $('ai-image-preview');
            const aiPrevClose = $('ai-image-close');
            const aiPrevDLBtn = $('ai-image-dl');
            const aiPrevImgBox = $('ai-image-container');

            // Comic Preview Elements
            const comicPrevBox = $('ai-comic-preview');
            const comicPrevClose = $('ai-comic-close');
            const comicPrevDLBtn = $('ai-comic-dl');
            const comicPrevImgBox = $('ai-comic-container');
            const comicNextBtn = $('comic-next-btn');
            const comicPrevBtn = $('comic-prev-btn');
            const comicIndicator = $('comic-panel-indicator');

            // Call Elements
            const callBtn = $('callBtn');
            const callModal = $('callModal');
            const endCallBtn = $('endCallBtn');
            const muteCallBtn = $('muteCallBtn');
            const callVoiceModel = $('callVoiceModel');
            const callVoiceStyle = $('callVoiceStyle');
            const callVoiceStyleLabel = $('callVoiceStyleLabel');
            const callConversation = $('callConversation');
            const botImageContainer = $('botImageContainer');
            const callStatusMessage = $('callStatusMessage');
            const tapToTalk = $('tapToTalk');
            const userSpeechWave = $('userSpeechWave');
            
            if (!chatViewport || !userInput || !inputDock) {
                console.error("Essential UI elements are missing. App functionality will be limited.");
                return;
            }
            
            const addWelcomeMessage = () => {
                const welcomeMsg = `<div class="message-group ai">
                    <div class="msg-bubble">
                        <div class="ai-content-area">
                            Greetings, traveler.  The cosmos is aligned. How can I illuminate your path today? I am fully charged and ready to create. 
                        </div>
                        <div class="ai-msg-controls">
                            <span style="font-size:0.8em; color: rgba(255,255,255,0.6); margin-right: auto; align-self: center;"></span>
                            <div style="margin-left:auto;"></div>
                            <button type="button" class="inline-copy-btn" title="Copy response"><i class="fa-solid fa-copy"></i></button>
                            <button type="button" class="inline-share-btn" title="Share response"><i class="fa-solid fa-share"></i></button>
                            <button type="button" class="inline-regen-btn" title="Regenerate response (current model)"><i class="fa-solid fa-arrows-rotate"></i></button>
                            <div class="switch-model-btn" title="Change AI Model">
                                <i class="fa-solid fa-sitemap"></i>
                                <div class="model-switch-popup">
                                    <button data-model="gemini"><i class="fa-solid fa-feather-alt"></i>Switch to Philadelphia</button>
                                    <button data-model="perplexity"><i class="fa-solid fa-star-of-life"></i>Switch to Seraphina</button>
                                    <button data-model="llama"><i class="fa-solid fa-robot"></i>Switch to Llama</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`;
                if(chatViewport.innerHTML.trim() === '') {
                    chatViewport.innerHTML = welcomeMsg;
                    hookAiMsgControls(); // Hook controls for initial message
                }
            };

            // --- MODEL SELECTION LOGIC ---
            function setCurrentModel(newModel) {
                if (!['gemini', 'perplexity', 'llama'].includes(newModel)) {
                    newModel = 'gemini'; // Default fallback
                }
                currentModel = newModel;
                localStorage.setItem('userPreferredModel', newModel);
                if (brandTitle) {
                    if (newModel === 'gemini') brandTitle.textContent = 'Philadelphia AI';
                    else if (newModel === 'perplexity') brandTitle.textContent = 'Seraphina AI';
                    else if (newModel === 'llama') brandTitle.textContent = 'Llama Chat';
                }
            }

            const savedModel = localStorage.getItem('userPreferredModel');
            if (savedModel) {
                setCurrentModel(savedModel);
            } else {
                addWelcomeMessage();
            }
            // --- END MODEL SELECTION LOGIC ---


            const emojis = ["","","","","","","","","","","","",""];
            if (emojiBtn && emojiPanel && userInput) {
                emojiBtn.addEventListener('click', (e) => {
                    emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
                    emojiPanel.classList.toggle('active');
                    const rect = emojiBtn.getBoundingClientRect();
                    const panelWidth = emojiPanel.offsetWidth || 210; 

                    let panelLeft = rect.left;
                    if (panelLeft + panelWidth > window.innerWidth - 10) {
                        panelLeft = window.innerWidth - panelWidth - 10;
                    }
                    if (panelLeft < 10) {
                        panelLeft = 10;
                    }

                    emojiPanel.style.left = `${panelLeft}px`;
                    emojiPanel.style.bottom = `${inputDock.offsetHeight + 15}px`;
                });
                document.addEventListener('click', e => {
                    if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
                        emojiPanel.classList.remove('active');
                    }
                });
                emojiPanel.addEventListener('click', function(e) {
                    if (e.target && e.target.classList.contains('emoji-pick')) {
                        const text = e.target.textContent || '';
                        const start = userInput.selectionStart || 0;
                        const end = userInput.selectionEnd || 0;
                        userInput.value = userInput.value.slice(0, start) + text + userInput.value.slice(end);
                        userInput.focus();
                        userInput.selectionStart = userInput.selectionEnd = start + text.length;
                        emojiPanel.classList.remove('active');
                        userInput.dispatchEvent(new Event('input'));
                    }
                });
            }

            if (userInput) {
                 // The 'Enter' keydown listener has been removed to allow default newline behavior.
                 // Sending is handled exclusively by the send button.
                const autoResize = () => {
                    if (!userInput) return;
                    userInput.style.height = 'auto'; // Reset height
                    const newHeight = Math.min(userInput.scrollHeight, 220); // 220 is max-height
                    userInput.style.height = `${newHeight}px`;
                };
                userInput.addEventListener('input', autoResize);
                autoResize();
            }

            if (chatFile) {
                chatFile.addEventListener('change', function() {
                    fileObjectURLs.forEach(url => URL.revokeObjectURL(url));
                    fileObjectURLs = [];
                    uploadedFiles = Array.from(this.files || []);
                    renderFilePreview();
                });
            }

            if (aiPrevClose) aiPrevClose.addEventListener('click', () => { if (aiPrevBox) aiPrevBox.classList.remove('active'); });
            if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
                if (!aiPrevImgBox) return;
                const img = aiPrevImgBox.querySelector('img');
                if (img) {
                    const a = document.createElement('a');
                    a.href = img.src;
                    a.download = 'philadelphia_ai_image.png';
                    a.click();
                }
            });

            if (lightbox) {
                lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
            }
            if (chatViewport) {
                chatViewport.addEventListener('click', e => {
                    if (e.target && e.target.tagName === 'IMG' && e.target.closest('.message-group.ai .msg-bubble')) {
                        e.preventDefault();
                        const lbImg = lightbox.querySelector('img');
                        if (lbImg) {
                            lbImg.src = e.target.src;
                            lightbox.classList.add('active');
                        }
                    }
                });
            }

            window.closeToolMenu = () => { if (toolsMenu) toolsMenu.classList.remove('active'); if (toolsMenuBg) toolsMenuBg.classList.remove('active'); };
            window.openToolMenu = () => { if (toolsMenuBg) toolsMenuBg.classList.add('active'); if (toolsMenu) toolsMenu.classList.add('active'); };
            window.closeProfileMenu = () => { if (profileMenu) profileMenu.classList.remove('active'); if (profileMenuBg) profileMenuBg.classList.remove('active'); };
            window.closeLinksMenu = () => { if (linksMenu) linksMenu.classList.remove('active'); if (linksMenuBg) linksMenuBg.classList.remove('active'); };


            if (profileMenuBg) {
                const openProfileBtn = $('openProfileMenu');
                if (openProfileBtn) {
                    openProfileBtn.addEventListener('click', () => {
                        if (profileMenuBg) profileMenuBg.classList.add('active');
                        if (profileMenu) profileMenu.classList.add('active');
                    });
                }
                profileMenuBg.addEventListener('click', e => { if (e.target === profileMenuBg) { closeProfileMenu(); } });
            }

            if (linksMenuBg) {
                const openLinksBtn = $('openLinksMenu');
                if (openLinksBtn) {
                    openLinksBtn.addEventListener('click', () => { if (linksMenuBg) linksMenuBg.classList.add('active'); if (linksMenu) linksMenu.classList.add('active'); });
                }
                linksMenuBg.addEventListener('click', e => { if (e.target === linksMenuBg) { closeLinksMenu(); } });
            }

            if (toolBtn) toolBtn.addEventListener('click', openToolMenu);
            if (toolsMenuBg) toolsMenuBg.addEventListener('click', e => { if (e.target === toolsMenuBg) closeToolMenu(); });

            if (toolFormBackBtn) {
                toolFormBackBtn.addEventListener('click', () => {
                    if (toolFormModal) toolFormModal.classList.remove('active');
                    if (toolFormModalBg) toolFormModalBg.classList.remove('active');
                    openToolMenu();
                });
            }
            if (toolFormModalBg) toolFormModalBg.addEventListener('click', e => { if (e.target === toolFormModalBg) toolFormModalBg.classList.remove('active'); });

            if (logoutBtn) logoutBtn.addEventListener('click', () => { auth.signOut(); window.location.href = 'signup-login.html'; });

            onAuthStateChanged(auth, user => {
                if (!user) {
                    try { window.location.href = "signup-login.html"; } catch (e) {}
                    return;
                }
                currentUser = user;
                const displayName = user.displayName || (user.email || '').split('@')[0];
                if (profileMenuUser) profileMenuUser.textContent = displayName;
                if (profileMenuEmail) profileMenuEmail.textContent = user.email || "";
                if (editName) editName.value = displayName;
                if (editPhoto) editPhoto.value = user.photoURL || "";
                if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";
                if (headerWelcome) headerWelcome.textContent = `Welcome, ${displayName}`;
                loadUserChats(user.uid);
            });

            if (profileForm) {
                profileForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!currentUser) return;
                    const status = $('profileStatusMsg');
                    if (status) status.textContent = 'Saving...';
                    try {
                        await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
                        if (auth.currentUser) await auth.currentUser.reload();
                        if (status) { status.textContent = "Profile updated!"; status.style.color = "var(--neon-green)"; }
                        setTimeout(() => { closeProfileMenu(); }, 800);
                        if (profilePicPreview) profilePicPreview.src = auth.currentUser?.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";
                        if (headerWelcome) headerWelcome.textContent = `Welcome, ${auth.currentUser?.displayName || 'User'}`;
                    } catch (err) {
                        if (status) { status.textContent = err.message; status.style.color = "#ffd700"; }
                    }
                });
            }

            async function loadUserChats(userId) {
                if (chatsUnsubscribe) chatsUnsubscribe();
                const chatsCol = collection(db, 'users', userId, 'chats');
                const q = query(chatsCol, orderBy('createdAt', 'desc'));
                chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                    if (snapshot.empty) {
                        await createNewChat(userId);
                        return;
                    }
                    chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatsListSidebar();
                    if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                        currentChatId = chats[0].id;
                    }
                    subscribeToMessages(userId, currentChatId);
                }, (error) => {
                    console.error("Error fetching chats: ", error);
                    if (chatsListEl) chatsListEl.innerHTML = `<div class="message-group system" style="color: #f44;">Error loading chats.</div>`;
                });
            }

            async function createNewChat(userId) {
                if (!userId) userId = currentUser?.uid;
                if (!userId) return;
                const chatsCol = collection(db, 'users', userId, 'chats');
                try {
                    const newChatDoc = await addDoc(chatsCol, { name: "New Chat", createdAt: serverTimestamp() });
                    currentChatId = newChatDoc.id;
                } catch (e) {
                    console.error("Error creating new chat: ", e);
                }
            }

            function subscribeToMessages(userId, chatId) {
                if (messagesUnsubscribe) messagesUnsubscribe();
                if (!userId || !chatId) {
                    renderChatBox([]);
                    return;
                }
                const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
                const q = query(messagesCol, orderBy('createdAt'));
                messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                    // *** FIX: Add guard to prevent re-rendering during AI response streaming ***
                    if (isAIResponding) {
                        return;
                    }
                    currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatBox(currentMessages);
                }, (error) => {
                    console.error("Error fetching messages: ", error);
                    if (chatViewport) chatViewport.innerHTML = `<div class="message-group system" style="color: #f44; margin-top: 20px;">Error loading messages for this chat.</div>`;
                });
            }

            if (newChatBtn) {
                newChatBtn.addEventListener('click', () => { if (currentUser) createNewChat(currentUser.uid); });
            }

            function renderChatsListSidebar() {
                if (!chatsListEl) return;
                chatsListEl.innerHTML = '';
                if (chats.length === 0) {
                    chatsListEl.innerHTML = `<div class="message-group system" style="padding: 10px;">No chats yet.</div>`;
                    return;
                }
                chats.forEach((chat) => {
                    const container = document.createElement('div');
                    container.style.display = 'flex';
                    container.style.alignItems = 'center';
                    container.style.marginBottom = '6px';
                    container.style.background = chat.id === currentChatId ? 'rgba(0, 234, 255, 0.15)' : 'transparent';
                    container.style.borderRadius = '8px';

                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = chat.name || `Chat`;
                    titleSpan.style.flex = '1';
                    titleSpan.style.cursor = 'pointer';
                    titleSpan.style.padding = '8px 5px';
                    titleSpan.style.color = 'var(--main-text-color)';
                    titleSpan.onclick = () => {
                        currentChatId = chat.id;
                        if (currentUser) subscribeToMessages(currentUser.uid, currentChatId);
                        renderChatsListSidebar();
                        closeProfileMenu();
                    };

                    const renameBtn = document.createElement('button');
                    renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                    renameBtn.title = 'Rename Chat';
                    renameBtn.style.margin = '0 6px 0 8px';
                    renameBtn.onclick = async (e) => {
                        e.stopPropagation();
                        const newName = prompt("Rename chat:", chat.name);
                        if (newName && newName.trim()) {
                            if (currentUser && chat.id) {
                                const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                                await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
                            }
                        }
                    };

                    const delBtn = document.createElement('button');
                    delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                    delBtn.title = 'Delete Chat';
                    delBtn.style.marginLeft = '6px';
                    delBtn.onclick = async (e) => {
                        e.stopPropagation();
                        if (!confirm(`Delete "${chat.name}"? This will delete all messages.`)) return;

                        if (currentUser && chat.id) {
                            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                            const messagesSnap = await getDocs(messagesCol);
                            const batch = writeBatch(db);
                            messagesSnap.docs.forEach(d => batch.delete(d.ref));
                            await batch.commit();

                            const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                            await deleteDoc(chatDoc);

                            if (currentChatId === chat.id) {
                                currentChatId = null;
                            }
                        }
                    };

                    container.appendChild(titleSpan);
                    container.appendChild(renameBtn);
                    container.appendChild(delBtn);
                    chatsListEl.appendChild(container);
                });
            }

            const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

            function inlineMarkdown(t = '') {
                let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
                s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
                s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
                s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                return s.replace(/\n/g, '<br>');
            }

            function renderMarkdown(text = '') {
                const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
                let html = '';
                let lastIndex = 0;
                text = text || '';
                text.replace(codeBlockRegex, (match, lang, code, offset) => {
                    const before = text.slice(lastIndex, offset);
                    html += inlineMarkdown(before);
                    const language = (lang || '').toLowerCase().trim();
                    const safeCode = escapeHTML(code);
                    html += `<pre data-lang="${language || 'plaintext'}"><button class="copy-btn"><i class='fa-solid fa-copy'></i> Copy</button><code class="language-${language || 'plaintext'}">${safeCode}</code></pre>`;
                    lastIndex = offset + match.length;
                    return match;
                });
                html += inlineMarkdown(text.slice(lastIndex));
                return { html };
            }

            function enhanceCodeBlocks(container) {
                if (!container) return;
                container.querySelectorAll('pre').forEach(pre => {
                    const codeEl = pre.querySelector('code');
                    if (window.hljs && codeEl && !pre.classList.contains('highlighted')) {
                        try { hljs.highlightElement(codeEl); } catch (e) { console.error("Highlight.js error:", e); }
                        pre.classList.add('highlighted');
                    }
                    const btn = pre.querySelector('.copy-btn');
                    if (btn && codeEl) {
                        const newBtn = btn.cloneNode(true);
                        btn.parentNode.replaceChild(newBtn, btn);

                        newBtn.addEventListener('click', async () => {
                            try {
                                await navigator.clipboard.writeText(codeEl.innerText);
                                newBtn.innerHTML = "<i class='fa-solid fa-check'></i> Copied!";
                                setTimeout(() => { if (newBtn) newBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy"; }, 1200);
                            } catch (e) {
                                newBtn.innerHTML = "<i class='fa-solid fa-times'></i> Failed";
                                setTimeout(() => { newBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copy"; }, 1200);
                            }
                        });
                    }
                });
            }

            function addSystemMessage(text) {
                const div = document.createElement('div');
                div.className = 'message-group system';
                div.innerHTML = `<div class="msg-bubble">${escapeHTML(text)}</div>`;
                chatViewport.appendChild(div);
                scrollToBottom();
            }

            function renderChatBox(messages = []) {
                if (!chatViewport) return;

                chatViewport.innerHTML = ''; 

                if(messages.length === 0) {
                    addWelcomeMessage();
                } else {
                    (messages || []).forEach((msg) => {
                        const div = document.createElement('div');
                        div.className = 'message-group ' + (msg.role === 'user' ? 'user' : 'ai');
                        div.setAttribute('data-message-id', msg.id);
                        let innerHtml = '';

                        if (msg.role === 'user') {
                            const fileHtml = (msg.files || [])
                                .map(file => {
                                    let icon = 'fa-file';
                                    if (file.type && file.type.startsWith('image/')) icon = 'fa-file-image';
                                    else if (file.type && file.type.startsWith('video/')) icon = 'fa-file-video';
                                    else if (file.type && file.type.startsWith('audio/')) icon = 'fa-file-audio';
                                    else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                                    return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name || 'Unknown file')}</div>`;
                                })
                                .join('');
                            
                            const userContent = renderMarkdown(msg.text || '').html;

                            innerHtml = `<div class="msg-bubble">
                                ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                                ${userContent}
                                <div class="user-msg-controls">
                                    <button type="button" class="inline-edit-btn" title="Edit message"><i class="fa-solid fa-pen-to-square"></i></button>
                                    <button type="button" class="inline-copy-btn" title="Copy message"><i class="fa-solid fa-copy"></i></button>
                                </div>
                            </div>`;
                        } else {
                            let content;
                            if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                                content = msg.text;
                            } else {
                                content = renderMarkdown(msg.text || '').html;
                            }
                            const timeDisplay = msg.duration ? `<span style="font-size:0.8em; color: rgba(255,255,255,0.6); margin-right: auto; align-self: center;">Generated in ${msg.duration}s</span>` : '';
                            innerHtml = `<div class="msg-bubble">
                                <div class="ai-content-area">${content}</div>
                                <div class="ai-msg-controls">
                                    ${timeDisplay}
                                    <div style="margin-left:auto;"></div>
                                    <button type="button" class="inline-copy-btn" title="Copy response"><i class="fa-solid fa-copy"></i></button>
                                    <button type="button" class="inline-share-btn" title="Share response"><i class="fa-solid fa-share"></i></button>
                                    <button type="button" class="inline-regen-btn" title="Regenerate response (current model)"><i class="fa-solid fa-arrows-rotate"></i></button>
                                    <div class="switch-model-btn" title="Change AI Model">
                                        <i class="fa-solid fa-sitemap"></i>
                                        <div class="model-switch-popup">
                                            <button data-model="gemini"><i class="fa-solid fa-feather-alt"></i>Switch to Philadelphia</button>
                                            <button data-model="perplexity"><i class="fa-solid fa-star-of-life"></i>Switch to Seraphina</button>
                                            <button data-model="llama"><i class="fa-solid fa-robot"></i>Switch to Llama</button>
                                        </div>
                                    </div>
                                </div>
                            </div>`;
                        }
                        div.innerHTML = innerHtml;
                        chatViewport.appendChild(div);
                    });
                }
                
                enhanceCodeBlocks(chatViewport);
                hookAiMsgControls();
                hookUserMsgControls();
                scrollToBottom();
            }

            async function deleteMessagesFrom(messageId) {
                if (!currentChatId || !currentUser) return;
                const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                if (msgIndex === -1) return;
                const batch = writeBatch(db);
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                for (let i = msgIndex; i < currentMessages.length; i++) {
                    const msgToDel = currentMessages[i];
                    if (msgToDel.id && !msgToDel.id.startsWith('temp-id-')) {
                        const docRef = doc(messagesCol, msgToDel.id);
                        batch.delete(docRef);
                    }
                }
                try {
                    await batch.commit();
                } catch (e) {
                    console.error("Error deleting messages: ", e);
                }
            }

            function hookAiMsgControls() {
                if (!chatViewport) return;
                chatViewport.querySelectorAll('.message-group.ai').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    if (!messageId) return;

                    const controls = div.querySelector('.ai-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const shareBtn = controls.querySelector('.inline-share-btn');
                    const regenBtn = controls.querySelector('.inline-regen-btn');
                    const switchModelContainer = controls.querySelector('.switch-model-btn');
                    const popup = controls.querySelector('.model-switch-popup'); 

                    if (copyBtn) copyBtn.onclick = () => {
                        const msgContentArea = div.querySelector('.ai-content-area');
                        if (!msgContentArea) return;
                        
                        const textToCopy = msgContentArea.innerText || ''; // Get plain text content
                        navigator.clipboard.writeText(textToCopy.trim());
                        copyBtn.innerHTML = "<i class='fa-solid fa-check'></i>";
                        setTimeout(() => { if (copyBtn) copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>"; }, 1200);
                    };

                    if (shareBtn) shareBtn.onclick = () => {
                        const msgContentArea = div.querySelector('.ai-content-area');
                        if (!msgContentArea) return;
                        try {
                            const url = window.location.origin;
                            const plainText = msgContentArea.innerText || '';
                            const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;
                            if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
                            else prompt("Copy and share manually:", shareText);
                        } catch (e) { console.warn('Share failed:', e); }
                    };

                    if (regenBtn) regenBtn.onclick = () => {
                        regenerateResponse(messageId); // Regenerate using the current global model
                    };
                    
                    if (popup) { 
                        popup.querySelectorAll('button').forEach(button => {
                            button.onclick = (ev) => {
                                ev.stopPropagation();
                                const newModel = ev.currentTarget.dataset.model;
                                setCurrentModel(newModel);
                                popup.style.display = 'none';
                            };
                        });
                        if (switchModelContainer) {
                            switchModelContainer.onclick = (ev) => {
                                ev.stopPropagation();
                                popup.style.display = popup.style.display === 'flex' ? 'none' : 'flex';
                            };
                        }
                    }
                });
                document.addEventListener('click', (e) => {
                    document.querySelectorAll('.model-switch-popup').forEach(popup => {
                        const switchBtn = popup.closest('.switch-model-btn');
                        if (popup.style.display === 'flex' && switchBtn && !switchBtn.contains(e.target) && !popup.contains(e.target)) {
                            popup.style.display = 'none';
                        }
                    });
                });
            }

            async function regenerateResponse(messageId) {
                const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                if (msgIndex < 1) return;
                const userMsg = currentMessages[msgIndex - 1];
                if (userMsg.role !== 'user') return;

                if (currentController) currentController.abort();
                
                await deleteMessagesFrom(messageId);
                
                await sendMessage(userMsg.text); 
            }


            function hookUserMsgControls() {
                if (!chatViewport) return;
                chatViewport.querySelectorAll('.message-group.user').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;
                    const controls = div.querySelector('.user-msg-controls');
                    if (!controls) return;
                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const editBtn = controls.querySelector('.inline-edit-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            const msgBubble = div.querySelector('.msg-bubble');
                            const textToCopy = msgBubble.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-check'></i>";
                            setTimeout(() => { if (copyBtn) copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>"; }, 1200);
                        } catch (e) { console.warn('Copy failed:', e); }
                    };

                    if (editBtn) editBtn.onclick = async () => {
                        try {
                            if (!msg.text) return;
                            if (userInput) {
                                userInput.value = msg.text;
                                userInput.focus();
                                userInput.dispatchEvent(new Event('input'));
                            }
                            await deleteMessagesFrom(messageId);
                        } catch (e) { console.warn('Edit failed:', e); }
                    };
                });
            }
            
            function scrollToBottom() {
                if (chatViewport) {
                    setTimeout(() => {
                        chatViewport.scrollTop = chatViewport.scrollHeight;
                    }, 0);
                }
            }

            function displayProcessingMessage(text) {
                if (!chatViewport) return;
                removeProcessingMessage(); // Clear previous message

                const div = document.createElement('div');
                div.className = "message-group ai";
                div.innerHTML = `
                    <div class="msg-bubble" aria-label="${text}">
                        <div class="ai-content-area" style="display: flex; align-items: center;">
                            <span class="spinner"></span>
                            <span style="margin-left:10px; color:var(--main-text-color); font-style:italic;">${escapeHTML(text)}</span>
                        </div>
                    </div>
                `;
                chatViewport.appendChild(div);
                currentProcessingMessageElement = div;
                isAIResponding = true;
                scrollToBottom();
            }

            function removeProcessingMessage() {
                if (currentProcessingMessageElement) {
                    currentProcessingMessageElement.remove();
                    currentProcessingMessageElement = null;
                }
            }

            async function showToolResponse(text, saveToDb = true, durationSeconds = null) {
                removeProcessingMessage(); // Clear "Generating..." message

                const div = document.createElement('div');
                div.className = "message-group ai";
                const msgBubble = document.createElement('div');
                msgBubble.className = 'msg-bubble';
                div.appendChild(msgBubble);
                
                const finalRenderText = text || "Tool execution finished.";
                
                msgBubble.innerHTML = `
                    <div class="ai-content-area">${renderMarkdown(finalRenderText).html}</div>
                    <div class="ai-msg-controls">
                        ${durationSeconds ? `<span style="font-size:0.8em; color: rgba(255,255,255,0.6); margin-right: auto; align-self: center;">Generated in ${durationSeconds}s</span>` : ''}
                        <div style="margin-left:auto;"></div>
                        <button type="button" class="inline-copy-btn" title="Copy response"><i class="fa-solid fa-copy"></i></button>
                        <button type="button" class="inline-share-btn" title="Share response"><i class="fa-solid fa-share"></i></button>
                        <button type="button" class="inline-regen-btn" title="Regenerate response (current model)"><i class="fa-solid fa-arrows-rotate"></i></button>
                        <div class="switch-model-btn" title="Change AI Model">
                            <i class="fa-solid fa-sitemap"></i>
                            <div class="model-switch-popup">
                                <button data-model="gemini"><i class="fa-solid fa-feather-alt"></i>Switch to Philadelphia</button>
                                <button data-model="perplexity"><i class="fa-solid fa-star-of-life"></i>Switch to Seraphina</button>
                                <button data-model="llama"><i class="fa-solid fa-robot"></i>Switch to Llama</button>
                            </div>
                        </div>
                    </div>
                `;
                chatViewport.appendChild(div);
                enhanceCodeBlocks(msgBubble);
                scrollToBottom();
                
                if (saveToDb && currentUser && currentChatId) {
                    const newMsg = { role: 'ai', text: finalRenderText, duration: durationSeconds, createdAt: serverTimestamp() };
                    try {
                        const docRef = await addDoc(collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages'), newMsg);
                        div.setAttribute('data-message-id', docRef.id);
                        hookAiMsgControls();
                    } catch (e) { console.error("Error saving AI message: ", e); }
                }
                isAIResponding = false; // Reset master flag
            }


            function renderFilePreview() {
                if (!filePreview) return;
                if (!uploadedFiles.length) {
                    filePreview.classList.remove('active');
                    filePreview.innerHTML = '';
                    fileObjectURLs.forEach(url => URL.revokeObjectURL(url));
                    fileObjectURLs = [];
                    return;
                }
                filePreview.classList.add('active');
                filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                    let preview = '';
                    let objUrl = '';
                    try {
                        objUrl = URL.createObjectURL(file);
                        fileObjectURLs.push(objUrl);
                    } catch (e) {
                        console.error("Error creating object URL for file preview:", e);
                        objUrl = '';
                    }

                    if (file.type && file.type.startsWith('image/')) {
                        preview = `<img src="${objUrl}">`;
                    } else if (file.type && file.type.startsWith('video/')) {
                        preview = `<video src="${objUrl}" controls></video>`;
                    } else if (file.type && file.type.startsWith('audio/')) {
                        preview = `<audio controls src="${objUrl}"></audio>`;
                    } else if (file.type === 'application/pdf') {
                        preview = `<i class="fa-solid fa-file-pdf" style="font-size: 2em;"></i>`;
                    } else {
                        preview = `<i class="fa-solid fa-file" style="font-size: 2em;"></i>`;
                    }
                    return `
                        <div>
                            ${preview}
                            <span>${escapeHTML(file.name || 'Unknown file')}</span>
                            <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
                        </div>`;
                }).join('');

                filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const idx = parseInt(btn.getAttribute('data-idx'));
                        if (uploadedFiles[idx] && fileObjectURLs[idx]) {
                            URL.revokeObjectURL(fileObjectURLs[idx]);
                        }
                        uploadedFiles.splice(idx, 1);
                        fileObjectURLs.splice(idx, 1);
                        if (!uploadedFiles.length && chatFile) chatFile.value = '';
                        renderFilePreview();
                    });
                });
                filePreview.style.bottom = `${inputDock.offsetHeight + 15}px`;
            }

            function showAIImagePreview(base64, caption = '') {
                if (!aiPrevBox || !aiPrevImgBox) return;
                aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image">` + `<div style="color:var(--main-text-color);font-size:.95em;margin-top:3px;text-align:center;">${caption}</div>`;
                aiPrevBox.classList.add('active');
                aiPrevBox.style.bottom = `${inputDock.offsetHeight + 15}px`;
            }

            async function addMessageToChat(role, text, files = [], duration = null) {
                if (!currentChatId || !currentUser) return;

                // Add message visually right away for responsiveness
                if (role === 'user') {
                     const div = document.createElement('div');
                    div.className = 'message-group user';
                    const fileHtml = (files || []).map(file => {
                        let icon = 'fa-file';
                        if (file.type?.startsWith('image/')) icon = 'fa-file-image';
                        else if (file.type?.startsWith('video/')) icon = 'fa-file-video';
                        else if (file.type?.startsWith('audio/')) icon = 'fa-file-audio';
                        return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                    }).join('');
                    div.innerHTML = `<div class="msg-bubble">
                        ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                        ${renderMarkdown(text).html}
                    </div>`; // Controls will be added by renderChatBox later
                    chatViewport.appendChild(div);
                    enhanceCodeBlocks(div); // Enhance code blocks in the new user message
                    scrollToBottom();
                }

                // Save to Firestore in the background
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesCol, { role, text, files, duration, createdAt: serverTimestamp() });
                } catch (e) {
                    console.error("Error adding message to Firestore: ", e);
                    // Optionally show an error to the user
                }
            }

            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            async function handleVideoGeneration(payload, isImageToVideo = false) {
                displayProcessingMessage('Submitting video generation job...');
                try {
                    const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
                    const commonPayload = { model: "MiniMax-Hailuo-02", duration: payload.duration || 6, resolution: payload.resolution || "1080P" };
                    let options;

                    if (isImageToVideo) {
                        const fd = new FormData();
                        fd.append('prompt', payload.prompt);
                        fd.append('file', payload.file); // Assuming payload.file exists for image-to-video
                        options = { method: 'POST', body: fd, signal: currentController?.signal };
                    } else {
                        const finalPayload = { ...payload, ...commonPayload };
                        options = {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(finalPayload),
                            signal: currentController?.signal
                        };
                    }

                    const startRes = await fetch(API_BASE_URL + endpoint, options);
                    const startData = await startRes.json();

                    if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || startData.error || 'Failed to start video task.');

                    await showToolResponse(` Video job submitted! Task ID: \`${startData.task_id}\`. I will notify you when it's ready. This can take a few minutes. Please do not leave this page or send another message.`);

                    const pollInterval = setInterval(async () => {
                        try {
                            if (currentController?.signal.aborted) {
                                clearInterval(pollInterval);
                                await showToolResponse(` Video status polling stopped.`);
                                return;
                            }
                            const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`, { signal: currentController?.signal });
                            const statusData = await statusRes.json();

                            if (statusRes.ok && statusData.url) {
                                clearInterval(pollInterval);
                                const videoHtml = ` Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview"></video>`;
                                await addMessageToChat('ai', videoHtml);
                            } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                                clearInterval(pollInterval);
                                await showToolResponse(` Video generation failed. Reason: ${statusData.error || 'Unknown error'}`);
                            }
                        } catch (pollErr) {
                            if (pollErr.name === 'AbortError') {
                                console.log("Video status polling aborted.");
                                await showToolResponse(` Video status polling stopped.`);
                            } else {
                                console.error("Error during video status polling:", pollErr);
                                await showToolResponse(` Error checking video status.`);
                            }
                            clearInterval(pollInterval);
                        }
                    }, 20000);
                } catch (err) {
                    if (err.name === 'AbortError') {
                        await showToolResponse(` Video generation request stopped.`);
                    } else {
                        await showToolResponse(` Could not start video generation: ${err.message}`);
                    }
                } finally {
                    removeProcessingMessage();
                }
            }
            
            // --- MODIFICATION START ---
            // Moved these definitions here to be accessible by multiple tool definitions.
            const version1Styles = [
                { value: 'illustration', text: 'Illustration (V6)' },
                { value: 'realistic', text: 'Realistic (Photoreal)' },
                { value: 'cinematic', text: 'Cinematic (Movie)' },
                { value: 'anime', text: 'Anime (Core)' }
            ];
            const version2ComicStyles = [
                { value: 'anime', text: 'Anime' },
                { value: 'american', text: 'American Comic' },
                { value: 'manga', text: 'Manga' }
            ];
            // --- MODIFICATION END ---


            // *** COMIC VIEWER FUNCTIONS ***
            function showComicPreview(images, caption = '') {
                if (!comicPrevBox) return;
                comicPanels = images;
                currentComicPanelIndex = 0;
                renderComicPanel();
                comicPrevBox.classList.add('active');
                comicPrevBox.style.bottom = `${inputDock.offsetHeight + 15}px`;
            }

            function renderComicPanel() {
                if (!comicPrevImgBox || comicPanels.length === 0) return;
                comicPrevImgBox.innerHTML = `<img src="data:image/png;base64,${comicPanels[currentComicPanelIndex]}" alt="Comic Panel ${currentComicPanelIndex + 1}">`;
                comicIndicator.textContent = `Panel ${currentComicPanelIndex + 1} of ${comicPanels.length}`;
                comicPrevBtn.disabled = currentComicPanelIndex === 0;
                comicNextBtn.disabled = currentComicPanelIndex === comicPanels.length - 1;
            }

            if(comicPrevClose) comicPrevClose.addEventListener('click', () => comicPrevBox.classList.remove('active'));
            if(comicNextBtn) comicNextBtn.addEventListener('click', () => {
                if (currentComicPanelIndex < comicPanels.length - 1) {
                    currentComicPanelIndex++;
                    renderComicPanel();
                }
            });
            if(comicPrevBtn) comicPrevBtn.addEventListener('click', () => {
                if (currentComicPanelIndex > 0) {
                    currentComicPanelIndex--;
                    renderComicPanel();
                }
            });
            if(comicPrevDLBtn) comicPrevDLBtn.addEventListener('click', () => {
                const a = document.createElement('a');
                a.href = `data:image/png;base64,${comicPanels[currentComicPanelIndex]}`;
                a.download = `philadelphia_comic_panel_${currentComicPanelIndex + 1}.png`;
                a.click();
            });
            // *** END COMIC VIEWER FUNCTIONS ***

            const toolDefinitions = {
                "image": {
                    title: "Generate Image",
                    description: "Create stunning visuals from a text prompt. Choose a model for different results.",
                    buildForm: () => `
                        <label for="tool-provider">Generation Model</label>
                        <select id="tool-provider" aria-label="Image generation model"><option value="thena">Version 1 (Stylized, Fast & Recommended)</option><option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option></select>
                        <label for="tool-prompt">Image Prompt</label>
                        <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required aria-label="Image prompt"></textarea>
                        <label for="tool-style" id="tool-style-label">Style (for Version 1 only)</label>
                        <select id="tool-style" aria-label="Image style">${version1Styles.map(s => `<option value="${s.value}">${s.text}</option>`).join('')}</select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate</button>`,
                    onFormReady: () => {
                        const provider = $('tool-provider');
                        const styleSelect = $('tool-style');
                        const styleLabel = $('tool-style-label');
                        if (!provider || !styleSelect || !styleLabel) return;
                        const toggleStyleVisibility = () => {
                            const isV1 = provider.value === 'thena';
                            styleSelect.style.display = isV1 ? 'block' : 'none';
                            styleLabel.style.display = isV1 ? 'block' : 'none';
                        };
                        provider.addEventListener('change', toggleStyleVisibility);
                        toggleStyleVisibility(); // Initial check
                    },
                    handleSubmit: async (form) => {
                        const use_minimax = form.querySelector('#tool-provider')?.value === 'minimax';
                        const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)';
                        const prompt = form.querySelector('#tool-prompt')?.value;
                        const style = form.querySelector('#tool-style')?.value;
                        if (!prompt) return "Please provide an image prompt.";
                        
                        const payload = { 
                            prompt: prompt, 
                            model: use_minimax ? 'illustration' : style, // Pass the detailed style for V1
                            use_minimax: use_minimax,
                            creative: false, width: null, height: null, fastMode: false, denseMode: false
                        };

                        await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                        displayProcessingMessage('Generating your image...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/generate-image`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload),
                                signal: currentController?.signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || data.detail || res.statusText);
                            removeProcessingMessage();
                            showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                            await showToolResponse(' Image generated! Check the floating image box to view or download.', true);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Image generation stopped.'; }
                            return ` Image generation failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "edit-photo": {
                    title: "Edit Photo",
                    description: "Upload a photo and describe the changes you want to make.",
                    buildForm: () => `
                        <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required aria-label="Edit instruction"></textarea>
                        <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required aria-label="Image to edit">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file')?.files[0];
                        const prompt = form.querySelector('#tool-prompt')?.value;
                        if (!file) return "Please select a file to edit.";
                        if (!prompt) return "Please provide an edit instruction.";
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('prompt', prompt);
                        await addMessageToChat('user', `Photo edit request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                        displayProcessingMessage('Editing your photo...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd, signal: currentController?.signal });
                            if (!res.ok) throw new Error((await res.json())?.error || 'Failed to edit photo.');
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const imgHtml = ` Photo edited successfully! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview">`;
                            await addMessageToChat('ai', imgHtml);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Photo edit stopped.'; }
                            return ` Photo edit failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "remove-bg": {
                    title: "Remove Background",
                    description: "Select an image file to automatically remove its background.",
                    buildForm: () => `
                        <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;" aria-label="Image file for background removal">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Remove Background</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file')?.files[0];
                        if (!file) return "Please select a file.";
                        await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        displayProcessingMessage('Removing background...');
                        const fd = new FormData();
                        fd.append('file', file);
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd, signal: currentController?.signal });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const imgHtml = ` Background removed! <br><img src="${url}" alt="Image with background removed" class="chat-media-preview">`;
                            await addMessageToChat('ai', imgHtml);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Background removal stopped.'; }
                            return ` Background removal failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "comic": {
                    title: "Create Comic",
                    description: "Write a story and watch it transform into a comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.",
                    buildForm: () => `
                        <label for="tool-provider">Generation Model</label>
                        <select id="tool-provider" aria-label="Comic generation model">
                            <option value="thena">Version 1 (Stylized, Recommended)</option>
                            <option value="minimax">Version 2 (Creative, MiniMax)</option>
                        </select>
                        <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required aria-label="Comic story"></textarea>
                        <label for="tool-style">Comic Style</label>
                        <select id="tool-style" aria-label="Comic style"></select>
                        <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" aria-label="Number of panels for comic"/>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Create Comic</button>`,
                    onFormReady: () => {
                        const providerSelect = $('tool-provider');
                        const styleSelect = $('tool-style');
                        if (!providerSelect || !styleSelect) return;

                        const updateStyles = () => {
                            const provider = providerSelect.value;
                            if (provider === 'thena') {
                                styleSelect.innerHTML = version1Styles.map(s => `<option value="${s.value}">${s.text}</option>`).join('');
                            } else { // minimax
                                styleSelect.innerHTML = version2ComicStyles.map(s => `<option value="${s.value}">${s.text}</option>`).join('');
                            }
                        };
                        
                        providerSelect.addEventListener('change', updateStyles);
                        updateStyles(); // Initial population
                    },
                    handleSubmit: async (form) => {
                        const modelProvider = form.querySelector('#tool-provider')?.value;
                        const story = form.querySelector('#tool-story')?.value;
                        const styleFromForm = form.querySelector('#tool-style')?.value;
                        const panels = parseInt(form.querySelector('#tool-panels')?.value, 10);
                        if (!story) return "Please provide a comic story.";

                        // --- MODIFICATION START: Map detailed styles to backend-compatible styles for Version 1 ---
                        let finalStyle;
                        if (modelProvider === 'thena') {
                            // Map the detailed Version 1 style to a simple one the backend understands
                            const realisticStyles = ['realistic', 'cinematic', 'illustration'];
                            if (realisticStyles.includes(styleFromForm)) {
                                finalStyle = 'american';
                            } else { // All other styles (anime, etc.) map to anime
                                finalStyle = 'anime';
                            }
                        } else {
                            // For Version 2 (minimax), use the style directly
                            finalStyle = styleFromForm;
                        }
                        // --- MODIFICATION END ---

                        const payload = { story, style: finalStyle, panels, user: currentUser?.displayName || "User", model_provider: modelProvider };
                        await addMessageToChat('user', `Comic creation request: "${story.substring(0, 50)}..." (Provider: ${modelProvider}, Style: ${styleFromForm})`);
                        displayProcessingMessage('Generating your comic panels...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload),
                                signal: currentController?.signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            
                            removeProcessingMessage();
                            showComicPreview(data.images);

                            await showToolResponse(' Comic created! Check the floating comic viewer to see the panels.', true);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Comic generation stopped.'; }
                            return ` Comic generation failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "voice-gen": {
                    title: "Voice Generation",
                    description: "Transform text into realistic speech. Choose a provider and voice style.",
                    buildForm: () => `
                        <label for="tool-provider">Voice Provider</label><select id="tool-provider" aria-label="Voice provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
                        <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required aria-label="Text to speak"></textarea>
                        <label for="tool-style">Voice Style</label><select id="tool-style" aria-label="Voice style"></select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice</button>`,
                    onFormReady: () => {
                        const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
                        if (!providerSelect || !styleSelect) return;
                        const voices = {
                            gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                            minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                        };
                        const updateStyles = () => {
                            const selectedProvider = providerSelect.value;
                            styleSelect.innerHTML = (voices[selectedProvider] || []).map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                        };
                        providerSelect.addEventListener('change', updateStyles);
                        updateStyles();
                    },
                    handleSubmit: async (form) => {
                        const provider = form.querySelector('#tool-provider')?.value;
                        const text = form.querySelector('#tool-prompt')?.value;
                        const style = form.querySelector('#tool-style')?.value;
                        if (!text) return "Please provide text to speak.";
                        const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';
                        await addMessageToChat('user', `Voice generation request using ${providerName}.`);
                        displayProcessingMessage('Generating your audio...');
                        try {
                            let res;
                            if (provider === 'gemini') {
                                const fd = new FormData();
                                fd.append('text', text);
                                fd.append('style', style);
                                res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd, signal: currentController?.signal });
                            } else {
                                res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({ text: text, voice_id: style }),
                                    signal: currentController?.signal
                                });
                            }
                            if (!res.ok) throw new Error(await res.text());
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const audioHtml = ` Voice generated! <br><audio controls src="${url}" class="chat-media-preview"></audio>`;
                            await addMessageToChat('ai', audioHtml);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Voice generation stopped.'; }
                            return ` Voice generation failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "audio-narration": {
                    title: "Audio Narration",
                    description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.",
                    buildForm: () => `
                        <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;" aria-label="File for narration">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file')?.files[0];
                        if (!file) return "Please select a file.";
                        await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        displayProcessingMessage('Analyzing and narrating document...');
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('style', 'podcast');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd, signal: currentController?.signal });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const narrationHtml = ` Narration generated! <br><audio controls src="${url}" class="chat-media-preview"></audio>`;
                            await addMessageToChat('ai', narrationHtml);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Audio narration stopped.'; }
                            return ` Audio narration failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "video-text": {
                    title: "Generate Video from Text",
                    description: "Describe the video you want to create. This process can take a few minutes.",
                    buildForm: () => `
                        <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required aria-label="Video prompt"></textarea>
                        <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15" aria-label="Video duration in seconds">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
                    handleSubmit: async (form) => {
                        const prompt = form.querySelector('#video-prompt')?.value;
                        const duration = parseInt(form.querySelector('#video-duration')?.value, 10);
                        if (!prompt) return "Please provide a video prompt.";
                        if (isNaN(duration) || duration < 2 || duration > 15) return "Duration must be between 2 and 15 seconds.";
                        const payload = { prompt, duration, resolution: "1080P" };
                        await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
                        await handleVideoGeneration(payload);
                        return null;
                    }
                },
                "video-image": {
                    title: "Generate Video from Image",
                    description: "Upload a starting image and describe how you want to animate it.",
                    buildForm: () => `
                        <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required aria-label="Animation prompt"></textarea>
                        <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required aria-label="Starting image for video"></input>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#video-image-file')?.files[0];
                        const prompt = form.querySelector('#video-image-prompt')?.value;
                        if (!file) return "Please select an image.";
                        if (!prompt) return "Please provide an animation prompt.";
                        await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{name: file.name, type: file.type}]);
                        const fd = new FormData();
                        fd.append('prompt', prompt);
                        fd.append('file', file);
                        await handleVideoGeneration(fd, true);
                        return null;
                    }
                },
                "music": {
                    title: "Generate Music",
                    description: "Generate music from a prompt, lyrics, and optional reference audio. Thanks to MiniMax.",
                    buildForm: () => `
                        <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required aria-label="Music prompt"></textarea>
                        <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..." aria-label="Music lyrics"></textarea>
                        <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*" aria-label="Reference audio"></input>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Music</button>`,
                    handleSubmit: async (form) => {
                        const prompt = form.querySelector('#music-prompt')?.value;
                        const lyrics = form.querySelector('#music-lyrics')?.value;
                        const refFile = form.querySelector('#music-ref')?.files[0];
                        if (!prompt) return "Please provide a music prompt.";
                        const payload = { prompt, lyrics, model: 'music-1.5' };
                        await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
                        displayProcessingMessage('Composing your music...');
                        try {
                            if (refFile) {
                                displayProcessingMessage('Uploading reference audio first...');
                                const fd = new FormData();
                                fd.append('file', refFile);
                                const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd, signal: currentController?.signal });
                                const uploadData = await uploadRes.json();
                                if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed.");
                                if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                                if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                                displayProcessingMessage('Reference uploaded. Composing music...');
                            }
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload),
                                signal: currentController?.signal
                            });
                            if (!res.ok) throw new Error((await res.json())?.detail || 'API request failed.');
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const musicHtml = ` Your music is ready! <br><audio controls src="${url}" class="chat-media-preview"></audio>`;
                            await addMessageToChat('ai', musicHtml);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Music generation stopped.'; }
                            return ` Music generation failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "website": {
                    title: "Create Website",
                    description: "Describe the website you want to build and get a live, working prototype.",
                    buildForm: () => `
                        <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required aria-label="Website description"></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Website</button>`,
                    handleSubmit: async (form) => {
                        const prompt = form.querySelector('#website-prompt')?.value;
                        if (!prompt) return "Please provide a website description.";
                        await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`);
                        displayProcessingMessage('Building and deploying your website...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt, user_id: currentUser?.uid }),
                                signal: currentController?.signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            await showToolResponse(` Website deployed successfully! [View here](${data.url})`, true);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Website creation stopped.'; }
                            return ` Website creation failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "edit-website": {
                    title: "Edit Last Website",
                    description: "Provide an instruction to modify the most recent website you created.",
                    buildForm: () => `
                        <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required aria-label="Edit instruction"></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>`,
                    handleSubmit: async (form) => {
                        const instruction = form.querySelector('#edit-instruction')?.value;
                        if (!instruction) return "Please provide an edit instruction.";
                        await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`);
                        displayProcessingMessage('Editing and redeploying your website...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ instruction, user_id: currentUser?.uid }),
                                signal: currentController?.signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            await showToolResponse(` Website updated successfully! [View new version here](${data.url})`, true);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Website edit stopped.'; }
                            return ` Website edit failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "my-sites": {
                    isAction: true,
                    runAction: async () => {
                        if (!currentUser) { await showToolResponse("User not logged in.", true); return null; }
                        await addMessageToChat('user', 'Show me a list of my websites.');
                        displayProcessingMessage('Fetching your website list...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`, { signal: currentController?.signal });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || 'Could not fetch sites.');
                            removeProcessingMessage();
                            if (!data.sites || data.sites.length === 0) {
                                await showToolResponse("You haven't created any websites yet.", true);
                                return null;
                            }
                            const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank" rel="noopener noreferrer">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                            await showToolResponse(`Here are the websites you've created:\n${siteList}`, true);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { await showToolResponse(` Website list fetching stopped.`, true); return null; }
                            await showToolResponse(` Error fetching websites: ${err.message}`, true);
                            return null;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
                "research-report": {
                    title: "Research Report",
                    description: "Generate a comprehensive research report in PDF format on any topic.",
                    buildForm: () => `
                        <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required aria-label="Research topic">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>`,
                    handleSubmit: async (form) => {
                        const topic = form.querySelector('#research-topic')?.value;
                        if (!topic) return "Please provide a research topic.";
                        await addMessageToChat('user', `Research report request on: "${topic}"`);
                        displayProcessingMessage('Conducting research and compiling report...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ topic }),
                                signal: currentController?.signal
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--neon-blue);font-weight:bold;">Download PDF Report</a>`;
                            await showToolResponse(` Research report on **${topic}** is ready! ${downloadLink}`, true);
                            return null;
                        } catch (err) {
                            if (err.name === 'AbortError') { return ' Research report generation stopped.'; }
                            return ` Research report failed: ${err.message}`;
                        } finally {
                            removeProcessingMessage();
                        }
                    }
                },
            };

            if (toolsMenu) {
                toolsMenu.addEventListener('click', async (e) => {
                    const toolLink = e.target && e.target.closest('.tool-link');
                    if (!toolLink) return;
                    e.preventDefault();
                    const toolKey = toolLink.getAttribute('data-tool');
                    const tool = toolDefinitions[toolKey];
                    if (!tool) { console.error(`Tool "${toolKey}" is not defined.`); return; }
                    
                    if (isAIResponding) return;
                    currentController = new AbortController(); 
                    
                    if (sendBtn) sendBtn.style.display = 'none';
                    if (callBtn) callBtn.style.display = 'none';
                    if (stopBtn) {
                        stopBtn.style.display = 'flex';
                        const toolStopListener = () => { if (currentController) currentController.abort(); };
                        if (stopBtn._currentStopListener) stopBtn.removeEventListener('click', stopBtn._currentStopListener);
                        stopBtn.addEventListener('click', toolStopListener, { once: true });
                        stopBtn._currentStopListener = toolStopListener;
                    }

                    closeToolMenu();
                    let result = null;
                    try {
                        if (tool.isAction) {
                            result = await tool.runAction();
                        } else {
                            displayToolForm(toolKey);
                            return; 
                        }
                    } catch (err) {
                        result = ` Tool execution error: ${err.message}`;
                    } finally {
                        if (result && typeof result === 'string') {
                            await showToolResponse(result, true);
                        }
                        // Reset UI state
                        isAIResponding = false;
                        removeProcessingMessage(); 
                        if (sendBtn) sendBtn.style.display = 'flex';
                        if (callBtn) callBtn.style.display = 'flex';
                        if (stopBtn) stopBtn.style.display = 'none';
                        if (stopBtn._currentStopListener) {
                            stopBtn.removeEventListener('click', stopBtn._currentStopListener);
                            stopBtn._currentStopListener = null;
                        }
                        currentController = null;
                    }
                });
            }

            function displayToolForm(toolKey) {
                const tool = toolDefinitions[toolKey];
                if (!tool || !toolFormModalBg || !toolFormTitle || !toolForm) return;
                toolFormTitle.textContent = tool.title;
                const descriptionHtml = tool.description ? `<div style="color:rgba(168, 234, 255, 0.8);font-size:.9em;margin-bottom:12px;">${tool.description}</div>` : '';
                toolForm.innerHTML = descriptionHtml + tool.buildForm();
                if (typeof tool.onFormReady === 'function') tool.onFormReady();

                toolForm.onsubmit = async (e) => {
                    e.preventDefault();
                    const submitButton = toolForm.querySelector('button[type="submit"]');
                    if (submitButton) submitButton.disabled = true;

                    if (toolFormModal) toolFormModal.classList.remove('active');
                    if (toolFormModalBg) toolFormModalBg.classList.remove('active');
                    
                    let resultText = null;
                    try {
                        resultText = await tool.handleSubmit(toolForm);
                    } catch (err) {
                        resultText = ` Tool submission failed: ${err.message}`;
                    } finally {
                        if (resultText) {
                            await showToolResponse(resultText, true);
                        }
                        // Reset UI state
                        isAIResponding = false;
                        removeProcessingMessage();
                        if (sendBtn) sendBtn.style.display = 'flex';
                        if (callBtn) callBtn.style.display = 'flex';
                        if (stopBtn) stopBtn.style.display = 'none';
                        if (stopBtn._currentStopListener) {
                            stopBtn.removeEventListener('click', stopBtn._currentStopListener);
                            stopBtn._currentStopListener = null;
                        }
                        currentController = null;
                    }
                };
                if (toolFormModalBg) toolFormModalBg.classList.add('active');
                if (toolFormModal) toolFormModal.classList.add('active');
            }
            
            // --- UPGRADED: Real-time Typewriter & Streaming Logic ---
            function startTypewriterEffect() {
                if (typewriterInterval) return; // Already running

                typewriterInterval = setInterval(() => {
                    if (typewriterIndex < fullResponseContent.length) {
                        if (currentAIContentElement && currentCursorElement) {
                            const nextChar = fullResponseContent[typewriterIndex];
                            currentCursorElement.insertAdjacentText('beforebegin', nextChar);
                            typewriterIndex++;
                            scrollToBottom(); // Keep view at the bottom as text is typed
                        }
                    } else {
                        // Typewriter is caught up to the buffer.
                        // The interval will be cleared by finalizeChatResponse when the stream ends.
                    }
                }, 15); // IMPROVEMENT: Typing speed increased from 25ms to 15ms for a "flashier" effect
            }

            function finalizeChatResponse(finalText, startTime) {
                if (typewriterInterval) clearInterval(typewriterInterval);
                typewriterInterval = null;

                const responseDuration = ((performance.now() - startTime) / 1000).toFixed(1);
                
                const controlsHtml = `
                    <span style="font-size:0.8em; color: rgba(255,255,255,0.6); margin-right: auto; align-self: center;">Generated in ${responseDuration}s</span>
                    <div style="margin-left:auto;"></div>
                    <button type="button" class="inline-copy-btn" title="Copy response"><i class="fa-solid fa-copy"></i></button>
                    <button type="button" class="inline-share-btn" title="Share response"><i class="fa-solid fa-share"></i></button>
                    <button type="button" class="inline-regen-btn" title="Regenerate response (current model)"><i class="fa-solid fa-arrows-rotate"></i></button>
                    <div class="switch-model-btn" title="Change AI Model">
                        <i class="fa-solid fa-sitemap"></i>
                        <div class="model-switch-popup">
                            <button data-model="gemini"><i class="fa-solid fa-feather-alt"></i>Switch to Philadelphia</button>
                            <button data-model="perplexity"><i class="fa-solid fa-star-of-life"></i>Switch to Seraphina</button>
                            <button data-model="llama"><i class="fa-solid fa-robot"></i>Switch to Llama</button>
                        </div>
                    </div>
                `;
                
                // Final render with full markdown and controls
                if (currentAIMessageElement && currentAIContentElement && currentAIControlsElement) {
                    currentAIContentElement.innerHTML = renderMarkdown(finalText).html; // Render final markdown
                    enhanceCodeBlocks(currentAIMessageElement);
                    currentAIControlsElement.innerHTML = controlsHtml;
                    currentAIControlsElement.style.display = 'flex';
                    hookAiMsgControls();
                }
                
                // Save final, complete message to the database
                if (currentUser && currentChatId && finalText.trim()) {
                    const newMsg = { role: 'ai', text: finalText, duration: responseDuration, createdAt: serverTimestamp() };
                    addDoc(collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages'), newMsg)
                        .then(docRef => {
                            if(currentAIMessageElement) currentAIMessageElement.setAttribute('data-message-id', docRef.id);
                        }).catch(e => console.error("Error saving final message:", e));
                }
                
                // Reset all streaming-related state variables
                isAIResponding = false;
                if (sendBtn) sendBtn.style.display = 'flex';
                if (stopBtn) stopBtn.style.display = 'none';
                if (callBtn) callBtn.style.display = 'flex';
                if (stopBtn._currentStopListener) stopBtn.removeEventListener('click', stopBtn._currentStopListener);
                currentController = null;
                fullResponseContent = '';
                typewriterIndex = 0;
                currentAIMessageElement = null;
                currentAIContentElement = null;
                currentAIControlsElement = null;
                currentCursorElement = null;

                scrollToBottom();
            }

            // --- RE-ARCHITECTED `sendMessage` FUNCTION ---
            window.sendMessage = async function(overrideText = null) {
                const msgText = overrideText ?? userInput.value.trim();
                if (!msgText && uploadedFiles.length === 0) return;
                if (isAIResponding) return;
                
                isAIResponding = true;
                if (currentController) currentController.abort();
                currentController = new AbortController();
                
                // --- 1. UI SETUP ---
                if (sendBtn) sendBtn.style.display = 'none';
                if (stopBtn) stopBtn.style.display = 'flex';
                if (callBtn) callBtn.style.display = 'none';
                const chatStopListener = () => { if (currentController) currentController.abort(); };
                if (stopBtn._currentStopListener) stopBtn.removeEventListener('click', stopBtn._currentStopListener);
                stopBtn.addEventListener('click', chatStopListener, { once: true });
                stopBtn._currentStopListener = chatStopListener;

                if (overrideText === null) {
                    const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
                    await addMessageToChat('user', msgText, filesForHistory);
                    userInput.value = '';
                    uploadedFiles = [];
                    renderFilePreview();
                    userInput.dispatchEvent(new Event('input'));
                }
                
                // --- 2. CREATE "THINKING" PLACEHOLDER ---
                if (typewriterInterval) clearInterval(typewriterInterval);
                typewriterIndex = 0;
                fullResponseContent = '';
                
                const aiMessageDiv = document.createElement('div');
                aiMessageDiv.className = "message-group ai";
                aiMessageDiv.innerHTML = `
                    <div class="msg-bubble">
                        <div class="ai-content-area">
                            <div class="thinking-indicator">
                                <div class="dot"></div><div class="dot"></div><div class="dot"></div>
                            </div>
                        </div>
                        <div class="ai-msg-controls" style="display: none;"></div>
                    </div>`;
                chatViewport.appendChild(aiMessageDiv);
                scrollToBottom();

                currentAIMessageElement = aiMessageDiv;
                currentAIContentElement = aiMessageDiv.querySelector('.ai-content-area');
                currentAIControlsElement = aiMessageDiv.querySelector('.ai-msg-controls');

                const startTime = performance.now();
                
                // --- 3. FETCH & STREAM RESPONSE ---
                try {
                    const historyForAI = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                    
                    // --- NEW: Handle Llama non-streaming model ---
                    if (currentModel === 'llama') {
                        const res = await fetch(API_ENDPOINTS.llama, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ prompt: msgText }), // Llama is stateless on the backend
                            signal: currentController.signal
                        });
                        if (!res.ok) {
                            const errorData = await res.json().catch(() => ({ detail: res.statusText }));
                            throw new Error(`Llama API error (${res.status}): ${errorData.detail || errorData.content}`);
                        }
                        const data = await res.json();
                        fullResponseContent = data.content || "I'm sorry, I couldn't get a response.";
                        
                    } else {
                        // Existing streaming logic for Gemini and Perplexity
                        const endpoint = API_ENDPOINTS[currentModel] || API_ENDPOINTS.gemini;
                        const res = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: msgText, history: historyForAI }),
                            signal: currentController.signal
                        });

                        if (!res.ok) throw new Error(`Server error (${res.status}): ${await res.text()}`);

                        const reader = res.body.getReader();
                        const decoder = new TextDecoder('utf-8');
                        let buffer = '';
                        let isFirstChunk = true;

                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            let newlineIndex;
                            while ((newlineIndex = buffer.indexOf('\n\n')) !== -1) {
                                const message = buffer.substring(0, newlineIndex).trim();
                                buffer = buffer.substring(newlineIndex + 2);
                                if (!message.startsWith('data: ')) continue;
                                
                                const jsonStr = message.substring(5).trim();
                                if (jsonStr === '[DONE]') break;

                                try {
                                    const chunkData = JSON.parse(jsonStr);

                                    // On first valid data chunk, replace "thinking" with typewriter
                                    if (isFirstChunk) {
                                        isFirstChunk = false;
                                        if (currentAIContentElement) {
                                            currentAIContentElement.innerHTML = '<span class="typewriter-cursor"></span>';
                                            currentCursorElement = currentAIContentElement.querySelector('.typewriter-cursor');
                                        }
                                        startTypewriterEffect();
                                    }

                                    if (chunkData.type === 'content' && chunkData.content) {
                                        const cleanedContent = chunkData.content.replace(/\[\d+\]|\[cite:\s*\d+(,\s*\d+)*\]/g, '');
                                        fullResponseContent += cleanedContent; // Add to buffer for typewriter
                                    }
                                } catch (e) { /* Ignore parsing errors */ }
                            }
                        }
                    }
                } catch (err) {
                    if (err.name === 'AbortError') {
                        fullResponseContent += '\n\n*(Response stopped by user)*';
                    } else {
                        console.error("Fetch/Stream error:", err);
                        fullResponseContent += `\n\n An error occurred: ${err.message}`;
                    }
                } finally {
                    // This function now handles cleanup, final rendering, and saving for BOTH streaming and non-streaming calls.
                    finalizeChatResponse(fullResponseContent, startTime);
                }
            };
            
            // --- VOICE CALL LOGIC (Unchanged) ---
            const callVoices = {
                gemini: { label: "Philadelphia (Styles)", styles: ["podcast", "cinematic", "upbeat", "soft", "dramatic"] },
                minimax: { label: "Seraphina (Characters)", styles: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"] }
            };

            function updateCallVoiceStyles() {
                if (!callVoiceModel || !callVoiceStyle || !callVoiceStyleLabel) return;
                const selectedModel = callVoiceModel.value;
                const voicesData = callVoices[selectedModel];
                callVoiceStyle.innerHTML = (voicesData.styles || []).map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                callVoiceStyleLabel.textContent = voicesData.label.includes("Styles") ? "Style:" : "Character:";
                selectedCallVoiceProvider = selectedModel;
                selectedCallVoiceId = callVoiceStyle.value;
            }

            if (callVoiceModel) {
                callVoiceModel.addEventListener('change', updateCallVoiceStyles);
                callVoiceStyle.addEventListener('change', () => { selectedCallVoiceId = callVoiceStyle.value; });
                updateCallVoiceStyles();
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = true;
                speechRecognition.interimResults = true;
                speechRecognition.lang = 'en-US';

                speechRecognition.onstart = () => {
                    isRecognizing = true;
                    userSaidSomething = false;
                    if (!isMuted) {
                        if (callStatusMessage) callStatusMessage.textContent = 'Listening...';
                        if (userSpeechWave) userSpeechWave.classList.add('active');
                    }
                };

                speechRecognition.onresult = (event) => {
                    if (!isCallActive || isMuted) return;
                    let interimTranscript = '';
                    let finalTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }

                    if(finalTranscript || interimTranscript) {
                        userSaidSomething = true;
                    }

                    let userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                    if (!userMsgEl) {
                        userMsgEl = document.createElement('div');
                        userMsgEl.className = 'call-msg user interim';
                        const waveElement = callConversation.querySelector('#userSpeechWave');
                        if(waveElement) callConversation.insertBefore(userMsgEl, waveElement);
                        else callConversation.appendChild(userMsgEl);
                    }
                    userMsgEl.textContent = (finalTranscript + interimTranscript).trim();
                    if(userMsgEl.textContent) callConversation.scrollTop = callConversation.scrollHeight;
                };

                speechRecognition.onend = () => {
                    isRecognizing = false;
                    if (userSpeechWave) userSpeechWave.classList.remove('active');
                    if (!isCallActive || isMuted) return;

                    let finalTranscript = '';
                    const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                    if (userMsgEl) {
                        finalTranscript = userMsgEl.textContent.trim();
                        userMsgEl.classList.remove('interim');
                        if (!finalTranscript) userMsgEl.remove();
                    }
                    
                    if (botIsSpeaking) {
                        // Wait for bot to finish.
                    } else if (finalTranscript && userSaidSomething) {
                        callHistory.push({ role: 'user', content: finalTranscript });
                        handleCallBotResponse();
                    } else if (isCallActive && !isMuted) {
                        try { speechRecognition.start(); } catch(e) {}
                    }
                };

                speechRecognition.onerror = (event) => {
                    isRecognizing = false;
                    if (userSpeechWave) userSpeechWave.classList.remove('active');
                    console.error('Speech recognition error:', event.error);
                    if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        if (callStatusMessage) callStatusMessage.textContent = 'Mic access denied. Enable in browser settings.';
                        setTimeout(endCall, 3000);
                    } else if (isCallActive && !isMuted && event.error !== 'aborted') {
                        try { speechRecognition.start(); } catch(e) {}
                    }
                };
            } else {
                if (callBtn) callBtn.style.display = 'none';
            }

            function addCallMessage(role, text) {
                if (!callConversation) return;
                const msgEl = document.createElement('div');
                msgEl.className = `call-msg ${role}`;
                msgEl.textContent = text;
                const waveElement = callConversation.querySelector('#userSpeechWave');
                if(waveElement) callConversation.insertBefore(msgEl, waveElement);
                else callConversation.appendChild(msgEl);
                callConversation.scrollTop = callConversation.scrollHeight;
            }

            async function handleCallBotResponse() {
                if (!isCallActive || !callStatusMessage || !tapToTalk) return;
                callStatusMessage.textContent = 'Philadelphia AI is thinking...';
                tapToTalk.style.display = 'none';
                if (speechRecognition && isRecognizing) try { speechRecognition.stop(); } catch(e) {}
                const userLastMessage = callHistory.at(-1)?.content || "";
                
                try {
                    const historyForChat = callHistory.map(m => ({ role: m.role, content: m.content || '' }));
                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: userLastMessage, history: historyForChat.slice(0, -1), call_context: true })
                    });
                    if (!res.ok) throw new Error(`Server error: ${res.status}`);
                    
                    const reader = res.body.getReader();
                    const decoder = new TextDecoder('utf-8');
                    let fullBotResponseText = '';
                    let buffer = '';
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });
                        let newlineIndex;
                        while ((newlineIndex = buffer.indexOf('\n\n')) !== -1) {
                            const message = buffer.substring(0, newlineIndex);
                            buffer = buffer.substring(newlineIndex + 2);
                            if (message.startsWith('data: ')) {
                                let jsonStr = message.substring(5).trim();
                                if (jsonStr === '[DONE]') break;
                                try {
                                    const chunkData = JSON.parse(jsonStr);
                                    if (chunkData.type === 'content') fullBotResponseText += chunkData.content;
                                } catch (e) {}
                            }
                        }
                    }

                    const finalBotResponse = fullBotResponseText.trim() || "I'm sorry, I couldn't generate a response.";
                    callHistory.push({ role: 'ai', content: finalBotResponse });
                    addCallMessage('bot', finalBotResponse);
                    speakBotResponse(finalBotResponse);
                } catch (err) {
                    const errorMsg = ` Call error: ${err.message}`;
                    addCallMessage('bot', errorMsg);
                    if(callStatusMessage) callStatusMessage.textContent = 'Error. Tap to speak.';
                    if(tapToTalk) tapToTalk.style.display = 'block';
                }
            }

            async function speakBotResponse(textToSpeak) {
                if (!isCallActive || !botImageContainer || !callStatusMessage) return;
                botIsSpeaking = true;
                botImageContainer.classList.add('speaking');
                callStatusMessage.textContent = 'Philadelphia AI is speaking...';
                if (speechRecognition && isRecognizing) try { speechRecognition.stop(); } catch(e) {}

                try {
                    let res;
                    if (selectedCallVoiceProvider === 'gemini') {
                        const fd = new FormData();
                        fd.append('text', textToSpeak);
                        fd.append('style', selectedCallVoiceId);
                        res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                    } else {
                        res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                            method: 'POST', headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ text: textToSpeak, voice_id: selectedCallVoiceId })
                        });
                    }
                    if (!res.ok) throw new Error(await res.text());
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    
                    currentAudio = new Audio(url);
                    currentAudio.onended = currentAudio.onerror = () => {
                        botIsSpeaking = false;
                        if (botImageContainer) botImageContainer.classList.remove('speaking');
                        currentAudio = null;
                        URL.revokeObjectURL(url);
                        if (isCallActive && !isMuted) {
                            if (callStatusMessage) callStatusMessage.textContent = 'Tap anywhere to speak';
                            if (tapToTalk) tapToTalk.style.display = 'block';
                            if (!isRecognizing) try { speechRecognition.start(); } catch(e) {}
                        }
                    };
                    currentAudio.play();
                } catch (err) {
                    botIsSpeaking = false;
                    if (botImageContainer) botImageContainer.classList.remove('speaking');
                    if (isCallActive && !isMuted) {
                        if (callStatusMessage) callStatusMessage.textContent = 'Voice Error. Tap to speak.';
                        if (tapToTalk) tapToTalk.style.display = 'block';
                        if (!isRecognizing) try { speechRecognition.start(); } catch(e) {}
                    }
                }
            }

            function endCall() {
                isCallActive = false;
                botIsSpeaking = false;
                if (currentAudio) { currentAudio.pause(); currentAudio = null; }
                if (speechRecognition && isRecognizing) try { speechRecognition.abort(); } catch(e) {}
                isRecognizing = false;
                if (callModal) callModal.classList.remove('active');
                if (botImageContainer) botImageContainer.classList.remove('speaking');
                if (tapToTalk) tapToTalk.style.display = 'none';
                if (callStatusMessage) callStatusMessage.textContent = 'Call Ended.';
                if (userSpeechWave) userSpeechWave.classList.remove('active');
            }

            function stopBotSpeakingAndStartListening() {
                if (!isCallActive) return;
                if (currentAudio) { currentAudio.pause(); currentAudio = null; }
                botIsSpeaking = false;
                if(botImageContainer) botImageContainer.classList.remove('speaking');
                const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                if(userMsgEl) userMsgEl.remove();
                if (!isMuted) {
                    if (callStatusMessage) callStatusMessage.textContent = 'Listening...';
                    if (tapToTalk) tapToTalk.style.display = 'none';
                    if (!isRecognizing) try { speechRecognition.start(); } catch(e) {}
                }
            }

            if (callModal) callModal.addEventListener('click', stopBotSpeakingAndStartListening);

            if (callBtn) {
                callBtn.addEventListener('click', () => {
                    if (!SpeechRecognition) {
                        alert("Your browser doesn't support the Web Speech API. Please try Chrome or Edge.");
                        return;
                    }
                    isCallActive = true;
                    isMuted = false;
                    if (muteCallBtn) {
                        muteCallBtn.classList.remove('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute';
                    }
                    callModal.classList.add('active');
                    callConversation.innerHTML = `<div class="call-msg status">Connecting...</div><div id="userSpeechWave"></div>`;
                    callStatusMessage.textContent = 'Calling...';
                    tapToTalk.style.display = 'none';
                    callHistory = [];

                    setTimeout(() => {
                        if (!isCallActive) return;
                        addCallMessage('status', 'Connected. Tap anywhere to speak.');
                        callStatusMessage.textContent = 'Tap anywhere to speak';
                        tapToTalk.style.display = 'block';
                        if (!isMuted && !isRecognizing) try { speechRecognition.start(); } catch(e) {}
                    }, 1500);
                });
            }

            if (endCallBtn) endCallBtn.addEventListener('click', endCall);

            if (muteCallBtn) {
                muteCallBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    isMuted = !isMuted;
                    if (isMuted) {
                        muteCallBtn.classList.add('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute';
                        if (speechRecognition && isRecognizing) try { speechRecognition.stop(); } catch(e) {}
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                        if (userSpeechWave) userSpeechWave.classList.remove('active');
                    } else {
                        muteCallBtn.classList.remove('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute';
                        if (isCallActive && !botIsSpeaking) {
                            callStatusMessage.textContent = 'Tap anywhere to speak';
                            if (tapToTalk) tapToTalk.style.display = 'block';
                            if (!isRecognizing) try { speechRecognition.start(); } catch(e) {}
                        }
                    }
                });
            }

            if(userInput) userInput.focus();
        });
    </script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
 window.dataLayer = window.dataLayer || [];
 function gtag(){dataLayer.push(arguments);}
 gtag('js', new Date()); 

 gtag('config', 'G-J1YTKP10ZX');
</script>
