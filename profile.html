<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Philadelphia AI - Cosmic Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-purple: #bd00ff;
            --cosmic-cyan: #0ff;
            --cosmic-magenta: #f0f;
            --cosmic-dark: #02001a;
            --cosmic-medium: #150030;
            --cosmic-light: #2a0050;
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            --glass-bg-strong: rgba(20, 20, 35, 0.7);
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            --text-glow: 0 0 10px rgba(0, 242, 255, 0.7), 0 0 20px rgba(189, 0, 255, 0.5);
            --box-glow: 0 0 20px rgba(0, 242, 255, 0.2);
            --code-bg: linear-gradient(92deg, #0f0022 79%, #3a0066 120%);
            --code-border: #8000ff;
            --code-text: #e0b0ff;
            --code-shadow: 0 0 15px rgba(189, 0, 255, 0.4);
            --call-accent: #00ff88;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: 'Roboto', 'Inter', system-ui,-apple-system,Segoe UI,sans-serif;
            background-color: var(--cosmic-dark);
            color: #fff;
            display: flex;
            justify-content: center;
            box-sizing: border-box;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and 11 */
            user-select: none; /* Standard syntax */
        }
        
        /* --- COSMIC BACKGROUND ENGINE --- */
        #cosmos-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
            background: radial-gradient(circle at 50% 50%, #050714, var(--cosmic-dark) 80%);
        }

        .nebula-layer {
            position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background-size: cover;
            animation: drift var(--duration) infinite linear var(--delay);
            mix-blend-mode: screen;
            opacity: var(--opacity);
            filter: blur(var(--blur-amount));
        }

        #nebula-layer-1 {
            background: 
                radial-gradient(circle at 55% 55%, rgba(76, 0, 255, 0.18), transparent 50%),
                radial-gradient(circle at 85% 25%, rgba(0, 242, 255, 0.18), transparent 40%);
            --duration: 70s; --delay: 0s; --opacity: 0.9; --blur-amount: 2px;
        }

        #nebula-layer-2 {
            background: radial-gradient(circle at 25% 85%, rgba(189, 0, 255, 0.25), transparent 50%);
            --duration: 55s; --delay: -10s; --opacity: 0.7; --blur-amount: 3px;
            animation-direction: reverse;
            mix-blend-mode: overlay;
        }

        #nebula-layer-3 { /* Deeper, slower nebula */
            background: radial-gradient(circle at 15% 15%, rgba(0, 255, 255, 0.1), transparent 60%);
            --duration: 90s; --delay: -20s; --opacity: 0.5; --blur-amount: 1px;
            animation-direction: alternate;
            mix-blend-mode: lighten;
        }

        @keyframes drift {
            0% { transform: translate(0%, 0%); }
            100% { transform: translate(-25%, -25%); }
        }

        .star, .shooting-star, .stardust, .celestial-body {
            position: absolute;
            pointer-events: none;
            will-change: transform, opacity;
        }

        .star {
            background: #fff; border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out var(--delay);
            box-shadow: 0 0 var(--glow-size) rgba(255, 255, 255, var(--glow-opacity));
        }
        
        .stardust {
            background: var(--neon-blue); border-radius: 50%;
            width: 1px; height: 1px;
            opacity: 0.5;
            animation: floatUp var(--duration) infinite linear;
            box-shadow: 0 0 2px var(--neon-blue);
        }

        .celestial-body {
            background: radial-gradient(circle at center, rgba(var(--color), 0.3), transparent 70%);
            border-radius: 50%;
            animation: rotateAndDrift var(--duration) infinite linear var(--delay);
            opacity: var(--opacity);
            filter: blur(5px);
            z-index: -2;
        }
        @keyframes rotateAndDrift {
            0% { transform: translate(var(--startX), var(--startY)) rotate(0deg); }
            100% { transform: translate(var(--endX), var(--endY)) rotate(360deg); }
        }

        @keyframes twinkle { 0%, 100% { opacity: 0.2; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1.1); } }
        @keyframes floatUp { 
            0% { transform: translateY(0); opacity: 0.8; }
            100% { transform: translateY(-100vh); opacity: 0; }
        }

        .shooting-star {
            height: 2px;
            background: linear-gradient(-90deg, #fff, transparent);
            filter: drop-shadow(0 0 8px var(--neon-blue));
            animation: shoot var(--duration) ease-out forwards; opacity: 0; z-index: 0;
            transform-origin: 100% 50%;
        }
        @keyframes shoot { 
            0% { transform: translate(var(--startX), var(--startY)) rotate(var(--angle)); opacity: 1; width: 0; }
            20% { width: var(--max-width); }
            100% { transform: translate(var(--endX), var(--endY)) rotate(var(--angle)); opacity: 0; width: 0; }
        }

        /* --- UI MAIN STRUCTURE --- */
        .ui-container {
            width: 100%; max-width: 700px; /* Increased max-width */
            height: 100%; display: flex; flex-direction: column;
            position: relative; z-index: 10;
            background: rgba(5, 7, 20, 0.4); /* Subtle darkening for readability */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5); /* Outer shadow for depth */
        }

        /* Header */
        header {
            padding: 20px 25px;
            display: flex; justify-content: space-between; align-items: center;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            box-shadow: 0 5px 30px rgba(0,0,0,0.3); /* Stronger header shadow */
            border-radius: 0 0 20px 20px;
        }

        .brand-plasma {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.6rem; font-weight: 800; letter-spacing: 1px;
            background: linear-gradient(90deg, #fff, var(--neon-blue), var(--neon-purple), #fff);
            background-size: 300% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: plasmaFlow 5s linear infinite;
            text-shadow: var(--text-glow);
            cursor: default;
        }
        @keyframes plasmaFlow { to { background-position: 300% center; } }

        .header-actions { display: flex; gap: 20px; font-size: 1.4rem; }
        .icon-btn { 
            cursor: pointer; opacity: 0.7; transition: 0.3s; position: relative; 
            color: var(--neon-blue); /* Neon color for icons */
        }
        .icon-btn:hover { opacity: 1; text-shadow: var(--text-glow); transform: scale(1.1); color: var(--neon-purple); }

        /* Chat Area */
        #chat-viewport {
            flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px;
            scroll-behavior: smooth;
            scrollbar-width: none; -ms-overflow-style: none; /* Hide Scrollbar visually but keep functionality */
        }
        #chat-viewport::-webkit-scrollbar { display: none; }

        .message-group { 
            display: flex; flex-direction: column; gap: 8px; max-width: 85%; position: relative; 
            animation: fadeInMessage 0.5s ease-out; /* Fade in animation for message groups */
        }
        .message-group.ai { align-self: flex-start; }
        .message-group.user { align-self: flex-end; align-items: flex-end; }

        @keyframes fadeInMessage {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .msg-bubble {
            padding: 16px 22px; border-radius: 24px;
            font-size: 1rem; line-height: 1.5;
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative; /* For glitch effect */
        }
        @keyframes popIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }

        .ai .msg-bubble {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8));
            border-bottom-left-radius: 4px;
            box-shadow: inset 0 0 20px rgba(0, 242, 255, 0.05);
        }

        .user .msg-bubble {
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.3), rgba(189, 0, 255, 0.3));
            border-bottom-right-radius: 4px;
            color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            box-shadow: var(--box-glow);
            border: 1px solid rgba(255,255,255,0.3);
        }

        .msg-bubble a {
            color: var(--neon-blue);
            text-decoration: none;
            transition: color 0.3s;
        }
        .msg-bubble a:hover {
            color: var(--neon-purple);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        /* --- Code block styling --- */
        .msg-bubble pre {
            background: var(--code-bg);
            border-radius: 11px;
            border: 1.7px solid var(--code-border);
            color: var(--code-text);
            box-shadow: var(--code-shadow);
            overflow-x: auto;
            padding: 1.18em 1.3em 1.16em 1.13em;
            margin: 1.15em 0 1em 0;
            position: relative;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95em;
            line-height: 1.4;
        }
        .msg-bubble pre::before {
            content: "CODE";
            color: var(--cosmic-cyan);
            font-size: 0.82em;
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 5px;
            right: 29px;
            opacity: 0.17;
            letter-spacing: 0.13em;
            pointer-events: none;
        }
        .msg-bubble code {
            display: block; /* Ensures code takes full width inside pre */
            background: transparent;
            border: none;
            color: var(--code-text);
            padding: 0;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .msg-bubble .copy-btn {
            position: absolute;
            top: 10px;
            right: 13px;
            z-index: 3;
            border-radius: 8px;
            border: none;
            padding: 3px 15px;
            background: linear-gradient(95deg, var(--cosmic-cyan) 40%, var(--neon-blue) 120%);
            color: var(--cosmic-dark);
            font-size: .98em;
            font-family: 'Inter';
            font-weight: bold;
            box-shadow: 0 2px 9px rgba(0,255,255,0.5), 0 0 7px rgba(0,255,255,0.3);
            transition: background .15s, color .15s;
            cursor: pointer;
            outline: none;
            border: 1px solid rgba(0,255,255,0.2);
        }
        .msg-bubble .copy-btn:hover {
            background: var(--neon-blue);
            color: #fff;
        }

        /* Glitch effect for new messages */
        .glitch-text {
            animation: glitch 0.8s infinite alternate;
        }
        @keyframes glitch {
            0% { text-shadow: 0 0 var(--cosmic-cyan), 0 0 var(--cosmic-magenta); transform: translate(0); }
            20% { text-shadow: 2px 0 var(--cosmic-cyan), -2px 0 var(--cosmic-magenta); transform: translate(-2px, 0); }
            40% { text-shadow: -2px 0 var(--cosmic-cyan), 2px 0 var(--cosmic-magenta); transform: translate(2px, 0); }
            60% { text-shadow: 1px 0 var(--cosmic-cyan), -1px 0 var(--cosmic-magenta); transform: translate(-1px, 0); }
            80% { text-shadow: -1px 0 var(--cosmic-cyan), 1px 0 var(--cosmic-magenta); transform: translate(1px, 0); }
            100% { text-shadow: 0 0 var(--cosmic-cyan), 0 0 var(--cosmic-magenta); transform: translate(0); }
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex; align-items: center; gap: 8px;
            background: rgba(30, 30, 60, 0.6);
            padding: 10px 18px; border-radius: 20px;
            align-self: flex-start;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 242, 255, 0.15);
            box-shadow: inset 0 0 10px rgba(0, 242, 255, 0.1);
        }
        .typing-indicator span {
            width: 8px; height: 8px; background: var(--neon-blue);
            border-radius: 50%; animation: pulse-dot 1s infinite ease-in-out;
            box-shadow: 0 0 5px var(--neon-blue);
        }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes pulse-dot {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        .typing-indicator.system {
            background: rgba(var(--color), 0.2);
            border-color: rgba(var(--color), 0.3);
            color: rgba(var(--color), 1);
        }

        /* Holographic Suggestions */
        .suggestions-dock {
            display: flex; flex-wrap: wrap; justify-content: flex-end; gap: 10px; margin-top: 10px;
            align-self: flex-end; /* Align to bottom right */
        }

        .chip {
            padding: 12px 20px; border-radius: 16px; font-size: 0.9rem; cursor: pointer;
            background: rgba(255, 255, 255, 0.07);
            border: 1px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(10px);
            transition: 0.3s; text-align: right; color: rgba(255,255,255,0.9);
            position: relative; overflow: hidden;
            display: flex; align-items: center; gap: 8px;
        }
        .chip:hover {
            background: rgba(0, 242, 255, 0.15);
            border-color: var(--neon-blue);
            box-shadow: var(--box-glow);
            transform: translateY(-3px) scale(1.02); color: #fff;
        }
        .chip i { color: var(--neon-blue); transition: color 0.3s; }
        .chip:hover i { color: var(--neon-purple); }

        /* The Shimmer Effect Class */
        .holo-shimmer::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(
                120deg, transparent, rgba(255, 255, 255, 0.4), transparent
            );
            transform: skewX(-25deg);
            animation: holoSheen 3s infinite linear;
        }
        @keyframes holoSheen { 0% { left: -100%; } 50%, 100% { left: 200%; } }

        /* Input Capsule */
        .input-dock {
            padding: 20px 25px;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(25px);
            border-top: 1px solid var(--glass-border);
            display: flex; gap: 15px; align-items: center;
            border-radius: 20px 20px 0 0;
        }

        .capsule-input {
            flex: 1; position: relative; min-height: 55px;
            background: var(--glass-bg-light);
            border-radius: 30px; border: 1px solid var(--glass-border);
            transition: 0.3s; display: flex; align-items: center;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
            padding-right: 15px; /* Space for file attachments */
        }
        .capsule-input:focus-within {
            border-color: var(--neon-blue);
            box-shadow: var(--box-glow), inset 0 2px 10px rgba(0,0,0,0.2);
            background: rgba(0, 242, 255, 0.05);
        }
        .capsule-input textarea {
            width: 100%; height: auto; min-height: 30px; max-height: 120px;
            background: transparent; border: none;
            padding: 12px 25px; color: #fff; font-size: 1.05rem; outline: none;
            resize: none; scrollbar-width: none;
            line-height: 1.5;
        }
        .capsule-input textarea::-webkit-scrollbar { display: none; }

        .input-actions {
            display: flex; gap: 8px; margin-left: 10px;
        }

        .thruster-btn, .input-action-btn {
            width: 55px; height: 55px; border-radius: 50%; border: none; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            box-shadow: var(--box-glow); transition: 0.3s;
            color: #000;
            font-size: 1.2em;
        }
        .thruster-btn {
            background: var(--plasma-gradient);
            color: #000;
        }
        .thruster-btn:hover { transform: scale(1.05) rotate(-10deg); box-shadow: 0 0 30px rgba(189, 0, 255, 0.6); }
        
        .input-action-btn {
            background: rgba(255, 255, 255, 0.07);
            color: var(--neon-blue);
            border: 1px solid var(--glass-border);
        }
        .input-action-btn:hover {
            background: rgba(0, 242, 255, 0.1);
            border-color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
            color: #fff;
            transform: scale(1.05);
        }

        /* File Preview */
        #file-preview {
            position: absolute; bottom: 65px; left: 15px; right: 15px;
            background: rgba(20, 20, 35, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid var(--neon-blue);
            border-radius: 15px;
            padding: 10px 15px;
            display: flex; flex-wrap: wrap; gap: 10px;
            box-shadow: var(--box-glow);
            z-index: 100;
            max-height: 150px;
            overflow-y: auto;
            display: none; /* Hidden by default */
        }
        .file-item {
            display: flex; align-items: center; gap: 8px;
            background: rgba(0, 242, 255, 0.08);
            border: 1px solid rgba(0, 242, 255, 0.2);
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 0.85em;
            color: #e0faff;
        }
        .file-item img, .file-item video, .file-item audio {
            max-width: 40px; max-height: 30px; border-radius: 5px;
            object-fit: cover;
        }
        .file-item .remove-btn {
            background: #ff4d4d; color: white; border: none; border-radius: 50%;
            width: 20px; height: 20px; font-size: 0.9em; cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            transition: background 0.2s;
        }
        .file-item .remove-btn:hover { background: #ff7777; }

        /* --- Panel (Profile, Links, Tools) Styling --- */
        .side-panel-bg {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(8px);
            z-index: 2000; display: none;
            opacity: 0; transition: opacity 0.3s ease;
        }
        .side-panel-bg.active {
            display: block; opacity: 1;
        }

        .side-panel {
            position: fixed; top: 0; left: -350px; /* Hidden by default */
            width: 320px; height: 100vh;
            background: linear-gradient(180deg, var(--cosmic-medium), var(--cosmic-dark));
            border-right: 2px solid var(--neon-blue);
            box-shadow: 10px 0 50px rgba(0, 242, 255, 0.3);
            z-index: 2001;
            padding: 20px;
            overflow-y: auto;
            transition: left 0.3s ease;
        }
        .side-panel-bg.active .side-panel {
            left: 0;
        }

        .panel-header {
            text-align: center; margin-bottom: 25px;
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3em;
            text-shadow: var(--text-glow);
        }
        .panel-close-btn {
            position: absolute; top: 10px; right: 10px;
            background: none; border: none; font-size: 2em;
            color: var(--neon-purple); cursor: pointer;
        }
        .panel-close-btn:hover { color: var(--neon-blue); }

        .profile-info img {
            width: 80px; height: 80px; border-radius: 50%;
            border: 3px solid var(--neon-blue); margin-bottom: 10px;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.5);
        }
        .profile-info .username { font-size: 1.2em; font-weight: bold; color: #fff; }
        .profile-info .email { font-size: 0.9em; color: var(--neon-blue); }

        .panel-links a, .panel-tools a {
            display: flex; align-items: center; gap: 12px;
            padding: 12px 15px; margin-bottom: 8px;
            background: rgba(0, 242, 255, 0.05);
            border-radius: 10px;
            color: #e0faff; text-decoration: none;
            transition: background 0.3s, transform 0.2s;
            border: 1px solid rgba(0, 242, 255, 0.2);
            font-size: 1.05em;
        }
        .panel-links a:hover, .panel-tools a:hover {
            background: rgba(0, 242, 255, 0.15);
            transform: translateX(5px);
            color: #fff;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
        }
        .panel-links i, .panel-tools i {
            color: var(--neon-blue); width: 20px; text-align: center;
        }
        .panel-links a:hover i, .panel-tools a:hover i { color: var(--neon-purple); }

        .form-group label {
            display: block; margin-top: 15px; margin-bottom: 5px;
            color: var(--neon-blue); font-size: 0.95em;
            text-shadow: 0 0 5px rgba(0, 242, 255, 0.3);
        }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%; padding: 10px; border-radius: 8px;
            background: var(--glass-bg-light); border: 1px solid var(--neon-blue);
            color: #fff; font-size: 1em;
            box-shadow: inset 0 0 10px rgba(0, 242, 255, 0.1);
        }
        .form-group textarea { resize: vertical; min-height: 80px; }
        .submit-btn {
            width: 100%; padding: 12px 20px; margin-top: 20px;
            background: var(--plasma-gradient); border: none; border-radius: 10px;
            color: #000; font-weight: bold; font-size: 1.1em; cursor: pointer;
            box-shadow: var(--box-glow); transition: 0.3s;
        }
        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(189, 0, 255, 0.6);
        }
        .status-message {
            margin-top: 10px; text-align: center; font-size: 0.9em;
            color: var(--neon-blue); text-shadow: 0 0 5px rgba(0, 242, 255, 0.3);
        }
        .logout-btn {
            background: #330055; color: var(--neon-purple); border: 1px solid var(--neon-purple);
        }
        .logout-btn:hover { background: #550088; color: #fff; }

        /* --- Tool Form Modal --- */
        #tool-form-modal-bg .side-panel {
            left: -350px;
        }
        #tool-form-modal-bg.active .side-panel {
            left: calc(50vw - 160px); /* Center for desktop */
        }
        @media (max-width: 768px) {
            #tool-form-modal-bg.active .side-panel {
                left: calc(50vw - 160px);
            }
        }
        #tool-form-modal-bg .panel-header { margin-bottom: 15px;}
        #tool-form-modal-bg .panel-header h3 { font-size: 1.1em;}
        #tool-form-modal-bg .panel-description {
            color: #ccc; font-size: 0.9em; margin-bottom: 20px;
            text-align: center;
        }
        #tool-form-modal-bg .tool-back-btn {
            background: rgba(255,255,255,0.05); color: var(--neon-blue); border: 1px solid var(--neon-blue);
            margin-top: 15px;
        }
        #tool-form-modal-bg .tool-back-btn:hover { background: rgba(0,242,255,0.1); }


        /* --- Call Modal Styling --- */
        #call-modal {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(135deg, var(--cosmic-dark), var(--cosmic-light));
            z-index: 3000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.5s ease;
        }
        #call-modal.active {
            display: flex; opacity: 1;
        }
        #call-modal-content {
            background: var(--glass-bg-strong);
            backdrop-filter: blur(20px);
            border: 1px solid var(--neon-blue);
            border-radius: 25px;
            padding: 30px;
            width: 90%; max-width: 600px;
            height: 90%; max-height: 800px;
            display: flex; flex-direction: column;
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.4);
        }
        #call-header {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em; text-align: center;
            color: var(--neon-blue); text-shadow: var(--text-glow);
            margin-bottom: 25px;
        }
        #bot-visualizer {
            display: flex; flex-direction: column; align-items: center;
            margin-bottom: 20px;
        }
        #bot-avatar-container {
            position: relative; width: 150px; height: 150px; margin-bottom: 15px;
        }
        #bot-avatar {
            width: 100%; height: 100%; border-radius: 50%;
            border: 5px solid var(--neon-blue);
            object-fit: cover;
            box-shadow: 0 0 25px rgba(0, 242, 255, 0.6);
            transition: border-color 0.3s, box-shadow 0.3s, transform 0.3s;
        }
        #bot-visualizer.speaking #bot-avatar {
            border-color: var(--call-accent);
            box-shadow: 0 0 35px var(--call-accent);
            animation: pulse-avatar 1.5s infinite alternate;
        }
        @keyframes pulse-avatar {
            0% { transform: scale(1); box-shadow: 0 0 20px var(--call-accent); }
            100% { transform: scale(1.05); box-shadow: 0 0 40px var(--call-accent); }
        }
        #bot-status-ring {
            position: absolute; top: -10px; left: -10px; right: -10px; bottom: -10px;
            border: 5px solid transparent; border-radius: 50%;
            animation: spin-ring 2s linear infinite;
            opacity: 0; transition: opacity 0.3s;
            pointer-events: none;
        }
        #bot-visualizer.speaking #bot-status-ring {
            border-top-color: var(--call-accent);
            border-bottom-color: var(--call-accent);
            opacity: 1;
        }
        @keyframes spin-ring {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #call-status-display {
            font-size: 1.1em; color: var(--neon-blue); text-shadow: 0 0 8px rgba(0, 242, 255, 0.5);
            margin-bottom: 15px; text-align: center;
            min-height: 25px;
        }
        #call-conversation {
            flex: 1; overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 15px;
            padding: 15px; background: rgba(0,0,0,0.2);
            margin-bottom: 20px;
            scroll-behavior: smooth;
            scrollbar-width: thin; scrollbar-color: var(--neon-purple) transparent;
        }
        #call-conversation::-webkit-scrollbar { width: 8px; }
        #call-conversation::-webkit-scrollbar-track { background: transparent; }
        #call-conversation::-webkit-scrollbar-thumb { background: var(--neon-purple); border-radius: 10px; }
        .call-msg {
            padding: 10px 15px; border-radius: 15px; margin-bottom: 10px;
            line-height: 1.5; word-break: break-word;
            animation: fadeInMessage 0.4s ease-out;
        }
        .call-msg.user {
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.2), rgba(189, 0, 255, 0.2));
            align-self: flex-end; margin-left: auto; max-width: 85%;
            border-bottom-right-radius: 4px;
        }
        .call-msg.bot {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.5), rgba(20, 20, 35, 0.7));
            align-self: flex-start; margin-right: auto; max-width: 85%;
            border-bottom-left-radius: 4px;
        }
        .call-msg.status {
            text-align: center; color: #888; font-style: italic; background: none;
            font-size: 0.9em;
        }
        #call-controls {
            display: flex; justify-content: center; gap: 20px;
        }
        .call-action-btn {
            padding: 12px 25px; border-radius: 25px; border: none;
            font-size: 1.1em; cursor: pointer; font-weight: bold;
            transition: 0.3s;
            display: flex; align-items: center; gap: 8px;
            color: #000;
            box-shadow: var(--box-glow);
        }
        #mute-call-btn {
            background: var(--plasma-gradient);
        }
        #mute-call-btn.muted {
            background: rgba(255,255,255,0.1); color: var(--neon-blue); border: 1px solid var(--neon-blue);
            box-shadow: none;
        }
        #mute-call-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 0 30px rgba(189, 0, 255, 0.6);
        }
        #mute-call-btn.muted:hover {
             box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
             background: rgba(0, 242, 255, 0.1);
        }

        #end-call-btn {
            background: linear-gradient(135deg, #ff4d4d, #b30000);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        #end-call-btn:hover {
            background: linear-gradient(135deg, #ff7777, #ff0000);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 0 35px rgba(255, 0, 0, 0.7);
        }

        /* --- Wow Feature 1: Galactic Navigator --- */
        #galactic-navigator {
            position: fixed; bottom: 120px; right: 20px;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
            box-shadow: 0 0 25px var(--neon-blue), 0 0 40px var(--neon-purple);
            display: flex; align-items: center; justify-content: center;
            font-size: 2em; color: white;
            z-index: 1000;
            cursor: pointer;
            animation: pulse-glow 2s infinite alternate;
            transition: transform 0.3s ease;
            display: none; /* Hidden by default */
        }
        #galactic-navigator.active { display: flex; }
        #galactic-navigator.thinking { animation: spin-galaxy 1.5s infinite linear; }
        #galactic-navigator:hover { transform: scale(1.1); animation-play-state: paused; }
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 20px var(--neon-blue), 0 0 30px var(--neon-purple); }
            100% { box-shadow: 0 0 30px var(--neon-purple), 0 0 50px var(--neon-blue); }
        }
        @keyframes spin-galaxy {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* --- Wow Feature 3: Quantum Leap Transition --- */
        #quantum-leap-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: radial-gradient(circle at center, rgba(0, 242, 255, 0.5), transparent 70%);
            z-index: 5000;
            display: none; opacity: 0;
            animation: quantum-leap-anim 0.8s forwards;
            pointer-events: none;
        }
        @keyframes quantum-leap-anim {
            0% { opacity: 0; transform: scale(0.1); filter: blur(5px); }
            50% { opacity: 1; transform: scale(1.2); filter: blur(20px); }
            100% { opacity: 0; transform: scale(2); filter: blur(5px); }
        }

        /* --- Tool Generated Content Preview (Wow Feature 5) --- */
        .tool-content-preview {
            max-width: 100%;
            max-height: 250px;
            border-radius: 12px;
            display: block;
            margin-top: 10px;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.5);
            object-fit: contain;
            cursor: zoom-in;
        }
        .tool-content-preview.video, .tool-content-preview.audio {
            width: 100%;
            max-height: 100px;
        }
        .tool-content-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }
        .tool-content-gallery img {
            max-width: 120px;
            height: auto;
            border-radius: 8px;
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 8px rgba(0, 242, 255, 0.3);
            cursor: zoom-in;
        }

        /* Lightbox for full screen media */
        #lightbox {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
            z-index: 6000; display: none; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.3s ease;
        }
        #lightbox.active { opacity: 1; display: flex;}
        #lightbox img, #lightbox video {
            max-width: 90vw; max-height: 90vh;
            border: 3px solid var(--neon-blue); border-radius: 15px;
            box-shadow: 0 0 60px rgba(0, 242, 255, 0.8);
            object-fit: contain;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .ui-container {
                max-width: 100%;
                border-radius: 0;
            }
            header {
                padding: 15px; border-radius: 0;
            }
            .brand-plasma { font-size: 1.3rem; }
            .header-actions { gap: 15px; font-size: 1.2rem; }
            #chat-viewport { padding: 15px; }
            .msg-bubble { padding: 12px 18px; font-size: 0.95rem; }
            .input-dock { padding: 15px; border-radius: 0; }
            .capsule-input { min-height: 50px; }
            .capsule-input textarea { padding: 10px 20px; font-size: 0.95rem; }
            .thruster-btn, .input-action-btn { width: 50px; height: 50px; }
            #galactic-navigator { bottom: 80px; right: 15px; width: 60px; height: 60px; font-size: 1.5em; }
            .side-panel { width: 100%; left: -100%; }
            .side-panel-bg.active .side-panel { left: 0; }
            #tool-form-modal-bg.active .side-panel { left: 0; } /* Full width for mobile */
        }
    </style>
</head>
<body>
    <div id="cosmos-container">
        <div id="nebula-layer-1" class="nebula-layer"></div>
        <div id="nebula-layer-2" class="nebula-layer"></div>
        <div id="nebula-layer-3" class="nebula-layer"></div>
    </div>

    <div class="ui-container">
        <header>
            <div class="brand-plasma">Philadelphia AI</div>
            <div class="header-actions">
                <div class="icon-btn" id="profile-menu-btn" title="User Profile"><i class="fas fa-user-astronaut"></i></div>
                <div class="icon-btn" id="tools-menu-btn" title="AI Tools"><i class="fas fa-tools"></i></div>
                <div class="icon-btn" id="theme-toggle-btn" title="Toggle Theme"><i class="fas fa-lightbulb"></i></div>
                <div class="icon-btn" id="menu-links-btn" title="Menu Links"><i class="fas fa-link"></i></div>
            </div>
        </header>

        <div id="chat-viewport">
            <div class="message-group ai">
                <div class="msg-bubble">
                    Greetings, traveler. <i class="fas fa-galaxy"></i> The cosmos is aligned. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨
                </div>
            </div>

            <div class="suggestions-dock" id="suggestions">
                <div class="chip holo-shimmer" onclick="sendSuggestion(this)"><i class="fas fa-palette"></i> Create a cosmic art piece.</div>
                <div class="chip holo-shimmer" onclick="sendSuggestion(this)"><i class="fas fa-globe"></i> Generate a dynamic website for my startup.</div>
                <div class="chip holo-shimmer" onclick="sendSuggestion(this)"><i class="fas fa-music"></i> Compose a cyberpunk soundtrack.</div>
            </div>
        </div>

        <div class="input-dock">
            <div class="capsule-input">
                <textarea id="user-input" placeholder="Broadcast your message..." autocomplete="off"></textarea>
                <div class="input-actions">
                    <label for="file-input" class="input-action-btn" title="Attach file"><i class="fas fa-paperclip"></i></label>
                    <input type="file" id="file-input" accept="image/*,audio/*,video/*,application/pdf,text/plain" multiple style="display:none">
                    <button class="input-action-btn" id="call-btn" title="Start Voice Call"><i class="fas fa-phone-volume"></i></button>
                </div>
            </div>
            <button class="thruster-btn holo-shimmer" id="send-btn">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
        </div>
        <div id="file-preview" style="display:none;"></div>
    </div>

    <!-- Wow Feature 1: Galactic Navigator -->
    <div id="galactic-navigator" class="active"><i class="fas fa-galaxy"></i></div>

    <!-- Wow Feature 3: Quantum Leap Transition Overlay -->
    <div id="quantum-leap-overlay"></div>

    <!-- Panel for Profile -->
    <div id="profile-panel-bg" class="side-panel-bg">
        <div id="profile-panel" class="side-panel">
            <button class="panel-close-btn">&times;</button>
            <div class="panel-header">Profile Module</div>
            <div class="profile-info" style="text-align: center;">
                <img id="profile-pic-preview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profile-display-name">User Voyager</div>
                <div class="email" id="profile-display-email">user@galaxy.com</div>
            </div>
            <form id="profile-form">
                <div class="form-group"><label for="edit-name">Display Name</label><input type="text" id="edit-name" required></div>
                <div class="form-group"><label for="edit-photo">Avatar URL</label><input type="url" id="edit-photo" placeholder="Paste image link"></div>
                <button type="submit" class="submit-btn">Update Profile</button>
                <div id="profile-status-msg" class="status-message"></div>
            </form>
            <button id="logout-btn" class="submit-btn logout-btn">Logout</button>
        </div>
    </div>

    <!-- Panel for Tools -->
    <div id="tools-panel-bg" class="side-panel-bg">
        <div id="tools-panel" class="side-panel">
            <button class="panel-close-btn">&times;</button>
            <div class="panel-header">AI Tool Suite</div>
            <div class="panel-tools">
                <h3 style="color:var(--neon-blue);margin:10px 0 5px 0;font-size:0.9em;text-transform:uppercase;">Creative Forge</h3>
                <a href="#" class="tool-link" data-tool="image"><i class="fas fa-image"></i> Generate Image</a>
                <a href="#" class="tool-link" data-tool="edit-photo"><i class="fas fa-magic"></i> Enhance Photo</a>
                <a href="#" class="tool-link" data-tool="remove-bg"><i class="fas fa-cut"></i> Decouple Background</a>
                <a href="#" class="tool-link" data-tool="comic"><i class="fas fa-book-reader"></i> Warp Comic Strip</a>
                <hr style="border-color: rgba(0,255,255,0.15); margin: 15px 0;">
                <h3 style="color:var(--neon-blue);margin:10px 0 5px 0;font-size:0.9em;text-transform:uppercase;">Audio-Visual Synthesizer</h3>
                <a href="#" class="tool-link" data-tool="voice-gen"><i class="fas fa-microphone-alt"></i> Synthesize Voice</a>
                <a href="#" class="tool-link" data-tool="audio-narration"><i class="fas fa-headphones"></i> Galactic Narration</a>
                <a href="#" class="tool-link" data-tool="video-text"><i class="fas fa-film"></i> Text-to-Video Warp</a>
                <a href="#" class="tool-link" data-tool="video-image"><i class="fas fa-photo-video"></i> Image-to-Video Flux</a>
                <a href="#" class="tool-link" data-tool="music"><i class="fas fa-music"></i> Stellar Composition</a>
                <hr style="border-color: rgba(0,255,255,0.15); margin: 15px 0;">
                <h3 style="color:var(--neon-blue);margin:10px 0 5px 0;font-size:0.9em;text-transform:uppercase;">Data Nexus & Deployment</h3>
                <a href="#" class="tool-link" data-tool="website"><i class="fas fa-globe-americas"></i> Deploy Website</a>
                <a href="#" class="tool-link" data-tool="edit-website"><i class="fas fa-pencil-ruler"></i> Refine Last Website</a>
                <a href="#" class="tool-link" data-tool="my-sites"><i class="fas fa-sitemap"></i> My Cyber-Domains</a>
                <a href="#" class="tool-link" data-tool="research-report"><i class="fas fa-flask"></i> Cosmic Research Report</a>
            </div>
        </div>
    </div>

    <!-- Panel for Menu Links -->
    <div id="links-panel-bg" class="side-panel-bg">
        <div id="links-panel" class="side-panel">
            <button class="panel-close-btn">&times;</button>
            <div class="panel-header">Stellar Links</div>
            <div class="panel-links">
                <a href="philadelphia.html"><i class="fas fa-home"></i> Philadelphia Hub</a>
                <a href="index.html"><i class="fas fa-rocket"></i> Elvion Command Center</a>
                <a href="about.html"><i class="fas fa-info-circle"></i> About Our Mission</a>
                <a href="privacy.html"><i class="fas fa-shield-alt"></i> Privacy Protocols</a>
                <a href="terms.html"><i class="fas fa-file-contract"></i> Terms of Service</a>
                <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Telegram Gateway</a>
            </div>
        </div>
    </div>

    <!-- Tool Form Modal -->
    <div id="tool-form-modal-bg" class="side-panel-bg">
        <div id="tool-form-modal" class="side-panel">
            <button class="panel-close-btn">&times;</button>
            <div class="panel-header" id="tool-form-title">Tool Configuration</div>
            <div class="panel-description" id="tool-form-description"></div>
            <form id="tool-form"></form>
            <button id="tool-form-back-btn" class="submit-btn tool-back-btn"><i class="fas fa-arrow-left"></i> Back to Tools</button>
            <div id="tool-status-msg" class="status-message"></div>
        </div>
    </div>

    <!-- Lightbox for media preview -->
    <div id="lightbox"></div>

    <!-- Call Modal -->
    <div id="call-modal">
        <div id="call-modal-content">
            <div id="call-header">Live Comms Link - Philadelphia AI</div>
            <div id="bot-visualizer">
                <div id="bot-avatar-container">
                    <img id="bot-avatar" src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Philadelphia AI">
                    <div id="bot-status-ring"></div>
                </div>
                <div id="call-status-display">Establishing connection...</div>
            </div>
            <div id="call-conversation">
                <div class="call-msg status">Initializing Comms...</div>
            </div>
            <div id="call-controls">
                <button id="mute-call-btn" class="call-action-btn"><i class="fas fa-microphone"></i> Mute</button>
                <button id="end-call-btn" class="call-action-btn"><i class="fas fa-phone-slash"></i> Terminate</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile, signOut } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        // Firebase Configuration (replace with your actual config)
        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const API_BASE_URL = 'https://web-production-9a18.up.railway.app'; // Your provided API Base URL

        // --- Core Application State ---
        let currentUser = null;
        let currentChatId = null;
        let chats = [];
        let currentMessages = [];
        let uploadedFiles = [];
        let currentController = null; // For aborting ongoing AI responses
        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;
        let currentTheme = 'cosmic'; // Default theme

        // --- DOM Elements Cache ---
        const els = {
            cosmosContainer: document.getElementById('cosmos-container'),
            chatViewport: document.getElementById('chat-viewport'),
            userInput: document.getElementById('user-input'),
            sendBtn: document.getElementById('send-btn'),
            fileInput: document.getElementById('file-input'),
            filePreview: document.getElementById('file-preview'),
            suggestions: document.getElementById('suggestions'),
            brandPlasma: document.querySelector('.brand-plasma'),
            profileMenuBtn: document.getElementById('profile-menu-btn'),
            toolsMenuBtn: document.getElementById('tools-menu-btn'),
            themeToggleBtn: document.getElementById('theme-toggle-btn'),
            menuLinksBtn: document.getElementById('menu-links-btn'),
            profilePanelBg: document.getElementById('profile-panel-bg'),
            profilePanel: document.getElementById('profile-panel'),
            toolsPanelBg: document.getElementById('tools-panel-bg'),
            toolsPanel: document.getElementById('tools-panel'),
            linksPanelBg: document.getElementById('links-panel-bg'),
            linksPanel: document.getElementById('links-panel'),
            profileForm: document.getElementById('profile-form'),
            editName: document.getElementById('edit-name'),
            editPhoto: document.getElementById('edit-photo'),
            profilePicPreview: document.getElementById('profile-pic-preview'),
            profileDisplayName: document.getElementById('profile-display-name'),
            profileDisplayEmail: document.getElementById('profile-display-email'),
            profileStatusMsg: document.getElementById('profile-status-msg'),
            logoutBtn: document.getElementById('logout-btn'),
            toolFormModalBg: document.getElementById('tool-form-modal-bg'),
            toolFormModal: document.getElementById('tool-form-modal'),
            toolFormTitle: document.getElementById('tool-form-title'),
            toolFormDescription: document.getElementById('tool-form-description'),
            toolForm: document.getElementById('tool-form'),
            toolFormBackBtn: document.getElementById('tool-form-back-btn'),
            toolStatusMsg: document.getElementById('tool-status-msg'),
            lightbox: document.getElementById('lightbox'),
            callBtn: document.getElementById('call-btn'),
            callModal: document.getElementById('call-modal'),
            callModalContent: document.getElementById('call-modal-content'),
            botVisualizer: document.getElementById('bot-visualizer'),
            botAvatar: document.getElementById('bot-avatar'),
            callStatusDisplay: document.getElementById('call-status-display'),
            callConversation: document.getElementById('call-conversation'),
            muteCallBtn: document.getElementById('mute-call-btn'),
            endCallBtn: document.getElementById('end-call-btn'),
            galacticNavigator: document.getElementById('galactic-navigator'),
            quantumLeapOverlay: document.getElementById('quantum-leap-overlay')
        };

        // --- Utility Functions ---
        const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

        // Wow Feature 2: Dynamic UI Glitch/Holographic Effects for new messages
        const applyGlitchEffect = (element) => {
            element.classList.add('glitch-text');
            setTimeout(() => {
                element.classList.remove('glitch-text');
            }, 1000); // Glitch for 1 second
        };

        // --- Markdown & Code Rendering ---
        function parseMarkdown(text = '') {
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            let parts = [];
            let lastIndex = 0;

            text.replace(codeBlockRegex, (match, lang, code, offset) => {
                const before = text.slice(lastIndex, offset);
                if (before) parts.push({ type: 'text', content: before });
                parts.push({ type: 'code', lang: (lang || 'plaintext').toLowerCase().trim(), content: code });
                lastIndex = offset + match.length;
                return match;
            });

            const after = text.slice(lastIndex);
            if (after) parts.push({ type: 'text', content: after });

            return parts;
        }

        async function typeAndRenderMarkdown(targetElement, markdownParts, saveToDb = true) {
            let fullHtmlContent = '';
            let currentMessageText = ''; // For saving to DB

            for (const part of markdownParts) {
                if (currentController && currentController.signal.aborted) {
                    // Abort typing, keep current content, save it.
                    targetElement.innerHTML = fullHtmlContent;
                    return currentMessageText;
                }

                if (part.type === 'text') {
                    const inlineHtml = inlineMarkdown(part.content);
                    fullHtmlContent += inlineHtml;
                    currentMessageText += part.content;
                    targetElement.innerHTML = fullHtmlContent;
                    await typeTextSimulated(targetElement, inlineHtml, 20); // Type text faster
                } else if (part.type === 'code') {
                    // Append a temporary pre/code block
                    const tempPre = document.createElement('pre');
                    const tempCode = document.createElement('code');
                    tempCode.className = `language-${part.lang}`;
                    tempPre.appendChild(tempCode);
                    targetElement.appendChild(tempPre);

                    // Type code character by character
                    let currentCodeHtml = '';
                    const codeChars = escapeHTML(part.content).split('');
                    for (const char of codeChars) {
                        if (currentController && currentController.signal.aborted) {
                            // If aborted during code typing
                            tempCode.innerHTML = currentCodeHtml; // Ensure partial code is visible
                            fullHtmlContent += tempPre.outerHTML;
                            currentMessageText += '```' + part.lang + '\n' + part.content + '```';
                            return currentMessageText;
                        }
                        currentCodeHtml += char;
                        tempCode.innerHTML = currentCodeHtml;
                        els.chatViewport.scrollTop = els.chatViewport.scrollHeight;
                        await new Promise(res => setTimeout(res, 5)); // Faster code typing
                    }
                    
                    // Add copy button after typing
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'copy-btn';
                    copyBtn.textContent = 'Copy';
                    copyBtn.onclick = async () => {
                        await navigator.clipboard.writeText(part.content);
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => copyBtn.textContent = 'Copy', 1000);
                    };
                    tempPre.appendChild(copyBtn);

                    // Update fullHtmlContent with the now complete code block
                    fullHtmlContent += tempPre.outerHTML;
                    currentMessageText += '```' + part.lang + '\n' + part.content + '```';
                }
                els.chatViewport.scrollTop = els.chatViewport.scrollHeight;
            }

            // Append AI message controls after all content is typed
            fullHtmlContent += `
                <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                    <button class="icon-btn" title="Copy"><i class="fas fa-copy"></i></button>
                    <button class="icon-btn" title="Share"><i class="fas fa-share-alt"></i></button>
                    <button class="icon-btn" title="Regenerate"><i class="fas fa-redo-alt"></i></button>
                </div>
            `;
            targetElement.innerHTML = fullHtmlContent; // Final render
            
            return currentMessageText; // Return for DB saving
        }

        async function typeTextSimulated(targetElement, htmlContent, delay = 50) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            const textNodes = Array.from(tempDiv.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);

            let currentText = targetElement.innerHTML; // Preserve existing HTML
            for (const textNode of textNodes) {
                const originalText = textNode.nodeValue;
                textNode.nodeValue = ''; // Clear text content for typing animation

                for (let i = 0; i < originalText.length; i++) {
                    if (currentController && currentController.signal.aborted) return;
                    textNode.nodeValue += originalText[i];
                    targetElement.innerHTML = currentText + tempDiv.innerHTML;
                    els.chatViewport.scrollTop = els.chatViewport.scrollHeight;
                    await new Promise(res => setTimeout(res, delay));
                }
            }
            targetElement.innerHTML = currentText + htmlContent; // Final render after typing
        }

        function inlineMarkdown(text = '') {
            let s = String(text).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
            s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
            s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            return s.replace(/\n/g, '<br>');
        }

        // --- Message Display ---
        async function addMessageToChatUI(text, type, messageId, files = [], isNew = true) {
            const group = document.createElement('div');
            group.className = `message-group ${type}`;
            if (messageId) group.dataset.messageId = messageId;

            const bubble = document.createElement('div');
            bubble.className = 'msg-bubble';

            if (files.length > 0) {
                const fileAttachmentsDiv = document.createElement('div');
                fileAttachmentsDiv.className = 'file-attachments';
                files.forEach(file => {
                    let icon = 'fas fa-file';
                    if (file.type.startsWith('image/')) icon = 'fas fa-file-image';
                    else if (file.type.startsWith('video/')) icon = 'fas fa-file-video';
                    else if (file.type.startsWith('audio/')) icon = 'fas fa-file-audio';
                    else if (file.type === 'application/pdf') icon = 'fas fa-file-pdf';

                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-placeholder';
                    fileItem.innerHTML = `<i class="${icon}"></i> ${escapeHTML(file.name)}`;
                    fileAttachmentsDiv.appendChild(fileItem);
                });
                bubble.appendChild(fileAttachmentsDiv);
            }

            if (type === 'user') {
                bubble.innerHTML += escapeHTML(text);
                bubble.innerHTML += `
                    <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                        <button class="icon-btn" title="Edit"><i class="fas fa-pen-to-square"></i></button>
                        <button class="icon-btn" title="Copy"><i class="fas fa-copy"></i></button>
                    </div>
                `;
                group.appendChild(bubble);
                els.chatViewport.appendChild(group);
                if (isNew) applyGlitchEffect(bubble); // Wow Feature 2: Glitch for new messages
                hookUserMsgControls(group, messageId);
            } else { // AI message
                group.appendChild(bubble);
                els.chatViewport.appendChild(group);

                // Type out markdown content
                const typedContent = await typeAndRenderMarkdown(bubble, parseMarkdown(text), true);
                if (typedContent) {
                    await addMessageToFirestore('ai', typedContent, [], messageId); // Save final typed content
                }
                if (isNew) applyGlitchEffect(bubble); // Wow Feature 2: Glitch for new messages
                hookAiMsgControls(group, messageId);
            }

            els.chatViewport.scrollTop = els.chatViewport.scrollHeight;
            return group;
        }

        function renderExistingMessages() {
            els.chatViewport.innerHTML = '';
            currentMessages.forEach(msg => {
                const group = document.createElement('div');
                group.className = `message-group ${msg.role}`;
                group.dataset.messageId = msg.id;

                const bubble = document.createElement('div');
                bubble.className = 'msg-bubble';

                if (msg.files && msg.files.length > 0) {
                    const fileAttachmentsDiv = document.createElement('div');
                    fileAttachmentsDiv.className = 'file-attachments';
                    msg.files.forEach(file => {
                        let icon = 'fas fa-file';
                        if (file.type.startsWith('image/')) icon = 'fas fa-file-image';
                        else if (file.type.startsWith('video/')) icon = 'fas fa-file-video';
                        else if (file.type.startsWith('audio/')) icon = 'fas fa-file-audio';
                        else if (file.type === 'application/pdf') icon = 'fas fa-file-pdf';
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-placeholder';
                        fileItem.innerHTML = `<i class="${icon}"></i> ${escapeHTML(file.name)}`;
                        fileAttachmentsDiv.appendChild(fileItem);
                    });
                    bubble.appendChild(fileAttachmentsDiv);
                }
                
                // Render markdown for existing messages directly
                const markdownParts = parseMarkdown(msg.text);
                let htmlContent = '';
                markdownParts.forEach(part => {
                    if (part.type === 'text') {
                        htmlContent += inlineMarkdown(part.content);
                    } else if (part.type === 'code') {
                        htmlContent += `<pre><button class="copy-btn">Copy</button><code class="language-${part.lang}">${escapeHTML(part.content)}</code></pre>`;
                    }
                });
                bubble.innerHTML += htmlContent;

                if (msg.role === 'user') {
                    bubble.innerHTML += `
                        <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                            <button class="icon-btn" title="Edit"><i class="fas fa-pen-to-square"></i></button>
                            <button class="icon-btn" title="Copy"><i class="fas fa-copy"></i></button>
                        </div>
                    `;
                } else {
                    bubble.innerHTML += `
                        <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                            <button class="icon-btn" title="Copy"><i class="fas fa-copy"></i></button>
                            <button class="icon-btn" title="Share"><i class="fas fa-share-alt"></i></button>
                            <button class="icon-btn" title="Regenerate"><i class="fas fa-redo-alt"></i></button>
                        </div>
                    `;
                }
                
                group.appendChild(bubble);
                els.chatViewport.appendChild(group);
                if (msg.role === 'user') {
                    hookUserMsgControls(group, msg.id);
                } else {
                    hookAiMsgControls(group, msg.id);
                }

                // Add copy buttons to pre elements
                group.querySelectorAll('pre').forEach(pre => {
                    const copyBtn = pre.querySelector('.copy-btn');
                    const codeEl = pre.querySelector('code');
                    if (copyBtn && codeEl) {
                        copyBtn.onclick = async () => {
                            await navigator.clipboard.writeText(codeEl.innerText);
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => copyBtn.textContent = 'Copy', 1000);
                        };
                    }
                });
            });
            els.chatViewport.appendChild(els.suggestions); // Ensure suggestions dock is at the bottom
            els.chatViewport.scrollTop = els.chatViewport.scrollHeight;
        }

        // --- Firebase Integration ---
        async function addMessageToFirestore(role, text, files = [], messageId = null) {
            if (!currentChatId || !currentUser) return;
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            try {
                if (messageId) { // Update existing message (e.g., after typewriter)
                    await setDoc(doc(messagesCol, messageId), { role, text, files, createdAt: serverTimestamp() }, { merge: true });
                } else { // Add new message
                    const docRef = await addDoc(messagesCol, { role, text, files, createdAt: serverTimestamp() });
                    return docRef.id;
                }
            } catch (e) {
                console.error("Error adding/updating message to Firestore: ", e);
            }
            return null;
        }

        async function deleteMessagesFrom(messageId) {
            if (!currentChatId || !currentUser) return;
            const msgIndex = currentMessages.findIndex(m => m.id === messageId);
            if (msgIndex === -1) return;
            const batch = writeBatch(db);
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            for (let i = msgIndex; i < currentMessages.length; i++) {
                const msgToDel = currentMessages[i];
                const docRef = doc(messagesCol, msgToDel.id);
                batch.delete(docRef);
            }
            try {
                await batch.commit();
            } catch (e) {
                console.error("Error deleting messages: ", e);
            }
        }

        // --- Chat Controls ---
        function hookAiMsgControls(messageGroup, messageId) {
            const copyBtn = messageGroup.querySelector('.ai-msg-controls .fa-copy');
            const shareBtn = messageGroup.querySelector('.ai-msg-controls .fa-share-alt');
            const regenBtn = messageGroup.querySelector('.ai-msg-controls .fa-redo-alt');

            if (copyBtn) copyBtn.parentElement.onclick = async () => {
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;
                await navigator.clipboard.writeText(msg.text);
                const originalText = copyBtn.innerHTML;
                copyBtn.innerHTML = "<i class='fas fa-check'></i> Copied!";
                setTimeout(() => copyBtn.innerHTML = originalText, 1000);
            };

            if (shareBtn) shareBtn.parentElement.onclick = () => {
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;
                const shareText = `Philadelphia AI Response: "${msg.text}"\n\nShared via Philadelphia AI: ${window.location.origin}`;
                if (navigator.share) {
                    navigator.share({ title: "Philadelphia AI", text: shareText, url: window.location.origin }).catch(() => {});
                } else {
                    prompt("Copy and share this response:", shareText);
                }
            };

            if (regenBtn) regenBtn.parentElement.onclick = async () => {
                const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                if (msgIndex < 1) return; // Need at least one user message before AI response
                const userMsg = currentMessages[msgIndex - 1];
                if (userMsg.role !== 'user') return;

                await deleteMessagesFrom(messageId);
                els.userInput.value = userMsg.text;
                uploadedFiles = userMsg.files || [];
                renderFilePreview();
                els.userInput.style.height = 'auto'; // Reset textarea height

                // Re-trigger send
                sendMessage();
            };
        }

        function hookUserMsgControls(messageGroup, messageId) {
            const copyBtn = messageGroup.querySelector('.user-msg-controls .fa-copy');
            const editBtn = messageGroup.querySelector('.user-msg-controls .fa-pen-to-square');

            if (copyBtn) copyBtn.parentElement.onclick = async () => {
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;
                await navigator.clipboard.writeText(msg.text);
                const originalText = copyBtn.innerHTML;
                copyBtn.innerHTML = "<i class='fas fa-check'></i> Copied!";
                setTimeout(() => copyBtn.innerHTML = originalText, 1000);
            };

            if (editBtn) editBtn.parentElement.onclick = async () => {
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;
                els.userInput.value = msg.text;
                uploadedFiles = msg.files || [];
                renderFilePreview();
                els.userInput.focus();
                await deleteMessagesFrom(messageId);
            };
        }

        // --- File Handling ---
        function renderFilePreview() {
            if (!els.filePreview) return;
            if (uploadedFiles.length === 0) {
                els.filePreview.style.display = 'none';
                els.filePreview.innerHTML = '';
                return;
            }
            els.filePreview.style.display = 'flex';
            els.filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                let preview = '';
                if (file.type.startsWith('image/')) {
                    preview = `<img src="${URL.createObjectURL(file)}" alt="Preview">`;
                } else if (file.type.startsWith('video/')) {
                    preview = `<video src="${URL.createObjectURL(file)}" muted autoplay loop></video>`;
                } else if (file.type.startsWith('audio/')) {
                    preview = `<audio controls src="${URL.createObjectURL(file)}"></audio>`;
                } else if (file.type === 'application/pdf') {
                    preview = `<i class="fas fa-file-pdf" style="font-size: 1.5em;"></i>`;
                } else {
                    preview = `<i class="fas fa-file" style="font-size: 1.5em;"></i>`;
                }
                return `
                    <div class="file-item">
                        ${preview}
                        <span>${escapeHTML(file.name)}</span>
                        <button type="button" data-idx="${idx}" class="remove-btn">&times;</button>
                    </div>`;
            }).join('');

            els.filePreview.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.idx);
                    uploadedFiles.splice(idx, 1);
                    if (!uploadedFiles.length) els.fileInput.value = '';
                    renderFilePreview();
                });
            });
        }

        // --- Typing Status ---
        let typingIndicatorElement = null;
        function showTypingIndicator(message = 'Philadelphia AI is composing...', type = 'ai') {
            if (!typingIndicatorElement) {
                typingIndicatorElement = document.createElement('div');
                typingIndicatorElement.className = `typing-indicator ${type}`;
                typingIndicatorElement.innerHTML = `<span></span><span></span><span></span> <span class="status-text">${message}</span>`;
                els.chatViewport.appendChild(typingIndicatorElement);
            } else {
                typingIndicatorElement.className = `typing-indicator ${type}`;
                typingIndicatorElement.querySelector('.status-text').textContent = message;
            }
            typingIndicatorElement.style.display = 'flex';
            els.chatViewport.scrollTop = els.chatViewport.scrollHeight;
            els.galacticNavigator.classList.add('thinking'); // Wow Feature 1
        }

        function hideTypingIndicator() {
            if (typingIndicatorElement) {
                typingIndicatorElement.style.display = 'none';
            }
            els.galacticNavigator.classList.remove('thinking'); // Wow Feature 1
        }

        // --- Wow Feature 1: Galactic Navigator Controls ---
        function updateGalacticNavigator(status) {
            if (status === 'thinking') {
                els.galacticNavigator.classList.add('active', 'thinking');
            } else if (status === 'idle') {
                els.galacticNavigator.classList.add('active');
                els.galacticNavigator.classList.remove('thinking');
            } else {
                els.galacticNavigator.classList.remove('active', 'thinking');
            }
        }

        // --- Wow Feature 3: Quantum Leap Transition ---
        function triggerQuantumLeap() {
            els.quantumLeapOverlay.style.display = 'block';
            els.quantumLeapOverlay.style.opacity = '1';
            setTimeout(() => {
                els.quantumLeapOverlay.style.opacity = '0';
                setTimeout(() => {
                    els.quantumLeapOverlay.style.display = 'none';
                }, 500); // Allow fade out
            }, 800); // Match animation duration
        }

        // --- Lightbox for full screen media preview ---
        function openLightbox(src, type = 'image') {
            els.lightbox.innerHTML = ''; // Clear previous content
            let mediaElement;
            if (type === 'image') {
                mediaElement = document.createElement('img');
                mediaElement.src = src;
                mediaElement.alt = "Full-screen AI Generated Content";
            } else if (type === 'video') {
                mediaElement = document.createElement('video');
                mediaElement.src = src;
                mediaElement.controls = true;
                mediaElement.autoplay = true;
                mediaElement.loop = true;
            } else {
                console.error("Unsupported media type for lightbox:", type);
                return;
            }
            els.lightbox.appendChild(mediaElement);
            els.lightbox.classList.add('active');
        }

        function closeLightbox() {
            els.lightbox.classList.remove('active');
            // Pause any playing media
            const media = els.lightbox.querySelector('img, video, audio');
            if (media && typeof media.pause === 'function') {
                media.pause();
            }
        }

        // --- Event Listeners ---
        window.addEventListener('DOMContentLoaded', () => {
            // Cosmic Background Engine Initialization
            function createParticle(type, count, spread, maxDuration) {
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = type;
                    const size = Math.random() * (type === 'star' ? 2 : 1.5) + 0.5;
                    particle.style.width = `${size}px`; particle.style.height = `${size}px`;
                    particle.style.left = `${Math.random() * spread}%`;
                    particle.style.top = `${Math.random() * spread}%`;
                    particle.style.setProperty('--duration', `${Math.random() * maxDuration + 5}s`);
                    particle.style.setProperty('--delay', `${Math.random() * -maxDuration}s`); // Start at various points in animation
                    if(type==='star') {
                        particle.style.opacity = Math.random();
                        particle.style.setProperty('--glow-size', `${Math.random() * 3 + 2}px`);
                        particle.style.setProperty('--glow-opacity', `${Math.random() * 0.7 + 0.3}`);
                    }
                    els.cosmosContainer.appendChild(particle);
                }
            }
            createParticle('star', 250, 100, 10);
            createParticle('stardust', 120, 100, 15);

            function launchShootingStar() {
                const star = document.createElement('div');
                star.className = 'shooting-star';
                const startX = Math.random() * window.innerWidth * 1.5;
                const startY = -100;
                const angle = Math.random() * (-20) - 25; // Between -25 and -45 degrees
                const duration = Math.random() * 1.5 + 2.5; // 2.5 to 4 seconds
                const maxWidth = Math.random() * 150 + 50; // 50 to 200px width

                star.style.setProperty('--startX', `${startX}px`);
                star.style.setProperty('--startY', `${startY}px`);
                star.style.setProperty('--angle', `${angle}deg`);
                star.style.setProperty('--duration', `${duration}s`);
                star.style.setProperty('--max-width', `${maxWidth}px`);
                star.style.setProperty('--endX', `${startX - 800}px`); // Further drift
                star.style.setProperty('--endY', `${startY + 600}px`); // Further drift

                els.cosmosContainer.appendChild(star);
                setTimeout(() => star.remove(), duration * 1000);
            }
            setInterval(launchShootingStar, Math.random() * 5000 + 3000); // Every 3-8 seconds

            // Celestial Bodies (slow moving galaxies)
            function createCelestialBody() {
                const body = document.createElement('div');
                body.className = 'celestial-body';
                const size = Math.random() * 400 + 200; // 200 to 600px
                const duration = Math.random() * 120 + 90; // 90 to 210 seconds
                const startX = Math.random() * 200 - 100; // -100% to 100% relative to viewport
                const startY = Math.random() * 200 - 100;
                const endX = startX + (Math.random() > 0.5 ? 50 : -50); // Drift +/- 50%
                const endY = startY + (Math.random() > 0.5 ? 50 : -50);
                const color = Math.random() > 0.5 ? '0, 242, 255' : '189, 0, 255'; // Neon blue or purple
                const opacity = Math.random() * 0.2 + 0.05; // Very faint

                body.style.width = `${size}px`;
                body.style.height = `${size}px`;
                body.style.left = `${startX}vw`;
                body.style.top = `${startY}vh`;
                body.style.setProperty('--duration', `${duration}s`);
                body.style.setProperty('--delay', `${Math.random() * -duration}s`);
                body.style.setProperty('--startX', `0`); // Using current pos as 0 for relative transform
                body.style.setProperty('--startY', `0`);
                body.style.setProperty('--endX', `${(endX - startX) * window.innerWidth / 100}px`);
                body.style.setProperty('--endY', `${(endY - startY) * window.innerHeight / 100}px`);
                body.style.setProperty('--color', color);
                body.style.setProperty('--opacity', opacity);

                els.cosmosContainer.appendChild(body);
                // Remove and recreate after animation finishes to ensure continuous movement
                setTimeout(() => { body.remove(); createCelestialBody(); }, duration * 1000);
            }
            for (let i = 0; i < 3; i++) createCelestialBody(); // 3-5 large celestial bodies

            // --- UI Event Listeners ---
            els.userInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    els.sendBtn.click();
                }
                els.userInput.style.height = 'auto'; // Reset height
                els.userInput.style.height = els.userInput.scrollHeight + 'px'; // Set to scroll height
            });
            els.userInput.addEventListener('input', () => {
                els.userInput.style.height = 'auto';
                els.userInput.style.height = els.userInput.scrollHeight + 'px';
            });

            els.sendBtn.addEventListener('click', sendMessage);
            els.fileInput.addEventListener('change', () => {
                uploadedFiles = Array.from(els.fileInput.files);
                renderFilePreview();
            });

            // Panel toggles
            els.profileMenuBtn.addEventListener('click', () => togglePanel(els.profilePanelBg));
            els.toolsMenuBtn.addEventListener('click', () => togglePanel(els.toolsPanelBg));
            els.menuLinksBtn.addEventListener('click', () => togglePanel(els.linksPanelBg));
            
            // Close buttons for panels
            document.querySelectorAll('.side-panel .panel-close-btn').forEach(btn => {
                btn.addEventListener('click', (e) => closePanel(e.target.closest('.side-panel-bg')));
            });

            // Click outside to close panels
            document.querySelectorAll('.side-panel-bg').forEach(panelBg => {
                panelBg.addEventListener('click', (e) => {
                    if (e.target === panelBg) {
                        closePanel(panelBg);
                    }
                });
            });

            els.logoutBtn.addEventListener('click', async () => {
                await signOut(auth);
                window.location.href = 'signup-login.html';
            });

            els.profileForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!currentUser) return;
                els.profileStatusMsg.textContent = 'Updating profile...';
                try {
                    await updateProfile(currentUser, {
                        displayName: els.editName.value,
                        photoURL: els.editPhoto.value
                    });
                    if (auth.currentUser) await auth.currentUser.reload();
                    els.profileStatusMsg.textContent = 'Profile updated!';
                    els.profileStatusMsg.style.color = 'var(--cosmic-cyan)';
                    setTimeout(() => closePanel(els.profilePanelBg), 1000);
                } catch (error) {
                    els.profileStatusMsg.textContent = `Error: ${error.message}`;
                    els.profileStatusMsg.style.color = 'red';
                }
            });

            els.lightbox.addEventListener('click', closeLightbox); // Close lightbox on click

            // --- Firebase Auth State Listener ---
            onAuthStateChanged(auth, async (user) => {
                if (!user) {
                    window.location.href = 'signup-login.html'; // Redirect to login if not authenticated
                    return;
                }
                currentUser = user;
                els.profileDisplayName.textContent = user.displayName || 'Voyager';
                els.profileDisplayEmail.textContent = user.email || '';
                els.editName.value = user.displayName || '';
                els.editPhoto.value = user.photoURL || '';
                els.profilePicPreview.src = user.photoURL || 'https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg';

                loadUserChats(user.uid);
            });

            // --- Theme Toggle (Wow Feature 4: Theme Cycles) ---
            const themes = {
                cosmic: {
                    '--neon-blue': '#00f2ff', '--neon-purple': '#bd00ff', '--cosmic-cyan': '#0ff', '--cosmic-magenta': '#f0f',
                    '--cosmic-dark': '#02001a', '--cosmic-medium': '#150030', '--cosmic-light': '#2a0050',
                    '--plasma-gradient': 'linear-gradient(135deg, var(--neon-blue), var(--neon-purple))',
                    '--glass-bg-strong': 'rgba(20, 20, 35, 0.7)', '--glass-bg-light': 'rgba(255, 255, 255, 0.08)',
                    '--glass-border': 'rgba(255, 255, 255, 0.15)',
                    '--text-glow': '0 0 10px rgba(0, 242, 255, 0.7), 0 0 20px rgba(189, 0, 255, 0.5)',
                    '--box-glow': '0 0 20px rgba(0, 242, 255, 0.2)',
                    '--code-bg': 'linear-gradient(92deg, #0f0022 79%, #3a0066 120%)', '--code-border': '#8000ff', '--code-text': '#e0b0ff',
                    '--code-shadow': '0 0 15px rgba(189, 0, 255, 0.4)',
                    '--call-accent': '#00ff88',
                    '--bg-radial': 'radial-gradient(circle at 50% 50%, #050714, var(--cosmic-dark) 80%)',
                    '--nebula1-bg': 'radial-gradient(circle at 55% 55%, rgba(76, 0, 255, 0.18), transparent 50%), radial-gradient(circle at 85% 25%, rgba(0, 242, 255, 0.18), transparent 40%)',
                    '--nebula2-bg': 'radial-gradient(circle at 25% 85%, rgba(189, 0, 255, 0.25), transparent 50%)',
                    '--nebula3-bg': 'radial-gradient(circle at 15% 15%, rgba(0, 255, 255, 0.1), transparent 60%)'
                },
                solarflare: {
                    '--neon-blue': '#ffbb00', '--neon-purple': '#ff4500', '--cosmic-cyan': '#ffa500', '--cosmic-magenta': '#ff2200',
                    '--cosmic-dark': '#1a0d00', '--cosmic-medium': '#301800', '--cosmic-light': '#502a00',
                    '--plasma-gradient': 'linear-gradient(135deg, var(--neon-blue), var(--neon-purple))',
                    '--glass-bg-strong': 'rgba(35, 20, 0, 0.7)', '--glass-bg-light': 'rgba(255, 255, 255, 0.08)',
                    '--glass-border': 'rgba(255, 255, 255, 0.15)',
                    '--text-glow': '0 0 10px rgba(255, 187, 0, 0.7), 0 0 20px rgba(255, 69, 0, 0.5)',
                    '--box-glow': '0 0 20px rgba(255, 187, 0, 0.2)',
                    '--code-bg': 'linear-gradient(92deg, #221000 79%, #663a00 120%)', '--code-border': '#ff8c00', '--code-text': '#ffddaa',
                    '--code-shadow': '0 0 15px rgba(255, 69, 0, 0.4)',
                    '--call-accent': '#ccff00',
                    '--bg-radial': 'radial-gradient(circle at 50% 50%, #1a0d00, var(--cosmic-dark) 80%)',
                    '--nebula1-bg': 'radial-gradient(circle at 55% 55%, rgba(255, 69, 0, 0.18), transparent 50%), radial-gradient(circle at 85% 25%, rgba(255, 187, 0, 0.18), transparent 40%)',
                    '--nebula2-bg': 'radial-gradient(circle at 25% 85%, rgba(255, 69, 0, 0.25), transparent 50%)',
                    '--nebula3-bg': 'radial-gradient(circle at 15% 15%, rgba(255, 165, 0, 0.1), transparent 60%)'
                },
                voidmatter: {
                    '--neon-blue': '#8a2be2', '--neon-purple': '#4b0082', '--cosmic-cyan': '#a020f0', '--cosmic-magenta': '#6a0dad',
                    '--cosmic-dark': '#0a0515', '--cosmic-medium': '#1f0d2c', '--cosmic-light': '#3a1a54',
                    '--plasma-gradient': 'linear-gradient(135deg, var(--neon-blue), var(--neon-purple))',
                    '--glass-bg-strong': 'rgba(15, 5, 25, 0.7)', '--glass-bg-light': 'rgba(255, 255, 255, 0.08)',
                    '--glass-border': 'rgba(255, 255, 255, 0.15)',
                    '--text-glow': '0 0 10px rgba(138, 43, 226, 0.7), 0 0 20px rgba(75, 0, 130, 0.5)',
                    '--box-glow': '0 0 20px rgba(138, 43, 226, 0.2)',
                    '--code-bg': 'linear-gradient(92deg, #180a2a 79%, #4a1d75 120%)', '--code-border': '#9932cc', '--code-text': '#e6ceff',
                    '--code-shadow': '0 0 15px rgba(75, 0, 130, 0.4)',
                    '--call-accent': '#00ddff',
                    '--bg-radial': 'radial-gradient(circle at 50% 50%, #0a0515, var(--cosmic-dark) 80%)',
                    '--nebula1-bg': 'radial-gradient(circle at 55% 55%, rgba(75, 0, 130, 0.18), transparent 50%), radial-gradient(circle at 85% 25%, rgba(138, 43, 226, 0.18), transparent 40%)',
                    '--nebula2-bg': 'radial-gradient(circle at 25% 85%, rgba(75, 0, 130, 0.25), transparent 50%)',
                    '--nebula3-bg': 'radial-gradient(circle at 15% 15%, rgba(160, 32, 240, 0.1), transparent 60%)'
                }
            };
            const themeKeys = Object.keys(themes);
            let currentThemeIndex = 0;

            function applyTheme(themeName) {
                const theme = themes[themeName];
                if (!theme) return;
                for (const key in theme) {
                    document.documentElement.style.setProperty(key, theme[key]);
                    // Specific background adjustments for cosmos layers
                    if (key === '--bg-radial') els.cosmosContainer.style.background = theme[key];
                    if (key === '--nebula1-bg') els.cosmosContainer.querySelector('#nebula-layer-1').style.background = theme[key];
                    if (key === '--nebula2-bg') els.cosmosContainer.querySelector('#nebula-layer-2').style.background = theme[key];
                    if (key === '--nebula3-bg') els.cosmosContainer.querySelector('#nebula-layer-3').style.background = theme[key];
                }
                currentTheme = themeName;
                localStorage.setItem('philadelphia-theme', themeName);
            }

            els.themeToggleBtn.addEventListener('click', () => {
                currentThemeIndex = (currentThemeIndex + 1) % themeKeys.length;
                applyTheme(themeKeys[currentThemeIndex]);
                triggerQuantumLeap(); // Wow Feature 3: Quantum Leap on theme change
            });

            // Load saved theme
            const savedTheme = localStorage.getItem('philadelphia-theme');
            if (savedTheme && themes[savedTheme]) {
                currentThemeIndex = themeKeys.indexOf(savedTheme);
                applyTheme(savedTheme);
            } else {
                applyTheme('cosmic'); // Default
            }
        });

        // --- Panel Toggle Helper ---
        function togglePanel(panelBgElement) {
            document.querySelectorAll('.side-panel-bg').forEach(bg => {
                if (bg !== panelBgElement && bg.classList.contains('active')) {
                    closePanel(bg); // Close other open panels
                }
            });
            panelBgElement.classList.toggle('active');
        }

        function closePanel(panelBgElement) {
            panelBgElement.classList.remove('active');
        }

        // --- Chat & Firestore Logic ---
        async function loadUserChats(userId) {
            if (chatsUnsubscribe) chatsUnsubscribe();
            const chatsCol = collection(db, 'users', userId, 'chats');
            const q = query(chatsCol, orderBy('createdAt', 'desc'));
            chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                if (snapshot.empty) {
                    await createNewChat(userId);
                    return;
                }
                chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                // For this version, we don't have a separate chat list UI yet,
                // so we just pick the latest or a default.
                if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                    currentChatId = chats[0].id;
                }
                subscribeToMessages(userId, currentChatId);
            }, (error) => {
                console.error("Error fetching chats: ", error);
            });
        }

        async function createNewChat(userId) {
            if (!userId) userId = currentUser?.uid;
            if (!userId) return;
            const chatsCol = collection(db, 'users', userId, 'chats');
            try {
                const newChatDoc = await addDoc(chatsCol, { name: "New Chat", createdAt: serverTimestamp() });
                currentChatId = newChatDoc.id;
            } catch (e) {
                console.error("Error creating new chat: ", e);
            }
        }

        function subscribeToMessages(userId, chatId) {
            if (messagesUnsubscribe) messagesUnsubscribe();
            if (!userId || !chatId) {
                els.chatViewport.innerHTML = ''; // Clear chat
                return;
            }
            const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
            const q = query(messagesCol, orderBy('createdAt'));
            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderExistingMessages(); // Re-render all messages
            }, (error) => {
                console.error("Error fetching messages: ", error);
                els.chatViewport.innerHTML = `<div style="color: red; text-align: center; margin-top: 20px;">Error loading messages.</div>`;
            });
        }

        // --- Main Send Message Logic ---
        async function sendMessage() {
            if (!currentChatId) {
                console.error("No active chat. Cannot send message.");
                return;
            }
            const messageText = els.userInput.value.trim();
            if (!messageText && uploadedFiles.length === 0) return;

            // Display user message immediately
            const userMessageId = await addMessageToFirestore('user', messageText, uploadedFiles);
            addMessageToChatUI(messageText, 'user', userMessageId, uploadedFiles);

            els.userInput.value = ''; // Clear input
            els.userInput.style.height = 'auto'; // Reset textarea height
            uploadedFiles = [];
            renderFilePreview();
            els.suggestions.style.display = 'none'; // Hide suggestions after user input

            // Show typing indicator
            showTypingIndicator();

            currentController = new AbortController();
            const signal = currentController.signal;

            let finalResponseText = '';
            const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));

            if (uploadedFiles.length > 0) {
                showTypingIndicator('Analyzing attached file(s)...', 'system');
                const file = uploadedFiles[0]; // Assuming only one file for basic analysis
                let endpoint = '';
                if (file.type.startsWith('image/')) endpoint = '/understand-image';
                else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                else {
                    finalResponseText = "Analysis Unit: File type unsupported for deep analysis. Proceeding with text-only interpretation.";
                }

                try {
                    if (endpoint) {
                        const formData = new FormData();
                        formData.append('prompt', messageText || `Describe and analyze this ${file.type.split('/')[0]}`);
                        formData.append('file', file);
                        const response = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: formData, signal });
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || "File analysis failed.");
                        finalResponseText = data.response;
                    }
                } catch (error) {
                    finalResponseText = error.name === 'AbortError' ? 'Analysis aborted by user.' : `Analysis Unit: Critical error during file processing: ${error.message}`;
                }
            } else if (messageText) {
                const history = currentMessages.map(m => ({ role: m.role, content: m.text }));
                try {
                    const response = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: messageText, history, user_id: currentUser?.uid || "user" }),
                        signal
                    });
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.error || "Server error.");
                    finalResponseText = data.response;
                } catch (error) {
                    finalResponseText = error.name === 'AbortError' ? 'Transmission interrupted.' : `Comms Error: Failed to establish connection: ${error.message}`;
                }
            }

            hideTypingIndicator();
            // Display AI response
            if (finalResponseText) {
                await addMessageToChatUI(finalResponseText, 'ai', null); // New AI message, ID will be set by Firestore snapshot
            }
            currentController = null;
        }

        // --- Suggestions ---
        function sendSuggestion(chipElement) {
            const text = chipElement.textContent.trim();
            els.userInput.value = text;
            sendMessage();
        }

        // --- AI Tools Logic ---
        const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
        const toolDefinitions = {
            "image": {
                title: "Generate Image",
                description: "Forge stunning visuals from text. Choose a model for distinct artistic outputs.",
                buildForm: () => `
                    <div class="form-group"><label for="tool-provider">Generation Matrix</label>
                    <select id="tool-provider"><option value="thena">Matrix-Theta (Stylized, Rapid)</option><option value="minimax">Matrix-Minimax (Creative, Realistic)</option></select></div>
                    <div class="form-group"><label for="tool-prompt">Image Schematic Prompt</label><textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required></textarea></div>
                    <div class="form-group"><label for="tool-style">Aesthetic Protocol (Matrix-Theta only)</label>
                    <select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-sparkles"></i> Synthesize Image</button>`,
                handleSubmit: async (form) => {
                    const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                    const providerName = use_minimax ? 'Matrix-Minimax' : 'Matrix-Theta';
                    const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
                    await addMessageToFirestore('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                    showTypingIndicator('Generating your image schematic...', 'system');
                    try {
                        const res = await fetch(`${API_BASE_URL}/generate-image`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        
                        const imgHtml = `âœ… Image Schematic Forged! <br><img src="data:image/png;base64,${data.image_b64}" alt="AI Generated Image" class="tool-content-preview" onclick="openLightbox(this.src, 'image')">`;
                        hideTypingIndicator();
                        await addMessageToChatUI(imgHtml, 'ai', null);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Image generation failed: ${err.message}`;
                    }
                }
            },
            "edit-photo": {
                title: "Enhance Photo",
                description: "Upload a visual and describe alterations you desire for optimal enhancement.",
                buildForm: () => `
                    <div class="form-group"><label for="tool-prompt">Modification Directive</label><textarea id="tool-prompt" placeholder="Change the background to a desolate alien landscape" required></textarea></div>
                    <div class="form-group"><label for="tool-file">Visual to Enhance</label><input type="file" id="tool-file" accept="image/*" required></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-magic"></i> Apply Enhancement</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    const prompt = form.querySelector('#tool-prompt').value;
                    if (!file) return "Please uplink a visual file for enhancement.";
                    const fd = new FormData(); fd.append('file', file); fd.append('prompt', prompt);
                    await addMessageToFirestore('user', `Photo enhancement request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                    showTypingIndicator('Processing visual enhancement...', 'system');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error((await res.json()).error || 'Failed to enhance photo.');
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob);
                        const imgHtml = `âœ… Visual Enhanced Successfully! <br><img src="${base64String}" alt="Enhanced Visual" class="tool-content-preview" onclick="openLightbox(this.src, 'image')">`;
                        hideTypingIndicator();
                        await addMessageToChatUI(imgHtml, 'ai', null);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Visual enhancement failed: ${err.message}`;
                    }
                }
            },
            "remove-bg": {
                title: "Decouple Background",
                description: "Select an image file to isolate its primary subject from the background matrix.",
                buildForm: () => `
                    <div class="form-group"><label for="tool-file">Select Visual File</label><input type="file" id="tool-file" accept="image/*" required></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-cut"></i> Decouple Background</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    if (!file) return "Please uplink a visual file.";
                    await addMessageToFirestore('user', `Background decoupling request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                    showTypingIndicator('Isolating background matrix...', 'system');
                    const fd = new FormData(); fd.append('file', file);
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const imgHtml = `âœ… Background Decoupled! <br><img src="${url}" alt="Image with decoupled background" class="tool-content-preview" onclick="openLightbox(this.src, 'image')">`;
                        hideTypingIndicator();
                        await addMessageToChatUI(imgHtml, 'ai', null);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Background decoupling failed: ${err.message}`;
                    }
                }
            },
            "comic": {
                title: "Warp Comic Strip",
                description: "Enter a narrative to be transmuted into a multi-panel comic sequence. Use tags like [DIALOGUE], [INSTRUCTION], [NARRATION].",
                buildForm: () => `
                    <div class="form-group"><label for="tool-story">Comic Narrative Log</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this anomaly?&#10;[NARRATION] Captain Kael stared into the void..." required></textarea></div>
                    <div class="form-group"><label for="tool-style">Artistic Protocol</label><select id="tool-style"><option value="anime">Neo-Anime</option><option value="american">Terran Classic</option><option value="manga">Manga Pulse</option></select></div>
                    <div class="form-group"><label for="tool-panels">Panel Sequence Count</label><input type="number" id="tool-panels" value="3" min="1" max="6" /></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-book-reader"></i> Generate Comic Sequence</button>`,
                handleSubmit: async (form) => {
                    const payload = {
                        story: form.querySelector('#tool-story').value, style: form.querySelector('#tool-style').value,
                        panels: parseInt(form.querySelector('#tool-panels').value, 10), user: currentUser?.displayName || "User"
                    };
                    await addMessageToFirestore('user', `Comic sequence generation request (protocol: ${payload.style}).`);
                    showTypingIndicator('Rendering comic sequence panels...', 'system');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="tool-content-preview" onclick="openLightbox(this.src, 'image')">`).join('');
                        const comicMessage = `ðŸ–¼ï¸ Comic Sequence Engaged! <br><div class="tool-content-gallery">${imagesHtml}</div>`;
                        hideTypingIndicator();
                        await addMessageToChatUI(comicMessage, 'ai', null);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Comic sequence generation failed: ${err.message}`;
                    }
                }
            },
            "voice-gen": {
                title: "Synthesize Voice",
                description: "Transmute text data into sentient speech. Select your vocal signature.",
                buildForm: () => `
                    <div class="form-group"><label for="tool-provider">Vocal Matrix Provider</label><select id="tool-provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select></div>
                    <div class="form-group"><label for="tool-prompt">Text to Vocalize</label><textarea id="tool-prompt" placeholder="The celestial anomaly approaches..." required></textarea></div>
                    <div class="form-group"><label for="tool-style">Vocal Signature</label><select id="tool-style"></select></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-microphone-alt"></i> Synthesize Audio</button>`,
                onFormReady: () => {
                    const providerSelect = document.getElementById('tool-provider'), styleSelect = document.getElementById('tool-style');
                    const voices = {
                        gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                        minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                    };
                    const updateStyles = () => {
                        styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                    };
                    providerSelect.addEventListener('change', updateStyles);
                    updateStyles();
                },
                handleSubmit: async (form) => {
                    const provider = form.querySelector('#tool-provider').value, text = form.querySelector('#tool-prompt').value, style = form.querySelector('#tool-style').value;
                    const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';
                    await addMessageToFirestore('user', `Voice synthesis request (provider: ${providerName}).`);
                    showTypingIndicator('Synthesizing vocal output...', 'system');
                    try {
                        let res;
                        if (provider === 'gemini') {
                            const fd = new FormData(); fd.append('text', text); fd.append('style', style);
                            res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                        } else {
                            res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ text, voice_id: style })
                            });
                        }
                        if (!res.ok) throw new Error(await res.text());
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const audioHtml = `ðŸ—£ï¸ Vocal Output Synthesized! <br><audio controls src="${url}" class="tool-content-preview audio"></audio>`;
                        hideTypingIndicator();
                        await addMessageToChatUI(audioHtml, 'ai', null);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Voice synthesis failed: ${err.message}`;
                    }
                }
            },
            "audio-narration": {
                title: "Galactic Narration",
                description: "Uplink a data scroll (PDF, TXT) to receive an audio-narrated summary, perfect for interstellar broadcasts.",
                buildForm: () => `
                    <div class="form-group"><label for="tool-file">Data Scroll for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-headphones"></i> Generate Galactic Narration</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    if (!file) return "Please uplink a data scroll.";
                    await addMessageToFirestore('user', `Galactic narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                    showTypingIndicator('Analyzing and narrating data scroll...', 'system');
                    const fd = new FormData(); fd.append('file', file); fd.append('style', 'podcast');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const narrationHtml = `ðŸ—£ï¸ Galactic Narration Complete! <br><audio controls src="${url}" class="tool-content-preview audio"></audio>`;
                        hideTypingIndicator();
                        await addMessageToChatUI(narrationHtml, 'ai', null);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Galactic narration failed: ${err.message}`;
                    }
                }
            },
            "video-text": {
                title: "Text-to-Video Warp",
                description: "Describe your desired video sequence to initiate creation. This process may require several stellar cycles.",
                buildForm: () => `
                    <div class="form-group"><label for="video-prompt">Video Sequence Directive</label><textarea id="video-prompt" placeholder="A majestic space eagle soaring through a nebula..." required></textarea></div>
                    <div class="form-group"><label for="video-duration">Temporal Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15"></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-film"></i> Initiate Video Warp</button>`,
                handleSubmit: async (form) => {
                    const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
                    await addMessageToFirestore('user', `Text-to-Video Warp request: "${payload.prompt}"`);
                    handleVideoGeneration(payload);
                    return null;
                }
            },
            "video-image": {
                title: "Image-to-Video Flux",
                description: "Uplink a static visual and articulate its desired animation for dynamic video flux.",
                buildForm: () => `
                    <div class="form-group"><label for="video-image-prompt">Animation Flux Directive</label><textarea id="video-image-prompt" placeholder="Make the nebula shimmer, with a slow, ethereal zoom-in" required></textarea></div>
                    <div class="form-group"><label for="video-image-file">Initial Visual</label><input type="file" id="video-image-file" accept="image/*" required></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-photo-video"></i> Initiate Video Flux</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#video-image-file').files[0];
                    if (!file) return "Please uplink an initial visual.";
                    await addMessageToFirestore('user', `Image-to-Video Flux request for: ${file.name}`, [{name: file.name, type: file.type}]);
                    const fd = new FormData(); fd.append('prompt', form.querySelector('#video-image-prompt').value); fd.append('file', file);
                    handleVideoGeneration(fd, true);
                    return null;
                }
            },
            "music": {
                title: "Stellar Composition",
                description: "Generate musical sequences from prompts, optional lyrics, and reference audio. Powered by the MiniMax sonic matrix.",
                buildForm: () => `
                    <div class="form-group"><label for="music-prompt">Sonic Matrix Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song with a space opera feel..." required></textarea></div>
                    <div class="form-group"><label for="music-lyrics">Vocal Code (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..."></textarea></div>
                    <div class="form-group"><label for="music-ref">Sonic Reference (Optional)</label><input type="file" id="music-ref" accept="audio/*"></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-music"></i> Generate Composition</button>`,
                handleSubmit: async (form) => {
                    const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
                    const refFile = form.querySelector('#music-ref').files[0];
                    await addMessageToFirestore('user', `Stellar composition request: "${payload.prompt}"`);
                    showTypingIndicator('Composing sonic matrix...', 'system');
                    try {
                        if (refFile) {
                            showTypingIndicator('Uplinking sonic reference...', 'system');
                            const fd = new FormData(); fd.append('file', refFile);
                            const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                            const uploadData = await uploadRes.json();
                            if (!uploadRes.ok) throw new Error(uploadData.error || "Sonic reference uplink failed.");
                            if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                            if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                            showTypingIndicator('Reference uplinked. Composing composition...', 'system');
                        }
                        const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                        });
                        if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const musicHtml = `ðŸŽµ Stellar Composition Ready! <br><audio controls src="${url}" class="tool-content-preview audio"></audio>`;
                        hideTypingIndicator();
                        await addMessageToChatUI(musicHtml, 'ai', null);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Stellar composition failed: ${err.message}`;
                    }
                }
            },
            "website": {
                title: "Deploy Website",
                description: "Articulate your desired cyber-domain. Philadelphia AI will architect and deploy a live prototype.",
                buildForm: () => `
                    <div class="form-group"><label for="website-prompt">Cyber-Domain Blueprint</label><textarea id="website-prompt" placeholder="A sleek portfolio site for an interstellar artist, dark theme with neon accents." required></textarea></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-globe-americas"></i> Architect & Deploy</button>`,
                handleSubmit: async (form) => {
                    const prompt = form.querySelector('#website-prompt').value;
                    await addMessageToFirestore('user', `Cyber-domain deployment request: "${prompt.substring(0, 50)}..."`);
                    showTypingIndicator('Architecting and deploying your cyber-domain...', 'system');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ prompt, user_id: currentUser.uid })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        hideTypingIndicator();
                        return `ðŸŒ Cyber-Domain Deployed! Access at: [${data.url}](${data.url})`;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Cyber-domain deployment failed: ${err.message}`;
                    }
                }
            },
            "edit-website": {
                title: "Refine Last Website",
                description: "Provide precise directives to modify your most recently deployed cyber-domain.",
                buildForm: () => `
                    <div class="form-group"><label for="edit-instruction">Refinement Directive</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Stellar Studio' and update the contact link." required></textarea></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-pencil-ruler"></i> Apply Refinements</button>`,
                handleSubmit: async (form) => {
                    const instruction = form.querySelector('#edit-instruction').value;
                    await addMessageToFirestore('user', `Cyber-domain refinement request: "${instruction.substring(0, 50)}..."`);
                    showTypingIndicator('Applying refinements to cyber-domain...', 'system');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ instruction, user_id: currentUser.uid })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        hideTypingIndicator();
                        return `âœï¸ Cyber-Domain Refined! View latest iteration: [${data.url}](${data.url})`;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Cyber-domain refinement failed: ${err.message}`;
                    }
                }
            },
            "my-sites": {
                isAction: true,
                runAction: async () => {
                    await addMessageToFirestore('user', 'Access my deployed cyber-domains.');
                    showTypingIndicator('Accessing cyber-domain registry...', 'system');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || 'Could not access cyber-domain registry.');
                        if (!data.sites || data.sites.length === 0) return "You haven't deployed any cyber-domains yet, Initiate a deployment!";
                        const siteList = data.sites.map(site => `- [${site.site_url}](${site.site_url}) (Deployed: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                        hideTypingIndicator();
                        return `Here are your deployed Cyber-Domains:\n${siteList}`;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Error accessing cyber-domain registry: ${err.message}`;
                    }
                }
            },
            "research-report": {
                title: "Cosmic Research Report",
                description: "Generate a comprehensive research dossier in PDF format on any given topic, drawing from the galactic data networks.",
                buildForm: () => `
                    <div class="form-group"><label for="research-topic">Research Directive</label><input type="text" id="research-topic" placeholder="The history of interstellar travel in deep space" required></div>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fas fa-flask"></i> Generate Research Dossier</button>`,
                handleSubmit: async (form) => {
                    const topic = form.querySelector('#research-topic').value;
                    await addMessageToFirestore('user', `Cosmic research dossier request on: "${topic}"`);
                    showTypingIndicator('Initiating deep-space data retrieval and dossier compilation...', 'system');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ topic })
                        });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--neon-blue);font-weight:bold;">Download PDF Dossier</a>`;
                        hideTypingIndicator();
                        return `âœ… Cosmic Research Dossier on **${topic}** ready! ${downloadLink}`;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Cosmic research dossier compilation failed: ${err.message}`;
                    }
                }
            },
        };

        els.toolsPanel.addEventListener('click', async (e) => {
            const toolLink = e.target.closest('.tool-link');
            if (!toolLink) return;
            e.preventDefault();
            const toolKey = toolLink.getAttribute('data-tool');
            const tool = toolDefinitions[toolKey];
            if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);
            closePanel(els.toolsPanelBg);

            if (tool.isAction) {
                const result = await tool.runAction();
                hideTypingIndicator();
                if (result) await addMessageToChatUI(result, 'ai', null);
            } else {
                displayToolForm(toolKey);
            }
        });

        els.toolFormBackBtn.addEventListener('click', () => {
            closePanel(els.toolFormModalBg);
            togglePanel(els.toolsPanelBg);
        });

        function displayToolForm(toolKey) {
            const tool = toolDefinitions[toolKey];
            if (!tool) return;
            els.toolFormTitle.textContent = tool.title;
            els.toolFormDescription.textContent = tool.description || '';
            els.toolForm.innerHTML = tool.buildForm();
            if (typeof tool.onFormReady === 'function') tool.onFormReady();

            els.toolForm.onsubmit = async (e) => {
                e.preventDefault();
                const submitButton = els.toolForm.querySelector('button[type="submit"]');
                const originalButtonContent = submitButton.innerHTML;
                submitButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Processing...`;
                submitButton.disabled = true;
                closePanel(els.toolFormModalBg); // Close the form modal when submitting

                const resultText = await tool.handleSubmit(els.toolForm);
                if (resultText) {
                    hideTypingIndicator();
                    await addMessageToChatUI(resultText, 'ai', null);
                }
                submitButton.innerHTML = originalButtonContent;
                submitButton.disabled = false;
            };
            togglePanel(els.toolFormModalBg);
        }

        async function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        async function handleVideoGeneration(payload, isImageToVideo = false) {
            showTypingIndicator('Submitting video synthesis task...', 'system');
            try {
                const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
                const commonPayload = { model: "MiniMax-Hailuo-02", duration: payload.duration || 6, resolution: payload.resolution || "1080P" };
                let options;

                if (isImageToVideo) {
                    payload.append('model', commonPayload.model);
                    payload.append('duration', commonPayload.duration);
                    payload.append('resolution', commonPayload.resolution);
                    options = { method: 'POST', body: payload };
                } else {
                    const finalPayload = { ...payload, ...commonPayload };
                    options = {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(finalPayload)
                    };
                }

                const startRes = await fetch(API_BASE_URL + endpoint, options);
                const startData = await startRes.json();

                if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to initiate video synthesis.');

                hideTypingIndicator();
                await addMessageToChatUI(`âœ… Video synthesis initiated! Task ID: \`${startData.task_id}\`. Standby for completion. This may require several temporal cycles. Do not initiate new tasks until completion.`, 'ai', null);

                const pollInterval = setInterval(async () => {
                    try {
                        const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                        const statusData = await statusRes.json();

                        if (statusRes.ok && statusData.url) {
                            clearInterval(pollInterval);
                            const videoHtml = `ðŸŽ‰ Video Synthesis Complete! <br><video controls src="${statusData.url}" class="tool-content-preview video" onclick="openLightbox(this.src, 'video')"></video>`;
                            await addMessageToChatUI(videoHtml, 'ai', null);
                        } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                            clearInterval(pollInterval);
                            await addMessageToChatUI(`âŒ Video Synthesis Failed. Error: ${statusData.error || 'Unknown error'}`, 'ai', null);
                        }
                    } catch (pollErr) {
                        clearInterval(pollInterval);
                        await addMessageToChatUI(`âŒ Error monitoring video synthesis status.`, 'ai', null);
                    }
                }, 20000); // Poll every 20 seconds
            } catch (err) {
                hideTypingIndicator();
                await addMessageToChatUI(`âŒ Could not initiate video synthesis: ${err.message}`, 'ai', null);
            }
        }

        // --- Voice Call Functionality ---
        let speechRecognition;
        let isCallActive = false;
        let callHistory = [];
        let botIsSpeaking = false;
        let userSaidSomething = false;
        let currentAudio = null;
        let isMuted = false;

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        if (SpeechRecognition) {
            speechRecognition = new SpeechRecognition();
            speechRecognition.continuous = false; // Only listen for single phrases unless re-started
            speechRecognition.interimResults = true;
            speechRecognition.lang = 'en-US';

            speechRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                userSaidSomething = true;
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                let userMsgEl = els.callConversation.querySelector('.call-msg.user.interim');
                if (!userMsgEl) {
                    userMsgEl = document.createElement('div');
                    userMsgEl.className = 'call-msg user interim';
                    els.callConversation.appendChild(userMsgEl);
                }
                userMsgEl.textContent = finalTranscript || interimTranscript;
                els.callConversation.scrollTop = els.callConversation.scrollHeight;

                els.callStatusDisplay.textContent = finalTranscript ? 'User Transmission: Finalizing...' : 'User Transmission: Active...';
            };

            speechRecognition.onend = () => {
                if (!isCallActive) return;
                if (isMuted) {
                    els.callStatusDisplay.textContent = 'Microphone: Muted.';
                    return;
                }

                let finalTranscript = '';
                const userMsgEl = els.callConversation.querySelector('.call-msg.user.interim');
                if (userMsgEl) {
                    finalTranscript = userMsgEl.textContent.trim();
                    userMsgEl.classList.remove('interim');
                    if (!finalTranscript) userMsgEl.remove(); // Remove empty interim message
                }

                if (botIsSpeaking) {
                    // Bot is speaking, just wait for it to finish and restart listening (in speakBotResponse)
                    els.callStatusDisplay.textContent = 'Philadelphia AI: Transmitting...';
                } else if (finalTranscript && userSaidSomething) {
                    userSaidSomething = false;
                    callHistory.push({ role: 'user', content: finalTranscript });
                    handleCallBotResponse();
                } else {
                    if (isCallActive && !isMuted) {
                        els.callStatusDisplay.textContent = 'Awaiting User Transmission...';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
                    }
                }
            };

            speechRecognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                if (event.error === 'no-speech' && isCallActive && !isMuted && !botIsSpeaking) {
                    userSaidSomething = false;
                    try { speechRecognition.stop(); speechRecognition.start(); } catch(e) {console.warn("Speech recognition restart failed after no-speech:", e);}
                } else if (event.error === 'network' && isCallActive) {
                    els.callStatusDisplay.textContent = 'Comms Link: Network anomaly detected. Attempting re-connection...';
                    speechRecognition.stop();
                } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    els.callStatusDisplay.textContent = 'Microphone Access: Denied. Enable in browser settings for comms.';
                    endCall();
                }
            };
        } else {
            els.callBtn.style.display = 'none'; // Hide call button if not supported
            console.warn("Speech Recognition not supported in this browser.");
        }

        function addCallMessage(role, text) {
            const msgEl = document.createElement('div');
            msgEl.className = `call-msg ${role}`;
            msgEl.textContent = text;
            els.callConversation.appendChild(msgEl);
            els.callConversation.scrollTop = els.callConversation.scrollHeight;
        }

        async function handleCallBotResponse() {
            if (!isCallActive) return;
            els.callStatusDisplay.textContent = 'Philadelphia AI: Processing Request...';
            const historyForBot = callHistory.map(m => m);
            const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : "";

            try {
                speechRecognition.stop(); // Stop listening while bot processes
                const res = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: userMessage, history: historyForBot.slice(0, -1), user_id: currentUser?.uid || "user" })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || "Server error.");
                const botResponse = data.response;
                callHistory.push({ role: 'ai', content: botResponse });
                addCallMessage('bot', botResponse);
                speakBotResponse(botResponse);
            } catch (err) {
                const errorMsg = `âŒ Comms Error: ${err.message}`;
                addCallMessage('bot', errorMsg);
                if (isCallActive && !isMuted) {
                    els.callStatusDisplay.textContent = 'Awaiting User Transmission...';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
                }
            }
        }

        async function speakBotResponse(text) {
            if (!isCallActive) return;
            botIsSpeaking = true;
            els.botVisualizer.classList.add('speaking');
            els.callStatusDisplay.textContent = 'Philadelphia AI: Transmitting Audio...';
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ text: text, voice_id: 'elder' })
                });
                if (!res.ok) throw new Error(await res.text());
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                currentAudio = audio;
                audio.onended = audio.onerror = () => {
                    botIsSpeaking = false;
                    els.botVisualizer.classList.remove('speaking');
                    currentAudio = null;
                    if (isCallActive && !isMuted) {
                        els.callStatusDisplay.textContent = 'Awaiting User Transmission...';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
                    } else if (isMuted) {
                        els.callStatusDisplay.textContent = 'Microphone: Muted.';
                    }
                };
                audio.play();
            } catch (err) {
                console.error("Voice synthesis error:", err);
                botIsSpeaking = false;
                els.botVisualizer.classList.remove('speaking');
                if (isCallActive && !isMuted) {
                    els.callStatusDisplay.textContent = 'Voice Synthesis Failed. Awaiting User Transmission...';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
                } else if (isMuted) {
                    els.callStatusDisplay.textContent = 'Microphone: Muted.';
                }
            }
        }

        function stopBotSpeakingAndStartListening() {
            if (!isCallActive || !botIsSpeaking) return;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            botIsSpeaking = false;
            els.botVisualizer.classList.remove('speaking');
            if (!isMuted) {
                els.callStatusDisplay.textContent = 'Awaiting User Transmission...';
                try {
                    speechRecognition.stop();
                    speechRecognition.start();
                } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
            } else {
                els.callStatusDisplay.textContent = 'Microphone: Muted.';
            }
            const userMsgEl = els.callConversation.querySelector('.call-msg.user.interim');
            if (userMsgEl) userMsgEl.textContent = ''; // Clear partial user speech
        }

        els.callModalContent.addEventListener('mousedown', stopBotSpeakingAndStartListening);
        els.callModalContent.addEventListener('touchstart', stopBotSpeakingAndStartListening);

        els.callBtn.addEventListener('click', () => {
            if (!SpeechRecognition) {
                alert("Comm Link Error: Your browser does not support essential Speech Recognition protocols.");
                return;
            }
            isCallActive = true;
            isMuted = false;
            els.muteCallBtn.classList.remove('muted');
            els.muteCallBtn.innerHTML = '<i class="fas fa-microphone"></i> Mute';
            els.callModal.classList.add('active');
            els.callConversation.innerHTML = '';
            addCallMessage('status', 'Establishing secure comms link...');
            els.callStatusDisplay.textContent = 'Initiating call sequence...';
            callHistory = [];
            
            setTimeout(() => {
                if (!isCallActive) return;
                addCallMessage('status', 'Comms Link Established. Philadelphia AI Awaiting Transmission.');
                els.callStatusDisplay.textContent = 'Awaiting User Transmission...';
                try { speechRecognition.start(); } catch(e) { console.error("Speech recognition start failed", e); els.callStatusDisplay.textContent = 'Microphone Access: Denied. Check permissions.'; }
            }, 1500);
        });

        function endCall() {
            isCallActive = false;
            botIsSpeaking = false;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            els.callModal.classList.remove('active');
            try { speechRecognition.stop(); } catch(e) {}
            els.botVisualizer.classList.remove('speaking');
            els.callStatusDisplay.textContent = 'Comms Link: Terminated.';
        }

        els.endCallBtn.addEventListener('click', endCall);

        els.muteCallBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            if (isMuted) {
                els.muteCallBtn.classList.add('muted');
                els.muteCallBtn.innerHTML = '<i class="fas fa-microphone-slash"></i> Unmute';
                speechRecognition.stop();
                els.callStatusDisplay.textContent = 'Microphone: Muted.';
            } else {
                els.muteCallBtn.classList.remove('muted');
                els.muteCallBtn.innerHTML = '<i class="fas fa-microphone"></i> Mute';
                if (isCallActive && !botIsSpeaking) {
                    els.callStatusDisplay.textContent = 'Awaiting User Transmission...';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
                } else if (isCallActive && botIsSpeaking) {
                    els.callStatusDisplay.textContent = 'Philadelphia AI: Transmitting Audio...';
                }
            }
        });
    </script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
