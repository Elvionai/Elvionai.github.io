<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Philadelphia AI - Cosmic Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
    <style>
        /* Base Cosmic Theme - Can be overridden by JS for other themes */
        :root {
            --neon-blue: #00f2ff;
            --neon-purple: #bd00ff;
            --neon-green: #00ff99; /* New accent */
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple), var(--neon-green));
            --plasma-gradient-2: linear-gradient(45deg, var(--neon-purple), var(--neon-blue));
            --glass-bg-strong: rgba(20, 20, 35, 0.75); /* Slightly stronger */
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.18); /* Slightly more visible */
            --text-glow: 0 0 10px rgba(0, 242, 255, 0.7), 0 0 20px rgba(189, 0, 255, 0.5), 0 0 30px rgba(0, 255, 153, 0.3);
            --box-glow: 0 0 20px rgba(0, 242, 255, 0.2);
            --user-bubble-glow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple);
            --ai-bubble-glow: inset 0 0 20px rgba(0, 242, 255, 0.08), 0 0 5px rgba(0, 242, 255, 0.1);
            --header-text-fill: linear-gradient(90deg, #fff, var(--neon-blue) 40%, var(--neon-purple) 60%, #fff);
            --header-text-glow-anim-1: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple);
            --header-text-glow-anim-2: 0 0 20px var(--neon-green), 0 0 35px var(--neon-blue);
            --code-bg: rgba(20, 20, 35, 0.9);
            --code-border: var(--neon-blue);
            --code-text: #e0faff;
            --input-focus-glow: 0 0 25px rgba(0, 242, 255, 0.4), 0 0 40px rgba(189, 0, 255, 0.2);
            --input-bg-focus: rgba(0, 242, 255, 0.1);
        }

        /* Reset & Base */
        * { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            height: 100vh;
            overflow: hidden;
            font-family: 'Roboto','Inter',system-ui,-apple-system,Segoe UI,sans-serif;
            background-color: #050714;
            color: #fff;
            display: flex;
            justify-content: center;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background-color 0.5s ease;
        }

        /* --- COSMIC BACKGROUND ENGINE --- */
        #cosmos-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #03000b 0%, #000000 100%);
        }

        .nebula-layer {
            position: absolute; top: 0; left: 0; width: 300%; height: 300%;
            background:
                radial-gradient(circle at 50% 50%, rgba(76, 0, 255, 0.1), transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.1), transparent 40%),
                linear-gradient(to bottom right, #050714, #1a0a2e);
            mix-blend-mode: screen;
            animation: drift 100s infinite linear;
            will-change: transform;
        }

        .nebula-layer:nth-child(2) {
            background: radial-gradient(circle at 20% 80%, rgba(189, 0, 255, 0.15), transparent 50%),
                        radial-gradient(circle at 70% 30%, rgba(0, 255, 153, 0.08), transparent 45%);
            animation: drift 70s infinite linear reverse;
            mix-blend-mode: overlay;
        }
        .nebula-layer:nth-child(3) { /* Closer, faster layer */
            background: radial-gradient(circle at 10% 10%, rgba(0, 242, 255, 0.05), transparent 60%),
                        radial-gradient(circle at 90% 90%, rgba(189, 0, 255, 0.07), transparent 55%);
            animation: drift 40s infinite linear;
            mix-blend-mode: soft-light;
            transform: scale(1.2); /* Slightly zoomed in */
        }


        @keyframes drift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-66.6%, -66.6%); } /* Covers 300% width */
        }

        .star, .shooting-star, .stardust, .energy-particle {
            position: absolute;
            pointer-events: none;
            will-change: transform, opacity;
        }

        .star {
            background: white; border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out;
            box-shadow: 0 0 5px rgba(255,255,255,0.8);
        }
        .star.blue-tint { background: var(--neon-blue); box-shadow: 0 0 5px var(--neon-blue); opacity: 0.7; }
        .star.purple-tint { background: var(--neon-purple); box-shadow: 0 0 5px var(--neon-purple); opacity: 0.6; }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(0.8); box-shadow: 0 0 3px rgba(255,255,255,0.7); }
            50% { opacity: 1; transform: scale(1.1); box-shadow: 0 0 8px rgba(255,255,255,1); }
        }

        .stardust {
            background: var(--neon-green); border-radius: 50%;
            width: 1px; height: 1px;
            opacity: 0.4;
            animation: floatUp var(--duration) infinite linear;
            filter: blur(0.5px);
        }
        @keyframes floatUp { to { transform: translateY(-100vh) translateX(var(--translateX)); opacity: 0; } }

        .energy-particle { /* New particle type */
            background: radial-gradient(circle, var(--neon-blue), transparent 60%);
            border-radius: 50%;
            opacity: 0.1;
            animation: pulseFade var(--duration) infinite ease-out;
        }
        @keyframes pulseFade {
            0% { transform: scale(0.1); opacity: 0; }
            50% { transform: scale(1); opacity: 0.2; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .shooting-star {
            height: 2px;
            background: linear-gradient(-90deg, var(--neon-blue), transparent);
            filter: drop-shadow(0 0 8px var(--neon-purple));
            animation: shoot var(--duration) ease-out; opacity: 0; z-index: 0;
            will-change: transform, opacity, width;
        }
        @keyframes shoot {
            0% { transform: translate(var(--startX), var(--startY)) rotate(var(--rotation)); opacity: 1; width: 0; }
            20% { width: 100px; }
            100% { transform: translate(calc(var(--startX) + var(--endX)), calc(var(--startY) + var(--endY))) rotate(var(--rotation)); opacity: 0; width: 0; }
        }

        .cosmic-eagle {
            position: absolute;
            opacity: 0;
            animation: eagleFlight var(--duration) linear infinite;
            will-change: transform, opacity;
            filter: drop-shadow(0 0 10px rgba(0, 242, 255, 0.5));
            z-index: -1;
        }

        @keyframes eagleFlight {
            0% {
                transform: translate(-100vw, var(--startY)) scale(var(--scale)) rotateY(0deg);
                opacity: 0;
            }
            10% { opacity: 0.3; }
            40% { opacity: 0.4; }
            50% {
                transform: translate(50vw, var(--startY)) scale(var(--scale)) rotateY(0deg);
                opacity: 0.5;
            }
            60% { opacity: 0.4; }
            90% { opacity: 0.1; }
            100% {
                transform: translate(200vw, var(--startY)) scale(var(--scale)) rotateY(0deg);
                opacity: 0;
            }
        }


        /* --- UI MAIN STRUCTURE --- */
        .ui-container {
            width: 100%; max-width: 600px;
            height: 100%; display: flex; flex-direction: column;
            position: relative; z-index: 10;
            background: rgba(5, 7, 20, 0.2); /* Subtle darkening for readability */
            box-shadow: 0 0 50px rgba(0,0,0,0.5); /* Outer shadow for the whole UI */
        }

        /* Header */
        header {
            padding: 20px 25px;
            display: flex; justify-content: space-between; align-items: center;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1003; /* Ensure header is on top */
        }

        .brand-plasma {
            font-family: 'Orbitron',sans-serif;
            font-size: 1.4rem; font-weight: 800; letter-spacing: 1px;
            background: var(--header-text-fill);
            background-size: 300% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: plasmaFlow 5s linear infinite;
            text-shadow: var(--header-text-glow-anim-1);
        }
        @keyframes plasmaFlow { to { background-position: 300% center; } }
        /* Header text animation glow variation */
        @keyframes neonglow-header {
            0% { text-shadow: var(--header-text-glow-anim-1);}
            50% { text-shadow: var(--header-text-glow-anim-2);}
            100% { text-shadow: var(--header-text-glow-anim-1);}
        }


        .header-actions { display: flex; gap: 20px; font-size: 1.4rem; }
        .icon-btn {
            background: none;
            border: none;
            color: var(--neon-blue);
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 10px;
            padding: 7px 11px;
            opacity: 0.8;
            transition: 0.3s;
            position: relative;
        }
        .icon-btn:hover {
            opacity: 1;
            color: #fff;
            text-shadow: var(--text-glow);
            background: rgba(0, 242, 255, 0.1);
            transform: scale(1.05);
        }

        /* Chat Area */
        #chat-viewport {
            flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px;
            scroll-behavior: smooth;
            scrollbar-width: none; -ms-overflow-style: none; /* Hide Scrollbar visually but keep functionality */
            position: relative;
            z-index: 1;
        }
        #chat-viewport::-webkit-scrollbar { display: none; }

        .message-group { display: flex; flex-direction: column; gap: 8px; max-width: 85%; position: relative; }
        .message-group.ai { align-self: flex-start; }
        .message-group.user { align-self: flex-end; align-items: flex-end; }

        .msg-bubble {
            padding: 16px 22px; border-radius: 24px;
            font-size: 1rem; line-height: 1.5;
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            word-break: break-word; /* Ensure long words break */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            overflow-x: auto; /* Allow horizontal scroll for wide content */
        }
        @keyframes popIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }

        .ai .msg-bubble {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8));
            border-bottom-left-radius: 4px;
            box-shadow: var(--ai-bubble-glow);
        }

        .user .msg-bubble {
            background: linear-gradient(135deg, rgba(0, 242, 255, 0.3), rgba(189, 0, 255, 0.3));
            border-bottom-right-radius: 4px;
            color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            box-shadow: var(--user-bubble-glow);
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* Message Controls (Copy, Edit, Share, Regen) */
        .message-controls {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 5px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
            font-size: 0.9em;
        }
        .message-group:hover .message-controls { opacity: 1; } /* Show on hover */

        .message-controls button {
            background: rgba(255, 255, 255, 0.07);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--neon-blue);
            padding: 5px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .message-controls button:hover {
            background: rgba(0, 242, 255, 0.2);
            border-color: var(--neon-blue);
            color: #fff;
            box-shadow: 0 0 10px var(--neon-blue);
            transform: translateY(-1px);
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            align-self: flex-start;
            gap: 10px;
            margin-top: 10px;
            padding: 10px 15px;
            background: rgba(20, 20, 35, 0.7);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--ai-bubble-glow);
            font-style: italic;
            color: rgba(255,255,255,0.7);
        }
        .typing-indicator .spinner {
            width: 18px; height: 18px;
            border: 2px solid rgba(0, 242, 255, 0.3);
            border-top-color: var(--neon-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .typing-bubble {
            display: inline-flex;
            align-items: center;
            height: 28px;
            padding: 4px 12px;
            border-radius: 15px;
            background: linear-gradient(90deg, rgba(10,68,119,0.8), rgba(14,191,255,0.5));
            box-shadow: 0 2px 12px rgba(13,252,255,0.47);
            border: 1px solid rgba(0,255,255,0.33);
        }
        .dot-anim {
            display:inline-block;
            width: 8px;
            height: 8px;
            margin:0 3px;
            background: var(--neon-blue);
            border-radius: 50%;
            opacity: 0.85;
            animation: typing-blink 1.4s infinite both;
            box-shadow: 0 0 6px var(--neon-blue);
        }
        .dot-anim:nth-child(2){animation-delay:.3s;}
        .dot-anim:nth-child(3){animation-delay:.6s;}

        @keyframes typing-blink {
            0%,100% {opacity:.25; transform: scale(0.8);}
            25% {opacity:.95; transform: scale(1.1);}
            50% {opacity:1; transform: scale(1.2);}
            75% {opacity:.65; transform: scale(1);}
        }


        /* Holographic Suggestions */
        .suggestions-dock {
            display: flex; flex-wrap: wrap; justify-content: flex-end; gap: 10px; margin-top: 10px;
            align-self: flex-end; /* Align to bottom-right of chat-viewport */
            z-index: 2; /* Ensure suggestions are above regular messages */
        }

        .chip {
            padding: 12px 20px; border-radius: 16px; font-size: 0.9rem; cursor: pointer;
            background: rgba(255, 255, 255, 0.07);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            transition: 0.3s; text-align: right; color: rgba(255,255,255,0.9);
            box-shadow: var(--box-glow);
        }
        .chip:hover {
            background: rgba(0, 242, 255, 0.15);
            border-color: var(--neon-blue);
            box-shadow: 0 0 25px rgba(0, 242, 255, 0.4);
            transform: translateY(-3px); color: #fff;
        }
        .holo-shimmer {
            position: relative; overflow: hidden;
        }
        .holo-shimmer::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(
                120deg, transparent, rgba(255, 255, 255, 0.4), transparent
            );
            transform: skewX(-25deg);
            animation: holoSheen 3s infinite linear;
        }
        @keyframes holoSheen { 0% { left: -100%; } 50%, 100% { left: 200%; } }

        /* Input Capsule */
        .input-dock {
            padding: 15px 25px; /* Adjust padding */
            background: var(--glass-bg-strong);
            backdrop-filter: blur(25px);
            border-top: 1px solid var(--glass-border);
            display: flex; gap: 10px; align-items: flex-end; /* Align to bottom for multiline */
            position: relative;
            z-index: 1002; /* Ensure input dock is on top */
        }

        .capsule-input {
            flex: 1; position: relative; min-height: 50px; max-height: 150px; /* Adjusted height */
            background: var(--glass-bg-light);
            border-radius: 30px; border: 1px solid var(--glass-border);
            transition: 0.3s; display: flex; align-items: center;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
        }
        .capsule-input:focus-within {
            border-color: var(--neon-blue);
            box-shadow: var(--input-focus-glow), inset 0 2px 10px rgba(0,0,0,0.2);
            background: var(--input-bg-focus);
        }
        .capsule-input textarea {
            width: 100%; height: auto; min-height: 30px; max-height: 120px; /* Adjusted textarea height */
            background: transparent; border: none;
            padding: 10px 25px; color: #fff; font-size: 1.05rem; outline: none;
            resize: none;
            scrollbar-width: none;
            -ms-overflow-style: none;
            overflow-y: auto;
            align-self: stretch; /* Make textarea fill the capsule vertically */
        }
        .capsule-input textarea::-webkit-scrollbar { display: none; }

        .thruster-btn {
            width: 50px; height: 50px; border-radius: 50%; border: none; cursor: pointer;
            background: var(--plasma-gradient);
            display: flex; align-items: center; justify-content: center;
            box-shadow: var(--box-glow); transition: 0.3s;
            color: #000; font-size: 1.2em; /* Adjusted size */
            flex-shrink: 0; /* Prevent button from shrinking */
        }
        .thruster-btn:hover { transform: scale(1.08) rotate(-10deg); box-shadow: 0 0 30px rgba(189, 0, 255, 0.6), var(--text-glow); }

        .action-icon-btn { /* For emoji, file, call, tool buttons */
            width: 40px; height: 40px;
            font-size: 1.1em;
            color: var(--neon-blue);
            background: rgba(255, 255, 255, 0.07);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        .action-icon-btn:hover {
            background: rgba(0, 242, 255, 0.15);
            border-color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
            color: #fff;
            transform: translateY(-1px);
        }
        .action-icon-btn.active {
            background: var(--plasma-gradient-2);
            border-color: var(--neon-green);
            color: #fff;
            box-shadow: 0 0 20px var(--neon-green);
        }

        /* File Preview */
        #filePreview {
            display: none;
            background: rgba(15, 36, 65, 0.98);
            border-radius: 12px;
            color: #c4f2ff;
            font-size: .98em;
            box-shadow: 0 3px 15px rgba(0, 170, 192, 0.73);
            margin: 0 auto 10px auto;
            width: 94vw;
            max-width: 520px;
            padding: 10px 14px 10px 15px;
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            border: 1.5px solid rgba(0, 255, 255, 0.27);
            flex-wrap: wrap; /* Allow multiple files to wrap */
            gap: 8px; /* Spacing between file items */
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 7px;
            margin-bottom: 1px;
            background: rgba(255,255,255,0.05);
            padding: 5px 10px;
            border-radius: 8px;
            border: 1px solid rgba(0,242,255,0.2);
        }

        .file-item img, .file-item video {
            max-width: 40px;
            max-height: 30px;
            border-radius: 5px;
            vertical-align: middle;
        }

        .file-item audio {
            width: 80px; /* Wider for better control */
            height: 25px; /* More compact */
            vertical-align: middle;
        }

        .remove-file-btn {
            background: #d23 !important;
            color: white !important;
            border: none !important;
            border-radius: 50% !important;
            padding: 2px 6px !important;
            cursor: pointer !important;
            font-size: 1em !important;
            font-weight: bold !important;
            margin-left: 8px !important;
            transition: background .16s, color .16s !important;
            min-width: 20px !important;
            height: 20px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        .remove-file-btn:hover {
            background: #ff4444 !important;
            color: #fff !important;
            transform: scale(1.1) !important;
        }


        /* AI-Generated Image Preview */
        #ai-image-preview {
            display: none;
            position: fixed;
            z-index: 1210;
            right: 22px;
            bottom: 100px;
            max-width: 320px;
            background: rgba(25, 26, 38, 0.95);
            padding: 12px;
            border-radius: 17px;
            box-shadow: 0 2px 19px rgba(0, 255, 242, 0.72);
            border: 1px solid var(--neon-blue);
            backdrop-filter: blur(10px);
        }
        #ai-image-preview img {
            max-width: 280px;
            max-height: 280px;
            border-radius: 12px;
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.5);
        }
        #ai-image-preview #ai-image-close {
            float: right;
            background: rgba(35, 35, 58, 0.8);
            border: none;
            border-radius: 7px;
            color: var(--neon-blue);
            font-size: 1.5em;
            cursor: pointer;
            margin-left: 5px;
            transition: all 0.2s ease;
        }
        #ai-image-preview #ai-image-close:hover {
            color: #fff;
            background: rgba(0, 242, 255, 0.3);
            transform: scale(1.1);
        }
        #ai-image-preview #ai-image-dl {
            margin-top: 9px;
            padding: 7px 20px;
            background: var(--plasma-gradient-2);
            color: #222;
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 7px rgba(0, 255, 242, 0.78);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        #ai-image-preview #ai-image-dl:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px var(--neon-green);
        }


        /* Modals & Panels (Side Menus, Tool Forms, Call Modal) */
        .panel-bg {
            display:none;
            position:fixed;
            top:0;
            left:0;
            width:100vw;
            height:100vh;
            background:rgba(0,0,0,0.85); /* Darker overlay */
            z-index:1200;
            backdrop-filter: blur(5px);
        }
        .panel-bg.active{ display:block; }

        .side-panel {
            position:absolute;
            top:0;
            left:-350px; /* Start off-screen */
            height:100vh;
            width:325px;
            background: linear-gradient(118deg, rgba(20, 20, 35, 0.95) 80%, rgba(30, 30, 60, 0.9) 200%);
            border-right:2.5px solid var(--neon-blue);
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.4);
            z-index:1212;
            padding:18px 16px 20px 15px;
            overflow-y:auto;
            border-radius:0 24px 32px 0;
            transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smooth slide-in */
            backdrop-filter: blur(15px);
        }
        .side-panel.active { left: 0; } /* Slide in */

        .side-panel .panel-header{ text-align:center; margin:18px 0 13px 0; }
        .side-panel img{
            width:56px; height:56px; border-radius:53%; margin-bottom:8px;
            border:2px solid var(--neon-green);
            box-shadow: 0 0 15px var(--neon-green);
        }
        .side-panel .username{
            font-weight:700; font-size:1.11em; color:var(--neon-blue);
            font-family:'Orbitron',sans-serif; text-shadow:0 0 8px var(--neon-blue);
        }
        .side-panel .email{ font-size:.97em; color:rgba(168, 234, 255, 0.7); }

        .panel-links a{
            color: var(--neon-blue); text-decoration:none; font-weight:500; font-size:1.08em;
            padding:8px 4px; display:flex; align-items:center; gap:12px;
            border-radius:9px; transition:background .14s;
        }
        .panel-links a:hover{
            background: rgba(0, 234, 255, 0.2);
            color:#f4fdff;
            text-shadow: 0 0 5px var(--neon-blue);
        }
        .panel-links a i { width: 20px; text-align: center; }

        .edit-form label{
            display:block; margin-top:10px; font-size:.99em; color:var(--neon-green);
            text-shadow:0 1px 14px rgba(17, 170, 255, 0.44);
        }
        .edit-form input, .edit-form textarea, .edit-form select{
            width:99%; padding:7px 11px; margin-top:5px;
            border:1.7px solid rgba(19, 240, 255, 0.58);
            border-radius:9px; background:rgba(7, 31, 53, 0.8);
            color:#fff; font-size:1.02em;
            box-shadow:0 0 8px rgba(4, 246, 253, 0.51) inset;
            transition:border-color .17s,box-shadow .17s;
        }
        .edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus{
            border-color:var(--neon-green);
            background:rgba(39, 63, 93, 0.7);
            color:#fff;
            box-shadow:0 0 15px var(--neon-green) inset;
        }
        .edit-form textarea { resize:vertical; min-height: 80px; }

        .submit-btn {
            margin-top:14px; padding:10px 20px;
            background: var(--plasma-gradient-2);
            border:none; border-radius:10px;
            color: #000; /* Dark text on vibrant button */
            font-weight:bold; cursor:pointer; font-size:1.11em;
            box-shadow:0 2px 13px rgba(0, 255, 242, 0.57);
            transition:background .14s,box-shadow .13s;
        }
        .submit-btn:hover{
            background: var(--plasma-gradient);
            box-shadow:0 0 20px var(--neon-green);
            color: #000;
        }
        .submit-btn .spinner {
            display: inline-block;
            width: 1em; height: 1em;
            border: 2px solid rgba(0,0,0,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 0.5em;
            vertical-align: middle;
        }

        /* Lightbox for large images */
        #lightbox {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.9);
            z-index: 5000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }
        #lightbox.active { display: flex; }
        #lightbox img {
            max-width: 90vw; max-height: 90vh;
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            box-shadow: 0 0 50px var(--neon-blue);
        }

        /* Call Modal */
        #callModal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(180deg, rgba(5,7,20,0.95), rgba(0,0,0,0.98));
            z-index: 4000;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            backdrop-filter: blur(10px);
            justify-content: space-between;
        }
        #callModal.active { display: flex; }

        #callHeader {
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em;
            text-shadow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple);
            margin-bottom: 20px;
            animation: neonglow-header 3s infinite alternate; /* Reuse header glow anim */
        }

        #botImageContainer {
            margin-top: 20px;
            position: relative;
            cursor: pointer; /* Tap to talk */
            width: 180px; height: 180px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%;
        }
        #botImageContainer img {
            width: 150px; height: 150px;
            border-radius: 50%;
            border: 4px solid var(--neon-blue);
            box-shadow: 0 0 30px var(--neon-blue);
            transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        @keyframes head-nod {
            0% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
            100% { transform: translateY(0); }
        }
        #botImageContainer.speaking img {
            border-color: var(--neon-green);
            box-shadow: 0 0 30px var(--neon-green);
            transform: scale(1.05);
            animation: head-nod 1.2s infinite ease-in-out;
        }

        #botSpeakingIndicator {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border-radius: 50%;
            border: 5px solid transparent;
            box-shadow: 0 0 20px var(--neon-blue);
            animation: pulse-aura 1.5s infinite ease-in-out;
            display: none;
            z-index: -1;
            box-sizing: border-box; /* Include border in size */
        }
        #botImageContainer.speaking #botSpeakingIndicator {
            box-shadow: 0 0 30px var(--neon-green), 0 0 50px rgba(0, 255, 153, 0.4);
            border-color: var(--neon-green);
            display: block;
            animation: pulse-aura-speak 1.2s infinite ease-in-out;
        }
        @keyframes pulse-aura {
            0% { transform: scale(0.9); opacity: 0.7; border-color: var(--neon-blue); }
            50% { transform: scale(1); opacity: 1; border-color: var(--neon-purple); }
            100% { transform: scale(0.9); opacity: 0.7; border-color: var(--neon-blue); }
        }
        @keyframes pulse-aura-speak {
            0% { transform: scale(0.95); opacity: 0.9; border-color: var(--neon-green); box-shadow: 0 0 25px var(--neon-green); }
            50% { transform: scale(1.02); opacity: 1; border-color: var(--neon-blue); box-shadow: 0 0 40px var(--neon-blue); }
            100% { transform: scale(0.95); opacity: 0.9; border-color: var(--neon-green); box-shadow: 0 0 25px var(--neon-green); }
        }


        #callStatusMessage {
            color: var(--neon-blue);
            font-size: 1.2em;
            margin-top: 15px;
            height: 30px;
            text-align: center;
            font-style: italic;
            text-shadow: 0 0 8px rgba(0, 170, 255, 0.7);
            animation: neonglow-status 2s infinite alternate;
        }
        @keyframes neonglow-status {
            0% { text-shadow: 0 0 5px var(--neon-blue); opacity: 0.7; }
            100% { text-shadow: 0 0 10px var(--neon-purple); opacity: 1; }
        }

        #tapToTalk {
            color: var(--neon-green);
            font-size: 1.3em;
            margin-top: 5px;
            text-shadow: 0 0 10px var(--neon-green);
            animation: neon-pulse 1.5s infinite alternate;
            display: none;
        }
        @keyframes neon-pulse {
            from { opacity: 0.7; transform: scale(1.0); }
            to { opacity: 1.0; transform: scale(1.02); }
        }


        #callConversation {
            flex-grow: 1;
            width: 100%;
            max-width: 600px;
            overflow-y: auto;
            margin: 20px 0;
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            scroll-behavior: smooth;
        }

        .call-msg {
            padding: 10px 15px;
            border-radius: 15px;
            line-height: 1.5;
            word-break: break-word;
            max-width: 80%;
        }
        .call-msg.user {
            background: linear-gradient(120deg, var(--neon-blue), var(--neon-purple));
            color: #fff;
            text-align: right;
            margin-left: auto;
            box-shadow: 0 0 10px rgba(0, 242, 255, 0.4);
        }
        .call-msg.bot {
            background: linear-gradient(120deg, rgba(30, 30, 60, 0.7), rgba(20, 20, 35, 0.8));
            color: #e0faff;
            margin-right: auto;
            box-shadow: 0 0 8px rgba(0, 242, 255, 0.2);
            border: 1px solid var(--glass-border);
        }
        .call-msg.status {
            text-align: center;
            color: rgba(136, 136, 136, 0.8);
            font-style: italic;
            background: none;
            max-width: 100%;
            margin: 0 auto;
        }
        .call-msg-user-listening-anim { /* For visual feedback when user speaks */
            border: 2px solid var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green), 0 0 20px rgba(0, 255, 153, 0.5);
            animation: user-speak-pulse 1s infinite alternate;
        }
        @keyframes user-speak-pulse {
            from { transform: scale(1); opacity: 0.8; }
            to { transform: scale(1.01); opacity: 1; }
        }


        #callControls {
            display: flex;
            gap: 20px;
            padding-bottom: 20px;
            margin-top: auto;
        }
        #endCallBtn, #muteCallBtn {
            font-size: 1.1em;
            padding: 12px 25px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(210, 51, 51, 0.5);
            transition: background .1s, box-shadow .1s, transform 0.2s ease;
            color: #fff;
        }
        #endCallBtn {
            background: linear-gradient(90deg, #d23, #ff6666);
            box-shadow: 0 0 15px rgba(210, 51, 51, 0.7);
        }
        #endCallBtn:hover {
            background: #ff4444;
            box-shadow: 0 0 25px #ff4444aa;
            transform: translateY(-2px);
        }
        #muteCallBtn {
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-purple));
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.7);
        }
        #muteCallBtn:hover {
            background: linear-gradient(90deg, var(--neon-purple), var(--neon-blue));
            box-shadow: 0 0 25px rgba(0, 123, 255, 0.9);
            transform: translateY(-2px);
        }
        #muteCallBtn.muted {
            background: linear-gradient(90deg, #555, #777);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #muteCallBtn.muted:hover {
            background: linear-gradient(90deg, #777, #999);
            box-shadow: 0 0 15px rgba(0,0,0,0.7);
        }


        /* Code block styling (enhanced for "shining" effect) */
        pre {
            background: var(--code-bg);
            border-radius: 11px;
            border: 1.7px solid var(--code-border);
            color: var(--code-text);
            box-shadow: 0 0 19px rgba(0, 234, 255, 0.22), 0 0 48px rgba(11, 234, 255, 0.22) inset;
            transition: background 0.3s, border-color 0.3s, color 0.3s, box-shadow 0.3s;
            overflow-x: auto;
            padding: 1.18em 1.3em 1.16em 1.13em;
            margin: 1.15em 0 1em 0;
            position: relative;
        }
        pre code {
            font-family: 'JetBrains Mono','Fira Mono','Menlo',monospace;
            font-size: .99em;
            display: block; /* Ensure code takes full width */
        }

        /* Shining effect for code blocks (triggered by JS after typing) */
        pre.shining {
            animation: codeShine 1.5s ease-out forwards;
        }
        @keyframes codeShine {
            0% {
                border-color: rgba(0, 242, 255, 0.3);
                box-shadow: 0 0 10px rgba(0, 242, 255, 0.1), inset 0 0 10px rgba(0, 242, 255, 0.1);
            }
            50% {
                border-color: var(--neon-green);
                box-shadow: 0 0 30px var(--neon-green), inset 0 0 30px var(--neon-green);
            }
            100% {
                border-color: var(--neon-blue);
                box-shadow: 0 0 20px var(--neon-blue), inset 0 0 20px var(--neon-blue);
            }
        }
        pre:before {
            content: "CODE";
            color: var(--neon-blue);
            font-size: 0.82em;
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 5px;
            right: 29px;
            opacity: 0.17;
            letter-spacing: 0.13em;
            pointer-events: none;
        }
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 13px;
            z-index: 3;
            border-radius: 8px;
            border: none;
            padding: 3px 15px;
            background: var(--plasma-gradient-2);
            color: #06182f;
            font-size: .98em;
            font-family: 'Inter';
            font-weight: bold;
            box-shadow: 0 2px 9px rgba(24, 227, 255, 0.77),0 0 7px rgba(0, 255, 215, 0.64);
            transition: background .15s, color .15s;
            cursor: pointer;
            outline: none;
            border: 1px solid rgba(12, 243, 255, 0.21);
        }
        .copy-btn:hover {
            background: var(--neon-blue);
            color: #fff;
        }


        /* Media previews */
        .chat-media-preview {
            max-width: 100%;
            max-height: 250px;
            border-radius: 12px;
            display: block;
            margin-top: 10px; /* Space from text */
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 15px var(--neon-blue);
        }
        .chat-media-preview.video-preview-thumb,
        .chat-media-preview.image-preview-thumb {
            cursor: zoom-in;
        }
        .audio-preview-thumb {
            width: 100%;
            min-height: 40px;
            border-radius: 10px;
            margin-top: 10px;
            filter: hue-rotate(90deg) saturate(1.5); /* Cosmic tint */
        }
        .file-attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 8px 0;
            max-width: 100%;
        }
        .file-placeholder {
            display: inline-block;
            padding: 8px 12px;
            background: rgba(11, 36, 71, 0.7);
            border: 1px solid rgba(26, 248, 255, 0.32);
            border-radius: 10px;
            color: var(--neon-blue);
            text-decoration: none;
            font-size: 0.9em;
            font-weight: bold;
        }
        .file-placeholder i { margin-right: 5px; }


        /* Dynamic Quantum Flow Header Avatar (Wow Feature 1) */
        #bot-avatar-header {
            width: 45px; height: 45px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
            box-shadow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple);
            position: relative;
            margin-right: 15px;
            animation: avatarPulse 3s infinite ease-in-out;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        #bot-avatar-header:hover { transform: scale(1.1); box-shadow: 0 0 25px var(--neon-green), 0 0 40px var(--neon-blue); }
        #bot-avatar-header .core-glow {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 70%; height: 70%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8), rgba(255,255,255,0) 70%);
            opacity: 0.8;
            animation: coreLight 2s infinite alternate;
        }
        @keyframes avatarPulse {
            0% { transform: scale(1); box-shadow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple); }
            50% { transform: scale(1.03); box-shadow: 0 0 20px var(--neon-green), 0 0 30px var(--neon-blue); }
            100% { transform: scale(1); box-shadow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple); }
        }
        @keyframes coreLight {
            0% { opacity: 0.6; transform: translate(-50%,-50%) scale(0.8); }
            100% { opacity: 1; transform: translate(-50%,-50%) scale(1); }
        }

        /* Cosmic Whisper Status Overlay (Wow Feature 4) */
        #cosmic-whisper-log {
            position: fixed;
            bottom: 120px;
            right: 20px;
            width: 250px;
            max-height: 200px;
            background: rgba(20, 20, 35, 0.8);
            border: 1px solid var(--neon-blue);
            border-radius: 12px;
            padding: 10px;
            font-size: 0.8em;
            color: rgba(0, 242, 255, 0.7);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(8px);
            overflow-y: auto;
            display: none; /* Hidden by default, toggled by JS */
            z-index: 1500;
        }
        #cosmic-whisper-log.active { display: block; }
        #cosmic-whisper-log div { margin-bottom: 5px; animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Theming - these classes will be added to <body> by JS */
        body.theme-celestial {
            --neon-blue: #ff00ff; --neon-purple: #8a2be2; --neon-green: #f0f;
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple), var(--neon-green));
            --plasma-gradient-2: linear-gradient(45deg, var(--neon-purple), var(--neon-blue));
            background-color: #0f001a;
            --glass-bg-strong: rgba(25,0,35,0.75);
            --input-focus-glow: 0 0 25px rgba(255,0,255,0.4), 0 0 40px rgba(138,43,226,0.2);
            --ai-bubble-glow: inset 0 0 20px rgba(255,0,255,0.08);
            --user-bubble-glow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple);
        }
        body.theme-starlight {
            --neon-blue: #a6faff; --neon-purple: #00c3ff; --neon-green: #aaffea;
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple), var(--neon-green));
            --plasma-gradient-2: linear-gradient(45deg, var(--neon-purple), var(--neon-blue));
            background-color: #030010;
            --glass-bg-strong: rgba(16,12,37,0.75);
            --input-focus-glow: 0 0 25px rgba(166,250,255,0.4), 0 0 40px rgba(0,195,255,0.2);
            --ai-bubble-glow: inset 0 0 20px rgba(166,250,255,0.08);
            --user-bubble-glow: 0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple);
        }
        /* Add more themes here */
    </style>
</head>
<body>

<div id="cosmos-container">
    <div class="nebula-layer"></div>
    <div class="nebula-layer"></div>
    <div class="nebula-layer"></div> <!-- More nebula layers -->
</div>

<div class="ui-container">
    <header>
        <div id="bot-avatar-header" title="Philadelphia AI">
            <div class="core-glow"></div>
        </div>
        <div class="brand-plasma">Philadelphia AI</div>
        <div class="header-actions">
            <button class="icon-btn" id="openProfileMenu" title="User Profile"><i class="fa-solid fa-user"></i></button>
            <button class="icon-btn" id="openLinksMenu" title="Menu Links"><i class="fa-solid fa-link"></i></button>
            <button class="icon-btn" id="themeBtn" title="Change Theme"><i class="fa-solid fa-lightbulb"></i></button>
        </div>
    </header>

    <div id="chat-viewport">
        <!-- Initial AI greeting -->
        <div class="message-group ai">
            <div class="msg-bubble">
                Greetings, traveler. ðŸ¦… The cosmic currents align. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨
            </div>
        </div>
        <!-- Suggestions will be inserted dynamically -->
        <div class="suggestions-dock" id="suggestions">
            <div class="chip holo-shimmer" onclick="sendSuggestion(this)">Create a cosmic comic. Style: Quantumpunk Anime.</div>
            <div class="chip holo-shimmer" onclick="sendSuggestion(this)">Design a website landing page for "Celestial Nexus Corp".</div>
            <div class="chip holo-shimmer" onclick="sendSuggestion(this)">Generate a space-opera short story prompt featuring an AI companion.</div>
        </div>
    </div>

    <div class="input-dock">
        <button type="button" id="emojiBtn" class="action-icon-btn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>
        <label for="chatFile" class="action-icon-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label>
        <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
        <div class="capsule-input">
            <textarea id="userInput" placeholder="Broadcast your message..." autocomplete="off"></textarea>
        </div>
        <button type="button" id="callBtn" class="action-icon-btn" title="Start Voice Call"><i class="fa-solid fa-phone"></i></button>
        <button type="button" id="toolBtn" class="action-icon-btn" title="Philadelphia Tools"><i class="fa-solid fa-wrench"></i></button>
        <button class="thruster-btn holo-shimmer" id="sendBtn" title="Send">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        </button>
        <!-- Stop button for AI response (replaces sendBtn during processing) -->
        <button class="thruster-btn" id="stopBtn" style="display:none; background: linear-gradient(90deg, #d23, #ff4d4d); box-shadow: 0 0 20px rgba(255, 77, 77, 0.7);" title="Stop Generating">
            <i class="fa-solid fa-stop" style="color: white;"></i>
        </button>
    </div>
</div>

<!-- All modals and panels from previous version, adapted to new styling -->
<div id="emojiPanel" style="display:none; position:fixed; left:10px; bottom:110px; z-index:2222; background:rgba(5, 31, 70, 0.95); border-radius:15px; padding:16px 15px 12px 15px; box-shadow:0 5px 22px rgba(0, 255, 241, 0.58); border:1px solid rgba(0, 255, 255, 0.4);"></div>
<div class="status-message" id="statusMsg" style="padding:6px 13px; color:var(--neon-green); font-size:.98em; min-height:17px; text-align:center; margin:4px auto 0 auto; max-width:430px; word-break:break-word; position:fixed; bottom: 85px; left: 50%; transform: translateX(-50%); z-index: 1004;"></div>
<div id="filePreview" class="file-preview"></div>

<div id="ai-image-preview" style="display:none;position:fixed;z-index:1210;right:22px;bottom:100px;max-width:320px;background:rgba(25,26,38,0.95);padding:12px;border-radius:17px;box-shadow:0 2px 19px rgba(0,255,242,0.72);border:1px solid var(--neon-blue);backdrop-filter:blur(10px);">
    <button id="ai-image-close" style="float:right;background:rgba(35,35,58,0.8);border:none;border-radius:7px;color:var(--neon-blue);font-size:1.5em;cursor:pointer;margin-left:5px;">&times;</button>
    <div id="ai-image-container"></div>
    <button id="ai-image-dl" style="margin-top:9px;padding:7px 20px;background:var(--plasma-gradient-2);color:#222;border:none;border-radius:8px;box-shadow:0 2px 7px rgba(0,255,242,0.78);cursor:pointer;font-weight:bold;">Download</button>
</div>

<div class="panel-bg" id="profileMenuBg">
    <nav class="side-panel" id="profileMenu">
        <div style="display:flex;align-items:center;justify-content:space-between;">
            <span style="font-size:1.17em;font-weight:700;color:var(--neon-blue);margin:18px 0 0 13px;">Chats</span>
            <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;" onclick="document.getElementById('profileMenuBg').classList.remove('active'); document.getElementById('profileMenu').classList.remove('active');">&times;</button>
        </div>
        <div id="chatsList" style="margin:7px 0 8px 6px;max-height:161px;overflow-y:auto;">
            <div class="spinner" style="margin: 20px auto; display: block;"></div>
        </div>
        <button id="newChatBtn" class="submit-btn" style="margin:0 0 12px 11px;"><i class="fa-solid fa-plus"></i> New Chat</button>
        <hr style="width:91%;margin:11px 0 7px 3%;border:1px solid rgba(0,255,240,0.19);">
        <div class="panel-header">
            <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
            <div class="username" id="profileMenuUser">User</div>
            <div class="email" id="profileMenuEmail">email@example.com</div>
        </div>
        <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;">
            <label for="edit-name">Name</label>
            <input type="text" id="edit-name" required>
            <label for="edit-photo">Photo URL</label>
            <input type="url" id="edit-photo" placeholder="Paste image link">
            <span style="font-size:0.83em;color:rgba(170,170,238,0.7);display:block;margin:5px 0 7px 2px;"> Tip: <a href="https://postimg.cc/" target="_blank" style="color:var(--neon-blue);">Upload at postimg.cc</a> </span>
            <button type="submit" class="submit-btn">Save</button>
            <div class="status-message" id="profileStatusMsg"></div>
        </form>
        <button class="submit-btn" id="logoutBtn" style="background:rgba(16,33,59,0.7);color:var(--neon-blue);margin:7px 7px 17px 7px;">Logout</button>
    </nav>
</div>

<div class="panel-bg" id="linkMenuBg">
    <nav class="side-panel" id="linkMenu">
        <div class="panel-header">
            <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia logo">
            <div class="username">Philadelphia AI</div>
        </div>
        <div class="panel-links">
            <a href="philadelphia.html"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a>
            <a href="index.html"><i class="fa-solid fa-home"></i>Elvion Homepage</a>
            <a href="about.html"><i class="fa-solid fa-circle-info"></i> About US</a>
            <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
            <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms</a>
            <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Try Telegram Version</a>
        </div>
    </nav>
</div>

<div class="panel-bg" id="toolsMenuBg">
    <nav class="side-panel" id="toolsMenu">
        <div class="panel-header" style="text-align:left;">
            <div class="username" style="font-size:1.2em;margin-left:-8px;text-align:center;">Philadelphia AI Tools</div>
        </div>
        <div class="panel-links">
            <h3 style="color:var(--neon-blue);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Creative Suite</h3>
            <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
            <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
            <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a>
            <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a>
            <hr style="border-color: rgba(0,234,255,0.19); margin: 10px 0;">
            <h3 style="color:var(--neon-blue);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Audio & Video</h3>
            <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
            <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
            <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a>
            <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
            <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a>
            <hr style="border-color: rgba(0,234,255,0.19); margin: 10px 0;">
            <h3 style="color:var(--neon-blue);margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Web & Research</h3>
            <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a>
            <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
            <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a>
            <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
        </div>
        <button class="submit-btn" style="margin-top:17px;" onclick="closeToolMenu();">Close</button>
    </nav>
</div>

<div class="panel-bg" id="toolFormModalBg">
    <nav class="side-panel" id="toolFormModal">
        <div class="panel-header">
            <div class="username" id="toolFormTitle">Tool Title</div>
        </div>
        <form class="edit-form" id="toolForm" style="padding:0 6px;"></form>
        <button id="toolFormBackBtn" class="submit-btn" style="background:rgba(16,33,59,0.7);color:var(--neon-blue);margin:7px 7px 17px 7px;">
            <i class="fa-solid fa-arrow-left"></i> Back to Tools
        </button>
        <div class="status-message" id="toolStatusMsg"></div>
    </nav>
</div>

<div id="lightbox">
    <img src="" alt="Lightbox image">
</div>

<!-- Immersive Voice Call Interface (Wow Feature 5) -->
<div id="callModal">
    <div id="callHeader">Philadelphia AI - Live Cosmic Link</div>
    <div id="botImageContainer">
        <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Bot">
        <div id="botSpeakingIndicator"></div>
    </div>
    <div id="callStatusMessage">Establishing Quantum Connection...</div>
    <div id="tapToTalk">Initiate Transmission (Tap Anywhere to Speak)</div>
    <div id="callConversation">
        <div class="call-msg status">Waiting for secure channel...</div>
    </div>
    <div id="callControls">
        <button id="muteCallBtn"><i class="fa-solid fa-microphone"></i> Mute Microphone</button>
        <button id="endCallBtn"><i class="fa-solid fa-phone-slash"></i> Terminate Link</button>
    </div>
</div>

<!-- Cosmic Whisper Status Overlay (Wow Feature 4) -->
<div id="cosmic-whisper-log">
    <!-- Log messages will appear here -->
    <div>[00:00:01] <i class="fa-solid fa-satellite-dish"></i> Initializing subspace relays...</div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getAuth, onAuthStateChanged, updateProfile, signOut } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
        authDomain: "elvionai.firebaseapp.com",
        projectId: "elvionai",
        storageBucket: "elvionai.appspot.com",
        messagingSenderId: "161078300830",
        appId: "1:161078300830:web:f460df8591704eb0e96b8f"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const $ = id => document.getElementById(id);

    const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

    let chats = [];
    let currentChatId = null;
    let currentMessages = []; // Full message objects, including file info
    let uploadedFiles = []; // Files currently attached to the input
    let currentUser = null;
    let currentController = null; // For aborting fetch requests

    let chatsUnsubscribe = null;
    let messagesUnsubscribe = null;

    window.addEventListener('DOMContentLoaded', () => {
        const cosmos = $('cosmos-container');
        const chatView = $('chat-viewport');
        const userInput = $('userInput');
        const sendBtn = $('sendBtn');
        const stopBtn = $('stopBtn');
        const chatFile = $('chatFile');
        const filePreview = $('filePreview');
        const emojiPanel = $('emojiPanel');
        const emojiBtn = $('emojiBtn');
        const suggestions = $('suggestions');

        // UI Elements for previous functionality
        const openProfileMenu = $('openProfileMenu');
        const profileMenuBg = $('profileMenuBg');
        const profileMenu = $('profileMenu');
        const openLinksMenu = $('openLinksMenu');
        const linkMenuBg = $('linkMenuBg');
        const linkMenu = $('linkMenu');
        const toolBtn = $('toolBtn');
        const toolsMenuBg = $('toolsMenuBg');
        const toolsMenu = $('toolsMenu');
        const toolFormModalBg = $('toolFormModalBg');
        const toolFormModal = $('toolFormModal');
        const toolForm = $('toolForm');
        const toolFormTitle = $('toolFormTitle');
        const toolFormBackBtn = $('toolFormBackBtn');
        const aiPrevBox = $('ai-image-preview');
        const aiPrevClose = $('ai-image-close');
        const aiPrevDLBtn = $('ai-image-dl');
        const aiPrevImgBox = $('ai-image-container');
        const themeBtn = $('themeBtn');
        const lightbox = $('lightbox');
        const callBtn = $('callBtn');
        const callModal = $('callModal');
        const endCallBtn = $('endCallBtn');
        const muteCallBtn = $('muteCallBtn');
        const callConversation = $('callConversation');
        const botImageContainer = $('botImageContainer');
        const callStatusMessage = $('callStatusMessage');
        const tapToTalk = $('tapToTalk');
        const profileMenuUser = $('profileMenuUser');
        const profileMenuEmail = $('profileMenuEmail');
        const editName = $('edit-name');
        const editPhoto = $('edit-photo');
        const profilePicPreview = $('profilePicPreview');
        const profileForm = $('profileForm');
        const logoutBtn = $('logoutBtn');
        const chatsListEl = $('chatsList');
        const newChatBtn = $('newChatBtn');
        const cosmicWhisperLog = $('cosmic-whisper-log');
        const botAvatarHeader = $('bot-avatar-header');


        // --- COSMIC BACKGROUND ENGINE JS ---
        function createParticle(type, spread, maxDuration, sizeMin, sizeMax, colorClass = '') {
            const particle = document.createElement('div');
            particle.className = `${type} ${colorClass}`;
            const size = Math.random() * (sizeMax - sizeMin) + sizeMin;
            particle.style.width = `${size}px`; particle.style.height = `${size}px`;
            particle.style.left = `${Math.random() * spread}%`;
            particle.style.top = `${Math.random() * spread}%`;
            particle.style.setProperty('--duration', `${Math.random() * maxDuration + 5}s`);
            if(type==='star') particle.style.opacity = Math.random() * 0.7 + 0.3; // Stars always visible
            if(type==='stardust') particle.style.setProperty('--translateX', `${Math.random() * 200 - 100}px`); // Random X drift
            if(type==='energy-particle') {
                particle.style.width = `${size * 5}px`; particle.style.height = `${size * 5}px`;
                particle.style.opacity = Math.random() * 0.2;
            }
            cosmos.appendChild(particle);
        }

        function igniteCosmos() {
            // 1. Static distant stars (more dense)
            for (let i = 0; i < 250; i++) {
                const rand = Math.random();
                if (rand < 0.33) createParticle('star', 100, 3, 0.5, 2.5);
                else if (rand < 0.66) createParticle('star', 100, 4, 0.8, 3, 'blue-tint');
                else createParticle('star', 100, 5, 0.6, 2.8, 'purple-tint');
            }
            // 2. Floating Stardust (closer layer)
            for (let i = 0; i < 100; i++) {
               createParticle('stardust', 100, 20, 0.5, 1.5);
            }
            // 3. Ethereal Energy Particles (slow pulse)
            for (let i = 0; i < 50; i++) {
                createParticle('energy-particle', 100, 15, 2, 5);
            }
        }

        function launchShootingStar() {
            const star = document.createElement('div');
            star.className = 'shooting-star';
            const startX = Math.random() * window.innerWidth * 1.5;
            const startY = -100;
            const endX = Math.random() * -800 - 400; // Random end X offset
            const endY = Math.random() * 800 + 400;  // Random end Y offset
            const rotation = Math.random() * 60 - 30; // Random rotation angle
            star.style.setProperty('--startX', `${startX}px`);
            star.style.setProperty('--startY', `${startY}px`);
            star.style.setProperty('--endX', `${endX}px`);
            star.style.setProperty('--endY', `${endY}px`);
            star.style.setProperty('--rotation', `${rotation}deg`);
            star.style.setProperty('--duration', `${Math.random() * 2 + 2.5}s`);

            cosmos.appendChild(star);
            setTimeout(() => star.remove(), (parseFloat(star.style.getPropertyValue('--duration')) * 1000) + 100);
        }

        function launchCosmicEagle() {
            const eagle = document.createElement('img');
            eagle.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="%2300f2ff" d="M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 22.8-15.6 32.7c-2.1 3.5-5.3 6.5-9.1 8.6l-49.6 28.8c-11.8 6.9-26.2 6-37.4-2.2l-33.8-25.7c-3.7 7.5-7.7 14.8-12.1 21.9c-2.1 3.2-4.8 6.1-7.9 8.3l-48.4 34.7c-11 7.9-25.9 7.4-36.2-1.4l-31.5-28.8c-3.1 4-6.5 7.7-10.2 11.1c-1.3 1.4-2.8 2.7-4.3 3.9l-45.7 37.9c-10.5 8.7-25.4 9.1-36.4 1l-35.3-25.2c-3.7 3.5-7.6 6.8-11.8 9.7c-1.8 1.2-3.6 2.4-5.5 3.4l-44.5 25.6c-11.8 6.8-26.2 6-37.4-2.2l-33.8-25.7c-3.7 7.5-7.7 14.8-12.1 21.9c-2.1 3.2-4.8 6.1-7.9 8.3l-48.4 34.7c-11 7.9-25.9 7.4-36.2-1.4l-31.5-28.8c-3.1 4-6.5 7.7-10.2 11.1c-1.3 1.4-2.8 2.7-4.3 3.9l-45.7 37.9c-10.5 8.7-25.4 9.1-36.4 1l-35.3-25.2c-3.7 3.5-7.6 6.8-11.8 9.7c-1.8 1.2-3.6 2.4-5.5 3.4L3.8 300.6C-2.4 293.4-.8 281.3 5.4 274.1L48.8 235.3c-1.1-8.3-1.7-16.8-1.7-25.4s.6-17.1 1.7-25.4L5.4 150.7C-2.4 143.4-.8 131.3 3.8 124.1l43.3-39.4c-1.1-8.3-1.7-16.8-1.7-25.4s.6-17.1 1.7-25.4L3.8 21.4c6.2-7.2 18.3-8.8 25.5-2.6l49.6 28.8c11.8 6.9 26.2 6 37.4-2.2l33.8-25.7c3.7 7.5 7.7 14.8 12.1 21.9c2.1 3.2 4.8 6.1 7.9 8.3l48.4 34.7c11 7.9 25.9 7.4 36.2-1.4l31.5-28.8c3.1 4 6.5 7.7 10.2 11.1c1.3 1.4 2.8 2.7 4.3 3.9l45.7 37.9c10.5 8.7 25.4 9.1 36.4 1l35.3-25.2c3.7 3.5 7.6 6.8 11.8 9.7c1.8 1.2 3.6 2.4 5.5 3.4l44.5 25.6c11.8 6.8 26.2 6 37.4-2.2l33.8-25.7c3.7 7.5 7.7 14.8 12.1 21.9c2.1 3.2 4.8 6.1 7.9 8.3l48.4 34.7c11 7.9 25.9 7.4 36.2-1.4l31.5-28.8c3.1 4 6.5 7.7 10.2 11.1c1.3 1.4 2.8 2.7 4.3 3.9l45.7 37.9c10.5 8.7 25.4 9.1 36.4 1l35.3-25.2c3.7 3.5 7.6 6.8 11.8 9.7c1.8 1.2 3.6 2.4 5.5 3.4l44.5 25.6c6.2 7.2 18.3 8.8 25.5 2.6L495.9 166.6zM256 160c-26.5 0-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48s-21.5-48-48-48zM192 320c-17.7 0-32 14.3-32 32s14.3 32 32 32h128c17.7 0 32-14.3 32-32s-14.3-32-32-32H192zM64 208a16 16 0 1 0 0-32 16 16 0 1 0 0 32zM448 208a16 16 0 1 0 0-32 16 16 0 1 0 0 32zM368 400a16 16 0 1 0 0-32 16 16 0 1 0 0 32zM144 400a16 16 0 1 0 0-32 16 16 0 1 0 0 32z"/></svg>';
            eagle.alt = 'Cosmic Eagle';
            eagle.className = 'cosmic-eagle';
            const startY = Math.random() * (window.innerHeight - 100) + 50; // Ensure it's not off screen
            const scale = Math.random() * 0.4 + 0.3; // 30-70% of original size
            eagle.style.setProperty('--startY', `${startY}px`);
            eagle.style.setProperty('--scale', `${scale}`);
            eagle.style.setProperty('--duration', `${Math.random() * 10 + 20}s`); // Longer flight duration
            cosmos.appendChild(eagle);
            setTimeout(() => eagle.remove(), (parseFloat(eagle.style.getPropertyValue('--duration')) * 1000) + 100);
        }

        igniteCosmos();
        setInterval(launchShootingStar, Math.random() * 5000 + 3000); // 3-8 seconds
        setInterval(launchCosmicEagle, Math.random() * 15000 + 15000); // 15-30 seconds


        // --- CHAT JS ---
        const autoResize = () => {
            userInput.style.height = 'auto';
            userInput.style.height = Math.min(userInput.scrollHeight, 120) + 'px'; // Max height 120px
            if (userInput.scrollHeight > 120) {
                 userInput.style.overflowY = 'scroll';
            } else {
                 userInput.style.overflowY = 'hidden';
            }
        };
        userInput.addEventListener('input', autoResize);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            } else if (e.key === 'Enter' && e.shiftKey) {
                // Allow Shift+Enter for new line in textarea
            }
        });
        autoResize(); // Initial resize

        // Emoji Panel Logic
        const emojis = ["ðŸ˜€","ðŸ˜‚","ðŸ˜","ðŸ¥°","ðŸ˜Ž","ðŸ‘","ðŸ™","ðŸ”¥","ðŸ’¯","ðŸŽ‰","ðŸ˜‡","ðŸ¤–","ðŸ‘€"];
        emojiBtn.addEventListener('click', (e) => {
            emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
            emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block';
            try {
                const rect = emojiBtn.getBoundingClientRect();
                emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
            } catch (e) { /* ignore positioning errors */ }
            emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
                span.addEventListener('click', function () {
                    const text = this.textContent || '';
                    const start = userInput.selectionStart || 0;
                    const end = userInput.selectionEnd || 0;
                    userInput.value = userInput.value.slice(0, start) + text + userInput.value.slice(end);
                    userInput.focus();
                    userInput.selectionStart = userInput.selectionEnd = start + text.length;
                    emojiPanel.style.display = 'none';
                    userInput.dispatchEvent(new Event('input')); // Trigger autoResize
                });
            });
        });
        document.addEventListener('click', e => {
            if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
                emojiPanel.style.display = 'none';
            }
        });


        // File Attachment Logic
        chatFile.addEventListener('change', function() {
            uploadedFiles = Array.from(this.files || []);
            renderFilePreview();
        });

        function renderFilePreview() {
            if (!filePreview) return;
            if (!uploadedFiles.length) {
                filePreview.style.display = 'none';
                filePreview.innerHTML = '';
                return;
            }
            filePreview.style.display = 'flex'; // Use flex for gap
            filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                let preview = '';
                if (file.type.startsWith('image/')) {
                    preview = `<img src="${URL.createObjectURL(file)}" alt="preview">`;
                } else if (file.type.startsWith('video/')) {
                    preview = `<video src="${URL.createObjectURL(file)}" controls></video>`;
                } else if (file.type.startsWith('audio/')) {
                    preview = `<audio controls src="${URL.createObjectURL(file)}"></audio>`;
                } else if (file.type === 'application/pdf') {
                    preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`;
                }
                return `
                    <div class="file-item">
                        ${preview}
                        <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span>
                        <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
                    </div>`;
            }).join('');

            filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.getAttribute('data-idx'));
                    uploadedFiles.splice(idx, 1);
                    if (!uploadedFiles.length && chatFile) chatFile.value = '';
                    renderFilePreview();
                });
            });
        }


        // Universal UI Management (Profile, Links, Tools)
        openProfileMenu.addEventListener('click', () => {
            profileMenuBg.classList.add('active');
            profileMenu.classList.add('active');
        });
        profileMenuBg.addEventListener('click', (e) => {
            if (e.target === profileMenuBg) {
                profileMenu.classList.remove('active');
                profileMenuBg.classList.remove('active');
            }
        });

        openLinksMenu.addEventListener('click', () => {
            linkMenuBg.classList.add('active');
            linkMenu.classList.add('active');
        });
        linkMenuBg.addEventListener('click', (e) => {
            if (e.target === linkMenuBg) {
                linkMenu.classList.remove('active');
                linkMenuBg.classList.remove('active');
            }
        });

        window.closeToolMenu = () => { // Made global for onclick from tool form
            toolsMenu.classList.remove('active');
            toolsMenuBg.classList.remove('active');
        };
        const openToolMenu = () => {
            toolsMenuBg.classList.add('active');
            toolsMenu.classList.add('active');
        };
        toolBtn.addEventListener('click', openToolMenu);
        toolsMenuBg.addEventListener('click', (e) => {
            if (e.target === toolsMenuBg) closeToolMenu();
        });

        if (toolFormBackBtn) {
            toolFormBackBtn.addEventListener('click', () => {
                toolFormModal.classList.remove('active');
                toolFormModalBg.classList.remove('active');
                openToolMenu();
            });
        }
        if (toolFormModalBg) toolFormModalBg.addEventListener('click', e => {
            if (e.target === toolFormModalBg) {
                toolFormModal.classList.remove('active');
                toolFormModalBg.classList.remove('active');
            }
        });


        // Firebase Authentication and Chat Loading
        logoutBtn.addEventListener('click', () => {
            signOut(auth);
            window.location.href = 'signup-login.html';
        });

        onAuthStateChanged(auth, user => {
            if (!user) {
                try {
                    window.location.href = "signup-login.html";
                } catch (e) { /* ignore if already redirected */ }
                return;
            }
            currentUser = user;
            // if (headerWelcome) headerWelcome.textContent = "Welcome, " + (user.displayName || (user.email || '').split('@'));
            if (profileMenuUser) profileMenuUser.textContent = user.displayName || "User";
            if (profileMenuEmail) profileMenuEmail.textContent = user.email || "";
            if (editName) editName.value = user.displayName || "";
            if (editPhoto) editPhoto.value = user.photoURL || "";
            if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";
            loadUserChats(user.uid);
        });

        profileForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!currentUser) return;
            const status = $('profileStatusMsg');
            if (status) status.textContent = 'Saving...';
            try {
                await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
                if (auth.currentUser) await auth.currentUser.reload();
                if (status) {
                    status.textContent = "Profile updated!";
                    status.style.color = "var(--neon-green)";
                }
                setTimeout(() => {
                    profileMenuBg.classList.remove('active');
                    profileMenu.classList.remove('active');
                }, 800);
                // if (headerWelcome) headerWelcome.textContent = "Welcome, " + (auth.currentUser?.displayName || 'User');
            } catch (err) {
                if (status) {
                    status.textContent = err.message;
                    status.style.color = "#ffdd00";
                }
            }
        });

        async function loadUserChats(userId) {
            if (chatsUnsubscribe) chatsUnsubscribe();
            const chatsCol = collection(db, 'users', userId, 'chats');
            const q = query(chatsCol, orderBy('createdAt', 'desc'));
            chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                if (snapshot.empty) {
                    await createNewChat(userId);
                    return;
                }
                chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderChatsListSidebar();
                if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                    currentChatId = chats.id;
                }
                subscribeToMessages(userId, currentChatId);
            }, (error) => {
                console.error("Error fetching chats: ", error);
                chatsListEl.innerHTML = `<div style="color: #f44;">Error loading chats.</div>`;
            });
        }

        async function createNewChat(userId) {
            if (!userId) userId = currentUser?.uid;
            if (!userId) return;
            const chatsCol = collection(db, 'users', userId, 'chats');
            try {
                const newChatDoc = await addDoc(chatsCol, { name: "New Chat", createdAt: serverTimestamp() });
                currentChatId = newChatDoc.id;
            } catch (e) {
                console.error("Error creating new chat: ", e);
            }
        }

        function subscribeToMessages(userId, chatId) {
            if (messagesUnsubscribe) messagesUnsubscribe();
            if (!userId || !chatId) {
                renderChatBox([]);
                return;
            }
            const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
            const q = query(messagesCol, orderBy('createdAt'));
            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderChatBox(currentMessages);
            }, (error) => {
                console.error("Error fetching messages: ", error);
                chatView.innerHTML = `<div style="color: #f44; text-align: center; margin-top: 20px;">Error loading messages for this chat.</div>`;
            });
        }

        newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));

        function renderChatsListSidebar() {
            if (!chatsListEl) return;
            chatsListEl.innerHTML = '';
            if (chats.length === 0) {
                chatsListEl.innerHTML = `<div style="padding: 10px; color: rgba(168, 234, 255, 0.7);">No chats yet.</div>`;
                return;
            }
            chats.forEach((chat) => {
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.alignItems = 'center';
                container.style.marginBottom = '6px';
                container.style.background = chat.id === currentChatId ? 'rgba(0, 234, 255, 0.15)' : 'transparent';
                container.style.borderRadius = '8px';

                const titleSpan = document.createElement('span');
                titleSpan.textContent = chat.name || `Chat`;
                titleSpan.style.flex = '1';
                titleSpan.style.cursor = 'pointer';
                titleSpan.style.padding = '8px 5px';
                titleSpan.onclick = () => {
                    currentChatId = chat.id;
                    subscribeToMessages(currentUser.uid, currentChatId);
                    renderChatsListSidebar();
                    profileMenu.classList.remove('active');
                    profileMenuBg.classList.remove('active');
                };

                const renameBtn = document.createElement('button');
                renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                renameBtn.title = 'Rename';
                renameBtn.style.margin = '0 6px 0 8px';
                renameBtn.className = 'chat-action-btn'; // New class for consistent styling
                renameBtn.style.color = 'var(--neon-blue)';
                renameBtn.onclick = async (e) => {
                    e.stopPropagation();
                    const newName = prompt("Rename chat:", chat.name);
                    if (newName && newName.trim()) {
                        const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                        await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
                    }
                };

                const delBtn = document.createElement('button');
                delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                delBtn.title = 'Delete';
                delBtn.style.marginLeft = '6px';
                delBtn.className = 'chat-action-btn'; // New class for consistent styling
                delBtn.style.color = '#ff4d4d';
                delBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!confirm(`Delete "${chat.name}"? This will delete all messages.`)) return;

                    const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                    const messagesSnap = await getDocs(messagesCol);
                    const batch = writeBatch(db);
                    messagesSnap.docs.forEach(d => batch.delete(d.ref));
                    await batch.commit();

                    const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                    await deleteDoc(chatDoc);

                    if (currentChatId === chat.id) {
                        currentChatId = null;
                    }
                };

                container.appendChild(titleSpan);
                container.appendChild(renameBtn);
                container.appendChild(delBtn);
                chatsListEl.appendChild(container);
            });
        }

        const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

        function inlineMarkdown(t = '') {
            let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code class="inline-code">${escapeHTML(a)}</code>`);
            s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
            s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            return s.replace(/\n/g, '<br>');
        }

        // Modified renderMarkdown to return structured data for typing animation
        function renderMarkdownStructure(text = '') {
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            const segments = [];
            let lastIndex = 0;
            text = text || '';

            text.replace(codeBlockRegex, (match, lang, code, offset) => {
                const before = text.slice(lastIndex, offset);
                if (before) segments.push({ type: 'text', content: before });

                segments.push({ type: 'code', lang: (lang || '').toLowerCase().trim(), content: code });
                lastIndex = offset + match.length;
                return match;
            });

            const after = text.slice(lastIndex);
            if (after) segments.push({ type: 'text', content: after });

            return segments;
        }

        function enhanceCodeBlocks(container) {
            if (!container) return;
            container.querySelectorAll('pre').forEach(pre => {
                const codeEl = pre.querySelector('code');
                if (window.hljs && codeEl) {
                    try { hljs.highlightElement(codeEl); } catch (e) { console.warn("Highlight.js failed:", e); }
                }
                const btn = pre.querySelector('.copy-btn');
                if (btn && codeEl) {
                    btn.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard.writeText(codeEl.innerText);
                            const prev = btn.innerHTML;
                            btn.innerHTML = 'Copied!';
                            setTimeout(() => btn.innerHTML = prev, 800);
                        } catch (e) {
                            btn.innerHTML = 'Failed';
                            setTimeout(() => btn.innerHTML = 'Copy', 800);
                        }
                    });
                }
            });
        }

        function renderChatBox(messages = []) {
            if (!chatView) return;
            chatView.innerHTML = '';
            (messages || []).forEach((msg) => {
                const div = document.createElement('div');
                div.className = 'message-group ' + (msg.role === 'user' ? 'user' : 'ai');
                div.setAttribute('data-message-id', msg.id);

                let contentHtml = '';

                if (msg.role === 'user') {
                    const fileHtml = (msg.files || [])
                        .map(file => {
                            let icon = 'fa-file';
                            if (file.type.startsWith('image/')) icon = 'fa-file-image';
                            else if (file.type.startsWith('video/')) icon = 'fa-file-video';
                            else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
                            else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                            return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                        })
                        .join('');

                    contentHtml = `
                        ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                        ${inlineMarkdown(msg.text || '')}
                        <div class="message-controls">
                            <button class="edit-msg-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i></button>
                            <button class="copy-msg-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                        </div>
                    `;
                } else {
                    // For AI messages, if it contains special HTML (like media tags), render directly
                    if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                        contentHtml = msg.text;
                    } else {
                        // Otherwise, process markdown
                        const segments = renderMarkdownStructure(msg.text || '');
                        contentHtml = segments.map(segment => {
                            if (segment.type === 'text') {
                                return inlineMarkdown(segment.content);
                            } else if (segment.type === 'code') {
                                return `<pre class="shining"><button class="copy-btn">Copy</button><code class="language-${segment.lang || 'plaintext'}">${escapeHTML(segment.content)}</code></pre>`;
                            }
                            return '';
                        }).join('');
                    }

                    contentHtml += `
                        <div class="message-controls">
                            <button class="copy-msg-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                            <button class="share-msg-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                            <button class="regen-msg-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                        </div>
                    `;
                }

                div.innerHTML = `<div class="msg-bubble">${contentHtml}</div>`;
                chatView.appendChild(div);
            });
            enhanceCodeBlocks(chatView);
            hookMessageControls();
            setTimeout(() => {
                chatView.scrollTop = chatView.scrollHeight;
            }, 50);
        }

        async function deleteMessagesFrom(messageId) {
            if (!currentChatId || !currentUser) return;
            const msgIndex = currentMessages.findIndex(m => m.id === messageId);
            if (msgIndex === -1) return;
            const batch = writeBatch(db);
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            for (let i = msgIndex; i < currentMessages.length; i++) {
                const msgToDel = currentMessages[i];
                const docRef = doc(messagesCol, msgToDel.id);
                batch.delete(docRef);
            }
            try {
                await batch.commit();
            } catch (e) {
                console.error("Error deleting messages: ", e);
            }
        }

        function hookMessageControls() {
            if (!chatView) return;
            chatView.querySelectorAll('.message-group').forEach(groupDiv => {
                const messageId = groupDiv.getAttribute('data-message-id');
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;

                const controls = groupDiv.querySelector('.message-controls');
                if (!controls) return;

                const copyBtn = controls.querySelector('.copy-msg-btn');
                const editBtn = controls.querySelector('.edit-msg-btn');
                const shareBtn = controls.querySelector('.share-msg-btn');
                const regenBtn = controls.querySelector('.regen-msg-btn');

                if (copyBtn) copyBtn.onclick = () => {
                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.text; // Use raw msg.text to copy markdown for accurate representation
                        const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                        navigator.clipboard.writeText(textToCopy);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                    } catch (e) {
                        console.warn('copy failed', e);
                    }
                };

                if (editBtn) editBtn.onclick = async () => {
                    try {
                        if (!msg.text) return;
                        userInput.value = msg.text;
                        userInput.focus();
                        autoResize();
                        await deleteMessagesFrom(messageId);
                    } catch (e) {
                        console.warn('edit failed', e);
                    }
                };

                if (shareBtn) shareBtn.onclick = () => {
                    try {
                        const url = window.location.origin;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.text;
                        const plainText = tempDiv.textContent || tempDiv.innerText || '';
                        const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;
                        if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
                        else prompt("Copy and share manually:", shareText);
                    } catch (e) {
                        console.warn('share failed', e);
                    }
                };

                if (regenBtn) regenBtn.onclick = async () => {
                    const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                    if (msgIndex < 1) return; // Cannot regenerate first message
                    const userMsg = currentMessages[msgIndex - 1];
                    if (userMsg.role !== 'user') return;

                    await deleteMessagesFrom(messageId);
                    userInput.value = userMsg.text;
                    autoResize();
                    uploadedFiles = [];
                    renderFilePreview();

                    showTypingIndicator('Regenerating response...');

                    const historyForRegen = currentMessages
                        .slice(0, msgIndex - 1)
                        .map(m => ({ role: m.role, content: m.text || '' }));

                    try {
                        const res = await fetch(`${API_BASE_URL}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: userMsg.text, history: historyForRegen, user_id: currentUser?.uid || "user" })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || "Server error.");
                        hideTypingIndicator();
                        await startTypewriter(data.response, false);
                    } catch (err) {
                        hideTypingIndicator();
                        await startTypewriter(`âŒ Regeneration error: ${err.message}`, false);
                    }
                };
            });
        }


        let typingTimeout;
        function showTypingIndicator(text = 'Philadelphia AI is thinking...') {
            let typingStatusEl = chatView.querySelector('.typing-indicator');
            if (!typingStatusEl) {
                typingStatusEl = document.createElement('div');
                typingStatusEl.className = 'typing-indicator';
                chatView.appendChild(typingStatusEl);
            }
            typingStatusEl.innerHTML = `<span class="spinner"></span> <span style="margin-left:8px; color:var(--neon-blue); font-style:italic;">${text}</span>`;
            chatView.scrollTop = chatView.scrollHeight;
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => { // Hide if no response after a long time
                if (typingStatusEl && typingStatusEl.parentNode) {
                    typingStatusEl.parentNode.removeChild(typingStatusEl);
                }
            }, 30000); // 30 seconds
        }

        function hideTypingIndicator() {
            const typingStatusEl = chatView.querySelector('.typing-indicator');
            if (typingStatusEl && typingStatusEl.parentNode) {
                typingStatusEl.parentNode.removeChild(typingStatusEl);
            }
            clearTimeout(typingTimeout);
        }

        async function startTypewriter(text, saveToDb = true) {
            if (!chatView) return;

            // Handle special media HTML directly
            if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) {
                const finalContent = text + `
                    <div class="message-controls">
                        <button class="copy-msg-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                        <button class="share-msg-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                        <button class="regen-msg-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                    </div>
                `;
                const tempDiv = document.createElement('div');
                tempDiv.className = "message-group ai";
                tempDiv.innerHTML = `<div class="msg-bubble">${finalContent}</div>`;
                chatView.appendChild(tempDiv);
                chatView.scrollTop = chatView.scrollHeight;
                hookMessageControls();
                if (saveToDb) {
                    await addMessageToChat('ai', text);
                } else {
                    const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                    try {
                        await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
                    } catch (e) {
                        console.error("Error saving regenerated AI tool message: ", e);
                    }
                }
                return;
            }

            const div = document.createElement('div');
            div.className = "message-group ai";
            const msgBubble = document.createElement('div');
            msgBubble.className = 'msg-bubble';
            div.appendChild(msgBubble);
            chatView.appendChild(div);

            const segments = renderMarkdownStructure(text);
            let currentText = '';
            let currentCodeBlock = null;

            for (const segment of segments) {
                if (currentController?.signal.aborted) {
                    // Truncate text if aborted
                    if (currentCodeBlock) {
                        currentText += `\`\`\`${currentCodeBlock.lang}\n${currentCodeBlock.content}\n\`\`\``;
                    }
                    break;
                }

                if (segment.type === 'text') {
                    for (const char of segment.content) {
                        if (currentController?.signal.aborted) break;
                        currentText += char;
                        msgBubble.innerHTML = inlineMarkdown(currentText);
                        chatView.scrollTop = chatView.scrollHeight;
                        await new Promise(res => setTimeout(res, 10));
                    }
                } else if (segment.type === 'code') {
                    // Type out code block markers first
                    currentText += `\`\`\`${segment.lang}\n`;
                    msgBubble.innerHTML = inlineMarkdown(currentText);
                    chatView.scrollTop = chatView.scrollHeight;
                    await new Promise(res => setTimeout(res, 50)); // Small delay for marker
                    
                    // Prepare pre and code elements for typing
                    const preElement = document.createElement('pre');
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'copy-btn';
                    copyBtn.textContent = 'Copy';
                    preElement.appendChild(copyBtn);
                    const codeElement = document.createElement('code');
                    codeElement.className = `language-${segment.lang || 'plaintext'}`;
                    preElement.appendChild(codeElement);
                    msgBubble.appendChild(preElement); // Append the structured code block

                    // Type out code content
                    let codeContentTyped = '';
                    for (const char of segment.content) {
                        if (currentController?.signal.aborted) break;
                        codeContentTyped += char;
                        codeElement.textContent = codeContentTyped;
                        chatView.scrollTop = chatView.scrollHeight;
                        await new Promise(res => setTimeout(res, 8)); // Faster for code
                    }

                    // After typing all code, apply highlighting and shining effect
                    if (window.hljs) {
                        try { hljs.highlightElement(codeElement); } catch (e) { console.warn("Highlight.js failed:", e); }
                    }
                    preElement.classList.add('shining'); // Add shining animation
                    // Hook copy button for this specific code block
                    copyBtn.onclick = async () => {
                        try {
                            await navigator.clipboard.writeText(codeElement.innerText);
                            const prev = copyBtn.textContent;
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => copyBtn.textContent = prev, 800);
                        } catch (e) {
                            copyBtn.textContent = 'Failed';
                            setTimeout(() => copyBtn.textContent = 'Copy', 800);
                        }
                    };

                    // Append closing backticks
                    currentText += `${segment.content}\n\`\`\``;
                    // Note: currentText now holds the typed markdown, but msgBubble innerHTML will be updated to reflect final segments
                }
            }

            // Final render to ensure all markdown is processed and controls are added
            msgBubble.innerHTML = segments.map(segment => {
                if (segment.type === 'text') {
                    return inlineMarkdown(segment.content);
                } else if (segment.type === 'code') {
                    return `<pre class="shining"><button class="copy-btn">Copy</button><code class="language-${segment.lang || 'plaintext'}">${escapeHTML(segment.content)}</code></pre>`;
                }
                return '';
            }).join('') + `
                <div class="message-controls">
                    <button class="copy-msg-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                    <button class="share-msg-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                    <button class="regen-msg-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                </div>
            `;

            enhanceCodeBlocks(msgBubble); // Ensure all final code blocks are highlighted and have copy buttons
            chatView.scrollTop = chatView.scrollHeight;
            hookMessageControls(); // Re-hook controls after final render

            if (saveToDb) {
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
                } catch (e) {
                    console.error("Error saving AI message: ", e);
                    msgBubble.innerHTML += "<br><small style='color: #f44;'>Failed to save message.</small>";
                }
            }
        }

        async function addMessageToChat(role, text, files = []) {
            if (!currentChatId || !currentUser) return;
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            try {
                await addDoc(messagesCol, { role, text, files, createdAt: serverTimestamp() });
            } catch (e) {
                console.error("Error adding message to Firestore: ", e);
            }
        }

        sendBtn.addEventListener('click', sendMessage);
        suggestions.addEventListener('click', (e) => {
            const chip = e.target.closest('.chip');
            if (chip) {
                // Animate chip on click
                chip.style.transform = 'translateY(2px) scale(0.95)';
                chip.style.opacity = '0.7';
                setTimeout(() => {
                    userInput.value = chip.textContent; // Use textContent for plain text
                    sendMessage();
                    suggestions.style.display = 'none'; // Hide suggestions after use
                    chip.style.transform = ''; // Reset animation
                    chip.style.opacity = '';
                }, 150);
            }
        });


        async function sendMessage() {
            if (!currentChatId) {
                alert("Please select a chat or create a new one.");
                return;
            }
            const msgText = userInput.value.trim();
            if (!msgText && uploadedFiles.length === 0) return;

            // Swap Send button with Stop button
            sendBtn.style.display = 'none';
            stopBtn.style.display = 'flex';
            currentController = new AbortController();
            const signal = currentController.signal;
            let finalResponse = '';

            stopBtn.onclick = () => {
                if (currentController) {
                    currentController.abort();
                    currentController = null; // Clear controller
                    hideTypingIndicator();
                    // Restore send button
                    stopBtn.style.display = 'none';
                    sendBtn.style.display = 'flex';
                }
            };

            const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
            await addMessageToChat('user', msgText, filesForHistory);
            const localUploadedFiles = [...uploadedFiles]; // Capture current files
            userInput.value = '';
            uploadedFiles = [];
            renderFilePreview();
            autoResize(); // Reset textarea height

            if (localUploadedFiles.length > 0) {
                showTypingIndicator('Analyzing cosmic data streams...');
                let endpoint = '';
                const file = localUploadedFiles[0]; // Assuming only one file for direct analysis APIs
                if (file.type.startsWith('image/')) endpoint = '/understand-image';
                else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                else {
                    hideTypingIndicator();
                    finalResponse = "Sorry, I cannot process that file type in this dimension.";
                }
                try {
                    if(endpoint) {
                        const fd = new FormData();
                        fd.append('prompt', msgText || `Analyze this ${file.type.split('/')[0]} data packet`);
                        fd.append('file', file);
                        const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || "Cosmic analysis failed.");
                        finalResponse = data.response;
                    }
                } catch (err) {
                    finalResponse = err.name === 'AbortError' ? 'âŒ Data analysis interrupted.' : `âŒ Cosmic data analysis failed: ${err.message}`;
                }
            } else if (msgText) {
                showTypingIndicator('Establishing quantum link...');
                try {
                    const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }),
                        signal
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "Cosmic link unstable.");
                    finalResponse = data.response;
                } catch (err) {
                    finalResponse = err.name === 'AbortError' ? 'âŒ Quantum transmission aborted.' : `âŒ A cosmic disturbance occurred: ${err.message}`;
                }
            }

            hideTypingIndicator();
            if (finalResponse) {
                await startTypewriter(finalResponse);
            }

            // Restore Send button
            stopBtn.style.display = 'none';
            sendBtn.style.display = 'flex';
            currentController = null;
        }

        // --- AI Tools Definitions ---
        const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
        const toolDefinitions = {
            "image": {
                title: "Generate Image",
                description: "Create stunning visuals from a text prompt. Choose a model for different results.",
                buildForm: () => `
                    <label for="tool-provider">Generation Model</label>
                    <select id="tool-provider"><option value="thena">Version 1 (Stylized, Fast & Recommended)</option><option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option></select>
                    <label for="tool-prompt">Image Prompt</label>
                    <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required></textarea>
                    <label for="tool-style">Style (for Version1 only)</label>
                    <select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate</button>`,
                handleSubmit: async (form) => {
                    const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                    const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)';
                    const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
                    await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                    showTypingIndicator('Generating your cosmic image...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/generate-image`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                        hideTypingIndicator();
                        await addMessageToChat('ai', 'âœ… Image generated! Check the floating image box to view or download.');
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Image generation failed: ${err.message}`;
                    }
                }
            },
            "edit-photo": {
                title: "Edit Photo",
                description: "Upload a photo and describe the changes you want to make.",
                buildForm: () => `
                    <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required></textarea>
                    <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    const prompt = form.querySelector('#tool-prompt').value;
                    if (!file) return "Please select a file to edit.";
                    const fd = new FormData();
                    fd.append('file', file);
                    fd.append('prompt', prompt);
                    await addMessageToChat('user', `Photo edit request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                    showTypingIndicator('Applying cosmic enhancements to your photo...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error((await res.json()).error || 'Failed to edit photo.');
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob);
                        const imgHtml = `âœ… Photo edited successfully! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
                        hideTypingIndicator();
                        await addMessageToChat('ai', imgHtml);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Photo edit failed: ${err.message}`;
                    }
                }
            },
            "remove-bg": {
                title: "Remove Background",
                description: "Select an image file to automatically remove its background.",
                buildForm: () => `
                    <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;">
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Remove Background</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    if (!file) return "Please select a file.";
                    await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                    showTypingIndicator('Calibrating background removal algorithms...');
                    const fd = new FormData();
                    fd.append('file', file);
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const imgHtml = `âœ… Background removed! <br><img src="${url}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                        hideTypingIndicator();
                        await addMessageToChat('ai', imgHtml);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Background removal failed: ${err.message}`;
                    }
                }
            },
            "comic": {
                title: "Create Comic",
                description: "Write a story and watch it transform into a cosmic comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.",
                buildForm: () => `
                    <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required></textarea>
                    <label for="tool-style">Comic Style</label><select id="tool-style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
                    <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" />
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Create Comic</button>`,
                handleSubmit: async (form) => {
                    const payload = {
                        story: form.querySelector('#tool-story').value,
                        style: form.querySelector('#tool-style').value,
                        panels: parseInt(form.querySelector('#tool-panels').value, 10),
                        user: currentUser?.displayName || "User"
                    };
                    await addMessageToChat('user', `Comic creation request with style: ${payload.style}.`);
                    showTypingIndicator('Drawing cosmic narrative panels...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join('');
                        const comicMessage = `ðŸ–¼ï¸ Comic successfully created! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                        hideTypingIndicator();
                        await addMessageToChat('ai', comicMessage);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Comic generation failed: ${err.message}`;
                    }
                }
            },
            "voice-gen": {
                title: "Voice Generation",
                description: "Transform text into realistic speech. Choose a provider and voice style.",
                buildForm: () => `
                    <label for="tool-provider">Voice Provider</label><select id="tool-provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
                    <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required></textarea>
                    <label for="tool-style">Voice Style</label><select id="tool-style"></select>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice</button>`,
                onFormReady: () => {
                    const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
                    const voices = {
                        gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                        minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                    };
                    const updateStyles = () => {
                        styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                    };
                    providerSelect.addEventListener('change', updateStyles);
                    updateStyles();
                },
                handleSubmit: async (form) => {
                    const provider = form.querySelector('#tool-provider').value,
                        text = form.querySelector('#tool-prompt').value,
                        style = form.querySelector('#tool-style').value;
                    const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';
                    await addMessageToChat('user', `Voice generation request using ${providerName}.`);
                    showTypingIndicator('Synthesizing vocal patterns...');
                    try {
                        let res;
                        if (provider === 'gemini') {
                            const fd = new FormData();
                            fd.append('text', text);
                            fd.append('style', style);
                            res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                        } else {
                            res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({ text, voice_id: style })
                            });
                        }
                        if (!res.ok) throw new Error(await res.text());
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const audioHtml = `ðŸ—£ï¸ Voice generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                        hideTypingIndicator();
                        await addMessageToChat('ai', audioHtml);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Voice generation failed: ${err.message}`;
                    }
                }
            },
            "audio-narration": {
                title: "Audio Narration",
                description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.",
                buildForm: () => `
                    <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;">
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    if (!file) return "Please select a file.";
                    await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                    showTypingIndicator('Analyzing and narrating document...');
                    const fd = new FormData();
                    fd.append('file', file);
                    fd.append('style', 'podcast');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const narrationHtml = `ðŸ—£ï¸ Narration generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                        hideTypingIndicator();
                        await addMessageToChat('ai', narrationHtml);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Audio narration failed: ${err.message}`;
                    }
                }
            },
            "video-text": {
                title: "Generate Video from Text",
                description: "Describe the video you want to create. This process can take a few minutes.",
                buildForm: () => `
                    <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required></textarea>
                    <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15">
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
                handleSubmit: async (form) => {
                    const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
                    await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
                    handleVideoGeneration(payload);
                    return null;
                }
            },
            "video-image": {
                title: "Generate Video from Image",
                description: "Upload a starting image and describe how you want to animate it.",
                buildForm: () => `
                    <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required></textarea>
                    <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#video-image-file').files[0];
                    if (!file) return "Please select an image.";
                    await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{name: file.name, type: file.type}]);
                    const fd = new FormData();
                    fd.append('prompt', form.querySelector('#video-image-prompt').value);
                    fd.append('file', file);
                    handleVideoGeneration(fd, true);
                    return null;
                }
            },
            "music": {
                title: "Generate Music",
                description: "Generate music from a prompt, lyrics, and optional reference audio. Thanks to MiniMax.",
                buildForm: () => `
                    <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required></textarea>
                    <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..."></textarea>
                    <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*">
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Music</button>`,
                handleSubmit: async (form) => {
                    const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
                    const refFile = form.querySelector('#music-ref').files[0];
                    await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
                    showTypingIndicator('Composing your cosmic symphony...');
                    try {
                        if (refFile) {
                            showTypingIndicator('Uploading reference audio first...');
                            const fd = new FormData();
                            fd.append('file', refFile);
                            const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                            const uploadData = await uploadRes.json();
                            if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed.");
                            if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                            if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                            showTypingIndicator('Reference uploaded. Composing music...');
                        }
                        const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const musicHtml = `ðŸŽµ Your music is ready! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                        hideTypingIndicator();
                        await addMessageToChat('ai', musicHtml);
                        return null;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Music generation failed: ${err.message}`;
                    }
                }
            },
            "website": {
                title: "Create Website",
                description: "Describe the website you want to build and get a live, working prototype.",
                buildForm: () => `
                    <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required></textarea>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Website</button>`,
                handleSubmit: async (form) => {
                    const prompt = form.querySelector('#website-prompt').value;
                    await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`);
                    showTypingIndicator('Building and deploying your stellar website...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ prompt, user_id: currentUser.uid })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        hideTypingIndicator();
                        return `ðŸŒ Website deployed successfully! [View here](${data.url})`;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Website creation failed: ${err.message}`;
                    }
                }
            },
            "edit-website": {
                title: "Edit Last Website",
                description: "Provide an instruction to modify the most recent website you created.",
                buildForm: () => `
                    <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required></textarea>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>`,
                handleSubmit: async (form) => {
                    const instruction = form.querySelector('#edit-instruction').value;
                    await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`);
                    showTypingIndicator('Editing and redeploying your celestial website...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ instruction, user_id: currentUser.uid })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        hideTypingIndicator();
                        return `âœï¸ Website updated successfully! [View new version here](${data.url})`;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Website edit failed: ${err.message}`;
                    }
                }
            },
            "my-sites": {
                isAction: true,
                runAction: async () => {
                    await addMessageToChat('user', 'Show me a list of my websites.');
                    showTypingIndicator('Fetching your galactic website manifest...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || 'Could not fetch sites.');
                        if (!data.sites || data.sites.length === 0) return "You haven't created any websites in this sector yet.";
                        const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank" style="color:var(--neon-blue);">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                        hideTypingIndicator();
                        return `Here are the websites you've manifested:\n${siteList}`;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Error fetching websites: ${err.message}`;
                    }
                }
            },
            "research-report": {
                title: "Research Report",
                description: "Generate a comprehensive research report in PDF format on any topic.",
                buildForm: () => `
                    <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required>
                    <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>`,
                handleSubmit: async (form) => {
                    const topic = form.querySelector('#research-topic').value;
                    await addMessageToChat('user', `Research report request on: "${topic}"`);
                    showTypingIndicator('Conducting deep-space research and compiling report...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ topic })
                        });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--neon-blue);font-weight:bold;">Download PDF Report</a>`;
                        hideTypingIndicator();
                        return `âœ… Research report on **${topic}** is ready! ${downloadLink}`;
                    } catch (err) {
                        hideTypingIndicator();
                        return `âŒ Research report failed: ${err.message}`;
                    }
                }
            },
        };

        if (toolsMenu) {
            toolsMenu.addEventListener('click', async (e) => {
                const toolLink = e.target.closest('.tool-link');
                if (!toolLink) return;
                e.preventDefault();
                const toolKey = toolLink.getAttribute('data-tool');
                const tool = toolDefinitions[toolKey];
                if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);
                closeToolMenu();
                if (tool.isAction) {
                    const result = await tool.runAction();
                    hideTypingIndicator();
                    if(result) await startTypewriter(result);
                } else {
                    displayToolForm(toolKey);
                }
            });
        }

        function displayToolForm(toolKey) {
            const tool = toolDefinitions[toolKey];
            if (!tool || !toolFormModalBg) return;
            toolFormTitle.textContent = tool.title;
            const descriptionHtml = tool.description ? `<div style="color:rgba(168, 234, 255, 0.7);font-size:.9em;margin-bottom:12px;">${tool.description}</div>` : '';
            toolForm.innerHTML = descriptionHtml + tool.buildForm();
            if (typeof tool.onFormReady === 'function') tool.onFormReady();

            toolForm.onsubmit = async (e) => {
                e.preventDefault();
                const submitButton = toolForm.querySelector('button[type="submit"]');
                const originalButtonContent = submitButton.innerHTML;
                submitButton.innerHTML = `<span class="spinner"></span> Processing...`;
                submitButton.disabled = true;
                toolFormModal.classList.remove('active');
                toolFormModalBg.classList.remove('active');
                const resultText = await tool.handleSubmit(toolForm);
                if (resultText) {
                    hideTypingIndicator();
                    await startTypewriter(resultText);
                }
                submitButton.innerHTML = originalButtonContent;
                submitButton.disabled = false;
            };
            toolFormModalBg.classList.add('active');
            toolFormModal.classList.add('active');
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        async function handleVideoGeneration(payload, isImageToVideo = false) {
            showTypingIndicator('Initiating video generation sequence...');
            try {
                const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
                const commonPayload = { model: "MiniMax-Hailuo-02", duration: payload.duration || 6, resolution: payload.resolution || "1080P" };
                let options;

                if (isImageToVideo) {
                    payload.append('model', commonPayload.model);
                    payload.append('duration', commonPayload.duration);
                    payload.append('resolution', commonPayload.resolution);
                    options = { method: 'POST', body: payload };
                } else {
                    const finalPayload = { ...payload, ...commonPayload };
                    options = {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(finalPayload)
                    };
                }

                const startRes = await fetch(API_BASE_URL + endpoint, options);
                const startData = await startRes.json();

                if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to start video task.');

                hideTypingIndicator();
                await startTypewriter(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. I will monitor the cosmic flow for its completion. This can take a few minutes. Maintain your current channel to receive updates.`);

                const pollInterval = setInterval(async () => {
                    try {
                        const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                        const statusData = await statusRes.json();

                        if (statusRes.ok && statusData.url) {
                            clearInterval(pollInterval);
                            const videoHtml = `ðŸŽ‰ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                            await addMessageToChat('ai', videoHtml);
                        } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                            clearInterval(pollInterval);
                            await startTypewriter(`âŒ Video generation failed. Reason: ${statusData.error || 'Unknown cosmic anomaly'}`);
                        }
                    } catch (pollErr) {
                        clearInterval(pollInterval);
                        await startTypewriter(`âŒ Error checking video status.`);
                    }
                }, 20000);
            } catch (err) {
                hideTypingIndicator();
                await startTypewriter(`âŒ Could not initiate video generation: ${err.message}`);
            }
        }


        function showAIImagePreview(base64, caption = '') {
            if (!aiPrevBox || !aiPrevImgBox) return;
            aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image">` + `<div style="color:rgba(170,170,238,0.7);font-size:.95em;margin-top:3px;text-align:center;">${caption}</div>`;
            aiPrevBox.style.display = 'block';
        }
        if (aiPrevClose) aiPrevClose.addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
        if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
            const img = aiPrevImgBox.querySelector('img');
            if (img) {
                const a = document.createElement('a');
                a.href = img.src;
                a.download = 'philadelphia_ai_image.png';
                a.click();
            }
        });
        if (lightbox) {
            lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
        }
        if (chatView) {
            chatView.addEventListener('click', e => {
                if (e.target.tagName === 'IMG' && e.target.closest('.message-group.ai .msg-bubble')) {
                    e.preventDefault();
                    const lbImg = lightbox.querySelector('img');
                    if (lbImg) {
                        lbImg.src = e.target.src;
                        lightbox.classList.add('active');
                    }
                }
            });
        }


        // --- Theming System ---
        const themes = {
            cyber: {
                '--neon-blue': '#00f2ff', '--neon-purple': '#bd00ff', '--neon-green': '#00ff99',
                '--plasma-gradient': 'linear-gradient(135deg, var(--neon-blue), var(--neon-purple), var(--neon-green))',
                '--plasma-gradient-2': 'linear-gradient(45deg, var(--neon-purple), var(--neon-blue))',
                '--glass-bg-strong': 'rgba(20, 20, 35, 0.75)', '--glass-bg-light': 'rgba(255, 255, 255, 0.08)', '--glass-border': 'rgba(255, 255, 255, 0.18)',
                '--text-glow': '0 0 10px rgba(0, 242, 255, 0.7), 0 0 20px rgba(189, 0, 255, 0.5), 0 0 30px rgba(0, 255, 153, 0.3)',
                '--box-glow': '0 0 20px rgba(0, 242, 255, 0.2)',
                '--user-bubble-glow': '0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple)',
                '--ai-bubble-glow': 'inset 0 0 20px rgba(0, 242, 255, 0.08), 0 0 5px rgba(0, 242, 255, 0.1)',
                '--header-text-fill': 'linear-gradient(90deg, #fff, var(--neon-blue) 40%, var(--neon-purple) 60%, #fff)',
                '--header-text-glow-anim-1': '0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple)',
                '--header-text-glow-anim-2': '0 0 20px var(--neon-green), 0 0 35px var(--neon-blue)',
                '--code-bg': 'rgba(20, 20, 35, 0.9)', '--code-border': 'var(--neon-blue)', '--code-text': '#e0faff',
                '--input-focus-glow': '0 0 25px rgba(0, 242, 255, 0.4), 0 0 40px rgba(189, 0, 255, 0.2)',
                '--input-bg-focus': 'rgba(0, 242, 255, 0.1)',
                'body-bg-color': '#050714',
                'nebula-bg-1': 'radial-gradient(circle at 50% 50%, rgba(76, 0, 255, 0.1), transparent 50%), radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.1), transparent 40%), linear-gradient(to bottom right, #050714, #1a0a2e)',
                'nebula-bg-2': 'radial-gradient(circle at 20% 80%, rgba(189, 0, 255, 0.15), transparent 50%), radial-gradient(circle at 70% 30%, rgba(0, 255, 153, 0.08), transparent 45%)',
                'nebula-bg-3': 'radial-gradient(circle at 10% 10%, rgba(0, 242, 255, 0.05), transparent 60%), radial-gradient(circle at 90% 90%, rgba(189, 0, 255, 0.07), transparent 55%)',
            },
            celestial: {
                '--neon-blue': '#ff00ff', '--neon-purple': '#8a2be2', '--neon-green': '#ff66ff',
                '--plasma-gradient': 'linear-gradient(135deg, var(--neon-blue), var(--neon-purple), var(--neon-green))',
                '--plasma-gradient-2': 'linear-gradient(45deg, var(--neon-purple), var(--neon-blue))',
                '--glass-bg-strong': 'rgba(25,0,35,0.75)', '--glass-bg-light': 'rgba(255, 255, 255, 0.06)', '--glass-border': 'rgba(255, 255, 255, 0.12)',
                '--text-glow': '0 0 10px rgba(255,0,255,0.7), 0 0 20px rgba(138,43,226,0.5), 0 0 30px rgba(255,102,255,0.3)',
                '--box-glow': '0 0 20px rgba(255,0,255,0.2)',
                '--user-bubble-glow': '0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple)',
                '--ai-bubble-glow': 'inset 0 0 20px rgba(255,0,255,0.08), 0 0 5px rgba(255,0,255,0.1)',
                '--header-text-fill': 'linear-gradient(90deg, #fff, var(--neon-blue) 40%, var(--neon-purple) 60%, #fff)',
                '--header-text-glow-anim-1': '0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple)',
                '--header-text-glow-anim-2': '0 0 20px var(--neon-green), 0 0 35px var(--neon-blue)',
                '--code-bg': 'rgba(25,0,35,0.9)', '--code-border': 'var(--neon-blue)', '--code-text': '#f0e6ff',
                '--input-focus-glow': '0 0 25px rgba(255,0,255,0.4), 0 0 40px rgba(138,43,226,0.2)',
                '--input-bg-focus': 'rgba(255,0,255,0.05)',
                'body-bg-color': '#0f001a',
                'nebula-bg-1': 'radial-gradient(circle at 50% 50%, rgba(138,43,226,0.1), transparent 50%), radial-gradient(circle at 80% 20%, rgba(255,0,255,0.1), transparent 40%), linear-gradient(to bottom right, #0f001a, #2b003e)',
                'nebula-bg-2': 'radial-gradient(circle at 20% 80%, rgba(255,0,255,0.15), transparent 50%), radial-gradient(circle at 70% 30%, rgba(255,102,255,0.08), transparent 45%)',
                'nebula-bg-3': 'radial-gradient(circle at 10% 10%, rgba(255,0,255,0.05), transparent 60%), radial-gradient(circle at 90% 90%, rgba(138,43,226,0.07), transparent 55%)',
            },
            starlight: {
                '--neon-blue': '#a6faff', '--neon-purple': '#00c3ff', '--neon-green': '#aaffea',
                '--plasma-gradient': 'linear-gradient(135deg, var(--neon-blue), var(--neon-purple), var(--neon-green))',
                '--plasma-gradient-2': 'linear-gradient(45deg, var(--neon-purple), var(--neon-blue))',
                '--glass-bg-strong': 'rgba(16,12,37,0.75)', '--glass-bg-light': 'rgba(255, 255, 255, 0.09)', '--glass-border': 'rgba(255, 255, 255, 0.15)',
                '--text-glow': '0 0 10px rgba(166,250,255,0.7), 0 0 20px rgba(0,195,255,0.5), 0 0 30px rgba(170,255,234,0.3)',
                '--box-glow': '0 0 20px rgba(166,250,255,0.2)',
                '--user-bubble-glow': '0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple)',
                '--ai-bubble-glow': 'inset 0 0 20px rgba(166,250,255,0.08), 0 0 5px rgba(166,250,255,0.1)',
                '--header-text-fill': 'linear-gradient(90deg, #fff, var(--neon-blue) 40%, var(--neon-purple) 60%, #fff)',
                '--header-text-glow-anim-1': '0 0 15px var(--neon-blue), 0 0 25px var(--neon-purple)',
                '--header-text-glow-anim-2': '0 0 20px var(--neon-green), 0 0 35px var(--neon-blue)',
                '--code-bg': 'rgba(16,12,37,0.9)', '--code-border': 'var(--neon-blue)', '--code-text': '#f0faff',
                '--input-focus-glow': '0 0 25px rgba(166,250,255,0.4), 0 0 40px rgba(0,195,255,0.2)',
                '--input-bg-focus': 'rgba(166,250,255,0.05)',
                'body-bg-color': '#030010',
                'nebula-bg-1': 'radial-gradient(circle at 50% 50%, rgba(0,195,255,0.1), transparent 50%), radial-gradient(circle at 80% 20%, rgba(166,250,255,0.1), transparent 40%), linear-gradient(to bottom right, #030010, #100c25)',
                'nebula-bg-2': 'radial-gradient(circle at 20% 80%, rgba(0,195,255,0.15), transparent 50%), radial-gradient(circle at 70% 30%, rgba(170,255,234,0.08), transparent 45%)',
                'nebula-bg-3': 'radial-gradient(circle at 10% 10%, rgba(166,250,255,0.05), transparent 60%), radial-gradient(circle at 90% 90%, rgba(0,195,255,0.07), transparent 55%)',
            },
            // Add other themes here following this pattern
        };
        let currentThemeIdx = 0;
        const themeKeys = Object.keys(themes);

        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) return;
            for (const key in theme) {
                if (key.startsWith('--')) {
                    document.documentElement.style.setProperty(key, theme[key]);
                } else if (key === 'body-bg-color') {
                    document.body.style.backgroundColor = theme[key];
                } else if (key.startsWith('nebula-bg-')) {
                    const layerIndex = parseInt(key.split('-')[2]) - 1;
                    if (cosmos.children[layerIndex]) {
                        cosmos.children[layerIndex].style.background = theme[key];
                    }
                }
            }
            // Update icon based on theme (can be more sophisticated)
            themeBtn.innerHTML = `<i class="fa-solid ${themeName === 'cyber' ? 'fa-lightbulb' : (themeName === 'celestial' ? 'fa-star' : 'fa-moon')}"></i>`;
            localStorage.setItem('philadelphia-theme', themeName);
        }

        themeBtn.addEventListener('click', () => {
            currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
            applyTheme(themeKeys[currentThemeIdx]);
        });

        const savedTheme = localStorage.getItem('philadelphia-theme');
        if (savedTheme && themes[savedTheme]) {
            currentThemeIdx = themeKeys.indexOf(savedTheme);
            applyTheme(savedTheme);
        } else {
            applyTheme('cyber'); // Default theme
        }


        // --- Voice Call Functionality ---
        let speechRecognition;
        let isCallActive = false;
        let callHistory = [];
        let botIsSpeaking = false;
        let userSaidSomething = false; // To track if user actually spoke
        let currentAudio = null;
        let isMuted = false;

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition) {
            speechRecognition = new SpeechRecognition();
            speechRecognition.continuous = true;
            speechRecognition.interimResults = true;
            speechRecognition.lang = 'en-US';

            let userInterimMessageEl = null;

            speechRecognition.onstart = () => {
                callStatusMessage.textContent = isMuted ? 'Microphone Muted.' : 'Listening for Transmission...';
                tapToTalk.style.display = 'none';
                botImageContainer.classList.remove('speaking');
                if (!isMuted) {
                    // Visual cue for user listening
                    userInterimMessageEl = document.createElement('div');
                    userInterimMessageEl.className = 'call-msg user interim call-msg-user-listening-anim';
                    callConversation.appendChild(userInterimMessageEl);
                    callConversation.scrollTop = callConversation.scrollHeight;
                }
            };

            speechRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                userSaidSomething = false; // Reset for each result event

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                        userSaidSomething = true;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                
                if (userInterimMessageEl) {
                    userInterimMessageEl.textContent = finalTranscript || interimTranscript;
                }
                callConversation.scrollTop = callConversation.scrollHeight;
            };

            speechRecognition.onend = () => {
                if (!isCallActive) return;

                if (userInterimMessageEl && userInterimMessageEl.textContent.trim() === '') {
                    // Remove empty interim message if user said nothing
                    if (userInterimMessageEl.parentNode) {
                        userInterimMessageEl.parentNode.removeChild(userInterimMessageEl);
                    }
                    userInterimMessageEl = null;
                } else if (userInterimMessageEl) {
                    // Finalize interim message
                    userInterimMessageEl.classList.remove('interim', 'call-msg-user-listening-anim');
                    // Add a placeholder to currentMessages for continuity, though not strictly saved to DB
                    callHistory.push({ role: 'user', content: userInterimMessageEl.textContent.trim() });
                    userInterimMessageEl = null;
                }


                if (botIsSpeaking) {
                    // Bot is speaking, do nothing, it will restart recognition after finishing.
                } else if (userSaidSomething && callHistory.length > 0 && callHistory[callHistory.length -1].role === 'user') {
                    // Only handle if user actually spoke AND the last history entry is a user message (to prevent double processing)
                    userSaidSomething = false; // Reset
                    handleCallBotResponse();
                } else {
                    // If no final transcript and bot isn't speaking, restart listening if call is active and not muted
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
                    }
                }
            };

            speechRecognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                if (event.error === 'no-speech' && isCallActive && !isMuted) {
                    userSaidSomething = false;
                    speechRecognition.stop(); // This will trigger onend, which handles restart
                } else if (event.error === 'network' && isCallActive) {
                    callStatusMessage.textContent = 'Network flux detected. Retrying quantum link...';
                    speechRecognition.stop();
                } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    callStatusMessage.textContent = 'Microphone access denied. Please grant permission for cosmic communication.';
                    endCall();
                }
                if (userInterimMessageEl && userInterimMessageEl.parentNode) {
                    userInterimMessageEl.parentNode.removeChild(userInterimMessageEl);
                    userInterimMessageEl = null;
                }
            };
        } else {
            callBtn.style.display = 'none';
            console.warn("Speech Recognition not supported in this browser. Voice call unavailable.");
        }

        function addCallMessage(role, text) {
            const msgEl = document.createElement('div');
            msgEl.className = `call-msg ${role}`;
            msgEl.textContent = text;
            callConversation.appendChild(msgEl);
            callConversation.scrollTop = callConversation.scrollHeight;
        }

        async function handleCallBotResponse() {
            if (!isCallActive) return;
            callStatusMessage.textContent = 'Philadelphia AI is processing thought streams...';
            tapToTalk.style.display = 'none';
            const historyForBot = callHistory.map(m => m);
            const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : "";

            try {
                speechRecognition.stop(); // Ensure mic is off while bot processes
                const res = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // Send entire call history for context, but exclude latest user message for explicit new message handling
                    body: JSON.stringify({ message: userMessage, history: historyForBot.slice(0, -1), user_id: currentUser?.uid || "user" })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || "Cosmic server response failed.");
                const botResponse = data.response;
                callHistory.push({ role: 'ai', content: botResponse });
                addCallMessage('bot', botResponse);
                speakBotResponse(botResponse);
            } catch (err) {
                const errorMsg = `âŒ Link Interrupted: ${err.message}`;
                addCallMessage('bot', errorMsg);
                if (isCallActive && !isMuted) {
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
                }
            }
        }

        async function speakBotResponse(text) {
            if (!isCallActive) return;
            botIsSpeaking = true;
            botImageContainer.classList.add('speaking');
            callStatusMessage.textContent = 'Philadelphia AI is transmitting...';
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ text: text, voice_id: 'elder' }) // Using 'elder' voice for a wise AI tone
                });
                if (!res.ok) throw new Error(await res.text());
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                currentAudio = audio;
                audio.onended = audio.onerror = () => {
                    botIsSpeaking = false;
                    botImageContainer.classList.remove('speaking');
                    currentAudio = null;
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
                    } else if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                    }
                };
                audio.play();
            } catch (err) {
                console.error("Voice generation error:", err);
                botIsSpeaking = false;
                botImageContainer.classList.remove('speaking');
                addCallMessage('status', 'Voice transmission corrupted. Text fallback.'); // Inform user
                if (isCallActive && !isMuted) {
                    callStatusMessage.textContent = 'Listening (Voice Failed)...';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
                } else if (isMuted) {
                    callStatusMessage.textContent = 'Microphone Muted.';
                    tapToTalk.style.display = 'none';
                }
            }
        }

        function stopBotSpeakingAndStartListening() {
            if (!isCallActive || !botIsSpeaking) return;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            botIsSpeaking = false;
            botImageContainer.classList.remove('speaking');
            if (!isMuted) {
                callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                tapToTalk.style.display = 'block';
                try {
                    speechRecognition.stop(); // Stop current recognition
                    speechRecognition.start(); // And restart to be ready for user input
                } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
            } else {
                callStatusMessage.textContent = 'Microphone Muted.';
                tapToTalk.style.display = 'none';
            }
            // Clear any lingering interim messages
            if (userInterimMessageEl && userInterimMessageEl.parentNode) {
                userInterimMessageEl.parentNode.removeChild(userInterimMessageEl);
                userInterimMessageEl = null;
            }
        }

        callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
        callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening); // For mobile

        callBtn.addEventListener('click', () => {
            if (!SpeechRecognition) {
                alert("Sorry, your browser doesn't support the Speech Recognition needed for this cosmic communication link.");
                return;
            }
            isCallActive = true;
            isMuted = false;
            muteCallBtn.classList.remove('muted');
            muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
            callModal.classList.add('active');
            callConversation.innerHTML = ''; // Clear previous call messages
            addCallMessage('status', 'Establishing Quantum Connection...');
            callStatusMessage.textContent = 'Calling...';
            tapToTalk.style.display = 'none';
            callHistory = [];
            setTimeout(() => {
                if (!isCallActive) return; // Check if call was ended during delay
                addCallMessage('status', 'Quantum Link Established. Transmit when ready.');
                try { speechRecognition.start(); } catch(e) { console.error("Speech recognition start failed", e); callStatusMessage.textContent = 'Microphone error. Check permissions.'; }
            }, 1500);
        });

        function endCall() {
            isCallActive = false;
            botIsSpeaking = false;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            callModal.classList.remove('active');
            try { speechRecognition.stop(); } catch(e) {} // Stop recognition
            botImageContainer.classList.remove('speaking');
            tapToTalk.style.display = 'none';
            callStatusMessage.textContent = 'Call Terminated.';
            // Clear any lingering interim messages
            if (userInterimMessageEl && userInterimMessageEl.parentNode) {
                userInterimMessageEl.parentNode.removeChild(userInterimMessageEl);
                userInterimMessageEl = null;
            }
        }

        endCallBtn.addEventListener('click', endCall);

        muteCallBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            if (isMuted) {
                muteCallBtn.classList.add('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute Microphone';
                speechRecognition.stop(); // Stop listening when muted
                callStatusMessage.textContent = 'Microphone Muted. Transmission on hold.';
                tapToTalk.style.display = 'none';
            } else {
                muteCallBtn.classList.remove('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
                if (isCallActive && !botIsSpeaking) {
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
                } else if (isCallActive && botIsSpeaking) {
                    callStatusMessage.textContent = 'Philadelphia AI is transmitting...';
                    tapToTalk.style.display = 'none';
                }
            }
        });

        // Wow Feature 4: Cosmic Whisper Log
        let whisperLogMessages = [];
        let whisperLogInterval;
        const toggleWhisperLog = () => {
            cosmicWhisperLog.classList.toggle('active');
            if (cosmicWhisperLog.classList.contains('active')) {
                // Start adding dummy messages if active
                if (!whisperLogInterval) {
                    whisperLogInterval = setInterval(() => {
                        const messages = [
                            `[${new Date().toLocaleTimeString()}] <i class="fa-solid fa-satellite-dish"></i> Scanning subspace frequencies...`,
                            `[${new Date().toLocaleTimeString()}] <i class="fa-solid fa-brain"></i> Calibrating neural matrix...`,
                            `[${new Date().toLocaleTimeString()}] <i class="fa-solid fa-atom"></i> Initiating quantum computations...`,
                            `[${new Date().toLocaleTimeString()}] <i class="fa-solid fa-code-branch"></i> Cross-referencing galactic databases...`,
                            `[${new Date().toLocaleTimeString()}] <i class="fa-solid fa-bolt"></i> Energizing core processors...`
                        ];
                        const newMessage = document.createElement('div');
                        newMessage.innerHTML = messages[Math.floor(Math.random() * messages.length)];
                        cosmicWhisperLog.appendChild(newMessage);
                        cosmicWhisperLog.scrollTop = cosmicWhisperLog.scrollHeight;
                        whisperLogMessages.push(newMessage);
                        if (whisperLogMessages.length > 10) { // Keep log clean
                            cosmicWhisperLog.removeChild(whisperLogMessages.shift());
                        }
                    }, 5000); // Add a new message every 5 seconds
                }
            } else {
                clearInterval(whisperLogInterval);
                whisperLogInterval = null;
            }
        };

        // Hook the header avatar to toggle the cosmic whisper log (Wow Feature 1 & 4 Interaction)
        botAvatarHeader.addEventListener('click', toggleWhisperLog);

        if(userInput) userInput.focus();
    });
</script>

</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
