<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Philadelphia AI Chat</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
<style>
:root {
    /* DEFAULT THEME: Cyber (Original, Vibrant, High-Contrast) */
    --cyan: #00fff7;
    --blue: #0a8afe;
    --dark-bg: #070b1a;
    --fade-blue: #133c8b;
    --gradient-1: linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%);
    --gradient-user: linear-gradient(120deg, #0857ee 32%, #00fff0 89%);
    --glass: rgba(25, 38, 67, 0.82);
    --bubble-glow: 0 0 13px #00d8ffb1, 0 0 24px #0197ff40;
    --user-glow: 0 0 22px #0fffd555, 0 0 14px #36f9ff70;
    --header-glass: rgba(17,29,47,0.92);
    --code-bg: linear-gradient(92deg,#031d39 79%,#092ff8 120%);
    --code-border: #15faff;
    --code-text: #17fafd;
    --main-text: #e1fafe;
    --link-text: #13efff;
    --input-bg: #09284c;
    --body-bg: radial-gradient(circle at 60% 45%, #112250 37%, #060e1e 88%, #1e0942 100%) fixed, repeating-linear-gradient(100deg,#061c4c 0 9%,#080e20 16% 19%,#030721 30% 41%,#052650 44% 62%,#050b16 74% 89%,#041048 99% 100%);
    --body-blend-mode: lighten, color-dodge;
    --panel-bg: linear-gradient(118deg,#131642 80%,#1629af 200%);
    --panel-border: #00fbffcb;
    --panel-shadow: 0 0 42px #25f8ffc9;
    --submit-bg: linear-gradient(94deg,#00ffff,#0090ff 90%) ;
    --submit-text: #102649;
    --submit-hover-bg: #008cff;
    --submit-hover-text: #fff;
    --header-text-glow: 0 0 12px #00ffe0cc, 0 0 27px #178fcf88;
    --header-text-anim-glow-1: 0 0 17px #00e7ff70,0 0 30px #0b8fff44;
    --header-text-anim-glow-2: 0 0 29px #00ffe9ee,0 0 44px #31d2ff82;
    --header-text-fill: linear-gradient(90deg,#00fff1,#00b4ff 40%,#fff 59%,#1093f1 89%,#24e0fa 100%);
}
html, body { 
    height: 100vh; 
    width: 100vw; 
    margin: 0; 
    padding: 0; 
    color: var(--main-text); 
    background: var(--body-bg); 
    background-blend-mode: var(--body-blend-mode); 
    font-family: 'Roboto','Inter',system-ui,-apple-system,Segoe UI,sans-serif; 
    display: flex; 
    flex-direction: column; 
    box-sizing: border-box; 
    transition: background 0.3s ease; 
} 
body { 
    overflow: hidden; 
    min-height: 100vh; 
    width: 100vw; 
} 
#stars-container { 
    pointer-events: none; 
    position: fixed; 
    left:0; 
    top:0;right:0;bottom:0; 
    width:100vw; 
    height:100vh; 
    z-index:1; 
    overflow: hidden; 
} 
.star { 
    position:absolute; 
    background: var(--cyan); /* Use theme color for stars */ 
    box-shadow: 0 0 12px var(--cyan), 0 0 22px var(--cyan); 
    opacity: 0.23; 
    border-radius: 50%; 
    pointer-events: none; 
    animation: star-twinkle 2.7s infinite alternate; 
} 
@keyframes star-twinkle { 
    0% { opacity:.18; } 
    41% { opacity:.88; } 
    100%{ opacity:.09;} 
} 
.header-bar { 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100vw; 
    display: flex; 
    align-items: center; 
    justify-content: space-between; 
    background: var(--header-glass); 
    z-index: 1003; 
    padding: 0; 
    box-shadow: 0 7px 48px #00aaff27, 0 3px 41px #09fcfe15; 
    border-radius: 0 0 22px 22px; 
    height: 70px; 
    transition: background 0.3s ease, box-shadow 0.3s ease; 
} 
.menu-btn { 
    background: none; 
    border: none; 
    color: var(--cyan); 
    font-size: 2em; 
    cursor: pointer; 
    border-radius: 14px; 
    margin-left: 17px; 
    margin-right: 3px; 
    padding: 7px 11px; 
} 
.menu-btn:hover { 
    background: #00eaff28; 
    color: #fff; 
} 
/* Theme switcher button style */ 
#themeBtn { 
    font-size: 1.6em; 
    padding: 7px 12px; 
    margin-left: -10px; 
} 
.site-heading { 
    font-family: 'Orbitron',sans-serif; 
    font-size: 1.28em; 
    font-weight: 700; 
    text-align: center; 
    flex: 1; 
    letter-spacing: .27px; 
    white-space:nowrap; 
    background: var(--header-text-fill); 
    background-size: 250% auto; 
    -webkit-background-clip: text; 
    -webkit-text-fill-color: transparent; 
    animation: neonglow 4.2s ease-in-out infinite alternate; 
    text-shadow: var(--header-text-glow); 
    user-select: none; 
    margin-left: 8px; 
    margin-right: 10px; 
} 
@keyframes neonglow { 
    0% { text-shadow: var(--header-text-anim-glow-1);} 
    100% { text-shadow: var(--header-text-anim-glow-2);} 
} 
.header-welcome { 
    color: #68e6fd; 
    font-size: .97em; 
    margin: -2px 0 .7em 0; 
    text-align: center; 
    text-shadow: 0 0 14px #00bcb4a8; 
} 
.main-content { 
    display: flex; 
    flex-direction: column; 
    flex-grow: 1; 
    overflow-y: hidden; 
    position: relative; 
    padding-top: 70px; 
    padding-bottom: 86px; /* Space for the input row */ 
    box-sizing: border-box; 
} 
.chat-box { 
    flex: 1 1 0px; 
    overflow-y: auto; 
    overflow-x: hidden; 
    width: 100vw; 
    max-width: 635px; 
    margin: 0 auto; 
    box-sizing: border-box; 
    padding: 15px 8px 15px 8px; /* Removed extra bottom padding */ 
    position: relative; 
    z-index:3; 
    scroll-behavior: smooth; 
    display: flex; 
    flex-direction: column; 
} 
/* This is the new, separate typing indicator container */ 
#typing-status { 
    display: none; /* Hidden by default */ 
    max-width: 635px; 
    margin: 0 auto; 
    padding: 0 8px; 
    width: 100vw; 
    box-sizing: border-box; 
    flex-shrink: 0; /* Prevent it from collapsing */ 
    min-height: 20px; /* Give it some space */ 
    padding-bottom: 10px; 
} 
.chat-message { 
    width: 100%; 
    display: flex; 
    gap:9px; 
    align-items: flex-end; 
    margin: 8px 0; 
    max-width:100vw; 
    flex-shrink: 0; 
} 
.chat-message .msg { 
    font-size: 1.01em; 
    line-height: 1.58; 
    max-width: 62vw; 
    min-width:0; 
    padding: 11px 16px 12px 15px; 
    border-radius: 16px 14px 11px 12px; 
    word-break: break-word; 
    white-space: pre-wrap; 
    overflow-x: auto; 
    background: var(--gradient-1); 
    color: var(--main-text); 
    text-shadow: 0 0 3px #23d8ff15; 
    box-shadow: var(--bubble-glow); 
    margin-right: auto; 
    margin-left: 0; 
    border: 1.2px solid #0090ffa0; 
    position:relative; 
    transition:background .3s, color .3s, box-shadow .3s; 
} 
.chat-message.user { 
    justify-content: flex-end; 
} 
.chat-message.user .msg { 
    background: var(--gradient-user); 
    color: var(--submit-text); 
    font-weight: 700; 
    text-shadow: 0 0 5px #00e0ff77, 0 0 2px #00ffe033; 
    border-radius: 17px 13px 15px 11px; 
    margin-left: auto; 
    margin-right: 0; 
    box-shadow: var(--user-glow); 
    border: 1.2px solid #04eef4c9; 
    max-width: 68vw; 
} 
@media (max-width:790px) { 
    .chat-box { 
        max-width:100vw; 
        padding: 15px 4px 15px 4px; 
    } 
    #typing-status { 
        padding: 0 4px 10px 4px; 
    } 
    .chat-message .msg { 
        font-size: .97em; 
        padding:9px 4vw 10px 5vw; 
        max-width:80vw;
    } 
    .chat-message.user .msg { 
        max-width: 83vw; 
    } 
} 
/* REVERTED TO ORIGINAL CYBER-THEME TYPING BUBBLE WITH DANCING ANIMATION */
.typing-bubble { 
    display: inline-flex; 
    align-items: center; 
    height: 28px; 
    padding: 4px 12px; 
    margin: 6px 4px; 
    border-radius: 15px; 
    background: linear-gradient(90deg, var(--fade-blue) 30%, var(--blue) 95%);
    box-shadow: 0 2px 12px var(--cyan); 
    border: 1px solid var(--cyan);
} 
.dot-anim { 
    display:inline-block; 
    width: 8px; 
    height: 8px; 
    margin:0 3px; 
    background: var(--cyan); 
    border-radius: 50%; 
    opacity: 0.85; 
    animation: typing-blink 0.7s infinite both; /* Faster, distinct dancing animation */
    box-shadow: 0 0 6px var(--cyan); 
} 
.dot-anim:nth-child(2){animation-delay:.15s;} /* Adjusted delays for dancing effect */
.dot-anim:nth-child(3){animation-delay:.3s;}

/* NEW Dancing Animation - KEPT */
@keyframes typing-blink {
    0%, 100% {opacity: 0.2; transform: translateY(0) scale(0.9);} 
    30% {opacity: 1; transform: translateY(-7px) scale(1.2);} /* Lift the dot up more aggressively */
    60% {opacity: 0.8; transform: translateY(0) scale(1.05);}
}

#typing-status .msg {
    display: flex; /* Ensure the typing bubble and status text are aligned */
    align-items: center;
    padding: 6px 13px 6px 13px; /* Add back padding for alignment */
    /* Remove default bubble styling and rely on .typing-bubble */
    background: none; 
    box-shadow: none; 
}
/* END TYPING BUBBLE REVERT */

pre, code { 
    font-family: 'JetBrains Mono','Fira Mono','Menlo',monospace; 
    font-size: .99em; 
    background: var(--code-bg); 
    border-radius: 11px; 
    border: 1.7px solid var(--code-border); 
    color: var(--code-text); 
    box-shadow: 0 0 19px #00eaff38, 0 0 48px #0beaff38 inset; 
    transition: background 0.3s, border-color 0.3s, color 0.3s; 
} 
pre { 
    overflow-x: auto; 
    padding: 1.18em 1.3em 1.16em 1.13em; 
    margin: 1.15em 0 1em 0; 
    position: relative; 
} 
pre:before { 
    content: "CODE"; 
    color: var(--cyan); 
    font-size: 0.82em; 
    font-family: 'Orbitron', monospace; 
    position: absolute; 
    top: 5px; 
    right: 29px; 
    opacity: 0.17; 
    letter-spacing: 0.13em; 
    pointer-events: none; 
} 
.copy-btn { 
    position: absolute; 
    top: 10px; 
    right: 13px; 
    z-index: 3; 
    border-radius: 8px; 
    border: none; 
    padding: 3px 15px; 
    background: linear-gradient(95deg,#0cf3ff 40%,#0980ff 120%); 
    color: #06182f; 
    font-size: .98em; 
    font-family: 'Inter'; 
    font-weight: bold; 
    box-shadow: 0 2px 9px #18e3ffc5,0 0 7px #00ffd7a4; 
    transition: background .15s, color .15s; 
    cursor: pointer; 
    outline: none; 
    border: 1px solid #0cf3ff35; 
} 
.copy-btn:hover { 
    background: #008cee; 
    color: #fff; 
} 
.inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn { 
    padding:4px 10px; 
    border-radius:7px; 
    border:none; 
    background:var(--submit-bg); 
    color:var(--submit-text); 
    font-family:'Inter',Arial,sans-serif; 
    font-size:.96em; 
    font-weight:600; 
    display:inline-flex; 
    align-items:center; 
    gap:4px; 
    margin-top:6px; 
    margin-right: 3px; 
    cursor:pointer; 
    box-shadow:0 2px 7px #17f6fe51;transition:background .14s,color .13s; 
} 
.inline-copy-btn:hover, .inline-share-btn:hover, .regen-btn:hover, .inline-edit-btn:hover{background:var(--submit-hover-bg); color:var(--submit-hover-text);} 
.file-attachments { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 8px; 
    margin: 8px 0; 
    max-width: 100%; 
} 
.chat-media-preview { 
    max-width: 100%; 
    max-height: 250px; 
    border-radius: 12px; 
    display: block; 
} 
.image-preview-thumb, .video-preview-thumb { 
    border: 2px solid var(--cyan); 
    box-shadow: 0 0 10px var(--cyan); 
} 
/* Make AI images clickable */ 
.chat-message.ai .msg img.chat-media-preview { 
    cursor: zoom-in; 
} 
.audio-preview-thumb { 
    width: 90%; 
    min-height: 40px; 
    border-radius: 10px; 
} 
.file-link, .file-placeholder { 
    display: inline-block; 
    padding: 8px 12px; 
    background: #0b2447; 
    border: 1px solid #1af8ff51; 
    border-radius: 10px; 
    color: var(--cyan); 
    text-decoration: none; 
    font-size: 0.9em; 
    font-weight: bold; 
} 
.file-link i, .file-placeholder i { 
    margin-right: 5px; 
} 
.file-preview{ 
    display:none; 
    background:rgba(15,36,65,0.98); 
    border-radius:12px;color:#c4f2ff;font-size:.98em; 
    box-shadow:0 3px 15px #00aac0bb; 
    margin:0 auto 10px auto;width:94vw;max-width:520px; 
    padding:10px 14px 10px 15px; 
    position: fixed; 
    bottom: 100px; 
    left: 50%; 
    transform: translateX(-50%); 
    z-index: 1002; 
    border: 1.5px solid #00ffff44; 
} 
.file-preview img, .file-preview video { 
    max-width:58px;max-height:41px;border-radius:6px;margin-right:6px;vertical-align: middle; 
} 
.file-preview audio { 
    width:52px; 
    margin-right:7px; 
} 
.remove-file-btn { 
    color: #fff !important; 
    background:#d23 !important; 
    border:none !important; 
    border-radius:50% !important; 
    padding:2px 6px !important; 
    cursor:pointer !important; 
    font-size:1.2em !important; 
    font-weight:bold !important; 
    margin-left:8px !important; 
    transition: background .16s, color .16s !important; 
    min-width: 24px !important; 
    height: 24px !important; 
    display: inline-flex !important; 
    align-items: center !important; 
    justify-content: center !important; 
} 
.remove-file-btn:hover { 
    background:#ff4444 !important; 
    color:#fff !important; 
    transform: scale(1.1) !important; 
} 
/* --- IMPROVED KEYBOARD FIT --- */ 
.chat-input-row { 
    position: fixed; 
    left: 50%; 
    transform: translateX(-50%); 
    bottom: 0; 
    display: flex; 
    align-items: stretch; 
    gap: 8px; 
    background: rgba(17, 29, 47, 0.94); 
    backdrop-filter: blur(8px); 
    border: 1.5px solid #1af8ff51; 
    border-radius: 23px 23px 0 0; 
    width: 95vw; 
    max-width: 900px; 
    padding: 9px 12px 10px 13px; 
    box-shadow: 0 0 39px #007fff22, 0 11px 33px #00fff014; 
    z-index: 1003; 
} 
@media (max-width: 920px) { 
    .chat-input-row { 
        width: 95vw; 
        max-width: 100%; 
        left: 50%; 
        transform: translateX(-50%); 
        border-radius: 22px 22px 8px 8px; 
    } 
} 
.chat-input-row textarea{ 
    flex:1 1 auto;resize:none;min-height:36px;max-height:120px; 
    background: var(--input-bg);color: var(--main-text);font-size:1em; 
    padding:10px 12px;border:none;border-radius:11px; 
    box-shadow:0 1px 6px #00f2ff27; 
    transition: background 0.3s, color 0.3s; 
} 
.chat-input-row button, .chat-input-row label{ 
    background:none;border:none;color:var(--cyan);font-size:1.21em; 
    cursor:pointer;border-radius:10px;transition:color .13s,background .15s;padding:0; 
    display:flex;align-items:center;justify-content:center;min-width:33px; 
    box-shadow: 0 0 3px #00eaff20; 
} 
.chat-input-row button:hover, .chat-input-row label:hover{color:#fff;background:#00cdf247;} 
/* Call button style */ 
#callBtn { 
    font-size: 1.1em; 
} 
#stopBtn { 
    background: #ff4d4d; 
    color: white; 
    font-size: 1.2em; 
    border-radius: 10px; 
    padding: 0; 
    min-width: 33px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    box-shadow: 0 0 10px #ff4d4d88; 
    transition: background .1s, color .1s; 
} 
#stopBtn:hover { 
    background: #ff7777; 
} 
#emojiPanel { 
    display:none; 
    position: fixed; 
    left:10px; 
    bottom:110px; 
    z-index:2222; 
    background: #051f46f9; 
    border-radius: 15px; 
    padding: 16px 15px 12px 15px; 
    box-shadow: 0 5px 22px #00fff194; 
    border: 1px solid #00ffff66; 
} 
.emoji-pick { 
    font-size:1.23em; 
    cursor:pointer; 
    padding:4px 8px; 
    border-radius:10px; 
    transition:background .13s; 
    user-select:none; 
} 
.emoji-pick:hover { 
    background:#35cdfd66; 
} 
.status-message{padding:6px 13px;color:#12ffc7;font-size:.98em;min-height:17px;text-align:center;margin:4px auto 0 auto;max-width:430px;word-break:break-word;} 
.panel-bg { 
    display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(13,20,52,0.86);z-index:1200; 
} 
.panel-bg.active{display:block;} 
.side-panel{position:absolute;top:0;left:0;height:100vh;width:325px; 
    background: var(--panel-bg); 
    border-right:2.5px solid var(--panel-border); 
    box-shadow: var(--panel-shadow); 
    z-index:1212; 
    padding:18px 16px 20px 15px;overflow-y:auto;border-radius:0 24px 32px 0; 
    transition: background 0.3s, border-color 0.3s, box-shadow 0.3s; 
} 
.side-panel .panel-header{text-align:center;margin:18px 0 13px 0;} 
.side-panel img{width:56px;height:56px;border-radius:53%;margin-bottom:8px;border:2px solid #31f6ffea;} 
.side-panel .username{font-weight:700;font-size:1.11em;color:#08d0fe;font-family:'Orbitron',sans-serif;text-shadow:0 0 8px #00eaffbb;} 
.side-panel .email{font-size:.97em;color:#a8eaff;} 
.panel-links a{color: var(--link-text);text-decoration:none;font-weight:500;font-size:1.08em;padding:8px 4px;display:flex;align-items:center;gap:12px;border-radius:9px;transition:background .14s;} 
.panel-links a:hover{background:#00eaff55;color:#f4fdff;} 
.panel-links a i { 
    width: 20px; 
    text-align: center; 
} 
#chatsList button{background:none;border:none;cursor:pointer;outline:none;font-size:1.11em;margin:0 5px;vertical-align:middle;border-radius:7px;padding:3px 5px;} 
#chatsList .fa-pen{color:#0fe0ee;transition:color .13s;} 
#chatsList .fa-pen:hover{color:#ffd800;} 
#chatsList .fa-trash{color:#ff244e;transition:color .10s;} 
#chatsList .fa-trash:hover{color:#fff900;} 
#chatsList .fa-play{color:#04ea70;font-size:1.2em;} 
#chatsList .fa-play:hover{color:#31adff;} 
.edit-form label{display:block;margin-top:10px;font-size:.99em;color:#38e4ff;text-shadow:0 1px 14px #11aaff71;} 
.edit-form input, .edit-form textarea, .edit-form select{ 
    width:99%;padding:7px 11px;margin-top:5px; 
    border:1.7px solid #13f0ff95;border-radius:9px;background:#071f35;color:#fff;font-size:1.02em; 
    box-shadow:0 0 8px #04f6fd81 inset;transition:border-color .17s,box-shadow .17s;} 
.edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus{border-color:#27eeff;background:#273f5d;color:#fff;} 
.edit-form textarea { 
    resize:vertical; 
    min-height: 80px; 
} 
.submit-btn{ 
    margin-top:14px; 
    padding:10px 20px; 
    background: var(--submit-bg); 
    border:none; 
    border-radius:10px; 
    color: var(--submit-text); 
    font-weight:bold; 
    cursor:pointer; 
    font-size:1.11em; 
    box-shadow:0 2px 13px #00fff292; 
    transition:background .14s,color .13s;} 
.submit-btn:hover{background: var(--submit-hover-bg);color: var(--submit-hover-text);} 
/* Lightbox for images */ 
#lightbox { 
    display: none; 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100vw; 
    height: 100vh; 
    background: rgba(0,0,0,0.85); 
    z-index: 5000; 
    justify-content: center; 
    align-items: center; 
} 
#lightbox.active { 
    display: flex; 
} 
#lightbox img { 
    max-width: 90vw; 
    max-height: 90vh; 
    border: 2px solid var(--cyan); 
    border-radius: 10px; 
    box-shadow: 0 0 50px var(--cyan); 
} 
/* Voice Call Modal */ 
#callModal { 
    display: none; 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100vw; 
    height: 100vh; 
    background: var(--dark-bg); 
    z-index: 4000; 
    flex-direction: column; 
    align-items: center; 
    padding: 20px; 
    box-sizing: border-box; 
} 
#callModal.active { 
    display: flex; 
} 
#callHeader { 
    color: var(--cyan); 
    font-family: 'Orbitron', sans-serif; 
    font-size: 1.5em; 
    text-shadow: 0 0 10px var(--cyan); 
    margin-bottom: 20px; 
} 
#botImageContainer { 
    margin-top: 20px; 
    position: relative; 
} 
#botImageContainer img { 
    width: 150px; 
    height: 150px; 
    border-radius: 50%; 
    border: 4px solid var(--cyan); 
    box-shadow: 0 0 30px var(--cyan); 
    transition: transform 0.3s ease; 
} 
@keyframes head-nod { 
    0% { transform: translateY(0); } 
    50% { transform: translateY(-3px); } 
    100% { transform: translateY(0); } 
} 
@keyframes glow-spread { 
    0% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; } 
    50% { box-shadow: 0 0 30px #00ff00, 0 0 50px #00ff0088; opacity: 1; } 
    100% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; } 
} 
#botImageContainer.speaking img { 
    border-color: #00ff00; 
    box-shadow: 0 0 30px #00ff00; 
    transform: scale(1.05); 
    animation: head-nod 1.2s infinite ease-in-out; 
} 
#botSpeakingIndicator { 
    position: absolute; 
    top: -5px; 
    left: -5px; 
    width: 160px; 
    height: 160px; 
    border-radius: 50%; 
    border: 5px solid transparent; 
    box-shadow: 0 0 20px var(--cyan); 
    animation: pulse 1s infinite; 
    display: none; 
    z-index: -1; 
} 
#botImageContainer.speaking #botSpeakingIndicator { 
    box-shadow: 0 0 30px #00ff00; 
    border-color: #00ff00; 
    display: block; 
    animation: glow-spread 1.7s infinite ease-in-out; 
} 
#callStatusMessage { 
    color: var(--cyan); 
    font-size: 1.1em; 
    margin-top: 15px; 
    height: 30px; 
    text-align: center; 
    font-style: italic; 
    text-shadow: 0 0 5px #00aaff; 
} 
#tapToTalk { 
    color: #ff00ff; 
    font-size: 1.2em; 
    margin-top: 5px; 
    text-shadow: 0 0 8px #ff00ff; 
    animation: neon-pulse 1.5s infinite alternate; 
    display: none; 
} 
@keyframes neon-pulse { 
    from { opacity: 0.7; transform: scale(1.0); } 
    to { opacity: 1.0; transform: scale(1.02); } 
} 
@keyframes pulse { 
    0% { opacity: 0; transform: scale(1); } 
    50% { opacity: 1; transform: scale(1.05); } 
    100% { opacity: 0; transform: scale(1); } 
} 
#callConversation { 
    flex-grow: 1; 
    width: 100%; 
    max-width: 600px; 
    overflow-y: auto; 
    margin: 20px 0; 
    border: 1px solid var(--fade-blue); 
    border-radius: 10px; 
    padding: 10px; 
    background: rgba(0, 0, 0, 0.2); 
} 
.call-msg { 
    padding: 8px 12px; 
    border-radius: 10px; 
    margin-bottom: 10px; 
    line-height: 1.5; 
    word-break: break-word; 
} 
.call-msg.user { 
    background: var(--gradient-user); 
    color: var(--submit-text); 
    text-align: right; 
    margin-left: auto; 
    max-width: 80%; 
} 
.call-msg.bot { 
    background: var(--gradient-1); 
    color: var(--main-text); 
    margin-right: auto; 
    max-width: 80%; 
} 
.call-msg.status { 
    text-align: center; 
    color: #888; 
    font-style: italic; 
    background: none; 
} 
#callControls { 
    display: flex; 
    gap: 20px; 
    padding-bottom: 20px; 
    margin-top: auto; /* Push controls to bottom */ 
} 
#endCallBtn, #muteCallBtn { 
    background: #d23; 
    color: white; 
    font-size: 1.2em; 
    padding: 10px 20px; 
    border: none; 
    border-radius: 10px; 
    cursor: pointer; 
    box-shadow: 0 0 10px #d2388; 
    transition: background .1s, box-shadow .1s; 
} 
#endCallBtn:hover, #muteCallBtn:hover { 
    background: #ff7777; 
    box-shadow: 0 0 15px #ff7777aa; 
} 
#muteCallBtn { 
    background: #007bff; /* Default blue for unmute */ 
    box-shadow: 0 0 10px #007bff88; 
} 
#muteCallBtn.muted { 
    background: #555; /* Grey when muted */ 
    box-shadow: none; 
} 
#muteCallBtn.muted:hover { 
    background: #777; 
} 
/* Spinner for loading states */ 
.spinner { 
    display: inline-block; 
    width: 20px; 
    height: 20px; 
    border: 3px solid rgba(0, 255, 247, 0.3); 
    border-radius: 50%; 
    border-top-color: var(--cyan); 
    animation: spin 1s ease-in-out infinite; 
    margin-right: 8px; 
} 
@keyframes spin { 
    to { transform: rotate(360deg); } 
} 
</style> 
</head> 
<body> 
<div id="stars-container"></div> 
<div class="main-content"> 
    <div class="header-bar"> 
        <button class="menu-btn" id="openProfileMenu" aria-label="Open profile menu"><i class="fa-solid fa-user"></i></button> 
        <div class="header-titles"> 
            <span class="site-heading">ðŸ¦…Philadelphia AIðŸ¦…</span> 
            <div class="header-welcome" id="headerWelcome"></div> 
        </div> 
        <button class="menu-btn" id="themeBtn" aria-label="Change theme"><i class="fa-solid fa-moon"></i></button> 
        <button class="menu-btn" id="openLinksMenu" aria-label="Open links menu"><i class="fa-solid fa-link"></i></button> 
    </div> 
    <div class="chat-box" id="chatBox"></div> 
    <div id="typing-status" class="chat-message ai" style="display: none;"></div> 
    <form class="chat-input-row" id="chatForm" autocomplete="off"> 
        <button type="button" id="emojiBtn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button> 
        <label for="chatFile" class="file-upload-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label> 
        <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none"> 
        <textarea id="chatInput" placeholder="Type hereâ€¦ (Shift+Enter = new line)"></textarea> 
        <button type="button" id="callBtn" title="Start Voice Call"><i class="fa-solid fa-phone"></i></button> 
        <button type="button" id="toolBtn" title="Philadelphia Tools" aria-controls="toolMenu" aria-expanded="false"><i class="fa-solid fa-wrench"></i></button> 
        <button type="submit" id="sendBtn" title="Send"><i class="fa-solid fa-paper-plane"></i></button> 
    </form> 
</div> 
<div id="emojiPanel"></div> 
<div class="status-message" id="statusMsg"></div> 
<div id="filePreview" class="file-preview"></div> 
<div class="panel-bg" id="profileMenuBg"> 
    <nav class="side-panel" id="profileMenu"> 
        <div style="display:flex;align-items:center;justify-content:space-between;"> 
            <span style="font-size:1.17em;font-weight:700;color:#00ffff;margin:18px 0 0 13px;">Chats</span> 
            <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;" onclick="profileMenuBg.classList.remove('active');">&times;</button> 
        </div> 
        <div id="chatsList" style="margin:7px 0 8px 6px;max-height:161px;overflow-y:auto;"> 
            <div class="spinner" style="margin: 20px auto; display: block;"></div> 
        </div> 
        <button id="newChatBtn" class="submit-btn" style="margin:0 0 12px 11px;"><i class="fa-solid fa-plus"></i> New Chat</button> 
        <hr style="width:91%;margin:11px 0 7px 3%;border:1px solid #00fff031;"> 
        <div class="panel-header"> 
            <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo"> 
            <div class="username" id="profileMenuUser">User</div> 
            <div class="email" id="profileMenuEmail">email@example.com</div> 
        </div> 
        <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;"> 
            <label for="edit-name">Name</label> 
            <input type="text" id="edit-name" required> 
            <label for="edit-photo">Photo URL</label> 
            <input type="url" id="edit-photo" placeholder="Paste image link"> 
            <span style="font-size:0.83em;color:#aae;display:block;margin:5px 0 7px 2px;"> Tip: <a href="https://postimg.cc/" target="_blank" style="color:#19fcff;">Upload at postimg.cc</a> </span> 
            <button type="submit" class="submit-btn">Save</button> 
            <div class="status-message" id="profileStatusMsg"></div> 
        </form> 
        <button class="submit-btn" id="logoutBtn" style="background:#10213b;color:#00eefd;margin:7px 7px 17px 7px;">Logout</button> 
    </nav> 
</div> 
<div id="ai-image-preview" style="display:none;position:fixed;z-index:1210;right:22px;bottom:100px;max-width:320px;background:#191a26e9;padding:12px;border-radius:17px;box-shadow:0 2px 19px #00fff2b8;"> 
    <button id="ai-image-close" style="float:right;background:#23233a;border:none;border-radius:7px;color:#00ffff;font-size:1.5em;cursor:pointer;margin-left:5px;">&times;</button> 
    <div id="ai-image-container"></div> 
    <button id="ai-image-dl" style="margin-top:9px;padding:7px 20px;background:linear-gradient(90deg,#00ffff,#0090ff);color:#222;border:none;border-radius:8px;box-shadow:0 2px 7px #00fff2c7;cursor:pointer;font-weight:bold;">Download</button> 
</div> 
<div class="panel-bg" id="linkMenuBg"> 
    <nav class="side-panel" id="linkMenu"> 
        <div class="panel-header"> 
            <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia logo"> 
            <div class="username">Philadelphia AI</div> 
        </div> 
        <div class="panel-links"> 
            <a href="philadelphia.html"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a> 
            <a href="index.html"><i class="fa-solid fa-home"></i>Elvion Homepage</a> 
            <a href="about.html"><i class="fa-solid fa-circle-info"></i> About US</a> 
            <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a> 
            <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms</a> 
            <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Try Telegram Version</a> 
        </div> 
    </nav> 
</div> 
<div class="panel-bg" id="toolsMenuBg"> 
    <nav class="side-panel" id="toolsMenu"> 
        <div class="panel-header" style="text-align:left;"> 
            <div class="username" style="font-size:1.2em;margin-left:-8px;text-align:center;">Philadelphia AI Tools</div> 
        </div> 
        <div class="panel-links"> 
            <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Creative Suite</h3> 
            <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a> 
            <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a> 
            <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a> 
            <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a> 
            <hr style="border-color: #00eaff30; margin: 10px 0;"> 
            <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Audio & Video</h3> 
            <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a> 
            <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration</a> 
            <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a> 
            <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a> 
            <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a> 
            <hr style="border-color: #00eaff30; margin: 10px 0;"> 
            <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Web & Research</h3> 
            <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a> 
            <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a> 
            <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a> 
            <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a> 
        </div> 
        <button class="submit-btn" style="margin-top:17px;" onclick="closeToolMenu();">Close</button> 
    </nav> 
</div> 
<div class="panel-bg" id="toolFormModalBg"> 
    <nav class="side-panel" id="toolFormModal"> 
        <div class="panel-header"> 
            <div class="username" id="toolFormTitle">Tool Title</div> 
        </div> 
        <form class="edit-form" id="toolForm" style="padding:0 6px;"></form> 
        <button id="toolFormBackBtn" class="submit-btn" style="background:#10213b;color:#00eefd;margin:7px 7px 17px 7px;"> 
            <i class="fa-solid fa-arrow-left"></i> Back to Tools 
        </button> 
        <div class="status-message" id="toolStatusMsg"></div> 
    </nav> 
</div> 
<div id="lightbox"> 
    <img src="" alt="Lightbox image"> 
</div> 
<div id="callModal"> 
    <div id="callHeader">Philadelphia AI - Live Call</div> 
    <div id="botImageContainer"> 
        <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Bot"> 
        <div id="botSpeakingIndicator"></div> 
    </div> 
    <div id="callStatusMessage">Connecting...</div> 
    <div id="tapToTalk">Tap Anywhere to Speak</div> 
    <div id="callConversation"> 
        <div class="call-msg status">Waiting for connection...</div> 
    </div> 
    <div id="callControls"> 
        <button id="muteCallBtn" class="submit-btn"><i class="fa-solid fa-microphone"></i> Mute Microphone</button> 
        <button id="endCallBtn" class="submit-btn" style="background: #d23;"><i class="fa-solid fa-phone-slash"></i> End Call</button> 
    </div> 
</div> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script> 
<script type="module"> 
// --- START OF FULLY REVAMPED & FIRESTORE-INTEGRATED JAVASCRIPT --- 
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js"; 
import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js"; 
// Import Firestore modules 
import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js"; 
const firebaseConfig = { 
    apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk", 
    authDomain: "elvionai.firebaseapp.com", 
    projectId: "elvionai", 
    storageBucket: "elvionai.appspot.com", 
    messagingSenderId: "161078300830", 
    appId: "1:161078300830:web:f460df8591704eb0e96b8f" 
}; 
const app = initializeApp(firebaseConfig); 
const auth = getAuth(app); 
const db = getFirestore(app); 
// Initialize Firestore 
// Short helper 
const $ = id => document.getElementById(id); 
// API Base URL 
const API_BASE_URL = 'https://web-production-9a18.up.railway.app'; 
// ---------- Global State Management & AbortController ---------- 
let chats = []; // Array of {id, name, createdAt} 
let currentChatId = null; 
let currentMessages = []; // Array of {id, role, text, files, createdAt} 
let uploadedFiles = []; 
let currentUser = null; 
let currentController = null; // Controller for ongoing chat/file fetch 
// Firestore listener unsubscribers 
let chatsUnsubscribe = null; 
let messagesUnsubscribe = null; 
window.addEventListener('DOMContentLoaded', () => { 
    // ---------- Element Selectors ---------- 
    const starsContainer = $('stars-container'); 
    const profileMenuBg = $('profileMenuBg'); 
    const profileMenu = $('profileMenu'); 
    const linkMenuBg = $('linkMenuBg'); 
    const linkMenu = $('linkMenu'); 
    const toolsMenuBg = $('toolsMenuBg'); 
    const toolsMenu = $('toolsMenu'); 
    const toolBtn = $('toolBtn'); 
    const logoutBtn = $('logoutBtn'); 
    const headerWelcome = $('headerWelcome'); 
    const profileMenuUser = $('profileMenuUser'); 
    const profileMenuEmail = $('profileMenuEmail'); 
    const editName = $('edit-name'); 
    const editPhoto = $('edit-photo'); 
    const profilePicPreview = $('profilePicPreview'); 
    const profileForm = $('profileForm'); 
    const chatBox = $('chatBox'); 
    const chatForm = $('chatForm'); 
    const chatInput = $('chatInput'); 
    const sendBtn = $('sendBtn'); 
    const chatFile = $('chatFile'); 
    const filePreview = $('filePreview'); 
    const newChatBtn = $('newChatBtn'); 
    const chatsListEl = $('chatsList'); 
    const emojiPanel = $('emojiPanel'); 
    const emojiBtn = $('emojiBtn'); 
    const toolFormModalBg = $('toolFormModalBg'); 
    const toolForm = $('toolForm'); 
    const toolFormTitle = $('toolFormTitle'); 
    const toolFormBackBtn = $('toolFormBackBtn'); 
    const aiPrevBox = $('ai-image-preview'); 
    const aiPrevClose = $('ai-image-close'); 
    const aiPrevDLBtn = $('ai-image-dl'); 
    const aiPrevImgBox = $('ai-image-container'); 
    const themeBtn = $('themeBtn'); 
    const lightbox = $('lightbox'); 
    const callBtn = $('callBtn'); 
    const callModal = $('callModal'); 
    const endCallBtn = $('endCallBtn'); 
    const muteCallBtn = $('muteCallBtn'); 
    // NEW: Mute button 
    const callConversation = $('callConversation'); 
    const botImageContainer = $('botImageContainer'); 
    const callStatusMessage = $('callStatusMessage'); 
    const tapToTalk = $('tapToTalk'); 
    const typingStatus = $('typing-status'); 
    if (!chatForm || !chatBox || !toolsMenu || !typingStatus) { 
        console.error("Essential UI elements are missing. App functionality will be limited."); 
        return; 
    } 
    // ---------- UI Initializers & Event Handlers ---------- 
    if (starsContainer) { 
        starsContainer.innerHTML = ''; 
        for (let i = 0; i < 34; i++) { 
            const s = document.createElement('div'); 
            s.className = 'star'; 
            const z = Math.random() * 2.1 + 1; 
            s.style.width = z + 'px'; 
            s.style.height = z + 'px'; 
            s.style.left = Math.random() * 100 + '%'; 
            s.style.top = Math.random() * 100 + '%'; 
            s.style.animationDelay = (Math.random() * 3.69) + 's'; 
            s.style.animationDuration = (2.2 + Math.random() * 1.1) + 's'; 
            starsContainer.appendChild(s); 
        } 
    } 
    const emojis = ["ðŸ˜€","ðŸ˜‚","ðŸ˜","ðŸ¥°","ðŸ˜Ž","ðŸ‘","ðŸ™","ðŸ”¥","ðŸ’¯","ðŸŽ‰","ðŸ˜‡","ðŸ¤–","ðŸ‘€"]; 
    if (emojiBtn && emojiPanel && chatInput) { 
        emojiBtn.addEventListener('click', (e) => { 
            emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join(''); 
            emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block'; 
            try { 
                const rect = emojiBtn.getBoundingClientRect(); 
                emojiPanel.style.left = `${Math.max(8, rect.left)}px`; 
            } catch (e) { /* ignore positioning errors */ } 
            emojiPanel.querySelectorAll('.emoji-pick').forEach(span => { 
                span.addEventListener('click', function () { 
                    const text = this.textContent || ''; 
                    const start = chatInput.selectionStart || 0; 
                    const end = chatInput.selectionEnd || 0; 
                    chatInput.value = chatInput.value.slice(0, start) + text + chatInput.value.slice(end); 
                    chatInput.focus(); 
                    chatInput.selectionStart = chatInput.selectionEnd = start + text.length; 
                    emojiPanel.style.display = 'none'; 
                    chatInput.dispatchEvent(new Event('input')); 
                }); 
            }); 
        }); 
        document.addEventListener('click', e => { 
            if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) { 
                emojiPanel.style.display = 'none'; 
            } 
        }); 
    } 
    if (chatInput) { 
        const autoResize = () => { 
            chatInput.style.height = 'auto'; 
            chatInput.style.height = Math.min(chatInput.scrollHeight, 168) + 'px'; 
        }; 
        chatInput.addEventListener('input', autoResize); 
        // NEW: Enter for new line, Shift+Enter or Send button for submit 
        chatInput.addEventListener('keydown', e => { 
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); // Do not submit, just add new line 
                const start = chatInput.selectionStart; 
                const end = chatInput.selectionEnd; 
                chatInput.value = chatInput.value.substring(0, start) + "\n" + chatInput.value.substring(end); 
                chatInput.selectionStart = chatInput.selectionEnd = start + 1; 
                autoResize(); // Adjust height after adding new line 
            } else if (e.key === 'Enter' && e.shiftKey) { 
                e.preventDefault(); // Prevent default shift+enter behavior (sometimes inserts two lines) 
                chatForm.requestSubmit(); // Submit on Shift+Enter 
            } 
        }); 
        autoResize(); 
    } 
    if (chatFile) { 
        chatFile.addEventListener('change', function() { 
            uploadedFiles = Array.from(this.files || []); 
            renderFilePreview(); 
        }); 
    } 
    if (aiPrevClose) aiPrevClose.addEventListener('click', () => { 
        aiPrevBox.style.display = 'none'; 
    }); 
    if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => { 
        const img = aiPrevImgBox.querySelector('img'); 
        if (img) { 
            const a = document.createElement('a'); 
            a.href = img.src; 
            a.download = 'philadelphia_ai_image.png'; 
            a.click(); 
        } 
    }); 
    // Image Lightbox handler 
    if (lightbox) { 
        lightbox.addEventListener('click', () => lightbox.classList.remove('active')); 
    } 
    if (chatBox) { 
        chatBox.addEventListener('click', e => { 
            if (e.target.tagName === 'IMG' && e.target.closest('.chat-message.ai .msg')) { 
                e.preventDefault(); 
                const lbImg = lightbox.querySelector('img'); 
                if (lbImg) { 
                    lbImg.src = e.target.src; 
                    lightbox.classList.add('active'); 
                } 
            } 
        }); 
    } 
    // ---------- Panel & Modal Management ---------- 
    window.closeToolMenu = () => { 
        if (toolsMenuBg) toolsMenuBg.classList.remove('active'); 
    }; 
    window.openToolMenu = () => { 
        if (toolsMenuBg) toolsMenuBg.classList.add('active'); 
    }; 
    if (profileMenuBg) { 
        $('openProfileMenu').addEventListener('click', () => { 
            profileMenuBg.classList.add('active'); 
            setTimeout(() => profileMenu.classList.add('active'), 10); 
        }); 
        profileMenuBg.addEventListener('click', e => { 
            if (e.target === profileMenuBg) { 
                profileMenu.classList.remove('active'); 
                setTimeout(() => profileMenuBg.classList.remove('active'), 110); 
            } 
        }); 
    } 
    if (linkMenuBg) { 
        $('openLinksMenu').addEventListener('click', () => { 
            linkMenuBg.classList.add('active'); 
            setTimeout(() => linkMenu.classList.add('active'), 10); 
        }); 
        linkMenuBg.addEventListener('click', e => { 
            if (e.target === linkMenuBg) { 
                linkMenu.classList.remove('active'); 
                setTimeout(() => linkMenuBg.classList.remove('active'), 110); 
            } 
        }); 
    } 
    if (toolBtn) toolBtn.addEventListener('click', openToolMenu); 
    if (toolsMenuBg) toolsMenuBg.addEventListener('click', e => { 
        if (e.target === toolsMenuBg) closeToolMenu(); 
    }); 
    if (toolFormBackBtn) { 
        toolFormBackBtn.addEventListener('click', () => { 
            toolFormModalBg.classList.remove('active'); 
            openToolMenu(); 
        }); 
    } 
    if (toolFormModalBg) toolFormModalBg.addEventListener('click', e => { 
        if (e.target === toolFormModalBg) toolFormModalBg.classList.remove('active'); 
    }); 
    if (logoutBtn) logoutBtn.addEventListener('click', () => { 
        auth.signOut(); 
        window.location.href = 'signup-login.html'; 
    }); 
    // ---------- Authentication & Profile Management ---------- 
    onAuthStateChanged(auth, user => { 
        if (!user) { 
            try { 
                window.location.href = "signup-login.html"; 
            } catch (e) {} 
            return; 
        } 
        currentUser = user; 
        if (headerWelcome) headerWelcome.textContent = "Welcome, " + (user.displayName || (user.email || '').split('@')[0]); 
        if (profileMenuUser) profileMenuUser.textContent = user.displayName || "User"; 
        if (profileMenuEmail) profileMenuEmail.textContent = user.email || ""; 
        if (editName) editName.value = user.displayName || ""; 
        if (editPhoto) editPhoto.value = user.photoURL || ""; 
        if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg"; 
        // Start loading chats from Firestore 
        loadUserChats(user.uid); 
    }); 
    if (profileForm) { 
        profileForm.addEventListener('submit', async (e) => { 
            e.preventDefault(); 
            if (!currentUser) return; 
            const status = $('profileStatusMsg'); 
            if (status) status.textContent = 'Saving...'; 
            try { 
                await updateProfile(currentUser, { 
                    displayName: editName.value, 
                    photoURL: editPhoto.value 
                }); 
                if (auth.currentUser) await auth.currentUser.reload(); 
                if (status) { 
                    status.textContent = "Profile updated!"; 
                    status.style.color = "#00ffff"; 
                } 
                setTimeout(() => { 
                    profileMenuBg?.classList.remove('active'); 
                }, 800); 
                if (headerWelcome) headerWelcome.textContent = "Welcome, " + (auth.currentUser?.displayName || 'User'); 
            } catch (err) { 
                if (status) { 
                    status.textContent = err.message; 
                    status.style.color = "#ffd700"; 
                } 
            } 
        }); 
    } 
    // ---------- Firestore Chat Logic ---------- 
    async function loadUserChats(userId) { 
        if (chatsUnsubscribe) chatsUnsubscribe(); // Unsubscribe from old listener 
        const chatsCol = collection(db, 'users', userId, 'chats'); 
        const q = query(chatsCol, orderBy('createdAt', 'desc')); 
        chatsUnsubscribe = onSnapshot(q, async (snapshot) => { 
            if (snapshot.empty) { 
                // No chats exist, create one 
                await createNewChat(userId); // The listener will re-run, so we just return 
                return; 
            } 
            chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); 
            renderChatsListSidebar(); 
            if (!currentChatId || !chats.find(c => c.id === currentChatId)) { 
                // If no chat is selected, or selected chat was deleted, select the newest one 
                currentChatId = chats[0].id; 
            } 
            // Subscribe to messages for the currently selected chat 
            subscribeToMessages(userId, currentChatId); 
        }, (error) => { 
            console.error("Error fetching chats: ", error); 
            chatsListEl.innerHTML = `<div style="color: #f44;">Error loading chats.</div>`; 
        }); 
    } 
    async function createNewChat(userId) { 
        if (!userId) userId = currentUser?.uid; 
        if (!userId) return; 
        const chatsCol = collection(db, 'users', userId, 'chats'); 
        try { 
            const newChatDoc = await addDoc(chatsCol, { name: "New Chat", createdAt: serverTimestamp() }); 
            currentChatId = newChatDoc.id; // No need to manually switch, the listener will handle it 
        } catch (e) { 
            console.error("Error creating new chat: ", e); 
        } 
    } 
    if (newChatBtn) { 
        newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid)); 
    } 
    function renderChatsListSidebar() { 
        if (!chatsListEl) return; 
        chatsListEl.innerHTML = ''; 
        if (chats.length === 0) { 
            chatsListEl.innerHTML = `<div style="padding: 10px; color: #a8eaff;">No chats yet.</div>`; 
            return; 
        } 
        chats.forEach((chat) => { 
            const container = document.createElement('div'); 
            container.style.display = 'flex'; 
            container.style.alignItems = 'center'; 
            container.style.marginBottom = '6px'; 
            container.style.background = chat.id === currentChatId ? 'rgba(0, 234, 255, 0.15)' : 'transparent'; 
            container.style.borderRadius = '8px'; 
            const titleSpan = document.createElement('span'); 
            titleSpan.textContent = chat.name || `Chat`; 
            titleSpan.style.flex = '1'; 
            titleSpan.style.cursor = 'pointer'; 
            titleSpan.style.padding = '8px 5px'; 
            titleSpan.onclick = () => { 
                currentChatId = chat.id; 
                subscribeToMessages(currentUser.uid, currentChatId); 
                renderChatsListSidebar(); // Re-render to show selection 
                profileMenu?.classList.remove('active'); 
                profileMenuBg?.classList.remove('active'); 
            }; 
            const renameBtn = document.createElement('button'); 
            renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>'; 
            renameBtn.title = 'Rename'; 
            renameBtn.style.margin = '0 6px 0 8px'; 
            renameBtn.onclick = async (e) => { 
                e.stopPropagation(); 
                const newName = prompt("Rename chat:", chat.name); 
                if (newName && newName.trim()) { 
                    const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id); 
                    await setDoc(chatDoc, { name: newName.trim() }, { merge: true }); // Listener will update UI 
                } 
            }; 
            const delBtn = document.createElement('button'); 
            delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>'; 
            delBtn.title = 'Delete'; 
            delBtn.style.marginLeft = '6px'; 
            delBtn.onclick = async (e) => { 
                e.stopPropagation(); 
                if (!confirm(`Delete "${chat.name}"? This will delete all messages.`)) return; 
                // Delete all messages in subcollection (batched) 
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages'); 
                const messagesSnap = await getDocs(messagesCol); 
                const batch = writeBatch(db); 
                messagesSnap.docs.forEach(d => batch.delete(d.ref)); 
                await batch.commit(); 
                // Delete chat doc 
                const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id); 
                await deleteDoc(doc(db, 'users', currentUser.uid, 'chats', chat.id));
                // If deleting current chat, reset 
                if (currentChatId === chat.id) { 
                    currentChatId = null; 
                } 
                // Listener will update sidebar 
            }; 
            container.appendChild(titleSpan); 
            container.appendChild(renameBtn); 
            container.appendChild(delBtn); 
            chatsListEl.appendChild(container); 
        }); 
    } 

    function subscribeToMessages(userId, chatId) { 
        if (messagesUnsubscribe) messagesUnsubscribe(); // Unsubscribe from old messages 
        if (!userId || !chatId) { 
            renderChatBox([]); // Clear chat box if no chat is selected 
            return; 
        } 
        const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages'); 
        const q = query(messagesCol, orderBy('createdAt')); 
        messagesUnsubscribe = onSnapshot(q, (snapshot) => { 
            currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); 
            renderChatBox(currentMessages); 
        }, (error) => { 
            console.error("Error fetching messages: ", error); 
            chatBox.innerHTML = `<div style="color: #f44; text-align: center; margin-top: 20px;">Error loading messages for this chat.</div>`; 
        }); 
    } 

    // ---------- Chat Rendering Logic - SAME AS BEFORE ----------
    const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); 
    function inlineMarkdown(t = '') { 
        let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`); 
        s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>'); 
        s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>'); 
        s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>'); 
        return s.replace(/\n/g, '<br>'); 
    } 
    function renderMarkdown(text = '') { 
        const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g; 
        let html = ''; 
        let lastIndex = 0; 
        text = text || ''; 
        text.replace(codeBlockRegex, (match, lang, code, offset) => { 
            const before = text.slice(lastIndex, offset); 
            html += inlineMarkdown(before); 
            const language = (lang || '').toLowerCase().trim(); 
            const safe = escapeHTML(code); 
            html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safe}</code></pre>`; 
            lastIndex = offset + match.length; 
            return match; 
        }); 
        html += inlineMarkdown(text.slice(lastIndex)); 
        return { html }; 
    } 
    function enhanceCodeBlocks(container) { 
        if (!container) return; 
        container.querySelectorAll('pre').forEach(pre => { 
            const codeEl = pre.querySelector('code'); 
            if (window.hljs && codeEl) { 
                try { 
                    hljs.highlightElement(codeEl); 
                } catch (e) { /* ignore */ } 
            } 
            const btn = pre.querySelector('.copy-btn'); 
            if (btn && codeEl) { 
                btn.addEventListener('click', async () => { 
                    try { 
                        await navigator.clipboard.writeText(codeEl.innerText); 
                        const prev = btn.textContent; 
                        btn.textContent = 'Copied!'; 
                        setTimeout(() => btn.textContent = prev, 800); 
                    } catch (e) { 
                        btn.textContent = 'Failed'; 
                        setTimeout(() => btn.textContent = 'Copy', 800); 
                    } 
                }); 
            } 
        }); 
    } 
    function renderChatBox(messages = []) { 
        if (!chatBox) return; 
        chatBox.innerHTML = ''; 
        (messages || []).forEach((msg) => { 
            const div = document.createElement('div'); 
            div.className = 'chat-message ' + (msg.role === 'user' ? 'user' : 'ai'); 
            // Store message ID and index for controls 
            div.setAttribute('data-message-id', msg.id); 
            let innerHtml = ''; 
            if (msg.role === 'user') { 
                const fileHtml = (msg.files || []) 
                    .map(file => { 
                        // We can't show previews for files from history without a storage solution 
                        // So we show a placeholder 
                        let icon = 'fa-file'; 
                        if (file.type.startsWith('image/')) icon = 'fa-file-image'; 
                        else if (file.type.startsWith('video/')) icon = 'fa-file-video'; 
                        else if (file.type.startsWith('audio/')) icon = 'fa-file-audio'; 
                        else if (file.type === 'application/pdf') icon = 'fa-file-pdf'; 
                        return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`; 
                    }) 
                    .join(''); 
                innerHtml = `<div class="msg"> 
                    ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''} 
                    ${escapeHTML(msg.text || '')} 
                    <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;"> 
                        <button class="inline-edit-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i></button> 
                        <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button> 
                    </div> 
                </div>`; 
            } else { 
                // AI message 
                // Check if the message contains HTML content (like tool results with images/audio/video) 
                let content; 
                if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) { 
                    content = msg.text; // Render raw HTML for tool outputs 
                } else { 
                    content = renderMarkdown(msg.text || '').html; 
                } 
                innerHtml = `<div class="msg">${content} 
                    <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;"> 
                        <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button> 
                        <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button> 
                        <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button> 
                    </div> 
                </div>`; 
            } 
            div.innerHTML = innerHtml; 
            chatBox.appendChild(div); 
        }); 
        enhanceCodeBlocks(chatBox); 
        hookAiMsgControls(); 
        hookUserMsgControls(); 
        // FIX: Force scroll to bottom on load/render 
        setTimeout(() => { 
            chatBox.scrollTop = chatBox.scrollHeight; 
        }, 50); 
    } 
    // --- Message Controls and Typewriter Logic - SAME AS BEFORE ---
    async function deleteMessagesFrom(messageId) { 
        if (!currentChatId || !currentUser) return; 
        const msgIndex = currentMessages.findIndex(m => m.id === messageId); 
        if (msgIndex === -1) return; 
        const batch = writeBatch(db); 
        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages'); 
        for (let i = msgIndex; i < currentMessages.length; i++) { 
            const msgToDel = currentMessages[i]; 
            const docRef = doc(messagesCol, msgToDel.id); 
            batch.delete(docRef); 
        } 
        try { 
            await batch.commit(); // The onSnapshot listener will automatically update the UI 
        } catch (e) { 
            console.error("Error deleting messages: ", e); 
        } 
    } 
    function hookAiMsgControls() { 
        if (!chatBox) return; 
        chatBox.querySelectorAll('.chat-message.ai').forEach(div => { 
            const messageId = div.getAttribute('data-message-id'); 
            const msg = currentMessages.find(m => m.id === messageId); 
            if (!msg) return; 
            const controls = div.querySelector('.ai-msg-controls'); 
            if (!controls) return; 
            const copyBtn = controls.querySelector('.inline-copy-btn'); 
            const shareBtn = controls.querySelector('.inline-share-btn'); 
            const regenBtn = controls.querySelector('.regen-btn'); 
            if (copyBtn) copyBtn.onclick = () => { 
                try { 
                    // Strip HTML tags for cleaner copy 
                    const tempDiv = document.createElement('div'); 
                    tempDiv.innerHTML = msg.text; 
                    const textToCopy = tempDiv.textContent || tempDiv.innerText || ''; 
                    navigator.clipboard.writeText(textToCopy); 
                    copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!"; 
                    setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950); 
                } catch (e) { 
                    console.warn('copy failed', e); 
                } 
            }; 
            if (shareBtn) shareBtn.onclick = () => { 
                try { 
                    const url = window.location.origin; 
                    const tempDiv = document.createElement('div'); 
                    tempDiv.innerHTML = msg.text; 
                    const plainText = tempDiv.textContent || tempDiv.innerText || ''; 
                    const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`; 
                    if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{}); 
                    else prompt("Copy and share manually:", shareText); 
                } catch (e) { 
                    console.warn('share failed', e); 
                } 
            }; 
            if (regenBtn) regenBtn.onclick = async () => { 
                const msgIndex = currentMessages.findIndex(m => m.id === messageId); 
                if (msgIndex < 1) return; // Can't regenerate first message 
                const userMsg = currentMessages[msgIndex - 1]; 
                if (userMsg.role !== 'user') return; // Preceding message wasn't user 
                // Delete this AI message and all subsequent messages 
                await deleteMessagesFrom(messageId); 
                // Re-send the user message 
                chatInput.value = userMsg.text; 
                chatInput.style.height = 'auto'; // Reset height 
                chatInput.style.height = Math.min(chatInput.scrollHeight, 168) + 'px'; 
                uploadedFiles = []; // Clear files (files are handled separately via db) 
                renderFilePreview(); 
                // Show "thinking..." immediately 
                showTypingAtNext(); 
                // Build history for regen 
                const historyForRegen = currentMessages 
                    .slice(0, msgIndex - 1) // Get all messages *before* the user's prompt 
                    .map(m => ({ role: m.role, content: m.text || '' })); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/chat`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ message: userMsg.text, history: historyForRegen, user_id: currentUser?.uid || "user" }) 
                    }); 
                    const data = await res.json(); 
                    if (!res.ok) throw new Error(data.error || "Server error."); 
                    removeTyping(); 
                    await startTypewriter(data.response, false); // Typewriter effect for regen 
                } catch (err) { 
                    removeTyping(); 
                    await startTypewriter(`âŒ Regeneration error: ${err.message}`, false); 
                } 
            }; 
        }); 
    } 
    function hookUserMsgControls() { 
        if (!chatBox) return; 
        chatBox.querySelectorAll('.chat-message.user').forEach(div => { 
            const messageId = div.getAttribute('data-message-id'); 
            const msg = currentMessages.find(m => m.id === messageId); 
            if (!msg) return; 
            const controls = div.querySelector('.user-msg-controls'); 
            if (!controls) return; 
            const copyBtn = controls.querySelector('.inline-copy-btn'); 
            const editBtn = controls.querySelector('.inline-edit-btn'); 
            if (copyBtn) copyBtn.onclick = () => { 
                try { 
                    // Strip HTML tags for cleaner copy 
                    const tempDiv = document.createElement('div'); 
                    tempDiv.innerHTML = msg.text; 
                    const textToCopy = tempDiv.textContent || tempDiv.innerText || ''; 
                    navigator.clipboard.writeText(textToCopy); 
                    copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!"; 
                    setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950); 
                } catch (e) { 
                    console.warn('copy failed', e); 
                } 
            }; 
            if (editBtn) editBtn.onclick = async () => { 
                try { 
                    if (!msg.text) return; 
                    chatInput.value = msg.text; 
                    chatInput.focus(); 
                    // Delete this message and all subsequent messages 
                    await deleteMessagesFrom(messageId); 
                    // UI will update via onSnapshot 
                } catch (e) { 
                    console.warn('edit failed', e); 
                } 
            }; 
        }); 
    } 
    // --- Typing Indicator Functions (KEPT DANCING) --- 
    function showTypingAtNext(statusText) { 
        if (!typingStatus) return; 
        let textHtml = '';
        if (statusText) {
             // Display the custom text next to the dancing dots
            textHtml = `<span style="margin-left:8px; color:var(--main-text); font-style:italic; font-size: 0.95em;">${statusText}</span>`;
        }
        typingStatus.innerHTML = `<div class="msg">
            <span class="typing-bubble">
                <span class="dot-anim"></span>
                <span class="dot-anim"></span>
                <span class="dot-anim"></span>
            </span>
            ${textHtml}
        </div>`;
        typingStatus.style.display = 'flex'; // Ensure it's visible 
        // Ensure scroll to bottom to show typing indicator 
        chatBox.scrollTop = chatBox.scrollHeight; 
    } 
    function removeTyping() { 
        if (!typingStatus) return; 
        typingStatus.style.display = 'none'; 
        typingStatus.innerHTML = ''; 
    } 
    // --- Typewriter Function (KEPT REAL-TIME) --- 
    async function startTypewriter(text, saveToDb = true) { 
        // If the text contains HTML tags related to media, skip typewriter and save directly 
        if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) { 
            if (saveToDb) { 
                await addMessageToChat('ai', text); // Save full HTML to DB 
            } else { 
                // For regen, if we skip typewriter, we still need to add it to the chatbox 
                const tempDiv = document.createElement('div'); 
                tempDiv.className = "chat-message ai"; 
                tempDiv.innerHTML = `<div class="msg">${text}</div>`; 
                chatBox.appendChild(tempDiv); 
                chatBox.scrollTop = chatBox.scrollHeight; 
                // Now manually save the regen response 
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages'); 
                try { 
                    await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() }); 
                } catch (e) { 
                    console.error("Error saving regenerated AI tool message: ", e); 
                } 
            } 
            return; 
        } 
        // Standard Typewriter (for text/markdown) 
        if (!chatBox) return; 
        // 1. Create a temporary message node for the animation 
        const div = document.createElement('div'); 
        div.className = "chat-message ai"; 
        const msgdiv = document.createElement('div'); 
        msgdiv.className = 'msg'; 
        div.appendChild(msgdiv); 
        chatBox.appendChild(div); 
        // Add temp node to chatBox 
        let sofar = ''; 
        const words = text.split(/(\s+)/); // Split on spaces, keeping them 
        let tempText = ''; 
        for (const word of words) { 
            if (currentController?.signal.aborted) { 
                text = tempText; // Save the aborted text 
                break; 
            } 
            tempText += word; 
            // Only render full code blocks, not partial ones 
            if (tempText.includes('```')) { 
                const parts = tempText.split('```'); 
                sofar = parts.slice(0, parts.length -1).join('```'); 
                if(parts.length % 2 === 0) sofar += '```'; // Re-add the last separator if we're inside a block 
            } else { 
                sofar = tempText; 
            } 
            // Render the current segment 
            msgdiv.innerHTML = renderMarkdown(sofar).html; 
            // Scroll to keep up with the typing 
            chatBox.scrollTop = chatBox.scrollHeight; 
            // Speed check: faster for symbols/spaces, slower for words 
            const delay = word.match(/[\s\.\,\!\?]/) ? 8 : 25; // Slightly reduced delay
            await new Promise(res => setTimeout(res, delay)); 
        } 
        // Final text (handles full text or aborted text) 
        const finalRenderText = text; 
        // 2. Add final controls to the temporary node 
        msgdiv.innerHTML = renderMarkdown(finalRenderText).html + ` 
            <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;"> 
                <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button> 
                <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button> 
                <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button> 
            </div> 
        `; 
        enhanceCodeBlocks(msgdiv); 
        chatBox.scrollTop = chatBox.scrollHeight; 
        // 3. Save the final message to Firestore 
        if (saveToDb) { 
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages'); 
            try { 
                await addDoc(messagesCol, { role: 'ai', text: finalRenderText, // Save the full (or aborted) text 
                    createdAt: serverTimestamp() }); 
                // The onSnapshot listener will now fire, 
                // replacing our temporary node with the permanent, DB-driven one. 
                // It will look seamless. 
            } catch (e) { 
                console.error("Error saving AI message: ", e); 
                msgdiv.innerHTML += "<br><small style='color: #f44;'>Failed to save message.</small>"; 
            } 
        } 
    } 
    // --- File Preview/Image Persistence Logic - KEPT BASE64 ---
    function renderFilePreview() { 
        if (!filePreview) return; 
        if (!uploadedFiles.length) { 
            filePreview.style.display = 'none'; 
            filePreview.innerHTML = ''; 
            return; 
        } 
        filePreview.style.display = 'block'; 
        filePreview.innerHTML = uploadedFiles.map((file, idx) => { 
            let preview = ''; 
            if (file.type.startsWith('image/')) { 
                preview = `<img src="${URL.createObjectURL(file)}" style="max-width:58px;max-height:41px;vertical-align:middle;border-radius:8px;margin-right:6px;">`; 
            } else if (file.type.startsWith('video/')) { 
                preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:58px;height:41px;vertical-align:middle;border-radius:8px;margin-right:7px;"></video>`; 
            } else if (file.type.startsWith('audio/')) { 
                preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:52px;margin-right:7px;"></audio>`; 
            } else if (file.type === 'application/pdf') { 
                preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`; 
            } 
            return ` 
                <div style="display:flex;align-items:center;gap:7px;margin-bottom:1px;"> 
                    ${preview} 
                    <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span> 
                    <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button> 
                </div>`; 
        }).join(''); 
        filePreview.querySelectorAll('.remove-file-btn').forEach(btn => { 
            btn.addEventListener('click', () => { 
                const idx = parseInt(btn.getAttribute('data-idx')); 
                uploadedFiles.splice(idx, 1); 
                if (!uploadedFiles.length && chatFile) chatFile.value = ''; 
                renderFilePreview(); 
            }); 
        }); 
    } 
    function showAIImagePreview(base64, caption = '') { 
        if (!aiPrevBox || !aiPrevImgBox) return; 
        aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:210px;max-height:210px;border-radius:12px;display:block;">` + `<div style="color:#aee;font-size:.95em;margin-top:3px;text-align:center;">${caption}</div>`; 
        aiPrevBox.style.display = 'block'; 
    } 
    async function addMessageToChat(role, text, files = []) { 
        if (!currentChatId || !currentUser) return; 
        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages'); 
        try { 
            await addDoc(messagesCol, { role, text, files, // This will be an array of {name, type} 
                createdAt: serverTimestamp() }); 
            // The onSnapshot listener will handle the UI update 
        } catch (e) { 
            console.error("Error adding message to Firestore: ", e); 
        } 
    } 
    // Helper to convert Blob to Base64 (CRITICAL FOR PERSISTENCE)
    function blobToBase64(blob) { 
        return new Promise((resolve, reject) => { 
            const reader = new FileReader(); 
            reader.onloadend = () => resolve(reader.result); 
            reader.onerror = reject; 
            reader.readAsDataURL(blob); 
        }); 
    } 
    async function handleVideoGeneration(payload, isImageToVideo = false) { 
        showTypingAtNext('Submitting video generation job...'); 
        try { 
            const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text'; 
            // NEW: Ensure model, duration, resolution are included for video tools 
            const commonPayload = { 
                model: "MiniMax-Hailuo-02", // Explicitly set model 
                duration: payload.duration || 6, // Default duration if not provided 
                resolution: payload.resolution || "1080P" // Default resolution 
            }; 
            let options; 
            if (isImageToVideo) { 
                // FormData for image upload 
                payload.append('model', commonPayload.model); 
                payload.append('duration', commonPayload.duration); 
                payload.append('resolution', commonPayload.resolution); 
                options = { method: 'POST', body: payload }; 
            } else { 
                // JSON for text 
                const finalPayload = { ...payload, ...commonPayload }; 
                options = { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(finalPayload) 
                }; 
            } 
            const startRes = await fetch(API_BASE_URL + endpoint, options); 
            const startData = await startRes.json(); 
            if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to start video task.'); 
            removeTyping(); 
            await startTypewriter(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. I'll notify you when it's ready. This can take a few minutes. Do not leave this page or send another message or task.`); 
            const pollInterval = setInterval(async () => { 
                try { 
                    const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`); 
                    const statusData = await statusRes.json(); 
                    if (statusRes.ok && statusData.url) { 
                        clearInterval(pollInterval); 
                        // Video uses external URL, cannot be stored in DB like Base64 (too large)
                        const videoHtml = `ðŸŽ‰ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`; 
                        await addMessageToChat('ai', videoHtml); // Save HTML directly 
                    } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) { 
                        clearInterval(pollInterval); 
                        await startTypewriter(`âŒ Video generation failed. Reason: ${statusData.error || 'Unknown error'}`); 
                    } 
                } catch (pollErr) { 
                    clearInterval(pollInterval); 
                    await startTypewriter(`âŒ Error checking video status.`); 
                } 
            }, 20000); 
        } catch (err) { 
            removeTyping(); 
            await startTypewriter(`âŒ Could not start video generation: ${err.message}`); 
        } 
    } 
    const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"]; 
    const toolDefinitions = { 
        "image": { 
            title: "Generate Image", 
            description: "Create stunning visuals from a text prompt. Choose a model for different results.", 
            buildForm: () => ` 
                <label for="tool-provider">Generation Model</label> 
                <select id="tool-provider"><option value="thena">Version 1 (Stylized, Fast & Recommended)</option><option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option></select> 
                <label for="tool-prompt">Image Prompt</label> 
                <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required></textarea> 
                <label for="tool-style">Style (for Version1 only)</label> 
                <select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate</button>`, 
            handleSubmit: async (form) => { 
                const use_minimax = form.querySelector('#tool-provider').value === 'minimax'; 
                const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)'; 
                const payload = { 
                    prompt: form.querySelector('#tool-prompt').value, 
                    model: form.querySelector('#tool-style').value, 
                    use_minimax 
                }; 
                await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`); 
                showTypingAtNext('Generating your image...'); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/generate-image`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(payload) 
                    }); 
                    const data = await res.json(); 
                    if (!res.ok) throw new Error(data.error || res.statusText); 
                    showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`); 
                    // NEW: Only add text message to chat 
                    removeTyping(); 
                    await addMessageToChat('ai', 'âœ… Image generated! Check the floating image box to view or download.'); 
                    return null; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Image generation failed: ${err.message}`; 
                } 
            } 
        }, 
        "edit-photo": { 
            title: "Edit Photo", 
            description: "Upload a photo and describe the changes you want to make.", 
            buildForm: () => ` 
                <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required></textarea> 
                <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>`, 
            handleSubmit: async (form) => { 
                const file = form.querySelector('#tool-file').files[0]; 
                const prompt = form.querySelector('#tool-prompt').value; 
                if (!file) return "Please select a file to edit."; 
                const fd = new FormData(); 
                fd.append('file', file); 
                fd.append('prompt', prompt); 
                await addMessageToChat('user', `Photo edit request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]); 
                showTypingAtNext('Editing your photo...'); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { 
                        method: 'POST', 
                        body: fd 
                    }); 
                    if (!res.ok) throw new Error((await res.json()).error || 'Failed to edit photo.'); 
                    const blob = await res.blob(); 
                    // CRITICAL FIX: Convert blob to base64 for persistent storage in chat 
                    const base64String = await blobToBase64(blob); 
                    const imgHtml = `âœ… Photo edited successfully! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`; 
                    removeTyping(); 
                    await addMessageToChat('ai', imgHtml); // Save HTML directly 
                    return null; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Photo edit failed: ${err.message}`; 
                } 
            } 
        }, 
        "remove-bg": { 
            title: "Remove Background", 
            description: "Select an image file to automatically remove its background.", 
            buildForm: () => ` 
                <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;"> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Remove Background</button>`, 
            handleSubmit: async (form) => { 
                const file = form.querySelector('#tool-file').files[0]; 
                if (!file) return "Please select a file."; 
                await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{name: file.name, type: file.type}]); 
                showTypingAtNext('Removing background...'); 
                const fd = new FormData(); 
                fd.append('file', file); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { 
                        method: 'POST', 
                        body: fd 
                    }); 
                    if (!res.ok) throw new Error(res.statusText); 
                    const blob = await res.blob(); 
                    // CRITICAL FIX: Convert blob to base64 for persistent storage in chat 
                    const base64String = await blobToBase64(blob); 
                    const imgHtml = `âœ… Background removed! <br><img src="${base64String}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`; 
                    removeTyping(); 
                    await addMessageToChat('ai', imgHtml); // Save HTML directly 
                    return null; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Background removal failed: ${err.message}`; 
                } 
            } 
        }, 
        "comic": { 
            title: "Create Comic", 
            description: "Write a story and watch it transform into a comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.", 
            buildForm: () => ` 
                <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required></textarea> 
                <label for="tool-style">Comic Style</label><select id="tool-style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select> 
                <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" /> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Create Comic</button>`, 
            handleSubmit: async (form) => { 
                const payload = { 
                    story: form.querySelector('#tool-story').value, 
                    style: form.querySelector('#tool-style').value, 
                    panels: parseInt(form.querySelector('#tool-panels').value, 10), 
                    user: currentUser?.displayName || "User" 
                }; 
                await addMessageToChat('user', `Comic creation request with style: ${payload.style}.`); 
                showTypingAtNext('Generating your comic panels...'); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(payload) 
                    }); 
                    const data = await res.json(); 
                    if (!res.ok) throw new Error(data.error || res.statusText); 
                    // CRITICAL FIX: Ensure base64 images are included directly in the chat message for persistence 
                    const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join(''); 
                    const comicMessage = `ðŸ–¼ï¸ Comic successfully created! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`; 
                    removeTyping(); 
                    await addMessageToChat('ai', comicMessage); // Save HTML directly 
                    return null; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Comic generation failed: ${err.message}`; 
                } 
            } 
        }, 
        "voice-gen": { 
            title: "Voice Generation", 
            description: "Transform text into realistic speech. Choose a provider and voice style.", 
            buildForm: () => ` 
                <label for="tool-provider">Voice Provider</label><select id="tool-provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select> 
                <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required></textarea> 
                <label for="tool-style">Voice Style</label><select id="tool-style"></select> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice</button>`, 
            onFormReady: () => { 
                const providerSelect = $('tool-provider'), styleSelect = $('tool-style'); 
                const voices = { 
                    gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"], 
                    minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"] 
                }; 
                const updateStyles = () => { 
                    styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join(''); 
                }; 
                providerSelect.addEventListener('change', updateStyles); 
                updateStyles(); 
            }, 
            handleSubmit: async (form) => { 
                const provider = form.querySelector('#tool-provider').value, text = form.querySelector('#tool-prompt').value, style = form.querySelector('#tool-style').value; 
                const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia'; 
                await addMessageToChat('user', `Voice generation request using ${providerName}.`); 
                showTypingAtNext('Generating your audio...'); 
                try { 
                    let res; 
                    if (provider === 'gemini') { 
                        const fd = new FormData(); 
                        fd.append('text', text); 
                        fd.append('style', style); 
                        res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd }); 
                    } else { 
                        res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, { 
                            method: 'POST', 
                            headers: {'Content-Type': 'application/json'}, 
                            body: JSON.stringify({ text, voice_id: style }) 
                        }); 
                    } 
                    if (!res.ok) throw new Error(await res.text()); 
                    const blob = await res.blob(); 
                    // CRITICAL FIX: Convert blob to base64 for persistent storage in chat 
                    const base64String = await blobToBase64(blob);
                    const audioHtml = `ðŸ—£ï¸ Voice generated! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`; 
                    removeTyping(); 
                    await addMessageToChat('ai', audioHtml); // Save HTML directly 
                    return null; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Voice generation failed: ${err.message}`; 
                } 
            } 
        }, 
        "audio-narration": { 
            title: "Audio Narration", 
            description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.", 
            buildForm: () => ` 
                <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;"> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>`, 
            handleSubmit: async (form) => { 
                const file = form.querySelector('#tool-file').files[0]; 
                if (!file) return "Please select a file."; 
                await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]); 
                showTypingAtNext('Analyzing and narrating document...'); 
                const fd = new FormData(); 
                fd.append('file', file); 
                fd.append('style', 'podcast'); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { 
                        method: 'POST', 
                        body: fd 
                    }); 
                    if (!res.ok) throw new Error(res.statusText); 
                    const blob = await res.blob(); 
                    // CRITICAL FIX: Convert blob to base64 for persistent storage in chat 
                    const base64String = await blobToBase64(blob);
                    const narrationHtml = `ðŸ—£ï¸ Narration generated! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`; 
                    removeTyping(); 
                    await addMessageToChat('ai', narrationHtml); // Save HTML directly 
                    return null; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Audio narration failed: ${err.message}`; 
                } 
            } 
        }, 
        "video-text": { 
            title: "Generate Video from Text", 
            description: "Describe the video you want to create. This process can take a few minutes.", 
            buildForm: () => ` 
                <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required></textarea> 
                <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15"> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`, 
            handleSubmit: async (form) => { 
                const payload = { 
                    prompt: form.querySelector('#video-prompt').value, 
                    duration: parseInt(form.querySelector('#video-duration').value, 1.0), 
                    resolution: "1080P" 
                }; 
                await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`); 
                handleVideoGeneration(payload); // This will handle its own typing indicators 
                return null; 
            } 
        }, 
        "video-image": { 
            title: "Generate Video from Image", 
            description: "Upload a starting image and describe how you want to animate it.", 
            buildForm: () => ` 
                <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required></textarea> 
                <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`, 
            handleSubmit: async (form) => { 
                const file = form.querySelector('#video-image-file').files[0]; 
                if (!file) return "Please select an image."; 
                await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{name: file.name, type: file.type}]); 
                const fd = new FormData(); 
                fd.append('prompt', form.querySelector('#video-image-prompt').value); 
                fd.append('file', file); 
                handleVideoGeneration(fd, true); // This will handle its own typing indicators 
                return null; 
            } 
        }, 
        "music": { 
            title: "Generate Music", 
            description: "Generate music from a prompt, lyrics, and optional reference audio. Thanks to MiniMax.", 
            buildForm: () => ` 
                <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required></textarea> 
                <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..."></textarea> 
                <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*"> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Music</button>`, 
            handleSubmit: async (form) => { 
                const payload = { 
                    prompt: form.querySelector('#music-prompt').value, 
                    lyrics: form.querySelector('#music-lyrics').value, 
                    model: 'music-1.5' 
                }; 
                const refFile = form.querySelector('#music-ref').files[0]; 
                await addMessageToChat('user', `Music generation request: "${payload.prompt}"`); 
                showTypingAtNext('Composing your music...'); 
                try { 
                    if (refFile) { 
                        showTypingAtNext('Uploading reference audio first...'); 
                        const fd = new FormData(); 
                        fd.append('file', refFile); 
                        const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd }); 
                        const uploadData = await uploadRes.json(); 
                        if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed."); 
                        if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id; 
                        if (uploadData.voice_id) payload.voice_id = uploadData.voice_id; 
                        showTypingAtNext('Reference uploaded. Composing music...'); 
                    } 
                    const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(payload) 
                    }); 
                    if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.'); 
                    const blob = await res.blob(); 
                    // CRITICAL FIX: Convert blob to base64 for persistent storage in chat 
                    const base64String = await blobToBase64(blob);
                    const musicHtml = `ðŸŽµ Your music is ready! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`; 
                    removeTyping(); 
                    await addMessageToChat('ai', musicHtml); // Save HTML directly 
                    return null; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Music generation failed: ${err.message}`; 
                } 
            } 
        }, 
        "website": { 
            title: "Create Website", 
            description: "Describe the website you want to build and get a live, working prototype.", 
            buildForm: () => ` 
                <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required></textarea> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Website</button>`, 
            handleSubmit: async (form) => { 
                const prompt = form.querySelector('#website-prompt').value; 
                await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`); 
                showTypingAtNext('Building and deploying your website...'); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ prompt, user_id: currentUser.uid }) 
                    }); 
                    const data = await res.json(); 
                    if (!res.ok) throw new Error(data.error || res.statusText); 
                    removeTyping(); 
                    return `ðŸŒ Website deployed successfully! [View here](${data.url})`; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Website creation failed: ${err.message}`; 
                } 
            } 
        }, 
        "edit-website": { 
            title: "Edit Last Website", 
            description: "Provide an instruction to modify the most recent website you created.", 
            buildForm: () => ` 
                <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required></textarea> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>`, 
            handleSubmit: async (form) => { 
                const instruction = form.querySelector('#edit-instruction').value; 
                await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`); 
                showTypingAtNext('Editing and redeploying your website...'); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ instruction, user_id: currentUser.uid }) 
                    }); 
                    const data = await res.json(); 
                    if (!res.ok) throw new Error(data.error || res.statusText); 
                    removeTyping(); 
                    return `âœï¸ Website updated successfully! [View new version here](${data.url})`; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Website edit failed: ${err.message}`; 
                } 
            } 
        }, 
        "my-sites": { 
            isAction: true, 
            runAction: async () => { 
                await addMessageToChat('user', 'Show me a list of my websites.'); 
                showTypingAtNext('Fetching your website list...'); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`); 
                    const data = await res.json(); 
                    if (!res.ok) throw new Error(data.error || 'Could not fetch sites.'); 
                    if (!data.sites || data.sites.length === 0) return "You haven't created any websites yet."; 
                    const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n'); 
                    removeTyping(); 
                    return `Here are the websites you've created:\n${siteList}`; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Error fetching websites: ${err.message}`; 
                } 
            } 
        }, 
        "research-report": { 
            title: "Research Report", 
            description: "Generate a comprehensive research report in PDF format on any topic.", 
            buildForm: () => ` 
                <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required> 
                <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>`, 
            handleSubmit: async (form) => { 
                const topic = form.querySelector('#research-topic').value; 
                await addMessageToChat('user', `Research report request on: "${topic}"`); 
                showTypingAtNext('Conducting research and compiling report...'); 
                try { 
                    const res = await fetch(`${API_BASE_URL}/api/tools/research`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ topic }) 
                    }); 
                    if (!res.ok) throw new Error(res.statusText); 
                    const blob = await res.blob(); 
                    const url = URL.createObjectURL(blob); // Still a temporary URL, but PDF download is fine
                    const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--link-text);font-weight:bold;">Download PDF Report</a>`; 
                    removeTyping(); 
                    return `âœ… Research report on **${topic}** is ready! ${downloadLink}`; 
                } catch (err) { 
                    removeTyping(); 
                    return `âŒ Research report failed: ${err.message}`; 
                } 
            } 
        }, 
    }; 
    if (toolsMenu) { 
        toolsMenu.addEventListener('click', async (e) => { 
            const toolLink = e.target.closest('.tool-link'); 
            if (!toolLink) return; 
            e.preventDefault(); 
            const toolKey = toolLink.getAttribute('data-tool'); 
            const tool = toolDefinitions[toolKey]; 
            if (!tool) return console.error(`Tool "${toolKey}" is not defined.`); 
            closeToolMenu(); 
            if (tool.isAction) { 
                const result = await tool.runAction(); 
                removeTyping(); 
                if(result) await startTypewriter(result); // Use typewriter 
            } else { 
                displayToolForm(toolKey); 
            } 
        }); 
    } 
    function displayToolForm(toolKey) { 
        const tool = toolDefinitions[toolKey]; 
        if (!tool || !toolFormModalBg) return; 
        toolFormTitle.textContent = tool.title; 
        const descriptionHtml = tool.description ? `<div style="color:#a8eaff;font-size:.9em;margin-bottom:12px;">${tool.description}</div>` : ''; 
        toolForm.innerHTML = descriptionHtml + tool.buildForm(); 
        if (typeof tool.onFormReady === 'function') tool.onFormReady(); 
        toolForm.onsubmit = async (e) => { 
            e.preventDefault(); 
            const submitButton = toolForm.querySelector('button[type="submit"]'); 
            const originalButtonContent = submitButton.innerHTML; 
            submitButton.innerHTML = `<div class="spinner"></div> Processing...`; 
            submitButton.disabled = true; 
            toolFormModalBg.classList.remove('active'); 
            const resultText = await tool.handleSubmit(toolForm); 
            // This handles cases where the tool returns a string result (e.g., website link, error) 
            // If resultText is null (e.g., media gen which saves to DB directly), no action is taken here. 
            if (resultText) { 
                removeTyping(); 
                await startTypewriter(resultText); // Use typewriter 
            } 
            submitButton.innerHTML = originalButtonContent; 
            submitButton.disabled = false; 
        }; 
        toolFormModalBg.classList.add('active'); 
    } 
    /* ---------- MAIN CHAT SUBMIT HANDLER (FIXED: Stop Button and Streaming) ---------- */ 
    chatForm.addEventListener('submit', async function (e) { 
        e.preventDefault(); 
        if (!currentChatId) { 
            alert("Please select a chat or create a new one."); 
            return; 
        } 
        const msgText = chatInput.value.trim(); 
        if (!msgText && uploadedFiles.length === 0) return; 
        // 1. Replace Send button with Stop button 
        const stopButton = document.createElement('button'); 
        stopButton.type = 'button'; 
        stopButton.id = 'stopBtn'; 
        stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>'; 
        sendBtn.replaceWith(stopButton); 
        currentController = new AbortController(); 
        const signal = currentController.signal; 
        let finalResponse = ''; 
        stopButton.addEventListener('click', () => { 
            if (currentController) { 
                currentController.abort(); 
            } 
        }); 
        // 2. Save user message first 
        const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type })); 
        await addMessageToChat('user', msgText, filesForHistory); 
        const localUploadedFiles = [...uploadedFiles]; // Copy for processing 
        chatInput.value = ''; 
        uploadedFiles = []; 
        renderFilePreview(); 
        chatInput.style.height = 'auto'; // Reset height 
        if (localUploadedFiles.length > 0) { 
            showTypingAtNext('Analyzing your file(s)...'); // Use dancing dots + status
            let endpoint = ''; 
            const file = localUploadedFiles[0]; 
            if (file.type.startsWith('image/')) endpoint = '/understand-image'; 
            else if (file.type === 'application/pdf') endpoint = '/understand-pdf'; 
            else if (file.type.startsWith('audio/')) endpoint = '/understand-audio'; 
            else if (file.type.startsWith('video/')) endpoint = '/understand-video'; 
            else { 
                removeTyping(); 
                finalResponse = "Sorry, I can't analyze that file type."; 
            } 
            try { 
                if(endpoint) { 
                    const fd = new FormData(); 
                    fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]}`); 
                    fd.append('file', file); 
                    const res = await fetch(API_BASE_URL + endpoint, { 
                        method: 'POST', 
                        body: fd, 
                        signal 
                    }); 
                    const data = await res.json(); 
                    if (!res.ok) throw new Error(data.error || "Analysis failed."); 
                    finalResponse = data.response; 
                } 
            } catch (err) { 
                finalResponse = err.name === 'AbortError' ? 'âŒ File analysis stopped.' : `âŒ File analysis failed: ${err.message}`; 
            } 
        } else if (msgText) { 
            showTypingAtNext(); // Show "..." (Dancing dots)
            try { 
                // Build history from currentMessages 
                const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' })); 
                const res = await fetch(`${API_BASE_URL}/chat`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }), 
                    signal 
                }); 
                const data = await res.json(); 
                if (!res.ok) throw new Error(data.error || "Server error."); 
                finalResponse = data.response; 
            } catch (err) { 
                finalResponse = err.name === 'AbortError' ? 'âŒ Response stopped.' : `âŒ An error occurred: ${err.message}`; 
            } 
        } 
        // 3. Handle final response and cleanup 
        removeTyping(); 
        if (finalResponse) { 
            await startTypewriter(finalResponse); 
        } 
        // 4. Restore button and clear controller 
        stopButton.replaceWith(sendBtn); 
        currentController = null; 
    }); 
    // ---------- Theme Switcher Logic (REVERTED DEFAULT TO CYBER) ---------- 
    const themes = { 
        cyber: { // Default (Enhanced) 
            '--cyan': '#00fff7', 
            '--blue': '#0a8afe', 
            '--dark-bg': '#070b1a', 
            '--fade-blue': '#133c8b', 
            '--gradient-1': 'linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%)', 
            '--gradient-user': 'linear-gradient(120deg, #0857ee 32%, #00fff0 89%)', 
            '--bubble-glow': '0 0 13px #00d8ffb1, 0 0 24px #0197ff40', 
            '--user-glow': '0 0 22px #0fffd555, 0 0 14px #36f9ff70', 
            '--header-glass': 'rgba(17,29,47,0.92)', 
            '--code-bg': 'linear-gradient(92deg,#031d39 79%,#092ff8 120%)', 
            '--code-border': '#15faff', 
            '--code-text': '#17fafd', 
            '--main-text': '#e1fafe', 
            '--link-text': '#13efff', 
            '--input-bg': '#09284c', 
            '--body-bg': 'radial-gradient(circle at 60% 45%, #112250 37%, #060e1e 88%, #1e0942 100%) fixed, repeating-linear-gradient(100deg,#061c4c 0 9%,#080e20 16% 19%,#030721 30% 41%,#052650 44% 62%,#050b16 74% 89%,#041048 99% 100%)', 
            '--body-blend-mode': 'lighten, color-dodge', 
            '--panel-bg': 'linear-gradient(118deg,#131642 80%,#1629af 200%)', 
            '--panel-border': '#00fbffcb', 
            '--panel-shadow': '0 0 42px #25f8ffc9', 
            '--submit-bg': 'linear-gradient(94deg,#00ffff,#0090ff 90%)', 
            '--submit-text': '#102649', 
            '--submit-hover-bg': '#008cff', 
            '--submit-hover-text': '#fff', 
            '--header-text-glow': '0 0 12px #00ffe0cc, 0 0 27px #178fcf88', 
            '--header-text-anim-glow-1': '0 0 17px #00e7ff70,0 0 30px #0b8fff44', 
            '--header-text-anim-glow-2': '0 0 29px #00ffe9ee,0 0 44px #31d2ff82', 
            '--header-text-fill': 'linear-gradient(90deg,#00fff1,#00b4ff 40%,#fff 59%,#1093f1 89%,#24e0fa 100%)' 
        }, 
        celestial: { // Otherworldly, Space (Deep Purple/Pink) 
            '--cyan': '#ff00ff', 
            '--blue': '#8a2be2', 
            '--dark-bg': '#0f001a', 
            '--fade-blue': '#2b003e', 
            '--gradient-1': 'linear-gradient(120deg, #2b003e 39%, #580080 68%, #ff00ff 97%)', 
            '--gradient-user': 'linear-gradient(120deg, #8a2be2 32%, #ff00ff 89%)', 
            '--bubble-glow': '0 0 15px #ff00ffb1', 
            '--user-glow': '0 0 25px #ff66ff55, 0 0 16px #cc00cc70', 
            '--header-glass': 'rgba(25,0,35,0.92)', 
            '--code-bg': 'linear-gradient(92deg,#2b003e 79%,#8a2be2 120%)', 
            '--code-border': '#ff00ff', 
            '--code-text': '#f0e6ff', 
            '--main-text': '#f0e6ff', 
            '--link-text': '#ff66ff', 
            '--input-bg': '#2b003e', 
            '--body-bg': 'radial-gradient(circle at 50% 50%, #1a0033 0%, #0f001a 100%)', 
            '--body-blend-mode': 'normal', 
            '--panel-bg': 'linear-gradient(118deg,#2b003e 80%,#580080 200%)', 
            '--panel-border': '#ff00ffcb', 
            '--panel-shadow': '0 0 45px #ff00ffc9', 
            '--submit-bg': 'linear-gradient(94deg,#ff00ff,#8a2be2 90%)', 
            '--submit-text': '#0f001a', 
            '--submit-hover-bg': '#8a2be2', 
            '--submit-hover-text': '#fff', 
            '--header-text-glow': '0 0 15px #ff00ffcc', 
            '--header-text-anim-glow-1': '0 0 20px #ff00ff70', 
            '--header-text-anim-glow-2': '0 0 35px #ff00ffee', 
            '--header-text-fill': 'linear-gradient(90deg,#ff00ff,#8a2be2 40%,#fff 59%,#8a2be2 89%,#ff00ff 100%)' 
        }, 
        starlight: { // Perfectable Stars (Soft Blue/White) 
            '--cyan': '#a6faff', 
            '--blue': '#00c3ff', 
            '--dark-bg': '#030010', 
            '--fade-blue': '#100c25', 
            '--gradient-1': 'linear-gradient(120deg, #100c25 39%, #1c153f 68%, #3f337f 97%)', 
            '--gradient-user': 'linear-gradient(120deg, #00c3ff 32%, #a6faff 89%)', 
            '--bubble-glow': '0 0 13px #00c3ffb1', 
            '--user-glow': '0 0 22px #a6faff55', 
            '--header-glass': 'rgba(16,12,37,0.92)', 
            '--code-bg': 'linear-gradient(92deg,#100c25 79%,#3f337f 120%)', 
            '--code-border': '#a6faff', 
            '--code-text': '#a6faff', 
            '--main-text': '#f0faff', 
            '--link-text': '#a6faff', 
            '--input-bg': '#100c25', 
            '--body-bg': 'radial-gradient(ellipse at bottom, #0d0920 0%, #030010 70%)', 
            '--body-blend-mode': 'normal', 
            '--panel-bg': 'linear-gradient(118deg,#100c25 80%,#1c153f 200%)', 
            '--panel-border': '#a6faffcb', 
            '--panel-shadow': '0 0 42px #a6faffc9', 
            '--submit-bg': 'linear-gradient(94deg,#a6faff,#00c3ff 90%)', 
            '--submit-text': '#030010', 
            '--submit-hover-bg': '#00c3ff', 
            '--submit-hover-text': '#fff', 
            '--header-text-glow': '0 0 12px #a6faffcc', 
            '--header-text-anim-glow-1': '0 0 17px #a6faff70', 
            '--header-text-anim-glow-2': '0 0 29px #a6faffee', 
            '--header-text-fill': 'linear-gradient(90deg,#a6faff,#00c3ff 40%,#fff 59%,#00f2ff 89%,#a6faff 100%)' 
        }, 
        midnight: { // Regular Dark 
            '--cyan': '#3391ff', 
            '--blue': '#007bff', 
            '--dark-bg': '#121212', 
            '--fade-blue': '#282828', 
            '--gradient-1': 'linear-gradient(120deg, #282828 39%, #333 68%, #444 97%)', 
            '--gradient-user': 'linear-gradient(120deg, #007bff 32%, #3391ff 89%)', 
            '--bubble-glow': '0 0 8px #007bff44', 
            '--user-glow': '0 0 12px #3391ff44', 
            '--header-glass': 'rgba(18,18,18,0.92)', 
            '--code-bg': 'linear-gradient(92deg,#222 79%,#333 120%)', 
            '--code-border': '#444', 
            '--code-text': '#f1f1f1', 
            '--main-text': '#f1f1f1', 
            '--link-text': '#3391ff', 
            '--input-bg': '#282828', 
            '--body-bg': 'linear-gradient(180deg, #181818 0%, #121212 100%)', 
            '--body-blend-mode': 'normal', 
            '--panel-bg': 'linear-gradient(118deg,#1e1e1e 80%,#282828 200%)', 
            '--panel-border': '#444', 
            '--panel-shadow': '0 0 20px #000000c9', 
            '--submit-bg': 'linear-gradient(94deg,#007bff,#3391ff 90%)', 
            '--submit-text': '#fff', 
            '--submit-hover-bg': '#0069d9', 
            '--submit-hover-text': '#fff', 
            '--header-text-glow': '0 0 10px #3391ffaa', 
            '--header-text-anim-glow-1': '0 0 12px #3391ff70', 
            '--header-text-anim-glow-2': '0 0 15px #3391ffee', 
            '--header-text-fill': 'linear-gradient(90deg,#3391ff,#007bff 40%,#fff 59%,#3391ff 89%,#aaccff 100%)' 
        }, 
        forest: { /* NEW THEME: Forest */ 
            '--cyan': '#99cc99', 
            '--blue': '#669966', 
            '--dark-bg': '#2a362a', 
            '--fade-blue': '#4a5a4a', 
            '--gradient-1': 'linear-gradient(120deg, #3a473a 39%, #5a6b5a 68%, #99cc99 97%)', 
            '--gradient-user': 'linear-gradient(120deg, #669966 32%, #99cc99 89%)', 
            '--bubble-glow': '0 0 10px #99cc99b1', 
            '--user-glow': '0 0 18px #99cc9955', 
            '--header-glass': 'rgba(42,54,42,0.92)', 
            '--code-bg': 'linear-gradient(92deg,#3a473a 79%,#5a6b5a 120%)', 
            '--code-border': '#99cc99', 
            '--code-text': '#e0ffe0', 
            '--main-text': '#e0ffe0', 
            '--link-text': '#99cc99', 
            '--input-bg': '#4a5a4a', 
            '--body-bg': 'linear-gradient(180deg, #3a473a 0%, #2a362a 100%)', 
            '--body-blend-mode': 'normal', 
            '--panel-bg': 'linear-gradient(118deg,#3a473a 80%,#4a5a4a 200%)', 
            '--panel-border': '#99cc99cb', 
            '--panel-shadow': '0 0 35px #99cc99c9', 
            '--submit-bg': 'linear-gradient(94deg,#99cc99,#669966 90%)', 
            '--submit-text': '#2a362a', 
            '--submit-hover-bg': '#669966', 
            '--submit-hover-text': '#fff', 
            '--header-text-glow': '0 0 10px #99cc99cc', 
            '--header-text-anim-glow-1': '0 0 15px #99cc9970', 
            '--header-text-anim-glow-2': '0 0 25px #99cc99ee', 
            '--header-text-fill': 'linear-gradient(90deg,#99cc99,#669966 40%,#fff 59%,#669966 89%,#99cc99 100%)' 
        }, 
        volcano: { /* NEW THEME: Volcano */ 
            '--cyan': '#ff7043', 
            '--blue': '#bf360c', 
            '--dark-bg': '#3e1a0b', 
            '--fade-blue': '#5e2a1b', 
            '--gradient-1': 'linear-gradient(120deg, #4e2211 39%, #6e3a2c 68%, #ff7043 97%)', 
            '--gradient-user': 'linear-gradient(120deg, #bf360c 32%, #ff7043 89%)', 
            '--bubble-glow': '0 0 12px #ff7043b1', 
            '--user-glow': '0 0 20px #ff704355', 
            '--header-glass': 'rgba(62,26,11,0.92)', 
            '--code-bg': 'linear-gradient(92deg,#4e2211 79%,#6e3a2c 120%)', 
            '--code-border': '#ff7043', 
            '--code-text': '#fff0e0', 
            '--main-text': '#fff0e0', 
            '--link-text': '#ff7043', 
            '--input-bg': '#5e2a1b', 
            '--body-bg': 'radial-gradient(circle at 50% 50%, #6e3a2c 0%, #3e1a0b 100%)', 
            '--body-blend-mode': 'normal', 
            '--panel-bg': 'linear-gradient(118deg,#4e2211 80%,#5e2a1b 200%)', 
            '--panel-border': '#ff7043cb', 
            '--panel-shadow': '0 0 40px #ff7043c9', 
            '--submit-bg': 'linear-gradient(94deg,#ff7043,#bf360c 90%)', 
            '--submit-text': '#3e1a0b', 
            '--submit-hover-bg': '#bf360c', 
            '--submit-hover-text': '#fff', 
            '--header-text-glow': '0 0 12px #ff7043cc', 
            '--header-text-anim-glow-1': '0 0 17px #ff704370', 
            '--header-text-anim-glow-2': '0 0 29px #ff7043ee', 
            '--header-text-fill': 'linear-gradient(90deg,#ff7043,#bf360c 40%,#fff 59%,#bf360c 89%,#ff7043 100%)' 
        } 
    }; 
    let currentThemeIdx = 0; 
    const themeKeys = Object.keys(themes); 
    function applyTheme(themeName) { 
        const theme = themes[themeName]; 
        if (!theme) return; 
        for (const key in theme) { 
            document.documentElement.style.setProperty(key, theme[key]); 
        } 
        localStorage.setItem('philadelphia-theme', themeName); 
        // Update theme icon 
        const icon = themeName === 'forest' ? 'fa-leaf' : (themeName === 'volcano' ? 'fa-fire' : (themeName === 'starlight' ? 'fa-star' : 'fa-moon'));
        themeBtn.innerHTML = `<i class="fa-solid ${icon}"></i>`; 
    } 
    themeBtn.addEventListener('click', () => { 
        currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length; 
        applyTheme(themeKeys[currentThemeIdx]); 
    }); 
    // Load saved theme 
    const savedTheme = localStorage.getItem('philadelphia-theme'); 
    if (savedTheme && themes[savedTheme]) { 
        currentThemeIdx = themeKeys.indexOf(savedTheme); 
        applyTheme(savedTheme); 
    } else { 
        applyTheme('cyber'); // REVERTED TO ORIGINAL CYBER THEME
    } 
    // ---------- Voice Call Logic - SAME AS BEFORE ----------
    let speechRecognition; 
    let isCallActive = false; 
    let callHistory = []; 
    let botIsSpeaking = false; 
    let userSaidSomething = false; 
    let currentAudio = null; 
    let isMuted = false; // NEW: Mute state 
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 
    if (SpeechRecognition) { 
        speechRecognition = new SpeechRecognition(); 
        speechRecognition.continuous = true; 
        speechRecognition.interimResults = true; 
        speechRecognition.lang = 'en-US'; 
        speechRecognition.onresult = (event) => { 
            let interimTranscript = ''; 
            let finalTranscript = ''; 
            userSaidSomething = true; 
            for (let i = event.resultIndex; i < event.results.length; ++i) { 
                if (event.results[i].isFinal) { 
                    finalTranscript += event.results[i][0].transcript; 
                } else { 
                    interimTranscript += event.results[i][0].transcript; 
                } 
            } 
            // Update user's interim speech 
            let userMsgEl = callConversation.querySelector('.call-msg.user.interim'); 
            if (!userMsgEl) { 
                userMsgEl = document.createElement('div'); 
                userMsgEl.className = 'call-msg user interim'; 
                callConversation.appendChild(userMsgEl); 
            } 
            userMsgEl.textContent = finalTranscript || interimTranscript; 
            callConversation.scrollTop = callConversation.scrollHeight; 
            // Update status for user speaking 
            callStatusMessage.textContent = finalTranscript ? 'User Speaking (Final)' : 'User Speaking...'; 
            tapToTalk.style.display = 'none'; 
        }; 
        speechRecognition.onspeechend = () => { 
            // This fires when user stops talking 
        }; 
        speechRecognition.onend = () => { 
            if (!isCallActive) return; 
            if (isMuted) { 
                // NEW: If muted, don't restart recognition 
                callStatusMessage.textContent = 'Microphone Muted.'; 
                tapToTalk.style.display = 'none'; 
                return; 
            } 
            let finalTranscript = ''; 
            const userMsgEl = callConversation.querySelector('.call-msg.user.interim'); 
            if (userMsgEl) { 
                finalTranscript = userMsgEl.textContent.trim(); 
                userMsgEl.classList.remove('interim'); 
            } 
            if (botIsSpeaking) { 
                // Bot is speaking, just wait for it to finish and restart listening (in speakBotResponse) 
            } else if (finalTranscript && userSaidSomething) { 
                // User finished speaking, send to bot 
                userSaidSomething = false; // Reset flag 
                callHistory.push({ role: 'user', content: finalTranscript }); 
                handleCallBotResponse(); 
            } else { 
                // User didn't say anything, just restart listening 
                if (isCallActive && !isMuted) { 
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)'; 
                    tapToTalk.style.display = 'block'; 
                    try { 
                        speechRecognition.start(); 
                    } catch(e) {console.warn("Speech recognition failed to start automatically:", e);} 
                } 
            } 
        }; 
        speechRecognition.onerror = (event) => { 
            console.error('Speech recognition error', event.error); 
            if (event.error === 'no-speech' && isCallActive && !isMuted) { 
                userSaidSomething = false; // Reset flag if no speech was detected 
                // Force restart listening if no speech was detected and not muted 
                speechRecognition.stop(); // Stop might trigger onend, which then restarts 
            } else if (event.error === 'network' && isCallActive) { 
                callStatusMessage.textContent = 'Network error. Attempting restart...'; 
                speechRecognition.stop(); 
            } else if (event.error === 'not-allowed' || event.error === 'permission-denied') { 
                callStatusMessage.textContent = 'Microphone permission denied. Please allow in browser settings.'; 
                endCall(); // End call if permission is denied 
            } 
        }; 
    } else { 
        callBtn.style.display = 'none'; // Hide call button if not supported 
        console.warn("Speech Recognition not supported in this browser."); 
    } 
    function addCallMessage(role, text) { 
        const msgEl = document.createElement('div'); 
        msgEl.className = `call-msg ${role}`; 
        msgEl.textContent = text; 
        callConversation.appendChild(msgEl); 
        callConversation.scrollTop = callConversation.scrollHeight; 
    } 
    async function handleCallBotResponse() { 
        if (!isCallActive) return; 
        callStatusMessage.textContent = 'Philadelphia AI is thinking...'; 
        tapToTalk.style.display = 'none'; 
        const historyForBot = callHistory.map(m => m); 
        const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : ""; 
        try { 
            // Stop recognition while thinking 
            speechRecognition.stop(); 
            const res = await fetch(`${API_BASE_URL}/chat`, { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ message: userMessage, history: historyForBot.slice(0, -1), // Send history *before* last user msg 
                    user_id: currentUser?.uid || "user" }) 
            }); 
            const data = await res.json(); 
            if (!res.ok) throw new Error(data.error || "Server error."); 
            const botResponse = data.response; 
            callHistory.push({ role: 'ai', content: botResponse }); // Add bot response 
            addCallMessage('bot', botResponse); 
            // Speak the response 
            speakBotResponse(botResponse); 
        } catch (err) { 
            const errorMsg = `âŒ Call error: ${err.message}`; 
            addCallMessage('bot', errorMsg); 
            // Restart listening 
            if (isCallActive && !isMuted) { 
                callStatusMessage.textContent = 'Listening... (Tap to Speak)'; 
                tapToTalk.style.display = 'block'; 
                try { 
                    speechRecognition.start(); 
                } catch(e) {console.warn("Speech recognition failed to start after error:", e);} 
            } 
        } 
    } 
    async function speakBotResponse(text) { 
        if (!isCallActive) return; 
        botIsSpeaking = true; 
        botImageContainer.classList.add('speaking'); 
        callStatusMessage.textContent = 'Philadelphia AI is speaking...'; 
        try { 
            // FIX: Using Minimax "elder" voice specifically 
            const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, { 
                method: 'POST', 
                headers: {'Content-Type': 'application/json'}, 
                body: JSON.stringify({ text: text, voice_id: 'elder' }) 
            }); 
            if (!res.ok) throw new Error(await res.text()); 
            const blob = await res.blob(); 
            const url = URL.createObjectURL(blob); 
            const audio = new Audio(url); 
            currentAudio = audio; // Store reference to allow stopping 
            audio.onended = audio.onerror = () => { 
                botIsSpeaking = false; 
                botImageContainer.classList.remove('speaking'); 
                currentAudio = null; 
                // Restart listening for user 
                if (isCallActive && !isMuted) { 
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)'; 
                    tapToTalk.style.display = 'block'; 
                    try { 
                        speechRecognition.start(); 
                    } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);} 
                } else if (isMuted) { 
                    callStatusMessage.textContent = 'Microphone Muted.'; 
                    tapToTalk.style.display = 'none'; 
                } 
            }; 
            audio.play(); 
        } catch (err) { 
            console.error("Voice gen error:", err); 
            botIsSpeaking = false; 
            botImageContainer.classList.remove('speaking'); 
            // Failed to speak, just restart listening 
            if (isCallActive && !isMuted) { 
                callStatusMessage.textContent = 'Listening (Voice Failed)...'; 
                tapToTalk.style.display = 'block'; 
                try { 
                    speechRecognition.start(); 
                } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);} 
            } else if (isMuted) { 
                callStatusMessage.textContent = 'Microphone Muted.'; 
                tapToTalk.style.display = 'none'; 
            } 
        } 
    } 
    // FIX: User can tap the screen to stop the bot and talk 
    function stopBotSpeakingAndStartListening() { 
        if (!isCallActive || !botIsSpeaking) return; // Only act if call is active and bot is speaking 
        if (currentAudio) { 
            currentAudio.pause(); 
            currentAudio.currentTime = 0; 
            currentAudio = null; 
        } 
        botIsSpeaking = false; 
        botImageContainer.classList.remove('speaking'); 
        if (!isMuted) { 
            callStatusMessage.textContent = 'Listening... (Tap to Speak)'; 
            tapToTalk.style.display = 'block'; 
            // Restart listening for user input 
            try { 
                speechRecognition.stop(); 
                speechRecognition.start(); 
            } catch(e) { console.warn("Could not restart speech recognition immediately:", e); } 
        } else { 
            callStatusMessage.textContent = 'Microphone Muted.'; 
            tapToTalk.style.display = 'none'; 
        } 
        // Clear interim message if it exists 
        const userMsgEl = callConversation.querySelector('.call-msg.user.interim'); 
        if (userMsgEl) userMsgEl.textContent = ''; 
    } 
    callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening); 
    callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening); 
    callBtn.addEventListener('click', () => { 
        if (!SpeechRecognition) { 
            alert("Sorry, your browser doesn't support the Speech Recognition needed for this feature."); 
            return; 
        } 
        isCallActive = true; 
        isMuted = false; // Reset mute state 
        muteCallBtn.classList.remove('muted'); 
        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone'; 
        callModal.classList.add('active'); 
        callConversation.innerHTML = ''; // Clear old call 
        addCallMessage('status', 'Connecting to Philadelphia AI...'); 
        callStatusMessage.textContent = 'Calling...'; 
        tapToTalk.style.display = 'none'; 
        callHistory = []; // Reset history 
        // Initial delay to simulate connection, then start listening 
        setTimeout(() => { 
            if (!isCallActive) return; 
            addCallMessage('status', 'Call Connected. Speak when ready.'); 
            callStatusMessage.textContent = 'Listening... (Tap to Speak)'; 
            tapToTalk.style.display = 'block'; 
            try { 
                speechRecognition.start(); 
            } catch(e) { 
                console.error("Speech recognition start failed", e); 
                callStatusMessage.textContent = 'Microphone error. Check permissions.'; 
            } 
        }, 1500); 
    }); 
    // NEW: Refactored endCall logic 
    function endCall() { 
        isCallActive = false; 
        botIsSpeaking = false; 
        if (currentAudio) { 
            currentAudio.pause(); 
            currentAudio.currentTime = 0; 
            currentAudio = null; 
        } 
        callModal.classList.remove('active'); 
        try { 
            speechRecognition.stop(); 
        } catch(e) {} 
        botImageContainer.classList.remove('speaking'); 
        tapToTalk.style.display = 'none'; 
        callStatusMessage.textContent = 'Call Ended.'; 
        // Ensure status updates 
    } 
    endCallBtn.addEventListener('click', endCall); 
    // NEW: Mute button functionality 
    if (muteCallBtn) { 
        muteCallBtn.addEventListener('click', () => { 
            isMuted = !isMuted; 
            if (isMuted) { 
                muteCallBtn.classList.add('muted'); 
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute Microphone'; 
                speechRecognition.stop(); 
                callStatusMessage.textContent = 'Microphone Muted.'; 
                tapToTalk.style.display = 'none'; 
            } else { 
                muteCallBtn.classList.remove('muted'); 
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone'; 
                if (isCallActive && !botIsSpeaking) { 
                    // Only restart if call is active and bot isn't speaking 
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)'; 
                    tapToTalk.style.display = 'block'; 
                    try { 
                        speechRecognition.start(); 
                    } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);} 
                } else if (isCallActive && botIsSpeaking) { 
                    callStatusMessage.textContent = 'Philadelphia AI is speaking...'; 
                    tapToTalk.style.display = 'none'; 
                } 
            } 
        }); 
    } 
    // Final initial render (will be triggered by auth state) 
    if(chatInput) chatInput.focus(); 
}); // end DOMContentLoaded 
</script> 
</body> 
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
