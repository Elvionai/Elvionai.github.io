<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Philadelphia AI - Quantum Nebula</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/> <!-- Changed highlight.js theme for better contrast -->
    <style>
        /* --- Quantum Nebula Theme Variables --- */
        :root {
            --primary-color: #6a059b; /* Deep vibrant purple */
            --secondary-color: #0d8eff; /* Electric blue */
            --accent-color: #f062ff; /* Bright magenta */
            --text-color: #e0f2f7; /* Soft light blue/white */
            --background-dark: #020015; /* Very dark background */
            --background-light: #0d012e; /* Slightly lighter bg for depth */

            --glass-base: rgba(13, 1, 46, 0.85); /* Darker, ethereal glass base */
            --glass-border-glow: rgba(106, 5, 155, 0.4); /* Purple border glow */
            --ui-element-glow: 0 0 15px var(--primary-color), 0 0 25px var(--secondary-color);
            
            --user-bubble-gradient: linear-gradient(145deg, #0d8eff, #6a059b);
            --ai-bubble-gradient: linear-gradient(145deg, #0d012e, #1f054a);
            --bubble-text-color: var(--text-color);
            --bubble-shadow: 0 5px 20px rgba(0, 0, 0, 0.4), inset 0 0 10px rgba(240, 98, 255, 0.1);

            --code-bg: #01000a; /* Pure black for code blocks */
            --code-border: #f062ff; /* Magenta border for code */
            --code-text-glow: #0d8eff; /* Electric blue glow for code text */

            --button-gradient-primary: linear-gradient(90deg, #f062ff, #6a059b);
            --button-gradient-hover: linear-gradient(90deg, #6a059b, #0d8eff);
            --button-text-color: var(--text-color);

            --header-text-gradient: linear-gradient(90deg, #e0f2f7, #f062ff, #0d8eff);
            --header-text-shadow: 0 0 10px var(--f062ff), 0 0 20px var(--0d8eff);

            /* Call UI specifics */
            --quantum-core-base: radial-gradient(circle, #f062ff 0%, #6a059b 40%, rgba(13, 1, 46, 0.9) 100%);
            --quantum-core-speaking-glow: 0 0 25px var(--f062ff), 0 0 50px var(--0d8eff), 0 0 70px rgba(255, 255, 255, 0.5);
        }

        /* --- Base Styles --- */
        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background-color: var(--background-dark);
            font-family: 'Inter', 'Roboto', system-ui, -apple-system, Segoe UI, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            transition: background-color 0.5s ease;
        }

        /* --- Quantum Nebula Background Animation --- */
        #background-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
            background: var(--background-dark);
        }

        .nebula-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover;
            opacity: 0.6;
            animation: nebula-drift 120s linear infinite alternate;
            pointer-events: none;
            filter: blur(10px);
        }
        .nebula-layer:nth-child(1) {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><filter id="f"><feGaussianBlur stdDeviation="15" /></filter><g filter="url(%23f)"><circle cx="200" cy="300" r="150" fill="%236a059b" /><circle cx="700" cy="600" r="180" fill="%230d8eff" /><circle cx="450" cy="800" r="120" fill="%23f062ff" /></g></svg>');
            animation-duration: 150s;
            transform: scale(1.2);
            opacity: 0.4;
        }
        .nebula-layer:nth-child(2) {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><filter id="f"><feGaussianBlur stdDeviation="20" /></filter><g filter="url(%23f)"><circle cx="800" cy="200" r="160" fill="%230d8eff" /><circle cx="300" cy="700" r="190" fill="%236a059b" /></g></svg>');
            animation-duration: 100s;
            transform: scale(1.1);
            animation-delay: -20s;
            opacity: 0.5;
        }
        @keyframes nebula-drift {
            0% { transform: translate(0, 0) scale(1.1); }
            50% { transform: translate(5vw, -5vh) scale(1.2); }
            100% { transform: translate(0, 0) scale(1.1); }
        }

        .quantum-dust {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><circle cx="100" cy="100" r="1" fill="%23e0f2f7" /><circle cx="300" cy="250" r="0.8" fill="%23e0f2f7" /><circle cx="500" cy="50" r="1.2" fill="%23e0f2f7" /><circle cx="700" cy="400" r="0.7" fill="%23e0f2f7" /><circle cx="900" cy="150" r="1" fill="%23e0f2f7" /></svg>');
            background-size: 50px 50px;
            opacity: 0.3;
            animation: dust-shimmer 200s linear infinite;
            pointer-events: none;
        }
        @keyframes dust-shimmer {
            from { background-position: 0 0; }
            to { background-position: 100% 100%; }
        }

        .hyperdrive-streak {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
            filter: drop-shadow(0 0 10px var(--accent-color));
            border-radius: 999px;
            pointer-events: none;
            opacity: 0;
            animation: hyperdrive 10s ease-out infinite;
        }
        .hyperdrive-streak:nth-child(1) { width: 150px; top: 20%; left: -20%; animation-delay: 0s; animation-duration: 8s; }
        .hyperdrive-streak:nth-child(2) { width: 100px; top: 60%; left: -30%; animation-delay: 3s; animation-duration: 12s; }
        .hyperdrive-streak:nth-child(3) { width: 200px; top: 40%; left: -10%; animation-delay: 7s; animation-duration: 10s; }
        @keyframes hyperdrive {
            0% { transform: translateX(0); opacity: 0; }
            10% { opacity: 1; transform: translateX(20vw); }
            90% { opacity: 1; transform: translateX(110vw); }
            100% { transform: translateX(120vw); opacity: 0; }
        }

        #celestial-sentinel {
            position: fixed;
            top: 5%; /* Start from top */
            left: 110%; /* Start off-screen right */
            width: 150px;
            height: auto;
            opacity: 0;
            filter: drop-shadow(0 0 10px var(--primary-color)) drop-shadow(0 0 20px var(--accent-color));
            animation: sentinel-flight 240s linear 60s infinite; /* Very long, rare flight */
            pointer-events: none;
            z-index: -1;
        }
        @keyframes sentinel-flight {
            0% { transform: translateX(0) translateY(0) rotate(0deg); opacity: 0; }
            5% { opacity: 0.7; }
            95% { opacity: 0.7; }
            100% { transform: translateX(-150vw) translateY(30vh) rotate(15deg); opacity: 0; }
        }

        .quantum-mote {
            position: fixed;
            width: 7px;
            height: 7px;
            background: var(--accent-color);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--accent-color);
            animation: mote-wander 30s linear infinite alternate, mote-pulse 2s ease-in-out infinite alternate;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s, box-shadow 0.2s;
            z-index: 1000;
        }
        .quantum-mote:hover { transform: scale(1.5); box-shadow: 0 0 15px var(--accent-color), 0 0 25px var(--primary-color); }
        @keyframes mote-wander {
            0% { transform: translate(10vw, 15vh); } 25% { transform: translate(85vw, 50vh); }
            50% { transform: translate(25vw, 80vh); } 75% { transform: translate(70vw, 20vh); }
            100% { transform: translate(45vw, 95vh); }
        }
        @keyframes mote-pulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        @keyframes burst-fade {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(2); }
        }

        /* --- Main Layout & Header --- */
        .header-bar {
            position: fixed; top: 0; left: 0; width: 100vw; display: flex; align-items: center;
            justify-content: space-between; z-index: 1003; padding: 0 15px; height: 70px;
            background: var(--glass-base); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--glass-border-glow); box-shadow: var(--ui-element-glow);
            border-radius: 0 0 25px 25px;
        }

        .menu-btn {
            background: none; border: none; color: var(--text-color); font-size: 1.9em; cursor: pointer;
            padding: 10px 15px; border-radius: 15px; transition: color 0.3s, background 0.3s;
        }
        .menu-btn:hover { background: rgba(240, 98, 255, 0.15); color: var(--accent-color); }
        
        .site-heading {
            font-family: 'Orbitron', sans-serif; font-size: 1.4em; font-weight: 700; text-align: center;
            flex: 1;
            background: var(--header-text-gradient); background-clip: text; -webkit-background-clip: text;
            -webkit-text-fill-color: transparent; text-shadow: var(--header-text-shadow); user-select: none;
            letter-spacing: 2px;
            animation: header-glow 4s ease-in-out infinite alternate;
        }
        @keyframes header-glow {
            0% { text-shadow: 0 0 8px var(--primary-color), 0 0 16px var(--secondary-color); }
            100% { text-shadow: 0 0 12px var(--accent-color), 0 0 24px var(--primary-color); }
        }
        
        .main-content {
            display: flex; flex-direction: column; flex-grow: 1; overflow-y: hidden;
            position: relative; padding-top: 70px; padding-bottom: 90px; box-sizing: border-box;
        }

        .chat-box {
            flex: 1 1 0px; overflow-y: auto; overflow-x: hidden; width: 100%; max-width: 750px; /* Slightly wider chat box */
            margin: 0 auto; box-sizing: border-box; padding: 20px 15px; z-index: 3;
            scroll-behavior: smooth; display: flex; flex-direction: column;
        }

        /* --- Chat Messages & Bubbles (Nebula Pockets) --- */
        .chat-message {
            display: flex; gap: 12px; margin: 12px 0; max-width: 90%; /* Moderate width */
            align-items: flex-end;
            animation: fadeIn 0.6s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }

        .chat-message .msg {
            font-size: 1.05em; line-height: 1.65; padding: 15px 22px; border-radius: 25px 25px 25px 8px;
            word-break: break-word; white-space: pre-wrap; background: var(--ai-bubble-gradient);
            color: var(--bubble-text-color);
            box-shadow: var(--bubble-shadow);
            border: 1px solid var(--glass-border-glow); position: relative;
            margin-right: auto;
            text-shadow: 0 0 3px rgba(240, 98, 255, 0.1);
        }

        .chat-message.user { justify-content: flex-end; margin-left: auto; }
        .chat-message.user .msg {
            background: var(--user-bubble-gradient); color: var(--text-color); font-weight: 500;
            border-radius: 25px 25px 8px 25px; box-shadow: var(--bubble-shadow);
            border: none;
            margin-left: auto;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
        }
        
        #typing-status {
            max-width: 750px;
            margin: 0 auto;
            padding: 0 15px 15px 15px;
            width: 100%;
            box-sizing: border-box;
            flex-shrink: 0;
            min-height: 20px;
        }

        #typing-status .msg { padding: 10px 18px; }
        .typing-bubble { display: inline-flex; align-items: center; }
        .dot-anim {
            width: 9px; height: 9px; margin: 0 4px; background: var(--accent-color);
            border-radius: 50%; box-shadow: 0 0 8px var(--accent-color);
            animation: typing-blink 1.4s infinite both;
        }
        .dot-anim:nth-child(2){ animation-delay: .3s; }
        .dot-anim:nth-child(3){ animation-delay: .6s; }
        @keyframes typing-blink { 0%,100% { opacity:.4; transform: scale(0.8); } 50% { opacity:1; transform: scale(1.1); } }

        /* --- Code Blocks (Quantum Crystalline) --- */
        pre {
            background: var(--code-bg);
            border: 2px solid var(--code-border);
            border-radius: 15px;
            padding: 1.5em 1.8em;
            margin: 1.2em 0;
            overflow-x: auto;
            position: relative;
            box-shadow: 0 0 30px rgba(240, 98, 255, 0.4), inset 0 0 20px rgba(13, 1, 46, 0.8);
            transition: all 0.3s ease;
        }
        pre:hover {
            box-shadow: 0 0 40px rgba(240, 98, 255, 0.6), inset 0 0 25px rgba(13, 1, 46, 1);
        }
        pre code {
            font-family: 'JetBrains Mono', monospace;
            color: var(--code-text-glow);
            text-shadow: 0 0 8px var(--code-text-glow);
            font-size: 0.98em;
        }
        .copy-btn {
            position: absolute; top: 15px; right: 15px; z-index: 3;
            background: rgba(106, 5, 155, 0.5); /* Primary color translucent */
            border: 1px solid var(--code-border); color: var(--text-color); border-radius: 10px;
            padding: 6px 12px; cursor: pointer; transition: background 0.3s, color 0.3s;
            font-size: 0.9em; font-weight: bold;
        }
        .copy-btn:hover { background: var(--code-border); color: var(--background-dark); }
        
        /* --- Input Area (Quantum Input Field) --- */
        .chat-input-row {
            position: fixed; left: 50%; transform: translateX(-50%); bottom: 0; display: flex; align-items: stretch;
            gap: 10px; width: 100%; max-width: 950px; /* Wider input area */
            padding: 12px 18px; box-sizing: border-box;
            background: var(--glass-base); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid var(--glass-border-glow);
            border-radius: 25px 25px 0 0;
            box-shadow: var(--ui-element-glow);
        }
        .chat-input-row textarea {
            flex: 1 1 auto; resize: none; min-height: 48px; max-height: 180px; /* Taller input */
            background: var(--background-light); color: var(--text-color); font-size: 1.1em;
            padding: 12px 18px; border: 1px solid var(--glass-border-glow); border-radius: 15px;
            transition: border-color 0.3s, box-shadow 0.3s, background 0.3s;
        }
        .chat-input-row textarea:focus {
            outline: none; border-color: var(--secondary-color);
            box-shadow: 0 0 20px rgba(13, 142, 255, 0.5);
            background: rgba(13, 1, 46, 0.9);
        }
        .chat-input-row button, .chat-input-row label {
            background: rgba(13, 1, 46, 0.7); /* Darker translucent */
            border: 1px solid var(--glass-border-glow); color: var(--accent-color);
            font-size: 1.4em; cursor: pointer; border-radius: 15px; transition: all 0.3s;
            display: flex; align-items: center; justify-content: center; min-width: 48px;
            box-shadow: 0 0 8px rgba(240, 98, 255, 0.2);
        }
        .chat-input-row button:hover, .chat-input-row label:hover {
            background: rgba(106, 5, 155, 0.7); /* Primary color translucent */
            border-color: var(--accent-color);
            color: var(--text-bright);
            box-shadow: 0 0 15px var(--accent-color), 0 0 25px var(--primary-color);
        }
        #sendBtn {
            background: var(--button-gradient-primary); border: none; color: var(--button-text-color);
            box-shadow: 0 0 10px var(--accent-color);
        }
        #sendBtn:hover { background: var(--button-gradient-hover); box-shadow: 0 0 20px var(--secondary-color); }
        #stopBtn {
            background: #d23; color: white; border: none;
            box-shadow: 0 0 10px #ff4d4d88;
        }
        #stopBtn:hover { background: #ff4d4d; box-shadow: 0 0 15px #ff4d4d; }

        /* --- File Previews and Controls --- */
        .file-attachments {
            display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0; max-width: 100%;
        }
        .chat-media-preview {
            max-width: 100%; max-height: 280px; border-radius: 15px; display: block;
            border: 2px solid var(--glass-border-glow); box-shadow: 0 0 15px rgba(240, 98, 255, 0.3);
        }
        .file-link, .file-placeholder {
            display: inline-block; padding: 10px 15px; background: var(--background-light);
            border: 1px solid var(--glass-border-glow); border-radius: 12px; color: var(--accent-color);
            text-decoration: none; font-size: 0.95em; font-weight: bold;
            box-shadow: 0 0 8px rgba(240, 98, 255, 0.2);
        }
        .file-preview{
            background:var(--glass-base); border-radius:15px; color:var(--text-color);
            box-shadow:0 5px 20px rgba(0, 0, 0, 0.4); border: 1.5px solid var(--glass-border-glow);
        }

        /* --- Emoji Panel --- */
        #emojiPanel {
            background: var(--glass-base); border-radius: 20px; padding: 18px 18px 15px 18px;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5); border: 1.5px solid var(--glass-border-glow);
        }
        .emoji-pick {
            font-size:1.3em; cursor:pointer; padding:5px 9px; border-radius:12px;
            transition:background .2s; user-select:none;
        }
        .emoji-pick:hover { background: rgba(106, 5, 155, 0.3); }

        /* --- Status Message --- */
        .status-message {
            padding:8px 15px; color:var(--accent-color); font-size:1em; min-height:17px;
            text-align:center; margin:6px auto 0 auto; max-width:480px; word-break:break-word;
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px rgba(240, 98, 255, 0.3);
        }

        /* --- Side Panels (Profile, Links, Tools) --- */
        .panel-bg {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(2, 0, 21, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            z-index: 1200;
        }
        .panel-bg.active { display: block; }
        .side-panel {
            position: absolute; top: 0; left: -380px; height: 100vh; width: 350px; /* Slightly wider panels */
            background: linear-gradient(180deg, var(--background-light) 0%, var(--background-dark) 100%);
            border-right: 2px solid var(--primary-color);
            box-shadow: 8px 0 45px rgba(0, 0, 0, 0.5);
            z-index: 1212; padding: 25px; overflow-y: auto;
            border-radius: 0 30px 40px 0;
            transition: left 0.5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        #profileMenuBg.active .side-panel, #linkMenuBg.active .side-panel, #toolsMenuBg.active .side-panel, #toolFormModalBg.active .side-panel {
            left: 0;
        }
        .side-panel .panel-header { text-align: center; margin: 20px 0 15px 0; }
        .side-panel img {
            width: 64px; height: 64px; border-radius: 50%; margin-bottom: 10px;
            border: 3px solid var(--accent-color); box-shadow: 0 0 15px var(--accent-color);
        }
        .side-panel .username {
            font-weight: 700; font-size: 1.15em; color: var(--accent-color);
            font-family: 'Orbitron', sans-serif; text-shadow: 0 0 10px var(--accent-color);
        }
        .side-panel .email { font-size: 1em; color: var(--text-color); opacity: 0.85; }
        .panel-links a {
            color: var(--text-color); text-decoration: none; font-weight: 500; font-size: 1.08em;
            padding: 12px 18px; display: flex; align-items: center; gap: 15px;
            border-radius: 10px; transition: background 0.2s, color 0.2s;
        }
        .panel-links a:hover { background: rgba(106, 5, 155, 0.3); color: var(--accent-color); }

        #chatsList button {
            background: none; border: none; cursor: pointer; outline: none; font-size: 1.15em;
            margin: 0 6px; vertical-align: middle; border-radius: 8px; padding: 4px 6px;
            color: var(--secondary-color);
        }
        #chatsList .fa-pen:hover{ color: var(--accent-color); }
        #chatsList .fa-trash:hover{ color: #ff6347; }
        #chatsList .fa-play:hover{ color: #4CAF50; }

        .edit-form label {
            display:block; margin-top:12px; font-size:1.05em; color:var(--accent-color);
            text-shadow:0 1px 16px rgba(240, 98, 255, 0.3);
        }
        .edit-form input, .edit-form textarea, .edit-form select {
            width:99%; padding:9px 13px; margin-top:6px; border:2px solid var(--glass-border-glow);
            border-radius:12px; background:var(--background-light); color:var(--text-color);
            font-size:1.05em; box-shadow:0 0 10px rgba(106, 5, 155, 0.2) inset;
            transition:border-color .2s,box-shadow .2s,background .2s;
        }
        .edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus{
            border-color:var(--secondary-color); background:rgba(13, 1, 46, 0.9); color:var(--text-color);
        }
        .submit-btn{
            background: var(--button-gradient-primary); color: var(--button-text-color); box-shadow:0 4px 18px rgba(0, 0, 0, 0.4);
            font-size:1.15em; padding:12px 25px; border-radius:12px;
        }
        .submit-btn:hover{
            background: var(--button-gradient-hover); box-shadow:0 4px 25px rgba(0, 0, 0, 0.6); transform: translateY(-2px);
        }

        /* --- Lightbox --- */
        #lightbox {
            background: rgba(0,0,0,0.95); z-index: 5000;
        }
        #lightbox img {
            border: 3px solid var(--accent-color); border-radius: 15px;
            box-shadow: 0 0 60px var(--accent-color);
        }

        /* --- AI Image Preview --- */
        #ai-image-preview {
            background:var(--glass-base); padding:15px; border-radius:20px;
            box-shadow:0 2px 25px rgba(0, 0, 0, 0.5);
            border: 1.5px solid var(--glass-border-glow);
        }
        #ai-image-preview #ai-image-close {
            background:var(--background-light); color:var(--accent-color);
            font-size:1.6em; border-radius:10px;
        }
        #ai-image-preview #ai-image-dl {
            background:var(--button-gradient-primary); color:var(--button-text-color);
            box-shadow:0 2px 10px rgba(0, 0, 0, 0.4); border-radius:10px;
        }

        /* --- Call Modal (Quantum Nexus) --- */
        #callModal {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: radial-gradient(circle at center, #0d012e 0%, var(--background-dark) 100%);
            z-index: 4000; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px; box-sizing: border-box; transition: opacity 0.5s; opacity: 0;
            overflow: hidden;
        }
        #callModal.active { display: flex; opacity: 1; }
        
        #callHeader {
            color: var(--text-color); font-family: 'Orbitron', sans-serif; font-size: 1.8em;
            text-shadow: 0 0 15px var(--accent-color); margin-bottom: 50px; position: absolute; top: 40px;
            letter-spacing: 2px;
        }

        #botImageContainer {
            width: 250px; height: 250px; display: flex; align-items: center; justify-content: center;
            position: relative; margin-top: 30px;
        }
        #botImageContainer img { display: none; } /* Hide old img */
        
        #quantum-nexus {
            width: 180px; height: 180px; border-radius: 50%;
            background: var(--quantum-core-base);
            box-shadow: 0 0 30px var(--primary-color), 0 0 60px var(--secondary-color), inset 0 0 40px var(--accent-color);
            position: relative; transition: transform 0.6s, box-shadow 0.6s;
            animation: nexus-idle 8s ease-in-out infinite alternate;
        }
        #quantum-nexus::before, #quantum-nexus::after {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 50%; opacity: 0.6;
            animation: nexus-energy 4s ease-in-out infinite alternate;
        }
        #quantum-nexus::after {
            animation-delay: 2s;
            background: radial-gradient(circle, rgba(240, 98, 255, 0.4) 0%, transparent 60%);
        }
        
        #botImageContainer.speaking #quantum-nexus {
            transform: scale(1.15); box-shadow: var(--quantum-core-speaking-glow);
            animation: nexus-speaking 1s ease-in-out infinite;
        }
        #botImageContainer.speaking #quantum-nexus::before, #botImageContainer.speaking #quantum-nexus::after {
             animation-duration: 0.8s; /* Faster energy flow when speaking */
        }

        @keyframes nexus-idle {
            0%, 100% { transform: scale(1); box-shadow: 0 0 25px var(--primary-color), 0 0 50px var(--secondary-color); }
            50% { transform: scale(1.03); box-shadow: 0 0 35px var(--primary-color), 0 0 70px var(--secondary-color); }
        }
        @keyframes nexus-speaking {
            0%, 100% { transform: scale(1.1); box-shadow: var(--quantum-core-speaking-glow); }
            50% { transform: scale(1.2); box-shadow: 0 0 35px var(--text-color), 0 0 70px var(--accent-color), 0 0 100px var(--primary-color); }
        }
        @keyframes nexus-energy {
            0%, 100% { transform: scale(0.9); opacity: 0.7; background: radial-gradient(circle, rgba(106, 5, 155, 0.4) 0%, transparent 60%); }
            50% { transform: scale(1.1); opacity: 1; background: radial-gradient(circle, rgba(13, 142, 255, 0.4) 0%, transparent 60%); }
        }

        #callStatusMessage {
            color: var(--text-color); font-size: 1.3em; margin-top: 40px; height: 35px; text-align: center;
            font-style: italic; text-shadow: 0 0 8px var(--secondary-color);
        }
        #tapToTalk {
            color: var(--accent-color); font-size: 1.25em; margin-top: 10px; text-shadow: 0 0 10px var(--accent-color);
            animation: neon-pulse 1.5s infinite alternate; display: none;
        }
        @keyframes neon-pulse {
            from { opacity: 0.7; transform: scale(1.0); }
            to { opacity: 1.0; transform: scale(1.02); }
        }

        #callConversation {
            width: 100%; max-width: 650px; height: 200px; overflow-y: auto;
            margin: 25px 0; padding: 15px;
            background: rgba(0, 0, 0, 0.25); border: 1.5px solid var(--glass-border-glow); border-radius: 15px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }
        .call-msg {
            padding: 10px 15px; border-radius: 12px; margin-bottom: 12px; line-height: 1.6; word-break: break-word;
            max-width: 85%;
        }
        .call-msg.user {
            background: var(--user-bubble-gradient); color: var(--button-text-color); text-align: right; margin-left: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .call-msg.bot {
            background: var(--ai-bubble-gradient); color: var(--text-color); margin-right: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .call-msg.status {
            text-align: center; color: var(--text-color); font-style: italic; opacity: 0.8; background: none;
            text-shadow: none;
        }

        #callControls {
            position: absolute; bottom: 50px; display: flex; gap: 40px;
        }
        #endCallBtn, #muteCallBtn {
            font-size: 2em; padding: 18px; border: none; border-radius: 50%;
            cursor: pointer; transition: all .3s; color: white;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
        }
        #endCallBtn { background: #d23; }
        #endCallBtn:hover { background: #ff4d4d; box-shadow: 0 0 30px #ff4d4d; transform: scale(1.05); }
        #muteCallBtn { background: var(--secondary-color); }
        #muteCallBtn.muted { background: #555; }
        #muteCallBtn:hover:not(.muted) { background: var(--accent-color); box-shadow: 0 0 30px var(--accent-color); transform: scale(1.05); }
        #muteCallBtn.muted:hover { background: #777; }
        
        .spinner {
            display: inline-block; width: 22px; height: 22px; border: 4px solid rgba(240, 98, 255, 0.3);
            border-radius: 50%; border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite; margin-right: 10px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="background-container">
        <div class="nebula-layer"></div>
        <div class="nebula-layer"></div>
        <div class="quantum-dust"></div>
        <div class="hyperdrive-streak"></div>
        <div class="hyperdrive-streak"></div>
        <div class="hyperdrive-streak"></div>
        <img id="celestial-sentinel" src='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 140"%3E%3Cdefs%3E%3ClinearGradient id="gradE" x1="0%25" y1="0%25" x2="100%25" y2="100%25"%3E%3Cstop offset="0%25" style="stop-color:rgb(240,98,255);stop-opacity:1" /%3E%3Cstop offset="100%25" style="stop-color:rgb(106,5,155);stop-opacity:1" /%3E%3C/linearGradient%3E%3Cfilter id="glowE"%3E%3CfeGaussianBlur stdDeviation="5" result="coloredBlur"/%3E%3CfeMerge%3E%3CfeMergeNode in="coloredBlur"/%3E%3CfeMergeNode in="SourceGraphic"/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath filter="url(%23glowE)" fill="url(%23gradE)" stroke="rgba(255,255,255,0.8)" stroke-width="2" d="M100 0 C120 20, 140 20, 160 0 L180 20 C160 60, 140 80, 100 140 C60 80, 40 60, 20 20 L40 0 C60 20, 80 20, 100 0 Z" /%3E%3C/svg%3E' alt="Celestial Sentinel">
    </div>
    
    <div class="quantum-mote" style="left: 10vw; top: 20vh; animation-delay: 0s; animation-duration: 20s;"></div>
    <div class="quantum-mote" style="left: 30vw; top: 70vh; animation-delay: -5s; animation-duration: 28s;"></div>
    <div class="quantum-mote" style="left: 70vw; top: 15vh; animation-delay: -10s; animation-duration: 32s;"></div>
    <div class="quantum-mote" style="left: 50vw; top: 90vh; animation-delay: -15s; animation-duration: 24s;"></div>
    <div class="quantum-mote" style="left: 80vw; top: 40vh; animation-delay: -20s; animation-duration: 26s;"></div>

    <div class="main-content">
        <div class="header-bar">
            <button class="menu-btn" id="openProfileMenu" aria-label="Open profile menu"><i class="fa-solid fa-bars"></i></button>
            <span class="site-heading">ü¶Ö Philadelphia AI ü¶Ö</span>
            <button class="menu-btn" id="themeBtn" aria-label="Change theme"><i class="fa-solid fa-palette"></i></button>
            <button class="menu-btn" id="openLinksMenu" aria-label="Open links menu"><i class="fa-solid fa-link"></i></button>
        </div>

        <div class="chat-box" id="chatBox"></div>

        <div id="typing-status" class="chat-message ai" style="display: none;"></div>

        <form class="chat-input-row" id="chatForm" autocomplete="off">
            <label for="chatFile" class="file-upload-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label>
            <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
            <textarea id="chatInput" placeholder="Engage with the Quantum Nexus..."></textarea>
            <button type="button" id="callBtn" title="Start Voice Call"><i class="fa-solid fa-phone-volume"></i></button>
            <button type="button" id="toolBtn" title="Philadelphia Tools"><i class="fa-solid fa-wrench"></i></button>
            <button type="submit" id="sendBtn" title="Send"><i class="fa-solid fa-paper-plane"></i></button>
        </form>
    </div>

    <div id="emojiPanel"></div>
    <div class="status-message" id="statusMsg"></div>
    <div id="filePreview" class="file-preview"></div>

    <div class="panel-bg" id="profileMenuBg">
        <nav class="side-panel" id="profileMenu">
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:1.17em;font-weight:700;color:var(--accent-color);margin:18px 0 0 13px; text-shadow: 0 0 8px var(--accent-color);">Chats</span>
                <button style="font-size:1.55em;color:#ff6347;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;" onclick="profileMenuBg.classList.remove('active');">&times;</button>
            </div>
            <div id="chatsList" style="margin:7px 0 8px 6px;max-height:161px;overflow-y:auto;">
                <div class="spinner" style="margin: 20px auto; display: block;"></div>
            </div>
            <button id="newChatBtn" class="submit-btn" style="margin:0 0 12px 11px;"><i class="fa-solid fa-plus"></i> New Chat</button>
            <hr style="width:91%;margin:11px 0 7px 3%;border:1px solid var(--glass-border-glow);">
            <div class="panel-header">
                <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profileMenuUser">User</div>
                <div class="email" id="profileMenuEmail">email@example.com</div>
            </div>
            <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;">
                <label for="edit-name">Name</label>
                <input type="text" id="edit-name" required>
                <label for="edit-photo">Photo URL</label>
                <input type="url" id="edit-photo" placeholder="Paste image link">
                <span style="font-size:0.83em;color:var(--text-color);opacity:0.7;display:block;margin:5px 0 7px 2px;"> Tip: <a href="https://postimg.cc/" target="_blank" style="color:var(--secondary-color);">Upload at postimg.cc</a> </span>
                <button type="submit" class="submit-btn">Save</button>
                <div class="status-message" id="profileStatusMsg"></div>
            </form>
            <button class="submit-btn" id="logoutBtn" style="background:var(--background-light);color:var(--accent-color);margin:7px 7px 17px 7px;">Logout</button>
        </nav>
    </div>

    <div id="ai-image-preview" style="display:none;position:fixed;z-index:1210;right:22px;bottom:100px;max-width:320px;background:var(--glass-base);padding:15px;border-radius:20px;box-shadow:0 2px 25px rgba(0, 0, 0, 0.5); border: 1.5px solid var(--glass-border-glow);">
        <button id="ai-image-close" style="float:right;background:var(--background-light);border:none;border-radius:10px;color:var(--accent-color);font-size:1.6em;cursor:pointer;margin-left:8px;">&times;</button>
        <div id="ai-image-container"></div>
        <button id="ai-image-dl" style="margin-top:12px;padding:9px 22px;background:var(--button-gradient-primary);color:var(--button-text-color);border:none;border-radius:10px;box-shadow:0 2px 10px rgba(0, 0, 0, 0.4);cursor:pointer;font-weight:bold;">Download</button>
    </div>

    <div class="panel-bg" id="linkMenuBg">
        <nav class="side-panel" id="linkMenu">
            <div class="panel-header">
                <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia logo">
                <div class="username">Philadelphia AI</div>
            </div>
            <div class="panel-links">
                <a href="philadelphia.html"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a>
                <a href="index.html"><i class="fa-solid fa-home"></i>Elvion Homepage</a>
                <a href="about.html"><i class="fa-solid fa-circle-info"></i> About US</a>
                <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
                <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms</a>
                <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Try Telegram Version</a>
            </div>
        </nav>
    </div>

    <div class="panel-bg" id="toolsMenuBg">
        <nav class="side-panel" id="toolsMenu">
            <div class="panel-header" style="text-align:left;">
                <div class="username" style="font-size:1.25em;margin-left:-10px;text-align:center; text-shadow: 0 0 10px var(--accent-color);">Philadelphia AI Tools</div>
            </div>
            <div class="panel-links">
                <h3 style="color:var(--primary-color);margin:12px 0 6px 5px;font-size:0.95em;text-transform:uppercase; text-shadow: 0 0 8px var(--primary-color);">Creative Suite</h3>
                <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
                <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
                <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a>
                <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a>
                <hr style="border-color: var(--glass-border-glow); margin: 12px 0;">
                <h3 style="color:var(--primary-color);margin:12px 0 6px 5px;font-size:0.95em;text-transform:uppercase; text-shadow: 0 0 8px var(--primary-color);">Audio & Video</h3>
                <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
                <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
                <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a>
                <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
                <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a>
                <hr style="border-color: var(--glass-border-glow); margin: 12px 0;">
                <h3 style="color:var(--primary-color);margin:12px 0 6px 5px;font-size:0.95em;text-transform:uppercase; text-shadow: 0 0 8px var(--primary-color);">Web & Research</h3>
                <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a>
                <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
                <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a>
                <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
            </div>
            <button class="submit-btn" style="margin-top:20px;" onclick="closeToolMenu();">Close</button>
        </nav>
    </div>

    <div class="panel-bg" id="toolFormModalBg">
        <nav class="side-panel" id="toolFormModal">
            <div class="panel-header">
                <div class="username" id="toolFormTitle">Tool Title</div>
            </div>
            <form class="edit-form" id="toolForm" style="padding:0 8px;"></form>
            <button id="toolFormBackBtn" class="submit-btn" style="background:var(--background-light);color:var(--accent-color);margin:10px 10px 20px 10px;">
                <i class="fa-solid fa-arrow-left"></i> Back to Tools
            </button>
            <div class="status-message" id="toolStatusMsg"></div>
        </nav>
    </div>

    <div id="lightbox">
        <img src="" alt="Lightbox image">
    </div>

    <div id="callModal">
        <div id="callHeader">Live Call with Philadelphia AI</div>
        <div id="botImageContainer">
            <img src="" alt=""> <!-- Hidden, but kept for legacy JS compatibility -->
            <div id="quantum-nexus"></div> <!-- New visual for bot presence -->
        </div>
        <div id="callStatusMessage">Connecting...</div>
        <div id="tapToTalk">Tap Anywhere to Speak</div>
        <div id="callConversation">
            <div class="call-msg status">Initializing Quantum Link...</div>
        </div>
        <div id="callControls">
            <button id="muteCallBtn" class="submit-btn"><i class="fa-solid fa-microphone"></i></button>
            <button id="endCallBtn" class="submit-btn"><i class="fa-solid fa-phone-slash"></i></button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const $ = id => document.getElementById(id);

        const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

        let chats = [];
        let currentChatId = null;
        let currentMessages = [];
        let uploadedFiles = [];
        let currentUser = null;
        let currentController = null;

        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;

        window.addEventListener('DOMContentLoaded', () => {
            const backgroundContainer = $('background-container');
            const profileMenuBg = $('profileMenuBg');
            const profileMenu = $('profileMenu');
            const linkMenuBg = $('linkMenuBg');
            const linkMenu = $('linkMenu');
            const toolsMenuBg = $('toolsMenuBg');
            const toolsMenu = $('toolsMenu');
            const toolBtn = $('toolBtn');
            const logoutBtn = $('logoutBtn');
            // const headerWelcome = $('headerWelcome'); // This element is not present in new HTML, can remove or ignore
            const profileMenuUser = $('profileMenuUser');
            const profileMenuEmail = $('profileMenuEmail');
            const editName = $('edit-name');
            const editPhoto = $('edit-photo');
            const profilePicPreview = $('profilePicPreview');
            const profileForm = $('profileForm');
            const chatBox = $('chatBox');
            const chatForm = $('chatForm');
            const chatInput = $('chatInput');
            const sendBtn = $('sendBtn');
            const chatFile = $('chatFile');
            const filePreview = $('filePreview');
            const newChatBtn = $('newChatBtn');
            const chatsListEl = $('chatsList');
            const emojiPanel = $('emojiPanel');
            // const emojiBtn = $('emojiBtn'); // This element is not present in new HTML, can remove or ignore
            const toolFormModalBg = $('toolFormModalBg');
            const toolForm = $('toolForm');
            const toolFormTitle = $('toolFormTitle');
            const toolFormBackBtn = $('toolFormBackBtn');
            const aiPrevBox = $('ai-image-preview');
            const aiPrevClose = $('ai-image-close');
            const aiPrevDLBtn = $('ai-image-dl');
            const aiPrevImgBox = $('ai-image-container');
            const themeBtn = $('themeBtn');
            const lightbox = $('lightbox');
            const callBtn = $('callBtn');
            const callModal = $('callModal');
            const endCallBtn = $('endCallBtn');
            const muteCallBtn = $('muteCallBtn');
            const callConversation = $('callConversation');
            const botImageContainer = $('botImageContainer'); // Now contains #quantum-nexus
            const callStatusMessage = $('callStatusMessage');
            const tapToTalk = $('tapToTalk');
            const typingStatus = $('typing-status');

            if (!chatForm || !chatBox || !toolsMenu || !typingStatus) {
                console.error("Essential UI elements are missing. App functionality will be limited.");
                // return; // Don't return, just warn, as the basic functionality might still work
            }

            // --- Quantum Mote Interaction (Interactive "Space Ants") ---
            document.querySelectorAll('.quantum-mote').forEach(mote => {
                mote.addEventListener('click', () => {
                    // Create a "burst" effect (using a class and animation)
                    const burstEffect = document.createElement('div');
                    burstEffect.style.position = 'fixed';
                    burstEffect.style.left = mote.style.left;
                    burstEffect.style.top = mote.style.top;
                    burstEffect.style.width = '10px';
                    burstEffect.style.height = '10px';
                    burstEffect.style.borderRadius = '50%';
                    burstEffect.style.background = 'radial-gradient(circle, var(--accent-color) 0%, transparent 100%)';
                    burstEffect.style.boxShadow = '0 0 15px var(--accent-color), 0 0 25px var(--primary-color)';
                    burstEffect.style.zIndex = '1001';
                    burstEffect.style.animation = 'burst-fade 0.4s forwards';
                    backgroundContainer.appendChild(burstEffect);

                    mote.style.opacity = '0'; // Hide the original mote
                    
                    // Reposition and reset the mote after the burst animation finishes
                    setTimeout(() => {
                        burstEffect.remove(); // Clean up the burst effect
                        const newX = Math.random() * 90 + 5; // 5% to 95% width
                        const newY = Math.random() * 90 + 5; // 5% to 95% height
                        const newDelay = Math.random() * 20; // new animation delay
                        const newDuration = Math.random() * 15 + 20; // new animation duration

                        mote.style.transition = 'none'; // Disable transition for instant reposition
                        mote.style.left = `${newX}vw`;
                        mote.style.top = `${newY}vh`;
                        mote.style.animationDelay = `${newDelay}s`;
                        mote.style.animationDuration = `${newDuration}s`;
                        
                        // Reset visual state after a short delay to allow repositioning
                        setTimeout(() => {
                            mote.style.transition = 'transform 0.2s, opacity 0.2s, box-shadow 0.2s'; // Restore transitions
                            mote.style.opacity = '1';
                        }, 50);

                    }, 400); // After burst animation
                });
            });


            const emojis = ["üòÄ","üòÇ","üòç","ü•∞","üòé","üëç","üôè","üî•","üíØ","üéâ","üòá","ü§ñ","üëÄ"];
            // Original emojiBtn is removed from HTML, so this block won't activate unless element is re-added
            // If you want to re-add it, put this back in the HTML: <button type="button" id="emojiBtn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>
            // And then uncomment this JS block:
            /*
            if (emojiBtn && emojiPanel && chatInput) {
                emojiBtn.addEventListener('click', (e) => {
                    emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
                    emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block';
                    try {
                        const rect = emojiBtn.getBoundingClientRect();
                        emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
                    } catch (e) { }
                    emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
                        span.addEventListener('click', function () {
                            const text = this.textContent || '';
                            const start = chatInput.selectionStart || 0;
                            const end = chatInput.selectionEnd || 0;
                            chatInput.value = chatInput.value.slice(0, start) + text + chatInput.value.slice(end);
                            chatInput.focus();
                            chatInput.selectionStart = chatInput.selectionEnd = start + text.length;
                            emojiPanel.style.display = 'none';
                            chatInput.dispatchEvent(new Event('input'));
                        });
                    });
                });
                document.addEventListener('click', e => {
                    if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
                        emojiPanel.style.display = 'none';
                    }
                });
            }
            */

            if (chatInput) {
                const autoResize = () => {
                    chatInput.style.height = 'auto';
                    chatInput.style.height = Math.min(chatInput.scrollHeight, 180) + 'px'; // Max height adjusted for new design
                };
                chatInput.addEventListener('input', autoResize);
                chatInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        chatForm.requestSubmit();
                    } else if (e.key === 'Enter' && e.shiftKey) {
                        autoResize();
                    }
                });
                autoResize();
            }

            if (chatFile) {
                chatFile.addEventListener('change', function() {
                    uploadedFiles = Array.from(this.files || []);
                    renderFilePreview();
                });
            }

            if (aiPrevClose) aiPrevClose.addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
            if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
                const img = aiPrevImgBox.querySelector('img');
                if (img) {
                    const a = document.createElement('a');
                    a.href = img.src;
                    a.download = 'philadelphia_ai_image.png';
                    a.click();
                }
            });

            if (lightbox) {
                lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
            }

            if (chatBox) {
                chatBox.addEventListener('click', e => {
                    if (e.target.tagName === 'IMG' && e.target.closest('.chat-message.ai .msg')) {
                        e.preventDefault();
                        const lbImg = lightbox.querySelector('img');
                        if (lbImg) {
                            lbImg.src = e.target.src;
                            lightbox.classList.add('active');
                        }
                    }
                });
            }

            window.closeToolMenu = () => {
                if (toolsMenuBg) toolsMenuBg.classList.remove('active');
            };
            window.openToolMenu = () => {
                if (toolsMenuBg) toolsMenuBg.classList.add('active');
            };

            if (profileMenuBg) {
                $('openProfileMenu').addEventListener('click', () => {
                    profileMenuBg.classList.add('active');
                    setTimeout(() => profileMenu.classList.add('active'), 10);
                });
                profileMenuBg.addEventListener('click', e => {
                    if (e.target === profileMenuBg) {
                        profileMenu.classList.remove('active');
                        setTimeout(() => profileMenuBg.classList.remove('active'), 110);
                    }
                });
            }

            if (linkMenuBg) {
                $('openLinksMenu').addEventListener('click', () => {
                    linkMenuBg.classList.add('active');
                    setTimeout(() => linkMenu.classList.add('active'), 10);
                });
                linkMenuBg.addEventListener('click', e => {
                    if (e.target === linkMenuBg) {
                        linkMenu.classList.remove('active');
                        setTimeout(() => linkMenuBg.classList.remove('active'), 110);
                    }
                });
            }

            if (toolBtn) toolBtn.addEventListener('click', openToolMenu);
            if (toolsMenuBg) toolsMenuBg.addEventListener('click', e => {
                if (e.target === toolsMenuBg) closeToolMenu();
            });

            if (toolFormBackBtn) {
                toolFormBackBtn.addEventListener('click', () => {
                    toolFormModalBg.classList.remove('active');
                    openToolMenu();
                });
            }

            if (toolFormModalBg) toolFormModalBg.addEventListener('click', e => {
                if (e.target === toolFormModalBg) toolFormModalBg.classList.remove('active');
            });

            if (logoutBtn) logoutBtn.addEventListener('click', () => {
                auth.signOut();
                window.location.href = 'signup-login.html';
            });

            onAuthStateChanged(auth, user => {
                if (!user) {
                    try {
                        window.location.href = "signup-login.html";
                    } catch (e) {}
                    return;
                }
                currentUser = user;
                // if (headerWelcome) headerWelcome.textContent = "Welcome, " + (user.displayName || (user.email || '').split('@')[0]); // headerWelcome is removed
                if (profileMenuUser) profileMenuUser.textContent = user.displayName || "User";
                if (profileMenuEmail) profileMenuEmail.textContent = user.email || "";
                if (editName) editName.value = user.displayName || "";
                if (editPhoto) editPhoto.value = user.photoURL || "";
                if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";
                loadUserChats(user.uid);
            });

            if (profileForm) {
                profileForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!currentUser) return;
                    const status = $('profileStatusMsg');
                    if (status) status.textContent = 'Saving...';
                    try {
                        await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
                        if (auth.currentUser) await auth.currentUser.reload();
                        if (status) {
                            status.textContent = "Profile updated!";
                            status.style.color = "var(--accent-color)";
                        }
                        setTimeout(() => {
                            profileMenuBg?.classList.remove('active');
                        }, 800);
                        // if (headerWelcome) headerWelcome.textContent = "Welcome, " + (auth.currentUser?.displayName || 'User'); // headerWelcome is removed
                    } catch (err) {
                        if (status) {
                            status.textContent = err.message;
                            status.style.color = "#ff6347";
                        }
                    }
                });
            }

            async function loadUserChats(userId) {
                if (chatsUnsubscribe) chatsUnsubscribe();
                const chatsCol = collection(db, 'users', userId, 'chats');
                const q = query(chatsCol, orderBy('createdAt', 'desc'));
                chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                    if (snapshot.empty) {
                        await createNewChat(userId);
                        return;
                    }
                    chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatsListSidebar();
                    if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                        currentChatId = chats[0].id;
                    }
                    subscribeToMessages(userId, currentChatId);
                }, (error) => {
                    console.error("Error fetching chats: ", error);
                    chatsListEl.innerHTML = `<div style="color: #ff6347;">Error loading chats.</div>`;
                });
            }

            async function createNewChat(userId) {
                if (!userId) userId = currentUser?.uid;
                if (!userId) return;
                const chatsCol = collection(db, 'users', userId, 'chats');
                try {
                    const newChatDoc = await addDoc(chatsCol, { name: "New Quantum Link", createdAt: serverTimestamp() });
                    currentChatId = newChatDoc.id;
                } catch (e) {
                    console.error("Error creating new chat: ", e);
                }
            }

            function subscribeToMessages(userId, chatId) {
                if (messagesUnsubscribe) messagesUnsubscribe();
                if (!userId || !chatId) {
                    renderChatBox([]);
                    return;
                }
                const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
                const q = query(messagesCol, orderBy('createdAt'));
                messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                    currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatBox(currentMessages);
                }, (error) => {
                    console.error("Error fetching messages: ", error);
                    chatBox.innerHTML = `<div style="color: #ff6347; text-align: center; margin-top: 20px;">Error loading messages for this chat.</div>`;
                });
            }

            if (newChatBtn) {
                newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));
            }

            function renderChatsListSidebar() {
                if (!chatsListEl) return;
                chatsListEl.innerHTML = '';
                if (chats.length === 0) {
                    chatsListEl.innerHTML = `<div style="padding: 10px; color: var(--text-color); opacity: 0.7;">No Quantum Links established yet.</div>`;
                    return;
                }
                chats.forEach((chat) => {
                    const container = document.createElement('div');
                    container.style.display = 'flex';
                    container.style.alignItems = 'center';
                    container.style.marginBottom = '8px';
                    container.style.padding = '8px 10px';
                    container.style.background = chat.id === currentChatId ? 'rgba(106, 5, 155, 0.2)' : 'transparent';
                    container.style.borderRadius = '10px';
                    container.style.border = chat.id === currentChatId ? '1px solid var(--primary-color)' : 'none';
                    container.style.boxShadow = chat.id === currentChatId ? '0 0 10px rgba(240, 98, 255, 0.2)' : 'none';


                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = chat.name || `Quantum Link`;
                    titleSpan.style.flex = '1';
                    titleSpan.style.cursor = 'pointer';
                    titleSpan.style.padding = '4px 0';
                    titleSpan.style.color = chat.id === currentChatId ? 'var(--accent-color)' : 'var(--text-color)';
                    titleSpan.style.textShadow = chat.id === currentChatId ? '0 0 5px var(--accent-color)' : 'none';
                    titleSpan.onclick = () => {
                        currentChatId = chat.id;
                        subscribeToMessages(currentUser.uid, currentChatId);
                        renderChatsListSidebar();
                        profileMenu?.classList.remove('active');
                        profileMenuBg?.classList.remove('active');
                    };

                    const renameBtn = document.createElement('button');
                    renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                    renameBtn.title = 'Rename Quantum Link';
                    renameBtn.style.margin = '0 8px 0 10px';
                    renameBtn.style.color = 'var(--secondary-color)';
                    renameBtn.onclick = async (e) => {
                        e.stopPropagation();
                        const newName = prompt("Rename Quantum Link:", chat.name);
                        if (newName && newName.trim()) {
                            const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                            await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
                        }
                    };

                    const delBtn = document.createElement('button');
                    delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                    delBtn.title = 'Sever Quantum Link';
                    delBtn.style.marginLeft = '8px';
                    delBtn.style.color = '#ff6347';
                    delBtn.onclick = async (e) => {
                        e.stopPropagation();
                        if (!confirm(`Sever Quantum Link "${chat.name}"? This will delete all messages.`)) return;

                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                        const messagesSnap = await getDocs(messagesCol);
                        const batch = writeBatch(db);
                        messagesSnap.docs.forEach(d => batch.delete(d.ref));
                        await batch.commit();

                        const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                        await deleteDoc(chatDoc);

                        if (currentChatId === chat.id) {
                            currentChatId = null;
                        }
                    };

                    container.appendChild(titleSpan);
                    container.appendChild(renameBtn);
                    container.appendChild(delBtn);
                    chatsListEl.appendChild(container);
                });
            }

            const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

            function inlineMarkdown(t = '') {
                let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
                s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
                s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
                s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                return s.replace(/\n/g, '<br>');
            }

            function renderMarkdown(text = '') {
                const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
                let html = '';
                let lastIndex = 0;
                text = text || '';
                text.replace(codeBlockRegex, (match, lang, code, offset) => {
                    const before = text.slice(lastIndex, offset);
                    html += inlineMarkdown(before);
                    const language = (lang || '').toLowerCase().trim();
                    const safe = escapeHTML(code);
                    html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safe}</code></pre>`;
                    lastIndex = offset + match.length;
                    return match;
                });
                html += inlineMarkdown(text.slice(lastIndex));
                return { html };
            }

            function enhanceCodeBlocks(container) {
                if (!container) return;
                container.querySelectorAll('pre').forEach(pre => {
                    const codeEl = pre.querySelector('code');
                    if (window.hljs && codeEl) {
                        try { hljs.highlightElement(codeEl); } catch (e) { /* ignore */ }
                    }
                    const btn = pre.querySelector('.copy-btn');
                    if (btn && codeEl) {
                        btn.addEventListener('click', async () => {
                            try {
                                await navigator.clipboard.writeText(codeEl.innerText);
                                const prev = btn.textContent;
                                btn.textContent = 'Copied!';
                                setTimeout(() => btn.textContent = prev, 800);
                            } catch (e) {
                                btn.textContent = 'Failed';
                                setTimeout(() => btn.textContent = 'Copy', 800);
                            }
                        });
                    }
                });
            }

            function renderChatBox(messages = []) {
                if (!chatBox) return;
                chatBox.innerHTML = '';
                (messages || []).forEach((msg) => {
                    const div = document.createElement('div');
                    div.className = 'chat-message ' + (msg.role === 'user' ? 'user' : 'ai');
                    div.setAttribute('data-message-id', msg.id);
                    let innerHtml = '';

                    if (msg.role === 'user') {
                        const fileHtml = (msg.files || [])
                            .map(file => {
                                let icon = 'fa-file';
                                if (file.type.startsWith('image/')) icon = 'fa-file-image';
                                else if (file.type.startsWith('video/')) icon = 'fa-file-video';
                                else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
                                else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                                return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                            })
                            .join('');

                        innerHtml = `<div class="msg">
                            ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                            ${escapeHTML(msg.text || '')}
                            <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:10px;">
                                <button class="inline-edit-btn submit-btn" title="Edit" style="background:var(--background-light);color:var(--accent-color); border: 1px solid var(--glass-border-glow); box-shadow: none;"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="inline-copy-btn submit-btn" title="Copy" style="background:var(--background-light);color:var(--accent-color); border: 1px solid var(--glass-border-glow); box-shadow: none;"><i class="fa-solid fa-copy"></i></button>
                            </div>
                        </div>`;
                    } else {
                        let content;
                        if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                            content = msg.text;
                        } else {
                            content = renderMarkdown(msg.text || '').html;
                        }
                        innerHtml = `<div class="msg">${content}
                            <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:10px;">
                                <button class="inline-copy-btn submit-btn" title="Copy" style="background:var(--background-light);color:var(--accent-color); border: 1px solid var(--glass-border-glow); box-shadow: none;"><i class="fa-solid fa-copy"></i></button>
                                <button class="inline-share-btn submit-btn" title="Share" style="background:var(--background-light);color:var(--accent-color); border: 1px solid var(--glass-border-glow); box-shadow: none;"><i class="fa-solid fa-share"></i></button>
                                <button class="regen-btn submit-btn" title="Regenerate" style="background:var(--background-light);color:var(--accent-color); border: 1px solid var(--glass-border-glow); box-shadow: none;"><i class="fa-solid fa-rotate-right"></i></button>
                            </div>
                        </div>`;
                    }
                    div.innerHTML = innerHtml;
                    chatBox.appendChild(div);
                });
                enhanceCodeBlocks(chatBox);
                hookAiMsgControls();
                hookUserMsgControls();
                setTimeout(() => {
                    chatBox.scrollTop = chatBox.scrollHeight;
                }, 50);
            }

            async function deleteMessagesFrom(messageId) {
                if (!currentChatId || !currentUser) return;
                const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                if (msgIndex === -1) return;
                const batch = writeBatch(db);
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                for (let i = msgIndex; i < currentMessages.length; i++) {
                    const msgToDel = currentMessages[i];
                    const docRef = doc(messagesCol, msgToDel.id);
                    batch.delete(docRef);
                }
                try {
                    await batch.commit();
                } catch (e) {
                    console.error("Error deleting messages: ", e);
                }
            }

            function hookAiMsgControls() {
                if (!chatBox) return;
                chatBox.querySelectorAll('.chat-message.ai').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;

                    const controls = div.querySelector('.ai-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const shareBtn = controls.querySelector('.inline-share-btn');
                    const regenBtn = controls.querySelector('.regen-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                        } catch (e) {
                            console.warn('copy failed', e);
                        }
                    };

                    if (shareBtn) shareBtn.onclick = () => {
                        try {
                            const url = window.location.origin;
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const plainText = tempDiv.textContent || tempDiv.innerText || '';
                            const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;
                            if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
                            else prompt("Copy and share manually:", shareText);
                        } catch (e) {
                            console.warn('share failed', e);
                        }
                    };

                    if (regenBtn) regenBtn.onclick = async () => {
                        const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                        if (msgIndex < 1) return;
                        const userMsg = currentMessages[msgIndex - 1];
                        if (userMsg.role !== 'user') return;

                        await deleteMessagesFrom(messageId);
                        chatInput.value = userMsg.text;
                        chatInput.style.height = 'auto';
                        chatInput.style.height = Math.min(chatInput.scrollHeight, 180) + 'px';
                        uploadedFiles = [];
                        renderFilePreview();

                        showTypingAtNext();

                        const historyForRegen = currentMessages
                            .slice(0, msgIndex - 1)
                            .map(m => ({ role: m.role, content: m.text || '' }));

                        try {
                            const res = await fetch(`${API_BASE_URL}/chat`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ message: userMsg.text, history: historyForRegen, user_id: currentUser?.uid || "user" })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Server error.");
                            removeTyping();
                            await startTypewriter(data.response, false);
                        } catch (err) {
                            removeTyping();
                            await startTypewriter(`‚ùå Regeneration error: ${err.message}`, false);
                        }
                    };
                });
            }

            function hookUserMsgControls() {
                if (!chatBox) return;
                chatBox.querySelectorAll('.chat-message.user').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;

                    const controls = div.querySelector('.user-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const editBtn = controls.querySelector('.inline-edit-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                        } catch (e) {
                            console.warn('copy failed', e);
                        }
                    };

                    if (editBtn) editBtn.onclick = async () => {
                        try {
                            if (!msg.text) return;
                            chatInput.value = msg.text;
                            chatInput.focus();
                            await deleteMessagesFrom(messageId);
                        } catch (e) {
                            console.warn('edit failed', e);
                        }
                    };
                });
            }

            function showTypingAtNext() {
                if (!typingStatus) return;
                typingStatus.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span></div>`;
                typingStatus.style.display = 'flex';
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            function showTypingWithText(text) {
                if (!typingStatus) return;
                typingStatus.innerHTML = `<div class="msg" style="display:flex;align-items:center;"><span class="spinner"></span> <span style="margin-left:10px; color:var(--text-color); font-style:italic;">${text}</span></div>`;
                typingStatus.style.display = 'flex';
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            function removeTyping() {
                if (!typingStatus) return;
                typingStatus.style.display = 'none';
                typingStatus.innerHTML = '';
            }

            async function startTypewriter(text, saveToDb = true) {
                if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) {
                    if (saveToDb) {
                        await addMessageToChat('ai', text);
                    } else {
                        const tempDiv = document.createElement('div');
                        tempDiv.className = "chat-message ai";
                        tempDiv.innerHTML = `<div class="msg">${text}</div>`;
                        chatBox.appendChild(tempDiv);
                        chatBox.scrollTop = chatBox.scrollHeight;

                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                        try {
                            await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
                        } catch (e) {
                            console.error("Error saving regenerated AI tool message: ", e);
                        }
                    }
                    return;
                }

                if (!chatBox) return;

                const div = document.createElement('div');
                div.className = "chat-message ai";
                const msgdiv = document.createElement('div');
                msgdiv.className = 'msg';
                div.appendChild(msgdiv);
                chatBox.appendChild(div);

                let sofar = '';
                const words = text.split(/(\s+)/);
                let tempText = '';
                for (const word of words) {
                    if (currentController?.signal.aborted) {
                        text = tempText;
                        break;
                    }
                    tempText += word;
                    if (tempText.includes('```')) {
                        const parts = tempText.split('```');
                        sofar = parts.slice(0, parts.length -1).join('```');
                        if(parts.length % 2 === 0) sofar += '```';
                    } else {
                        sofar = tempText;
                    }
                    msgdiv.innerHTML = renderMarkdown(sofar).html;
                    chatBox.scrollTop = chatBox.scrollHeight;
                    const delay = word.match(/[\s\.\,\!\?]/) ? 10 : 30;
                    await new Promise(res => setTimeout(res, delay));
                }

                const finalRenderText = text;

                msgdiv.innerHTML = renderMarkdown(finalRenderText).html + `
                    <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:10px;">
                        <button class="inline-copy-btn submit-btn" title="Copy" style="background:var(--background-light);color:var(--accent-color); border: 1px solid var(--glass-border-glow); box-shadow: none;"><i class="fa-solid fa-copy"></i></button>
                        <button class="inline-share-btn submit-btn" title="Share" style="background:var(--background-light);color:var(--accent-color); border: 1px solid var(--glass-border-glow); box-shadow: none;"><i class="fa-solid fa-share"></i></button>
                        <button class="regen-btn submit-btn" title="Regenerate" style="background:var(--background-light);color:var(--accent-color); border: 1px solid var(--glass-border-glow); box-shadow: none;"><i class="fa-solid fa-rotate-right"></i></button>
                    </div>
                `;
                enhanceCodeBlocks(msgdiv);
                chatBox.scrollTop = chatBox.scrollHeight;

                if (saveToDb) {
                    const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                    try {
                        await addDoc(messagesCol, { role: 'ai', text: finalRenderText, createdAt: serverTimestamp() });
                    } catch (e) {
                        console.error("Error saving AI message: ", e);
                        msgdiv.innerHTML += "<br><small style='color: #ff6347;'>Failed to save message.</small>";
                    }
                }
            }

            function renderFilePreview() {
                if (!filePreview) return;
                if (!uploadedFiles.length) {
                    filePreview.style.display = 'none';
                    filePreview.innerHTML = '';
                    return;
                }
                filePreview.style.display = 'block';
                filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                    let preview = '';
                    if (file.type.startsWith('image/')) {
                        preview = `<img src="${URL.createObjectURL(file)}" style="max-width:64px;max-height:48px;vertical-align:middle;border-radius:10px;margin-right:8px; border: 1px solid var(--glass-border-glow);">`;
                    } else if (file.type.startsWith('video/')) {
                        preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:64px;height:48px;vertical-align:middle;border-radius:10px;margin-right:8px; border: 1px solid var(--glass-border-glow);"></video>`;
                    } else if (file.type.startsWith('audio/')) {
                        preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:60px;margin-right:8px;"></audio>`;
                    } else if (file.type === 'application/pdf') {
                        preview = `<span style="font-size:1.4em;margin-right:8px;">üìÑ</span>`;
                    }
                    return `
                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:2px;">
                            ${preview}
                            <span style="color:var(--text-color);opacity:0.9;font-size:1em;">${escapeHTML(file.name)}</span>
                            <button type="button" data-idx="${idx}" class="remove-file-btn submit-btn" style="background:#d23; color:white; font-size:1.1em; padding: 4px 10px; border-radius: 8px; box-shadow: none;" aria-label="Remove file">&times;</button>
                        </div>`;
                }).join('');

                filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const idx = parseInt(btn.getAttribute('data-idx'));
                        uploadedFiles.splice(idx, 1);
                        if (!uploadedFiles.length && chatFile) chatFile.value = '';
                        renderFilePreview();
                    });
                });
            }

            function showAIImagePreview(base64, caption = '') {
                if (!aiPrevBox || !aiPrevImgBox) return;
                aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:240px;max-height:240px;border-radius:15px;display:block; border: 2px solid var(--accent-color); box-shadow: 0 0 20px var(--accent-color);">` + `<div style="color:var(--text-color);opacity:0.9;font-size:1em;margin-top:5px;text-align:center;">${caption}</div>`;
                aiPrevBox.style.display = 'block';
            }

            async function addMessageToChat(role, text, files = []) {
                if (!currentChatId || !currentUser) return;
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesCol, { role, text, files, createdAt: serverTimestamp() });
                } catch (e) {
                    console.error("Error adding message to Firestore: ", e);
                }
            }

            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            async function handleVideoGeneration(payload, isImageToVideo = false) {
                showTypingWithText('Submitting video generation job...');
                try {
                    const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
                    const commonPayload = { model: "MiniMax-Hailuo-02", duration: payload.duration || 6, resolution: payload.resolution || "1080P" };
                    let options;

                    if (isImageToVideo) {
                        payload.append('model', commonPayload.model);
                        payload.append('duration', commonPayload.duration);
                        payload.append('resolution', commonPayload.resolution);
                        options = { method: 'POST', body: payload };
                    } else {
                        const finalPayload = { ...payload, ...commonPayload };
                        options = {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(finalPayload)
                        };
                    }

                    const startRes = await fetch(API_BASE_URL + endpoint, options);
                    const startData = await startRes.json();

                    if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to start video task.');

                    removeTyping();
                    await startTypewriter(`‚úÖ Video generation initiated! Task ID: \`${startData.task_id}\`. I will notify you when the Quantum rendering is complete. This may take several moments. Please remain on this page and avoid sending new requests.`);

                    const pollInterval = setInterval(async () => {
                        try {
                            const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                            const statusData = await statusRes.json();

                            if (statusRes.ok && statusData.url) {
                                clearInterval(pollInterval);
                                const videoHtml = `üéâ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                                await addMessageToChat('ai', videoHtml);
                            } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                                clearInterval(pollInterval);
                                await startTypewriter(`‚ùå Video generation failed. Reason: ${statusData.error || 'Unknown quantum anomaly'}`);
                            }
                        } catch (pollErr) {
                            clearInterval(pollInterval);
                            await startTypewriter(`‚ùå Error checking video status. Quantum link unstable.`);
                        }
                    }, 20000);
                } catch (err) {
                    removeTyping();
                    await startTypewriter(`‚ùå Could not initiate video generation: ${err.message}`);
                }
            }

            const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
            const toolDefinitions = {
                "image": {
                    title: "Generate Image",
                    description: "Fabricate stunning visuals from a text prompt. Select a Quantum Model for diverse aesthetic outcomes.",
                    buildForm: () => `
                        <label for="tool-provider">Generation Model</label>
                        <select id="tool-provider" class="edit-form-select"><option value="thena">Quantum Render v1 (Stylized, High-Speed)</option><option value="minimax">Quantum Render v2 (Creative, Realistic, Text-Optimized)</option></select>
                        <label for="tool-prompt">Image Prompt</label>
                        <textarea id="tool-prompt" placeholder="A cosmic serpent weaving through a star cluster, vibrant nebulae, glowing crystalline structures" required></textarea>
                        <label for="tool-style">Render Style (for Quantum Render v1 only)</label>
                        <select id="tool-style" class="edit-form-select">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate Quantum Image</button>`,
                    handleSubmit: async (form) => {
                        const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                        const providerName = use_minimax ? 'Quantum Render v2' : 'Quantum Render v1';
                        const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
                        await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                        showTypingWithText('Fabricating your image...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/generate-image`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                            removeTyping();
                            await addMessageToChat('ai', '‚úÖ Image generated! Access the floating Quantum Display to view or download.');
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Image generation failed: ${err.message}`;
                        }
                    }
                },
                "edit-photo": {
                    title: "Manipulate Image Matrix",
                    description: "Upload an image and describe the quantum alterations you wish to apply.",
                    buildForm: () => `
                        <label for="tool-prompt">Alteration Directive</label><textarea id="tool-prompt" placeholder="Transmute the background into a swirling galactic core" required></textarea>
                        <label for="tool-file">Image for Manipulation</label><input type="file" id="tool-file" accept="image/*" required>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Quantum Alteration</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        const prompt = form.querySelector('#tool-prompt').value;
                        if (!file) return "Please select an image file for manipulation.";
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('prompt', prompt);
                        await addMessageToChat('user', `Image manipulation request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Manipulating image matrix...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error((await res.json()).error || 'Failed to manipulate image matrix.');
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const imgHtml = `‚úÖ Image matrix successfully altered! <br><img src="${base64String}" alt="Altered Image" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Image matrix manipulation failed: ${err.message}`;
                        }
                    }
                },
                "remove-bg": {
                    title: "Sever Background Field",
                    description: "Select an image file to surgically remove its background field.",
                    buildForm: () => `
                        <label for="tool-file">Select Image for Field Severance</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Sever Background Field</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        if (!file) return "Please select an image file.";
                        await addMessageToChat('user', `Background field severance request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Initiating background field severance...');
                        const fd = new FormData();
                        fd.append('file', file);
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const imgHtml = `‚úÖ Background field severed! <br><img src="${url}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Background field severance failed: ${err.message}`;
                        }
                    }
                },
                "comic": {
                    title: "Chronicle of Quantum Tales",
                    description: "Spin a narrative and observe its manifestation into a multi-panel quantum chronicle. Utilize [DIALOGUE], [INSTRUCTION], and [NARRATION] tags to guide the unfolding story.",
                    buildForm: () => `
                        <label for="tool-story">Quantum Tale Narrative</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you witnessing this temporal anomaly?&#10;[NARRATION] The ancient nexus pulsed with unforeseen energy..." required></textarea>
                        <label for="tool-style">Chronicle Aesthetic</label><select id="tool-style" class="edit-form-select"><option value="anime">Anime Shards</option><option value="american">Cosmic Marvel</option><option value="manga">Galactic Manga</option></select>
                        <label for="tool-panels">Number of Panels (Quantum Shards)</label><input type="number" id="tool-panels" value="3" min="1" max="6" />
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Forge Quantum Tale</button>`,
                    handleSubmit: async (form) => {
                        const payload = {
                            story: form.querySelector('#tool-story').value,
                            style: form.querySelector('#tool-style').value,
                            panels: parseInt(form.querySelector('#tool-panels').value, 10),
                            user: currentUser?.displayName || "User"
                        };
                        await addMessageToChat('user', `Quantum Tale narrative request with aesthetic: ${payload.style}.`);
                        showTypingWithText('Forging your quantum tale panels...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Quantum Tale Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 8px;">`).join('');
                            const comicMessage = `üñºÔ∏è Quantum Tale successfully forged! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                            removeTyping();
                            await addMessageToChat('ai', comicMessage);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Quantum Tale forging failed: ${err.message}`;
                        }
                    }
                },
                "voice-gen": {
                    title: "Aural Synthesizer",
                    description: "Transmute written constructs into hyper-realistic aural emissions. Choose a Voice Matrix and modulation style.",
                    buildForm: () => `
                        <label for="tool-provider">Voice Matrix Provider</label><select id="tool-provider" class="edit-form-select"><option value="gemini">Philadelphia Nexus (Modulation Styles)</option><option value="minimax">Seraphina Echo (Character Personas)</option></select>
                        <label for="tool-prompt">Text for Aural Emission</label><textarea id="tool-prompt" placeholder="The quantum harmonies resonate across the void..." required></textarea>
                        <label for="tool-style">Aural Modulation Style</label><select id="tool-style" class="edit-form-select"></select>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Aural Emission</button>`,
                    onFormReady: () => {
                        const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
                        const voices = {
                            gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                            minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                        };
                        const updateStyles = () => {
                            styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                        };
                        providerSelect.addEventListener('change', updateStyles);
                        updateStyles();
                    },
                    handleSubmit: async (form) => {
                        const provider = form.querySelector('#tool-provider').value,
                            text = form.querySelector('#tool-prompt').value,
                            style = form.querySelector('#tool-style').value;
                        const providerName = provider === 'minimax' ? 'Seraphina Echo' : 'Philadelphia Nexus';
                        await addMessageToChat('user', `Aural emission request using ${providerName}.`);
                        showTypingWithText('Generating your aural emission...');
                        try {
                            let res;
                            if (provider === 'gemini') {
                                const fd = new FormData();
                                fd.append('text', text);
                                fd.append('style', style);
                                res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                            } else {
                                res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({ text, voice_id: style })
                                });
                            }
                            if (!res.ok) throw new Error(await res.text());
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const audioHtml = `üó£Ô∏è Aural emission generated! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', audioHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Aural emission failed: ${err.message}`;
                        }
                    }
                },
                "audio-narration": {
                    title: "Quantum Lore Recitation",
                    description: "Upload a data scroll (PDF, TXT) to receive a narrated audio summary, modulated in a chronicle-recitation style.",
                    buildForm: () => `
                        <label for="tool-file">Select Data Scroll for Recitation</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Initiate Recitation</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        if (!file) return "Please select a data scroll.";
                        await addMessageToChat('user', `Quantum Lore Recitation request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Analyzing data scroll and initiating recitation protocol...');
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('style', 'podcast');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const narrationHtml = `üó£Ô∏è Recitation complete! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', narrationHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Quantum Lore Recitation failed: ${err.message}`;
                        }
                    }
                },
                "video-text": {
                    title: "Synthesize Chronal Visuals from Text",
                    description: "Describe the chronal visual sequence you desire. This complex quantum rendering can require significant temporal resources.",
                    buildForm: () => `
                        <label for="video-prompt">Chronal Visual Sequence Directive</label><textarea id="video-prompt" placeholder="A majestic celestial dragon soaring through nebulae, its scales shimmering with starlight..." required></textarea>
                        <label for="video-duration">Temporal Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Initiate Chronal Synthesis</button>`,
                    handleSubmit: async (form) => {
                        const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
                        await addMessageToChat('user', `Text-to-Chronal Visual request: "${payload.prompt}"`);
                        handleVideoGeneration(payload);
                        return null;
                    }
                },
                "video-image": {
                    title: "Animate Static Chronal Fragment",
                    description: "Upload a static chronal fragment (image) and dictate its desired animation parameters.",
                    buildForm: () => `
                        <label for="video-image-prompt">Animation Parameters</label><textarea id="video-image-prompt" placeholder="The nebulae swirl gently, a distant planet slowly orbits, subtle zoom on the central star" required></textarea>
                        <label for="video-image-file">Static Chronal Fragment</label><input type="file" id="video-image-file" accept="image/*" required>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Initiate Fragment Animation</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#video-image-file').files[0];
                        if (!file) return "Please select a static chronal fragment.";
                        await addMessageToChat('user', `Image-to-Chronal Visual request for: ${file.name}`, [{name: file.name, type: file.type}]);
                        const fd = new FormData();
                        fd.append('prompt', form.querySelector('#video-image-prompt').value);
                        fd.append('file', file);
                        handleVideoGeneration(fd, true);
                        return null;
                    }
                },
                "music": {
                    title: "Harmonic Flux Generator",
                    description: "Generate a resonant harmonic flux from a prompt, lyrical constructs, and optional reference sonic patterns. Powered by MiniMax's Quantum Audio Matrix.",
                    buildForm: () => `
                        <label for="music-prompt">Harmonic Flux Directive / Description</label><textarea id="music-prompt" placeholder="Upbeat cosmic symphony with shimmering synth waves and a driving percussion pulse..." required></textarea>
                        <label for="music-lyrics">Lyrical Constructs (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1: Stars ignite, destinies align&#10;Chorus: Quantum dreams, forever thine..."></textarea>
                        <label for="music-ref">Reference Sonic Pattern (Optional)</label><input type="file" id="music-ref" accept="audio/*">
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Harmonic Flux</button>`,
                    handleSubmit: async (form) => {
                        const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
                        const refFile = form.querySelector('#music-ref').files[0];
                        await addMessageToChat('user', `Harmonic Flux generation request: "${payload.prompt}"`);
                        showTypingWithText('Composing your harmonic flux...');
                        try {
                            if (refFile) {
                                showTypingWithText('Uploading reference sonic pattern to Quantum Audio Matrix...');
                                const fd = new FormData();
                                fd.append('file', refFile);
                                const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                                const uploadData = await uploadRes.json();
                                if (!uploadRes.ok) throw new Error(uploadData.error || "Reference pattern upload failed.");
                                if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                                if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                                showTypingWithText('Reference pattern assimilated. Composing harmonic flux...');
                            }
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            if (!res.ok) throw new Error((await res.json()).detail || 'Quantum Audio Matrix request failed.');
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const musicHtml = `üéµ Your harmonic flux is ready! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', musicHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Harmonic Flux generation failed: ${err.message}`;
                        }
                    }
                },
                "website": {
                    title: "Manifest Digital Constellation",
                    description: "Describe the digital constellation (website) you wish to manifest and receive a live, functioning prototype within the Quantum Web.",
                    buildForm: () => `
                        <label for="website-prompt">Digital Constellation Directive</label><textarea id="website-prompt" placeholder="A vibrant personal nexus for a quantum astrophysicist, showcasing research and cosmic photography..." required></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Manifest Digital Constellation</button>`,
                    handleSubmit: async (form) => {
                        const prompt = form.querySelector('#website-prompt').value;
                        await addMessageToChat('user', `Digital Constellation manifestation request: "${prompt.substring(0, 50)}..."`);
                        showTypingWithText('Assembling and deploying your digital constellation within the Quantum Web...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt, user_id: currentUser.uid })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return `üåê Digital Constellation deployed successfully! Observe its form in the Quantum Web: [View here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Digital Constellation manifestation failed: ${err.message}`;
                        }
                    }
                },
                "edit-website": {
                    title: "Refactor Last Digital Constellation",
                    description: "Provide an instruction to modify the most recently manifested digital constellation.",
                    buildForm: () => `
                        <label for="edit-instruction">Refactor Directive</label><textarea id="edit-instruction" placeholder="Transmute the primary navigational elements to a shimmering, ethereal blue..." required></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Refactor</button>`,
                    handleSubmit: async (form) => {
                        const instruction = form.querySelector('#edit-instruction').value;
                        await addMessageToChat('user', `Digital Constellation refactor request: "${instruction.substring(0, 50)}..."`);
                        showTypingWithText('Refactoring and redeploying your digital constellation...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ instruction, user_id: currentUser.uid })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return `‚úèÔ∏è Digital Constellation refactored successfully! Observe new configuration: [View new version here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Digital Constellation refactor failed: ${err.message}`;
                        }
                    }
                },
                "my-sites": {
                    isAction: true,
                    runAction: async () => {
                        await addMessageToChat('user', 'Access my Quantum Web manifests.');
                        showTypingWithText('Querying your manifested Digital Constellations...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || 'Could not access manifests.');
                            if (!data.sites || data.sites.length === 0) return "You have not yet manifested any Digital Constellations within the Quantum Web.";
                            const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank" style="color:var(--secondary-color);">${site.site_url}</a> (Manifested: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                            removeTyping();
                            return `Here are your manifested Digital Constellations:\n${siteList}`;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Error accessing Quantum Web manifests: ${err.message}`;
                        }
                    }
                },
                "research-report": {
                    title: "Quantum Data Synthesis Report",
                    description: "Generate a comprehensive Quantum Data Synthesis Report in PDF format on any specified temporal-spatial topic.",
                    buildForm: () => `
                        <label for="research-topic">Temporal-Spatial Topic</label><input type="text" id="research-topic" placeholder="The origins of dark energy fluctuations" required>
                        <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Synthesis Report</button>`,
                    handleSubmit: async (form) => {
                        const topic = form.querySelector('#research-topic').value;
                        await addMessageToChat('user', `Quantum Data Synthesis Report request on: "${topic}"`);
                        showTypingWithText('Initiating Quantum Data Synthesis and compiling report...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ topic })
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const downloadLink = `<a href="${url}" download="quantum_synthesis_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--secondary-color);font-weight:bold;">Download Quantum Synthesis Report (PDF)</a>`;
                            removeTyping();
                            return `‚úÖ Quantum Data Synthesis Report on **${topic}** is ready! ${downloadLink}`;
                        } catch (err) {
                            removeTyping();
                            return `‚ùå Quantum Data Synthesis Report failed: ${err.message}`;
                        }
                    }
                },
            };

            if (toolsMenu) {
                toolsMenu.addEventListener('click', async (e) => {
                    const toolLink = e.target.closest('.tool-link');
                    if (!toolLink) return;
                    e.preventDefault();
                    const toolKey = toolLink.getAttribute('data-tool');
                    const tool = toolDefinitions[toolKey];
                    if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);
                    closeToolMenu();
                    if (tool.isAction) {
                        const result = await tool.runAction();
                        removeTyping();
                        if(result) await startTypewriter(result);
                    } else {
                        displayToolForm(toolKey);
                    }
                });
            }

            function displayToolForm(toolKey) {
                const tool = toolDefinitions[toolKey];
                if (!tool || !toolFormModalBg) return;
                toolFormTitle.textContent = tool.title;
                const descriptionHtml = tool.description ? `<div style="color:var(--text-color);opacity:0.8;font-size:0.95em;margin-bottom:15px;">${tool.description}</div>` : '';
                toolForm.innerHTML = descriptionHtml + tool.buildForm();
                if (typeof tool.onFormReady === 'function') tool.onFormReady();

                toolForm.onsubmit = async (e) => {
                    e.preventDefault();
                    const submitButton = toolForm.querySelector('button[type="submit"]');
                    const originalButtonContent = submitButton.innerHTML;
                    submitButton.innerHTML = `<div class="spinner"></div> Initiating...`;
                    submitButton.disabled = true;
                    toolFormModalBg.classList.remove('active');
                    const resultText = await tool.handleSubmit(toolForm);
                    if (resultText) {
                        removeTyping();
                        await startTypewriter(resultText);
                    }
                    submitButton.innerHTML = originalButtonContent;
                    submitButton.disabled = false;
                };
                toolFormModalBg.classList.add('active');
            }

            chatForm.addEventListener('submit', async function (e) {
                e.preventDefault();
                if (!currentChatId) {
                    alert("Please establish a Quantum Link or forge a new one.");
                    return;
                }
                const msgText = chatInput.value.trim();
                if (!msgText && uploadedFiles.length === 0) return;

                const stopButton = document.createElement('button');
                stopButton.type = 'button';
                stopButton.id = 'stopBtn';
                stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>';
                sendBtn.replaceWith(stopButton);
                currentController = new AbortController();
                const signal = currentController.signal;
                let finalResponse = '';

                stopButton.addEventListener('click', () => {
                    if (currentController) {
                        currentController.abort();
                    }
                });

                const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
                await addMessageToChat('user', msgText, filesForHistory);
                const localUploadedFiles = [...uploadedFiles];
                chatInput.value = '';
                uploadedFiles = [];
                renderFilePreview();
                chatInput.style.height = 'auto';

                if (localUploadedFiles.length > 0) {
                    showTypingWithText('Analyzing your quantum data stream...');
                    let endpoint = '';
                    const file = localUploadedFiles[0];
                    if (file.type.startsWith('image/')) endpoint = '/understand-image';
                    else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                    else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                    else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                    else {
                        removeTyping();
                        finalResponse = "Analysis protocol for this quantum data type is currently unavailable.";
                    }
                    try {
                        if(endpoint) {
                            const fd = new FormData();
                            fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]} quantum data`);
                            fd.append('file', file);
                            const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Quantum data analysis failed.");
                            finalResponse = data.response;
                        }
                    } catch (err) {
                        finalResponse = err.name === 'AbortError' ? '‚ùå Quantum data analysis terminated.' : `‚ùå Quantum data analysis failed: ${err.message}`;
                    }
                } else if (msgText) {
                    showTypingAtNext();
                    try {
                        const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                        const res = await fetch(`${API_BASE_URL}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }),
                            signal
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || "Quantum Nexus connection error.");
                        finalResponse = data.response;
                    } catch (err) {
                        finalResponse = err.name === 'AbortError' ? '‚ùå Quantum Nexus response interrupted.' : `‚ùå An anomaly occurred in the Quantum Nexus: ${err.message}`;
                    }
                }

                removeTyping();
                if (finalResponse) {
                    await startTypewriter(finalResponse);
                }

                stopButton.replaceWith(sendBtn);
                currentController = null;
            });

            // --- Theme Cycling (Now cycling through Quantum Nebula variations) ---
            const themeVariations = [
                { /* Quantum Nebula Default */
                    '--primary-color': '#6a059b', '--secondary-color': '#0d8eff', '--accent-color': '#f062ff',
                    '--text-color': '#e0f2f7', '--background-dark': '#020015', '--background-light': '#0d012e',
                    '--glass-base': 'rgba(13, 1, 46, 0.85)', '--glass-border-glow': 'rgba(106, 5, 155, 0.4)',
                    '--user-bubble-gradient': 'linear-gradient(145deg, #0d8eff, #6a059b)',
                    '--ai-bubble-gradient': 'linear-gradient(145deg, #0d012e, #1f054a)',
                    '--code-border': '#f062ff', '--code-text-glow': '#0d8eff',
                    '--button-gradient-primary': 'linear-gradient(90deg, #f062ff, #6a059b)',
                    '--button-gradient-hover': 'linear-gradient(90deg, #6a059b, #0d8eff)',
                    '--header-text-gradient': 'linear-gradient(90deg, #e0f2f7, #f062ff, #0d8eff)',
                    '--quantum-core-base': 'radial-gradient(circle, #f062ff 0%, #6a059b 40%, rgba(13, 1, 46, 0.9) 100%)',
                    '--quantum-core-speaking-glow': '0 0 25px #f062ff, 0 0 50px #0d8eff, 0 0 70px rgba(255, 255, 255, 0.5)',
                },
                { /* Quantum Nebula - Verdant Shift */
                    '--primary-color': '#008000', /* Dark Green */
                    '--secondary-color': '#39ff14', /* Electric Green */
                    '--accent-color': '#00ffff', /* Cyan */
                    '--text-color': '#e0f7e0',
                    '--background-dark': '#011005',
                    '--background-light': '#0a200f',
                    '--glass-base': 'rgba(10, 30, 15, 0.85)', '--glass-border-glow': 'rgba(0, 128, 0, 0.4)',
                    '--user-bubble-gradient': 'linear-gradient(145deg, #39ff14, #008000)',
                    '--ai-bubble-gradient': 'linear-gradient(145deg, #0a200f, #15351a)',
                    '--code-border': '#00ffff', '--code-text-glow': '#39ff14',
                    '--button-gradient-primary': 'linear-gradient(90deg, #00ffff, #008000)',
                    '--button-gradient-hover': 'linear-gradient(90deg, #008000, #39ff14)',
                    '--header-text-gradient': 'linear-gradient(90deg, #e0f7e0, #00ffff, #39ff14)',
                    '--quantum-core-base': 'radial-gradient(circle, #00ffff 0%, #008000 40%, rgba(10, 30, 15, 0.9) 100%)',
                    '--quantum-core-speaking-glow': '0 0 25px #00ffff, 0 0 50px #39ff14, 0 0 70px rgba(255, 255, 255, 0.5)',
                },
                { /* Quantum Nebula - Amber Flux */
                    '--primary-color': '#b35f00', /* Dark Orange */
                    '--secondary-color': '#ff9500', /* Bright Orange */
                    '--accent-color': '#ffcc00', /* Gold */
                    '--text-color': '#fffbe0',
                    '--background-dark': '#150a00',
                    '--background-light': '#2e1501',
                    '--glass-base': 'rgba(46, 21, 1, 0.85)', '--glass-border-glow': 'rgba(179, 95, 0, 0.4)',
                    '--user-bubble-gradient': 'linear-gradient(145deg, #ff9500, #b35f00)',
                    '--ai-bubble-gradient': 'linear-gradient(145deg, #2e1501, #4a2705)',
                    '--code-border': '#ffcc00', '--code-text-glow': '#ff9500',
                    '--button-gradient-primary': 'linear-gradient(90deg, #ffcc00, #b35f00)',
                    '--button-gradient-hover': 'linear-gradient(90deg, #b35f00, #ff9500)',
                    '--header-text-gradient': 'linear-gradient(90deg, #fffbe0, #ffcc00, #ff9500)',
                    '--quantum-core-base': 'radial-gradient(circle, #ffcc00 0%, #b35f00 40%, rgba(46, 21, 1, 0.9) 100%)',
                    '--quantum-core-speaking-glow': '0 0 25px #ffcc00, 0 0 50px #ff9500, 0 0 70px rgba(255, 255, 255, 0.5)',
                }
            ];
            let currentThemeIdx = 0;

            function applyTheme(theme) {
                for (const key in theme) {
                    document.documentElement.style.setProperty(key, theme[key]);
                }
            }

            themeBtn.addEventListener('click', () => {
                currentThemeIdx = (currentThemeIdx + 1) % themeVariations.length;
                applyTheme(themeVariations[currentThemeIdx]);
            });

            // Apply default theme on load
            applyTheme(themeVariations[0]);


            let speechRecognition;
            let isCallActive = false;
            let callHistory = [];
            let botIsSpeaking = false;
            let userSaidSomething = false;
            let currentAudio = null;
            let isMuted = false;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = true;
                speechRecognition.interimResults = true;
                speechRecognition.lang = 'en-US';

                speechRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    userSaidSomething = true;
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }

                    let userMsgEl = callConversation.querySelector('.call-msg.user:last-child');
                    if (!userMsgEl || userMsgEl.classList.contains('bot') || userMsgEl.classList.contains('status')) {
                        userMsgEl = document.createElement('div');
                        userMsgEl.className = 'call-msg user';
                        callConversation.appendChild(userMsgEl);
                    }
                    userMsgEl.textContent = finalTranscript || interimTranscript;
                    callConversation.scrollTop = callConversation.scrollHeight;

                    callStatusMessage.textContent = finalTranscript ? 'User Speaking...' : 'User Speaking (listening for final)...';
                    tapToTalk.style.display = 'none';
                };

                speechRecognition.onspeechend = () => {
                    // This event fires when speech is detected and then stops.
                    // It doesn't necessarily mean the final result is ready,
                    // but it's a good cue to check if the user has stopped talking.
                };

                speechRecognition.onend = () => {
                    if (!isCallActive) return;
                    if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                        return;
                    }

                    let finalTranscript = '';
                    const userMsgEl = callConversation.querySelector('.call-msg.user:last-child');
                    if (userMsgEl && userSaidSomething) { // Only take final transcript if user actually spoke
                        finalTranscript = userMsgEl.textContent.trim();
                        // If it was just interim speech that didn't finalize, it might be empty.
                    }
                    userSaidSomething = false; // Reset for next turn

                    if (botIsSpeaking) {
                        // Bot is speaking, its onended handler will restart recognition
                    } else if (finalTranscript) {
                        callHistory.push({ role: 'user', content: finalTranscript });
                        handleCallBotResponse();
                    } else {
                        // No speech detected, restart listening
                        if (isCallActive && !isMuted) {
                            callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
                        }
                    }
                };

                speechRecognition.onerror = (event) => {
                    console.error('Speech recognition error', event.error);
                    if (event.error === 'no-speech' && isCallActive && !isMuted) {
                        userSaidSomething = false;
                        // Speech recognition will auto-stop and then re-start via onend logic, no explicit restart here
                    } else if (event.error === 'network' && isCallActive) {
                        callStatusMessage.textContent = 'Network anomaly detected. Attempting re-initialization...';
                        speechRecognition.stop(); // This will trigger onend
                    } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                        callStatusMessage.textContent = 'Microphone access denied. Please grant permission in your browser settings.';
                        endCall();
                    }
                };
            } else {
                callBtn.style.display = 'none';
                console.warn("Speech Recognition not supported in this browser.");
            }

            function addCallMessage(role, text) {
                const msgEl = document.createElement('div');
                msgEl.className = `call-msg ${role}`;
                msgEl.textContent = text;
                callConversation.appendChild(msgEl);
                callConversation.scrollTop = callConversation.scrollHeight;
            }

            async function handleCallBotResponse() {
                if (!isCallActive) return;
                callStatusMessage.textContent = 'Philadelphia AI is processing quantum data...';
                tapToTalk.style.display = 'none';
                
                try { speechRecognition.stop(); } catch(e) { console.warn("Failed to stop speech recognition:", e); }

                const historyForBot = callHistory.map(m => m);
                const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : "";

                try {
                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: userMessage, history: historyForBot.slice(0, -1), user_id: currentUser?.uid || "user" })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "Quantum Nexus connection error.");
                    const botResponse = data.response;
                    callHistory.push({ role: 'ai', content: botResponse });
                    speakBotResponse(botResponse);
                } catch (err) {
                    const errorMsg = `‚ùå Call anomaly: ${err.message}`;
                    addCallMessage('bot', errorMsg);
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
                    }
                }
            }

            async function speakBotResponse(text) {
                if (!isCallActive) return;

                // --- MODIFIED: Sanitize text for voice-only output (blunt responses) ---
                let spokenText = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1'); // Remove markdown links, keep the text
                spokenText = spokenText.replace(/<img[^>]*>/g, "I've transmitted an image to your quantum display.");
                spokenText = spokenText.replace(/<video[^>]*>/g, "I've transmitted a video sequence to your quantum display.");
                spokenText = spokenText.replace(/<audio[^>]*>/g, "I've transmitted an audio file to your quantum display.");
                spokenText = spokenText.replace(/click here/ig, "view the details in your quantum display");
                spokenText = spokenText.replace(/download/ig, "retrieve it from your quantum display");
                spokenText = spokenText.replace(/```[\s\S]*?```/g, "I've projected a code matrix to your quantum display.");
                spokenText = spokenText.replace(/\[View new version here\]/ig, "You can observe the new configuration in your quantum display.");
                spokenText = spokenText.replace(/\[View here\]/ig, "You can observe it in your quantum display.");
                spokenText = spokenText.replace(/\[Download PDF Report\]/ig, "You can download the quantum synthesis report from your quantum display.");
                spokenText = spokenText.replace(/\[[a-zA-Z0-9\s]+\]\(\S+\)/g, "Please consult your quantum display for further data."); // Catch any other markdown links

                // Add the spoken text to the call conversation UI
                addCallMessage('bot', spokenText);

                botIsSpeaking = true;
                botImageContainer.classList.add('speaking'); // Activates quantum-nexus animation
                callStatusMessage.textContent = 'Philadelphia AI is emitting aural data...';
                tapToTalk.style.display = 'none';

                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ text: spokenText, voice_id: 'elegant' }) // Using 'elegant' voice_id
                    });
                    if (!res.ok) throw new Error(await res.text());
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    currentAudio = audio;
                    audio.onended = audio.onerror = () => {
                        botIsSpeaking = false;
                        botImageContainer.classList.remove('speaking');
                        currentAudio = null;
                        if (isCallActive && !isMuted) {
                            callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Aural reception re-initialization failed after emission:", e);}
                        } else if (isMuted) {
                            callStatusMessage.textContent = 'Microphone Muted.';
                            tapToTalk.style.display = 'none';
                        }
                    };
                    audio.play();
                } catch (err) {
                    console.error("Aural emission failed:", err);
                    botIsSpeaking = false;
                    botImageContainer.classList.remove('speaking');
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Listening (Aural Emission Failed)...';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Aural reception re-initialization failed after emission error:", e);}
                    } else if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                    }
                }
            }

            function stopBotSpeakingAndStartListening() {
                if (!isCallActive || !botIsSpeaking) return;
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                botIsSpeaking = false;
                botImageContainer.classList.remove('speaking');
                if (!isMuted) {
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try {
                        speechRecognition.stop();
                        speechRecognition.start();
                    } catch(e) { console.warn("Could not re-initialize aural reception immediately:", e); }
                } else {
                    callStatusMessage.textContent = 'Microphone Muted.';
                    tapToTalk.style.display = 'none';
                }
                const userMsgEl = callConversation.querySelector('.call-msg.user:last-child');
                if (userMsgEl && userMsgEl.textContent.trim() === '') {
                    userMsgEl.remove();
                }
            }

            callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
            callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);

            callBtn.addEventListener('click', () => {
                if (!SpeechRecognition) {
                    alert("Sorry, your browser doesn't support the Aural Reception protocols needed for this feature.");
                    return;
                }
                isCallActive = true;
                isMuted = false;
                muteCallBtn.classList.remove('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i>';
                callModal.classList.add('active');
                callConversation.innerHTML = '';
                addCallMessage('status', 'Initializing Quantum Link to Philadelphia AI...');
                callStatusMessage.textContent = 'Establishing Quantum Link...';
                tapToTalk.style.display = 'none';
                callHistory = [];
                setTimeout(() => {
                    if (!isCallActive) return;
                    addCallMessage('status', 'Quantum Link Established. Awaiting Aural Input.');
                    callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) { console.error("Aural reception initiation failed", e); callStatusMessage.textContent = 'Microphone anomaly. Check access permissions.'; }
                }, 2000); // Simulate connection delay
            });

            function endCall() {
                isCallActive = false;
                botIsSpeaking = false;
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                callModal.classList.remove('active');
                try { speechRecognition.stop(); } catch(e) {}
                botImageContainer.classList.remove('speaking');
                tapToTalk.style.display = 'none';
                callStatusMessage.textContent = 'Quantum Link Severed.';
            }

            endCallBtn.addEventListener('click', endCall);

            if (muteCallBtn) {
                muteCallBtn.addEventListener('click', () => {
                    isMuted = !isMuted;
                    if (isMuted) {
                        muteCallBtn.classList.add('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i>';
                        speechRecognition.stop();
                        callStatusMessage.textContent = 'Aural Input Suppressed.';
                        tapToTalk.style.display = 'none';
                    } else {
                        muteCallBtn.classList.remove('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i>';
                        if (isCallActive && !botIsSpeaking) {
                            callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Aural reception initiation failed after un-suppression:", e);}
                        } else if (isCallActive && botIsSpeaking) {
                            callStatusMessage.textContent = 'Philadelphia AI is emitting aural data...';
                            tapToTalk.style.display = 'none';
                        }
                    }
                });
            }

            if(chatInput) chatInput.focus();
        });
    </script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
¬† window.dataLayer = window.dataLayer || [];
¬† function gtag(){dataLayer.push(arguments);}
¬† gtag('js', new Date()); 

¬† gtag('config', 'G-J1YTKP10ZX');
</script>
