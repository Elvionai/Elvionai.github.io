<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Philadelphia AI - Command Center</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
    <style>
        :root {
            /* Default "Tech Noir" theme (Command Center) */
            --primary-accent: #00e7ff; /* Cyan for primary highlights */
            --secondary-accent: #aaff00; /* Neon green for secondary highlights/active states */
            --dark-bg: #1a1a2e; /* Deep dark background for panels */
            --mid-bg: #282a4a; /* Slightly lighter for main body */
            --light-bg: #3a3f5f; /* Lighter for hover/active */
            --text-color: #e0e0e0; /* Off-white for general text */
            --subtle-text-color: #a0a0b0; /* Muted grey for secondary text */
            --border-color: #3f4a6f; /* Dark blue-grey for borders */
            --input-bg: #1c1c3a; /* Input field background */

            --ai-bubble-bg: #22223b; /* Darker, solid for AI messages */
            --user-bubble-bg: #333355; /* Slightly lighter, solid for user messages */
            --ai-bubble-shadow: 0 4px 12px rgba(0, 231, 255, 0.1), 0 0 8px rgba(0, 231, 255, 0.05);
            --user-bubble-shadow: 0 4px 12px rgba(170, 255, 0, 0.1), 0 0 8px rgba(170, 255, 0, 0.05);

            --code-bg: #1b1b2a; /* Code block background */
            --code-border: #00e7ff; /* Code border color */
            --code-text: #00fff2; /* Code text color */

            --link-color: #00e7ff; /* Link text color */

            --button-bg: #00e7ff; /* Default button background */
            --button-text: #1a1a2e; /* Default button text color */
            --button-hover-bg: #aaff00; /* Default button hover background */
            --button-hover-text: #1a1a2e; /* Default button hover text color */

            --panel-bg: #1f1f3a; /* Panel background */
            --panel-border: #00e7ff; /* Panel border */
            --panel-shadow: 0 0 25px rgba(0, 231, 255, 0.3), 0 0 10px rgba(0, 231, 255, 0.1);

            --header-text-fill: linear-gradient(90deg, var(--primary-accent), var(--secondary-accent) 40%, #fff 59%, var(--primary-accent) 89%, var(--secondary-accent) 100%);
            --header-text-glow: 0 0 8px var(--primary-accent), 0 0 15px var(--secondary-accent);
            --header-text-anim-glow-1: 0 0 10px var(--primary-accent), 0 0 20px var(--secondary-accent);
            --header-text-anim-glow-2: 0 0 15px var(--primary-accent), 0 0 30px var(--secondary-accent);
        }

        /* Celestial Theme */
        .celestial-theme {
            --primary-accent: #ff00ff;
            --secondary-accent: #8a2be2;
            --dark-bg: #0f001a;
            --mid-bg: #2b003e;
            --light-bg: #580080;
            --text-color: #f0e6ff;
            --subtle-text-color: #d0b0e0;
            --border-color: #800080;
            --input-bg: #2b003e;
            --ai-bubble-bg: #2b003e;
            --user-bubble-bg: #580080;
            --ai-bubble-shadow: 0 4px 12px rgba(255, 0, 255, 0.1), 0 0 8px rgba(255, 0, 255, 0.05);
            --user-bubble-shadow: 0 4px 12px rgba(138, 43, 226, 0.1), 0 0 8px rgba(138, 43, 226, 0.05);
            --code-bg: #2b003e;
            --code-border: #ff00ff;
            --code-text: #ff99ff;
            --link-color: #ff66ff;
            --button-bg: #ff00ff;
            --button-text: #0f001a;
            --button-hover-bg: #8a2be2;
            --button-hover-text: #0f001a;
            --panel-bg: #2b003e;
            --panel-border: #ff00ff;
            --panel-shadow: 0 0 25px rgba(255, 0, 255, 0.3), 0 0 10px rgba(255, 0, 255, 0.1);
            --header-text-fill: linear-gradient(90deg, var(--primary-accent), var(--secondary-accent) 40%, #fff 59%, var(--primary-accent) 89%, var(--secondary-accent) 100%);
            --header-text-glow: 0 0 10px var(--primary-accent), 0 0 20px var(--secondary-accent);
            --header-text-anim-glow-1: 0 0 15px var(--primary-accent), 0 0 25px var(--secondary-accent);
            --header-text-anim-glow-2: 0 0 20px var(--primary-accent), 0 0 35px var(--secondary-accent);
        }

        /* Starlight Theme */
        .starlight-theme {
            --primary-accent: #a6faff;
            --secondary-accent: #00c3ff;
            --dark-bg: #030010;
            --mid-bg: #100c25;
            --light-bg: #1c153f;
            --text-color: #f0faff;
            --subtle-text-color: #c0e0e0;
            --border-color: #3f337f;
            --input-bg: #100c25;
            --ai-bubble-bg: #100c25;
            --user-bubble-bg: #1c153f;
            --ai-bubble-shadow: 0 4px 12px rgba(166, 250, 255, 0.1), 0 0 8px rgba(166, 250, 255, 0.05);
            --user-bubble-shadow: 0 4px 12px rgba(0, 195, 255, 0.1), 0 0 8px rgba(0, 195, 255, 0.05);
            --code-bg: #100c25;
            --code-border: #a6faff;
            --code-text: #a6faff;
            --link-color: #a6faff;
            --button-bg: #a6faff;
            --button-text: #030010;
            --button-hover-bg: #00c3ff;
            --button-hover-text: #030010;
            --panel-bg: #100c25;
            --panel-border: #a6faff;
            --panel-shadow: 0 0 25px rgba(166, 250, 255, 0.3), 0 0 10px rgba(166, 250, 255, 0.1);
            --header-text-fill: linear-gradient(90deg, var(--primary-accent), var(--secondary-accent) 40%, #fff 59%, var(--primary-accent) 89%, var(--secondary-accent) 100%);
            --header-text-glow: 0 0 8px var(--primary-accent), 0 0 15px var(--secondary-accent);
            --header-text-anim-glow-1: 0 0 10px var(--primary-accent), 0 0 20px var(--secondary-accent);
            --header-text-anim-glow-2: 0 0 15px var(--primary-accent), 0 0 30px var(--secondary-accent);
        }

        /* Midnight Theme */
        .midnight-theme {
            --primary-accent: #3391ff;
            --secondary-accent: #007bff;
            --dark-bg: #121212;
            --mid-bg: #1e1e1e;
            --light-bg: #282828;
            --text-color: #f1f1f1;
            --subtle-text-color: #a8a8a8;
            --border-color: #444;
            --input-bg: #282828;
            --ai-bubble-bg: #1e1e1e;
            --user-bubble-bg: #282828;
            --ai-bubble-shadow: 0 4px 12px rgba(51, 145, 255, 0.1), 0 0 8px rgba(51, 145, 255, 0.05);
            --user-bubble-shadow: 0 4px 12px rgba(0, 123, 255, 0.1), 0 0 8px rgba(0, 123, 255, 0.05);
            --code-bg: #1e1e1e;
            --code-border: #3391ff;
            --code-text: #e0e0e0;
            --link-color: #3391ff;
            --button-bg: #3391ff;
            --button-text: #121212;
            --button-hover-bg: #007bff;
            --button-hover-text: #121212;
            --panel-bg: #1e1e1e;
            --panel-border: #3391ff;
            --panel-shadow: 0 0 25px rgba(51, 145, 255, 0.3), 0 0 10px rgba(51, 145, 255, 0.1);
            --header-text-fill: linear-gradient(90deg, var(--primary-accent), var(--secondary-accent) 40%, #fff 59%, var(--primary-accent) 89%, var(--secondary-accent) 100%);
            --header-text-glow: 0 0 8px var(--primary-accent), 0 0 15px var(--secondary-accent);
            --header-text-anim-glow-1: 0 0 10px var(--primary-accent), 0 0 20px var(--secondary-accent);
            --header-text-anim-glow-2: 0 0 15px var(--primary-accent), 0 0 30px var(--secondary-accent);
        }

        /* Forest Theme */
        .forest-theme {
            --primary-accent: #99cc99;
            --secondary-accent: #669966;
            --dark-bg: #2a362a;
            --mid-bg: #3a473a;
            --light-bg: #4a5a4a;
            --text-color: #e0ffe0;
            --subtle-text-color: #aaccbb;
            --border-color: #5a6b5a;
            --input-bg: #3a473a;
            --ai-bubble-bg: #3a473a;
            --user-bubble-bg: #4a5a4a;
            --ai-bubble-shadow: 0 4px 12px rgba(153, 204, 153, 0.1), 0 0 8px rgba(153, 204, 153, 0.05);
            --user-bubble-shadow: 0 4px 12px rgba(102, 153, 102, 0.1), 0 0 8px rgba(102, 153, 102, 0.05);
            --code-bg: #3a473a;
            --code-border: #99cc99;
            --code-text: #c0f0c0;
            --link-color: #99cc99;
            --button-bg: #99cc99;
            --button-text: #2a362a;
            --button-hover-bg: #669966;
            --button-hover-text: #2a362a;
            --panel-bg: #3a473a;
            --panel-border: #99cc99;
            --panel-shadow: 0 0 25px rgba(153, 204, 153, 0.3), 0 0 10px rgba(153, 204, 153, 0.1);
            --header-text-fill: linear-gradient(90deg, var(--primary-accent), var(--secondary-accent) 40%, #fff 59%, var(--primary-accent) 89%, var(--secondary-accent) 100%);
            --header-text-glow: 0 0 8px var(--primary-accent), 0 0 15px var(--secondary-accent);
            --header-text-anim-glow-1: 0 0 10px var(--primary-accent), 0 0 20px var(--secondary-accent);
            --header-text-anim-glow-2: 0 0 15px var(--primary-accent), 0 0 30px var(--secondary-accent);
        }

        /* Volcano Theme */
        .volcano-theme {
            --primary-accent: #ff7043;
            --secondary-accent: #bf360c;
            --dark-bg: #3e1a0b;
            --mid-bg: #4e2211;
            --light-bg: #5e2a1b;
            --text-color: #fff0e0;
            --subtle-text-color: #e0b0a0;
            --border-color: #6e3a2c;
            --input-bg: #4e2211;
            --ai-bubble-bg: #4e2211;
            --user-bubble-bg: #5e2a1b;
            --ai-bubble-shadow: 0 4px 12px rgba(255, 112, 67, 0.1), 0 0 8px rgba(255, 112, 67, 0.05);
            --user-bubble-shadow: 0 4px 12px rgba(191, 54, 12, 0.1), 0 0 8px rgba(191, 54, 12, 0.05);
            --code-bg: #4e2211;
            --code-border: #ff7043;
            --code-text: #ffd0a0;
            --link-color: #ff7043;
            --button-bg: #ff7043;
            --button-text: #3e1a0b;
            --button-hover-bg: #bf360c;
            --button-hover-text: #3e1a0b;
            --panel-bg: #4e2211;
            --panel-border: #ff7043;
            --panel-shadow: 0 0 25px rgba(255, 112, 67, 0.3), 0 0 10px rgba(255, 112, 67, 0.1);
            --header-text-fill: linear-gradient(90deg, var(--primary-accent), var(--secondary-accent) 40%, #fff 59%, var(--primary-accent) 89%, var(--secondary-accent) 100%);
            --header-text-glow: 0 0 8px var(--primary-accent), 0 0 15px var(--secondary-accent);
            --header-text-anim-glow-1: 0 0 10px var(--primary-accent), 0 0 20px var(--secondary-accent);
            --header-text-anim-glow-2: 0 0 15px var(--primary-accent), 0 0 30px var(--primary-accent);
        }


        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background: var(--mid-bg); /* Mid-tone background for overall body */
            font-family: 'Roboto','Inter',system-ui,-apple-system,Segoe UI,sans-serif;
            display: grid;
            grid-template-columns: 250px 1fr 0px; /* Left Nav fixed, Chat flexible, Right Panel initially closed */
            grid-template-rows: 1fr;
            box-sizing: border-box;
            overflow: hidden; /* Control overall overflow */
            transition: background-color 0.5s ease, color 0.5s ease, grid-template-columns 0.3s ease-in-out;
        }

        body.right-panel-open {
            grid-template-columns: 250px 1fr 380px; /* Left Nav, Chat, Right Panel open */
        }

        #appContainer {
            display: contents; /* Allow children to flow into body's grid areas */
        }

        /* --- Left Navigation Panel --- */
        #leftNav {
            grid-column: 1 / 2;
            background: var(--dark-bg);
            border-right: 1px solid var(--border-color);
            padding: 20px 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 100;
        }

        .header-logo {
            font-family: 'Orbitron',sans-serif;
            font-size: 1.4em;
            font-weight: 700;
            text-align: center;
            letter-spacing: .27px;
            white-space:nowrap;
            background: var(--header-text-fill);
            background-size: 250% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: neonglow 4.2s ease-in-out infinite alternate;
            text-shadow: var(--header-text-glow);
            user-select: none;
            margin-bottom: 25px;
            cursor: pointer;
        }
        @keyframes neonglow {
            0% { text-shadow: var(--header-text-anim-glow-1);}
            100% { text-shadow: var(--header-text-anim-glow-2);}
        }

        .profile-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 20px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .profile-section img {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid var(--primary-accent);
            box-shadow: 0 0 15px rgba(0, 231, 255, 0.4);
            margin-bottom: 10px;
            cursor: pointer;
        }
        .profile-section .username {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            font-weight: 700;
            color: var(--primary-accent);
            text-shadow: 0 0 8px rgba(0, 231, 255, 0.4);
        }
        .profile-section .email {
            font-size: 0.85em;
            color: var(--subtle-text-color);
            margin-top: 5px;
        }

        .nav-link-group h3 {
            color: var(--secondary-accent);
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 20px;
            margin-bottom: 10px;
            padding-left: 5px;
        }
        .nav-link-group a, .nav-link-group button {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 10px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.95em;
            border-radius: 8px;
            transition: background-color 0.2s ease, color 0.2s ease;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
        }
        .nav-link-group a:hover, .nav-link-group button:hover, .nav-link-group a.active, .nav-link-group button.active {
            background: var(--light-bg);
            color: var(--primary-accent);
        }
        .nav-link-group a i, .nav-link-group button i {
            width: 20px;
            text-align: center;
            color: var(--primary-accent);
        }
        .nav-link-group a:hover i, .nav-link-group button:hover i, .nav-link-group a.active i, .nav-link-group button.active i {
            color: var(--secondary-accent);
        }

        /* --- Central Chat Area --- */
        #chatArea {
            grid-column: 2 / 3;
            display: flex;
            flex-direction: column;
            background: var(--mid-bg); /* Main content background */
            position: relative;
            overflow: hidden;
        }

        .site-heading-chat {
            font-family: 'Orbitron',sans-serif;
            font-size: 1.2em;
            font-weight: 700;
            text-align: center;
            padding: 15px 0;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            color: var(--primary-accent);
            text-shadow: 0 0 5px var(--primary-accent);
            position: sticky;
            top: 0;
            z-index: 50;
        }

        .chat-box {
            flex: 1 1 0px;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Space between message cards */
            scroll-behavior: smooth;
            width: 100%;
            max-width: 900px; /* Restrict max width of chat messages for readability */
            margin: 0 auto; /* Center chat content */
            box-sizing: border-box;
        }

        #typing-status {
            display: none;
            padding: 10px 20px;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            box-sizing: border-box;
            flex-shrink: 0;
            min-height: 20px;
        }

        .chat-message {
            display: flex;
            align-items: flex-start;
            animation: fadeInScaleUp 0.3s ease-out;
        }

        @keyframes fadeInScaleUp {
            from { opacity: 0; transform: translateY(15px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .chat-message .msg {
            font-size: 0.98em;
            line-height: 1.6;
            max-width: 75%; /* Messages don't fill entire width */
            padding: 12px 18px;
            border-radius: 12px;
            word-break: break-word;
            white-space: pre-wrap;
            overflow-x: auto;
            background: var(--ai-bubble-bg);
            color: var(--text-color);
            box-shadow: var(--ai-bubble-shadow);
            border: 1px solid var(--border-color);
            transition: background 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
        }
        .chat-message.user {
            justify-content: flex-end;
        }
        .chat-message.user .msg {
            background: var(--user-bubble-bg);
            box-shadow: var(--user-bubble-shadow);
            margin-left: auto;
            margin-right: 0;
        }

        .typing-bubble {
            display: inline-flex;
            align-items: center;
            height: 30px;
            padding: 5px 15px;
            border-radius: 15px;
            background: var(--dark-bg);
            box-shadow: 0 2px 10px rgba(0, 231, 255, 0.1);
            border: 1px solid var(--border-color);
            color: var(--subtle-text-color);
        }
        .dot-anim {
            display:inline-block;
            width: 8px;
            height: 8px;
            margin:0 3px;
            background: var(--primary-accent);
            border-radius: 50%;
            opacity: 0.85;
            animation: typing-blink 1.4s infinite both;
            box-shadow: 0 0 6px var(--primary-accent);
        }
        .dot-anim:nth-child(2){animation-delay:.3s;}
        .dot-anim:nth-child(3){animation-delay:.6s;}
        @keyframes typing-blink {
            0%,100% {opacity:.25; transform: scale(0.8);}
            25% {opacity:.95; transform: scale(1.1);}
            50% {opacity:1; transform: scale(1.2);}
            75% {opacity:.65; transform: scale(1);}
        }

        /* Input Bar (Fixed at bottom of chat area) */
        .chat-input-bar {
            width: 100%;
            max-width: 900px; /* Matches chat content width */
            margin: 0 auto;
            background: var(--dark-bg);
            border-top: 1px solid var(--border-color);
            padding: 12px 20px;
            display: flex;
            align-items: flex-end; /* Align to bottom for textarea growth */
            gap: 10px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
            z-index: 50;
            flex-shrink: 0; /* Prevents shrinking */
            box-sizing: border-box;
        }
        .chat-input-bar textarea {
            flex: 1;
            min-height: 40px;
            max-height: 120px;
            resize: none;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-color);
            padding: 10px 12px;
            font-size: 0.95em;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .chat-input-bar textarea:focus {
            border-color: var(--primary-accent);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 5px rgba(0, 231, 255, 0.3);
        }
        .chat-input-bar button, .chat-input-bar label {
            background: none;
            border: none;
            color: var(--primary-accent);
            font-size: 1.1em;
            cursor: pointer;
            width: 38px;
            height: 38px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, color 0.2s ease;
            flex-shrink: 0;
        }
        .chat-input-bar button:hover, .chat-input-bar label:hover {
            background: var(--light-bg);
            color: var(--secondary-accent);
        }
        #sendBtn {
            background: var(--button-bg);
            color: var(--button-text);
            box-shadow: 0 2px 8px rgba(0, 231, 255, 0.2);
        }
        #sendBtn:hover {
            background: var(--button-hover-bg);
            color: var(--button-hover-text);
            box-shadow: 0 2px 10px rgba(170, 255, 0, 0.3);
        }
        #stopBtn {
            background: #d9534f; /* Red */
            color: white;
            box-shadow: 0 2px 8px rgba(217, 83, 79, 0.3);
        }
        #stopBtn:hover {
            background: #c9302c; /* Darker Red */
        }


        /* --- Right Tool Panel --- */
        #rightToolPanel {
            grid-column: 3 / 4;
            background: var(--dark-bg);
            border-left: 1px solid var(--border-color);
            padding: 20px 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            z-index: 100;
            transition: transform 0.3s ease-in-out;
            transform: translateX(100%); /* Start hidden */
            box-sizing: border-box;
        }
        body.right-panel-open #rightToolPanel {
            transform: translateX(0); /* Slide in */
        }
        #rightToolPanel .panel-close-btn {
            position: sticky;
            top: 0;
            align-self: flex-end;
            margin-bottom: 15px;
            background: var(--light-bg);
            border: none;
            border-radius: 50%;
            color: var(--primary-accent);
            font-size: 1.1em;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 0 5px rgba(0, 231, 255, 0.2);
            z-index: 10;
        }
        #rightToolPanel .panel-close-btn:hover {
            background: var(--secondary-accent);
            color: var(--button-text);
            transform: scale(1.1);
        }

        #toolPanelContent h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-accent);
            font-size: 1.2em;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 231, 255, 0.4);
        }
        #toolPanelContent h3 {
            color: var(--secondary-accent);
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-top: 15px;
            margin-bottom: 8px;
            padding-left: 5px;
        }
        #toolPanelContent hr {
            border-color: var(--border-color);
            margin: 15px 0;
        }
        #toolPanelContent .tool-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 10px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9em;
            border-radius: 8px;
            transition: background-color 0.2s ease, color 0.2s ease;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
        }
        #toolPanelContent .tool-link:hover {
            background: var(--light-bg);
            color: var(--primary-accent);
        }
        #toolPanelContent .tool-link i {
            width: 20px;
            text-align: center;
            color: var(--primary-accent);
        }
        #toolPanelContent .tool-link:hover i {
            color: var(--secondary-accent);
        }


        /* --- Common Styles for Overlays/Modals (adapted) --- */
        .overlay-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.8); /* Darker overlay */
            z-index: 2000; /* Higher z-index */
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }
        .overlay-modal.active {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 25px;
            box-shadow: var(--panel-shadow);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(20px) scale(0.95);
            opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            position: relative;
        }
        .overlay-modal.active .modal-content {
            transform: translateY(0) scale(1);
            opacity: 1;
        }

        .modal-header {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-accent);
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 8px rgba(0, 231, 255, 0.4);
        }

        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--light-bg);
            border: none;
            border-radius: 50%;
            color: var(--primary-accent);
            font-size: 1.2em;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .modal-close-btn:hover {
            background: var(--secondary-accent);
            color: var(--button-text);
            transform: scale(1.1);
        }

        /* --- Specific Modal Content Styling --- */
        #profileModal .profile-section img { cursor: default; } /* Override hover on profile image in modal */
        #profileModal .edit-form label {
            display: block;
            margin-top: 15px;
            font-size: 0.95em;
            color: var(--primary-accent);
        }
        #profileModal .edit-form input, #profileModal .edit-form textarea, #profileModal .edit-form select {
            width: 100%;
            padding: 10px 12px;
            margin-top: 8px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9em;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        #profileModal .edit-form input:focus, #profileModal .edit-form textarea:focus, #profileModal .edit-form select:focus {
            border-color: var(--primary-accent);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 5px rgba(0, 231, 255, 0.3);
        }
        #profileModal .edit-form textarea { min-height: 80px; resize: vertical; }

        #profileModal #chatsList .chat-list-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            border-radius: 6px;
            background: var(--dark-bg);
            border: 1px solid transparent;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        #profileModal #chatsList .chat-list-item.active-chat {
            background: var(--light-bg);
            border-color: var(--primary-accent);
        }
        #profileModal #chatsList .chat-list-item-title {
            flex: 1;
            padding: 8px 10px;
            cursor: pointer;
            color: var(--text-color);
            font-size: 0.9em;
            transition: color 0.2s ease;
        }
        #profileModal #chatsList .chat-list-item:hover {
             background: var(--light-bg);
        }
        #profileModal #chatsList .chat-list-item-title:hover {
            color: var(--primary-accent);
        }
        #profileModal #chatsList button {
            background: none;
            border: none;
            color: var(--subtle-text-color);
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: color 0.2s ease, background 0.2s ease;
        }
        #profileModal #chatsList button:hover {
            background: var(--light-bg);
            color: var(--primary-accent);
        }
        #profileModal #chatsList .fa-trash:hover {
            color: #d9534f;
        }

        #profileModal .submit-btn {
            background: var(--button-bg);
            color: var(--button-text);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
            margin-top: 20px;
            width: 100%;
            box-shadow: 0 2px 8px rgba(0, 231, 255, 0.2);
            transition: background 0.2s ease, color 0.2s ease;
        }
        #profileModal .submit-btn:hover {
            background: var(--button-hover-bg);
            color: var(--button-hover-text);
            box-shadow: 0 2px 10px rgba(170, 255, 0, 0.3);
        }

        .status-message {
            text-align: center;
            padding: 10px 0;
            color: var(--primary-accent);
            font-size: 0.9em;
            margin-top: 10px;
        }

        /* --- Code Block Styling --- */
        pre, code {
            font-family: 'JetBrains Mono','Fira Mono','Menlo',monospace;
            font-size: 0.9em;
            background: var(--code-bg);
            border-radius: 8px;
            border: 1px solid var(--code-border);
            color: var(--code-text);
            box-shadow: 0 0 10px rgba(0, 231, 255, 0.2), inset 0 0 8px rgba(0, 231, 255, 0.1);
            transition: background 0.3s, border-color 0.3s, color 0.3s;
        }
        pre {
            overflow-x: auto;
            padding: 1em 1.2em;
            margin: 1em 0;
            position: relative;
        }
        pre:before {
            content: "CODE";
            color: var(--code-text);
            font-size: 0.75em;
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 5px;
            right: 15px;
            opacity: 0.3;
            letter-spacing: 0.1em;
            pointer-events: none;
        }
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 10px;
            z-index: 3;
            border-radius: 6px;
            border: none;
            padding: 3px 10px;
            background: var(--button-bg);
            color: var(--button-text);
            font-size: 0.85em;
            font-family: 'Inter';
            font-weight: bold;
            box-shadow: 0 1px 5px rgba(0, 231, 255, 0.3);
            transition: background .15s, color .15s;
            cursor: pointer;
            outline: none;
        }
        .copy-btn:hover {
            background: var(--button-hover-bg);
            color: var(--button-hover-text);
            box-shadow: 0 1px 7px rgba(170, 255, 0, 0.4);
        }
        .inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn {
            padding: 5px 10px;
            border-radius: 6px;
            border: none;
            background: var(--dark-bg);
            color: var(--primary-accent);
            font-family: 'Inter', Arial, sans-serif;
            font-size: 0.85em;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-top: 6px;
            margin-right: 3px;
            cursor: pointer;
            box-shadow: 0 1px 5px rgba(0, 231, 255, 0.1);
            transition: background 0.14s, color 0.13s;
        }
        .inline-copy-btn:hover, .inline-share-btn:hover, .regen-btn:hover, .inline-edit-btn:hover {
            background: var(--light-bg);
            color: var(--secondary-accent);
        }

        /* --- File Attachments & Previews --- */
        .file-attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }
        .chat-media-preview {
            max-width: 100%;
            max-height: 200px; /* Smaller previews for command center aesthetic */
            border-radius: 8px;
            display: block;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .chat-message.ai .msg img.chat-media-preview {
            cursor: zoom-in;
        }
        .audio-preview-thumb {
            width: 90%;
            min-height: 35px;
            border-radius: 8px;
        }
        .file-link, .file-placeholder {
            display: inline-flex;
            align-items: center;
            padding: 8px 10px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--primary-accent);
            text-decoration: none;
            font-size: 0.85em;
            font-weight: bold;
            gap: 6px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
        }

        #filePreview {
            display: none;
            background: var(--dark-bg);
            border-radius: 8px;
            color: var(--text-color);
            box-shadow: 0 0 15px rgba(0,0,0,0.4);
            max-width: 400px;
            width: 90vw;
            padding: 10px 12px;
            position: fixed;
            bottom: 60px; /* Above the input bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            border: 1px solid var(--border-color);
        }
        #filePreview img, #filePreview video, #filePreview audio {
            max-width: 48px;
            max-height: 36px;
            border-radius: 4px;
            margin-right: 6px;
            vertical-align: middle;
        }
        #filePreview .remove-file-btn {
            color: white;
            background: #d9534f;
            border-radius: 50%;
            padding: 2px 5px;
            cursor: pointer;
            font-size: 1.1em;
            margin-left: 8px;
            min-width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        #filePreview .remove-file-btn:hover {
            background: #c9302c;
            transform: scale(1.1);
        }


        /* --- AI Image Preview (Floating) --- */
        #ai-image-preview {
            display: none;
            position: fixed;
            z-index: 1500;
            right: 20px;
            bottom: 80px; /* Above file preview */
            max-width: 280px;
            background: var(--dark-bg);
            padding: 12px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.4), 0 0 10px var(--primary-accent);
            border: 1px solid var(--primary-accent);
        }
        #ai-image-preview img {
            max-width: 250px;
            max-height: 250px;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
            border: 1px solid var(--border-color);
        }
        #ai-image-preview #ai-image-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--light-bg);
            border: none;
            border-radius: 50%;
            color: var(--primary-accent);
            font-size: 1em;
            cursor: pointer;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #ai-image-preview #ai-image-close:hover {
            background: #d9534f;
            color: white;
            transform: scale(1.1);
        }
        #ai-image-preview #ai-image-dl {
            margin-top: 10px;
            padding: 8px 15px;
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 6px;
            box-shadow: 0 1px 5px rgba(0, 231, 255, 0.3);
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            display: block;
            width: fit-content;
            margin: 10px auto 0 auto;
        }
        #ai-image-preview #ai-image-dl:hover {
            background: var(--button-hover-bg);
            color: var(--button-hover-text);
        }


        /* --- Lightbox --- */
        #lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.9);
            z-index: 5000;
            justify-content: center;
            align-items: center;
        }
        #lightbox.active {
            display: flex;
        }
        #lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            border: 2px solid var(--primary-accent);
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 231, 255, 0.8);
        }

        /* --- Call Modal (Updated to Command Center Aesthetic) --- */
        #callModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--dark-bg);
            z-index: 4000;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        #callModal.active {
            display: flex;
            opacity: 1;
        }

        #callHeader {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-accent);
            font-size: 1.5em;
            text-shadow: 0 0 10px var(--primary-accent), 0 0 20px var(--secondary-accent);
            margin-bottom: 25px;
            margin-top: 20px;
        }

        #botImageContainer {
            margin-top: 25px;
            position: relative;
        }
        #botImageContainer img {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 3px solid var(--primary-accent);
            box-shadow: 0 0 25px var(--primary-accent);
            transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        @keyframes head-nod {
            0% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
            100% { transform: translateY(0); }
        }
        @keyframes glow-spread {
            0% { box-shadow: 0 0 10px var(--primary-accent); opacity: 0.7; }
            50% { box-shadow: 0 0 30px var(--primary-accent), 0 0 50px var(--secondary-accent); opacity: 1; }
            100% { box-shadow: 0 0 10px var(--primary-accent); opacity: 0.7; }
        }
        #botImageContainer.speaking img {
            border-color: var(--secondary-accent);
            box-shadow: 0 0 25px var(--secondary-accent);
            transform: scale(1.05);
            animation: head-nod 1.2s infinite ease-in-out;
        }

        #botSpeakingIndicator {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 160px;
            height: 160px;
            border-radius: 50%;
            border: 4px solid transparent;
            box-shadow: 0 0 20px var(--primary-accent);
            display: none;
            z-index: -1;
        }
        #botImageContainer.speaking #botSpeakingIndicator {
            box-shadow: 0 0 30px var(--secondary-accent);
            border-color: var(--secondary-accent);
            display: block;
            animation: glow-spread 1.7s infinite ease-in-out;
        }

        #callStatusMessage {
            color: var(--primary-accent);
            font-size: 1.1em;
            margin-top: 15px;
            height: 30px;
            text-align: center;
            font-style: italic;
            text-shadow: 0 0 6px rgba(0, 231, 255, 0.4);
        }

        #tapToTalk {
            color: var(--secondary-accent);
            font-size: 1.2em;
            margin-top: 10px;
            text-shadow: 0 0 8px var(--secondary-accent);
            animation: neon-pulse 1.5s infinite alternate;
            display: none;
            cursor: pointer;
        }
        @keyframes neon-pulse {
            from { opacity: 0.7; transform: scale(1.0); }
            to { opacity: 1.0; transform: scale(1.02); }
        }

        #callConversation {
            flex-grow: 1;
            width: 100%;
            max-width: 600px;
            overflow-y: auto;
            margin: 20px 0;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            background: var(--mid-bg);
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .call-msg {
            padding: 10px 15px;
            border-radius: 8px;
            line-height: 1.5;
            word-break: break-word;
            opacity: 0;
            animation: fadeInMessage 0.3s ease-out forwards;
        }
        @keyframes fadeInMessage {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .call-msg.user {
            background: var(--user-bubble-bg);
            color: var(--text-color);
            text-align: right;
            margin-left: auto;
            max-width: 80%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .call-msg.bot {
            background: var(--ai-bubble-bg);
            color: var(--text-color);
            margin-right: auto;
            max-width: 80%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .call-msg.status {
            text-align: center;
            color: var(--subtle-text-color);
            font-style: italic;
            background: none;
            box-shadow: none;
            border: none;
        }

        #callControls {
            display: flex;
            gap: 20px;
            padding-bottom: 20px;
            margin-top: auto;
        }
        #endCallBtn, #muteCallBtn {
            background: #d9534f; /* Red */
            color: white;
            font-size: 1.2em;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(217, 83, 79, 0.4);
            transition: background .1s, box-shadow .1s;
        }
        #endCallBtn:hover {
            background: #c9302c;
            box-shadow: 0 0 15px rgba(201, 48, 44, 0.6);
        }
        #muteCallBtn {
            background: var(--button-bg);
            box-shadow: 0 0 10px rgba(0, 231, 255, 0.4);
            color: var(--button-text);
        }
        #muteCallBtn:hover {
            background: var(--button-hover-bg);
            box-shadow: 0 0 15px rgba(170, 255, 0, 0.6);
            color: var(--button-hover-text);
        }
        #muteCallBtn.muted {
            background: var(--input-bg);
            color: var(--subtle-text-color);
            box-shadow: 0 0 8px rgba(0,0,0,0.3);
        }
        #muteCallBtn.muted:hover {
            background: var(--light-bg);
            color: var(--text-color);
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 231, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-accent);
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1024px) {
            body {
                grid-template-columns: 80px 1fr 0px; /* Smaller left nav on medium screens */
            }
            body.right-panel-open {
                grid-template-columns: 80px 1fr 300px;
            }
            #leftNav {
                padding: 15px 10px;
            }
            .profile-section img {
                width: 60px;
                height: 60px;
            }
            .profile-section .username, .profile-section .email {
                display: none; /* Hide text to save space */
            }
            .header-logo {
                font-size: 1em;
                margin-bottom: 15px;
            }
            .nav-link-group a, .nav-link-group button {
                padding: 8px 5px;
                font-size: 0.8em;
                justify-content: center;
            }
            .nav-link-group a span, .nav-link-group button span {
                display: none; /* Hide text, only show icon */
            }
            #rightToolPanel {
                padding: 15px 10px;
            }
            #rightToolPanel.right-panel-open {
                width: 300px;
            }
        }

        @media (max-width: 768px) {
            body {
                grid-template-columns: 0px 1fr 0px; /* Hide both sidebars by default */
            }
            #leftNav, #rightToolPanel {
                position: fixed;
                top: 0;
                height: 100vh;
                width: 250px; /* Fixed width when open */
                z-index: 1000;
                transition: transform 0.3s ease-in-out;
            }
            #leftNav {
                left: 0;
                transform: translateX(-100%);
                box-shadow: 5px 0 15px rgba(0,0,0,0.5);
            }
            body.left-nav-open #leftNav {
                transform: translateX(0);
            }
            #rightToolPanel {
                right: 0;
                transform: translateX(100%);
                box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            }
            body.right-panel-open #rightToolPanel {
                transform: translateX(0);
            }
            #chatArea {
                grid-column: 1 / -1; /* Chat area takes full width */
            }
            .site-heading-chat {
                display: none; /* Hide chat heading on small screens */
            }
            .chat-input-bar {
                border-radius: 10px 10px 0 0;
                width: 100vw; /* Take full width */
                max-width: 100vw;
            }
            .chat-message .msg, .chat-message.user .msg {
                max-width: 90%; /* Allow messages to be wider */
            }
        }
        @media (max-width: 480px) {
            #leftNav, #rightToolPanel {
                width: 90vw; /* Wider sidebars when open */
            }
            .chat-input-bar button, .chat-input-bar label {
                width: 32px;
                height: 32px;
                font-size: 1em;
            }
            .chat-input-bar textarea {
                padding: 8px 10px;
                min-height: 35px;
            }
        }

    </style>
</head>
<body>
    <div id="appContainer">
        <!-- Left Navigation Panel -->
        <nav id="leftNav">
            <h1 class="header-logo">Philadelphia AI</h1>

            <div class="profile-section" id="openProfileModalBtn">
                <img id="profilePicNav" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profileNavUser">User</div>
                <div class="email" id="profileNavEmail">email@example.com</div>
            </div>

            <div class="nav-link-group">
                <h3>Chats</h3>
                <div id="chatsListNav" style="max-height: 200px; overflow-y: auto; padding-right: 5px;">
                    <div class="spinner" style="margin: 20px auto; display: block;"></div>
                </div>
                <button id="newChatBtnNav"><i class="fa-solid fa-plus"></i> <span>New Chat</span></button>
            </div>

            <div class="nav-link-group" style="margin-top: auto;">
                <h3>System</h3>
                <button id="openLinksModalBtn"><i class="fa-solid fa-link"></i> <span>Links & Info</span></button>
                <button id="toggleRightPanelBtn"><i class="fa-solid fa-wrench"></i> <span>AI Tools</span></button>
                <button id="themeBtnNav"><i class="fa-solid fa-palette"></i> <span>Change Theme</span></button>
                <button id="logoutBtnNav"><i class="fa-solid fa-right-from-bracket"></i> <span>Logout</span></button>
            </div>
        </nav>

        <!-- Central Chat Area -->
        <main id="chatArea">
            <h2 class="site-heading-chat">Philadelphia AI Command Center</h2>
            <div class="chat-box" id="chatBox"></div>
            <div id="typing-status" class="chat-message ai" style="display: none;"></div>
            <form class="chat-input-bar" id="chatForm" autocomplete="off">
                <button type="button" id="emojiBtn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>
                <label for="chatFile" class="file-upload-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label>
                <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
                <textarea id="chatInput" placeholder="Enter command or message... (Shift+Enter for new line)"></textarea>
                <button type="button" id="callBtn" title="Start Voice Call"><i class="fa-solid fa-phone"></i></button>
                <button type="submit" id="sendBtn" title="Send"><i class="fa-solid fa-paper-plane"></i></button>
            </form>
        </main>

        <!-- Right Tool Panel -->
        <aside id="rightToolPanel">
            <button class="panel-close-btn" id="closeRightPanelBtn" title="Close Tools"><i class="fa-solid fa-xmark"></i></button>
            <div id="toolPanelContent">
                <h2 id="toolPanelTitle">AI Command Nexus</h2>
                <div class="tool-list" id="toolList">
                    <h3>Creative Tools</h3>
                    <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
                    <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
                    <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a>
                    <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a>
                    <hr>
                    <h3>Audio & Video</h3>
                    <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
                    <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration (Document)</a>
                    <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a>
                    <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
                    <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a>
                    <hr>
                    <h3>Web & Research</h3>
                    <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a>
                    <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
                    <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a>
                    <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
                </div>

                <form class="edit-form" id="toolForm" style="display:none; margin-top: 20px;"></form>
                <button id="toolFormBackBtn" class="submit-btn" style="display:none; width:100%; background:var(--dark-bg);color:var(--primary-accent);margin-top:20px; box-shadow:none;">
                    <i class="fa-solid fa-arrow-left"></i> Back to Tools
                </button>
                <div class="status-message" id="toolStatusMsg"></div>
            </div>
        </aside>
    </div>


    <!-- Floating & Modals (retained as overlays, but restyled) -->
    <div id="emojiPanel"></div>
    <div class="status-message" id="statusMsg"></div>
    <div id="filePreview"></div>
    <div id="ai-image-preview">
        <button id="ai-image-close" title="Close">&times;</button>
        <div id="ai-image-container"></div>
        <button id="ai-image-dl" title="Download Image"><i class="fa-solid fa-download"></i> Download</button>
    </div>
    <div id="lightbox">
        <img src="" alt="Lightbox image">
    </div>

    <!-- Modals for Profile and Links -->
    <div class="overlay-modal" id="profileModal">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="profileModal.classList.remove('active');">&times;</button>
            <h2 class="modal-header">User Profile & Chats</h2>
            <div class="profile-section">
                <img id="profilePicModal" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
                <div class="username" id="profileModalUser">User</div>
                <div class="email" id="profileModalEmail">email@example.com</div>
            </div>

            <h3 style="color:var(--secondary-accent); margin-top:20px; margin-bottom:10px; padding-left:5px; text-transform:uppercase; font-size:0.9em;">Chat Archives</h3>
            <div id="chatsListModal" style="max-height:180px;overflow-y:auto; padding-right: 5px;">
                <div class="spinner" style="margin: 20px auto; display: block;"></div>
            </div>
            <button id="newChatBtnModal" class="submit-btn" style="width:100%;">
                <i class="fa-solid fa-plus"></i> New Chat Archive
            </button>
            <hr style="border-color:var(--border-color); margin: 25px 0;">

            <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0;">
                <label for="edit-name">Commander Name</label>
                <input type="text" id="edit-name" required>
                <label for="edit-photo">Avatar URL</label>
                <input type="url" id="edit-photo" placeholder="Paste image link">
                <span style="font-size:0.8em;color:var(--subtle-text-color);display:block;margin:5px 0 15px 2px;"> Tip: <a href="https://postimg.cc/" target="_blank" style="color:var(--link-color);">Upload at postimg.cc</a> </span>
                <button type="submit" class="submit-btn">Update Profile Data</button>
                <div class="status-message" id="profileStatusMsg"></div>
            </form>
            <button id="logoutBtnModal" class="submit-btn" style="background:var(--mid-bg); color:var(--primary-accent); margin-top:20px;">
                Log Out of Command System
            </button>
        </div>
    </div>

    <div class="overlay-modal" id="linksModal">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="linksModal.classList.remove('active');">&times;</button>
            <h2 class="modal-header">System Links & Info</h2>
            <div class="panel-links">
                <a href="philadelphia.html"><i class="fa-solid fa-house-chimney"></i>Philadelphia Homepage</a>
                <a href="index.html"><i class="fa-solid fa-globe"></i>Elvion Network Hub</a>
                <a href="about.html"><i class="fa-solid fa-circle-info"></i> About System Operations</a>
                <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Protocols</a>
                <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms of Service</a>
                <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Engage Telegram Unit</a>
            </div>
        </div>
    </div>

    <!-- Call Modal -->
    <div id="callModal">
        <div id="callHeader">Philadelphia AI - Live Comms Link</div>
        <div id="botImageContainer">
            <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="AI Bot Avatar">
            <div id="botSpeakingIndicator"></div>
        </div>
        <div id="callStatusMessage">Establishing secure channel...</div>
        <div id="tapToTalk">Tap to Transmit</div>
        <div id="callConversation">
            <div class="call-msg status">Waiting for secure link...</div>
        </div>
        <div id="callControls">
            <button id="muteCallBtn"><i class="fa-solid fa-microphone"></i> Mute</button>
            <button id="endCallBtn"><i class="fa-solid fa-phone-slash"></i> Terminate Link</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile, signOut } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const $ = id => document.getElementById(id);

        const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

        let chats = [];
        let currentChatId = null;
        let currentMessages = [];
        let uploadedFiles = [];
        let currentUser = null;
        let currentController = null;

        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;

        window.addEventListener('DOMContentLoaded', () => {
            const leftNav = $('leftNav');
            const rightToolPanel = $('rightToolPanel');
            const toggleRightPanelBtn = $('toggleRightPanelBtn');
            const closeRightPanelBtn = $('closeRightPanelBtn');
            const toolPanelContent = $('toolPanelContent');
            const toolList = $('toolList');
            const toolForm = $('toolForm');
            const toolFormTitle = $('toolPanelTitle'); // Reusing panel title for tool form
            const toolFormBackBtn = $('toolFormBackBtn');
            const toolStatusMsg = $('toolStatusMsg');

            const openProfileModalBtn = $('openProfileModalBtn');
            const profileModal = $('profileModal');
            const profileModalContent = profileModal.querySelector('.modal-content');
            const profilePicNav = $('profilePicNav');
            const profileNavUser = $('profileNavUser');
            const profileNavEmail = $('profileNavEmail');
            const profilePicModal = $('profilePicModal');
            const profileModalUser = $('profileModalUser');
            const profileModalEmail = $('profileModalEmail');
            const profileForm = $('profileForm');
            const editName = $('edit-name');
            const editPhoto = $('edit-photo');
            const profileStatusMsg = $('profileStatusMsg');
            const newChatBtnModal = $('newChatBtnModal');
            const chatsListModal = $('chatsListModal');
            const logoutBtnModal = $('logoutBtnModal');

            const openLinksModalBtn = $('openLinksModalBtn');
            const linksModal = $('linksModal');
            const linksModalContent = linksModal.querySelector('.modal-content');

            const chatBox = $('chatBox');
            const chatForm = $('chatForm');
            const chatInput = $('chatInput');
            const sendBtn = $('sendBtn');
            const chatFile = $('chatFile');
            const filePreview = $('filePreview');
            const emojiPanel = $('emojiPanel');
            const emojiBtn = $('emojiBtn');
            const aiPrevBox = $('ai-image-preview');
            const aiPrevClose = $('ai-image-close');
            const aiPrevDLBtn = $('ai-image-dl');
            const aiPrevImgBox = $('ai-image-container');
            const lightbox = $('lightbox');

            const callBtn = $('callBtn');
            const callModal = $('callModal');
            const endCallBtn = $('endCallBtn');
            const muteCallBtn = $('muteCallBtn');
            const callConversation = $('callConversation');
            const botImageContainer = $('botImageContainer');
            const callStatusMessage = $('callStatusMessage');
            const tapToTalk = $('tapToTalk');
            const typingStatus = $('typing-status');
            const statusMsg = $('statusMsg');

            const headerLogo = $('leftNav').querySelector('.header-logo');
            const newChatBtnNav = $('newChatBtnNav');
            const chatsListNav = $('chatsListNav');
            const themeBtnNav = $('themeBtnNav');
            const logoutBtnNav = $('logoutBtnNav');

            // --- Layout & Panel Toggling ---
            let isRightPanelOpen = false;

            toggleRightPanelBtn.addEventListener('click', () => {
                isRightPanelOpen = !isRightPanelOpen;
                document.body.classList.toggle('right-panel-open', isRightPanelOpen);
                if (isRightPanelOpen) {
                    rightToolPanel.style.transform = 'translateX(0)';
                } else {
                    rightToolPanel.style.transform = 'translateX(100%)';
                }
            });

            closeRightPanelBtn.addEventListener('click', () => {
                isRightPanelOpen = false;
                document.body.classList.remove('right-panel-open');
                rightToolPanel.style.transform = 'translateX(100%)';
            });

            // Handle responsive sidebar toggles (for small screens)
            if (window.matchMedia("(max-width: 768px)").matches) {
                // Initial state for small screens: nav hidden
                leftNav.style.transform = 'translateX(-100%)';
                rightToolPanel.style.transform = 'translateX(100%)';

                // Overlay click to close modals/panels
                document.addEventListener('click', (e) => {
                    if (document.body.classList.contains('left-nav-open') && !leftNav.contains(e.target) && e.target !== toggleRightPanelBtn && e.target !== openProfileModalBtn && e.target !== openLinksModalBtn && e.target !== newChatBtnNav && e.target !== themeBtnNav && e.target !== logoutBtnNav && e.target.closest('#chatsListNav') === null) {
                        document.body.classList.remove('left-nav-open');
                        leftNav.style.transform = 'translateX(-100%)';
                    }
                    if (document.body.classList.contains('right-panel-open') && !rightToolPanel.contains(e.target) && e.target !== toggleRightPanelBtn && e.target.closest('#toolList') === null && e.target.closest('#toolForm') === null) {
                        document.body.classList.remove('right-panel-open');
                        rightToolPanel.style.transform = 'translateX(100%)';
                    }
                });

                // Toggle Left Nav on logo click for mobile
                headerLogo.addEventListener('click', () => {
                    document.body.classList.toggle('left-nav-open');
                    leftNav.style.transform = document.body.classList.contains('left-nav-open') ? 'translateX(0)' : 'translateX(-100%)';
                    if (document.body.classList.contains('right-panel-open')) { // Close right if left opens
                        document.body.classList.remove('right-panel-open');
                        rightToolPanel.style.transform = 'translateX(100%)';
                    }
                });

                // Override toggleRightPanelBtn for mobile to toggle leftNav instead if open
                toggleRightPanelBtn.removeEventListener('click', () => { /* remove default desktop behavior */ });
                toggleRightPanelBtn.addEventListener('click', () => {
                    document.body.classList.toggle('right-panel-open');
                    rightToolPanel.style.transform = document.body.classList.contains('right-panel-open') ? 'translateX(0)' : 'translateX(100%)';
                    if (document.body.classList.contains('left-nav-open')) { // Close left if right opens
                        document.body.classList.remove('left-nav-open');
                        leftNav.style.transform = 'translateX(-100%)';
                    }
                });
            }


            // --- Modal Open/Close Logic ---
            openProfileModalBtn.addEventListener('click', () => profileModal.classList.add('active'));
            openLinksModalBtn.addEventListener('click', () => linksModal.classList.add('active'));

            const modalCloseBtns = document.querySelectorAll('.modal-close-btn');
            modalCloseBtns.forEach(btn => {
                btn.addEventListener('click', () => btn.closest('.overlay-modal').classList.remove('active'));
            });
            const overlayModals = document.querySelectorAll('.overlay-modal');
            overlayModals.forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('active');
                    }
                });
            });


            // --- Emoji Panel Logic (retained from previous) ---
            const emojis = ["","","","","","","","","","","","","","","","","","",""]; // Updated emojis
            if (emojiBtn && emojiPanel && chatInput) {
                emojiBtn.addEventListener('click', (e) => {
                    emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
                    emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block';
                    try {
                        const rect = emojiBtn.getBoundingClientRect();
                        emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
                    } catch (e) { /* ignore positioning errors */ }
                    emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
                        span.addEventListener('click', function () {
                            const text = this.textContent || '';
                            const start = chatInput.selectionStart || 0;
                            const end = chatInput.selectionEnd || 0;
                            chatInput.value = chatInput.value.slice(0, start) + text + chatInput.value.slice(end);
                            chatInput.focus();
                            chatInput.selectionStart = chatInput.selectionEnd = start + text.length;
                            emojiPanel.style.display = 'none';
                            chatInput.dispatchEvent(new Event('input'));
                        });
                    });
                });
                document.addEventListener('click', e => {
                    if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
                        emojiPanel.style.display = 'none';
                    }
                });
            }

            // --- Chat Input Auto-Resize & Enter Key (retained) ---
            if (chatInput) {
                const autoResize = () => {
                    chatInput.style.height = 'auto';
                    chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px'; // Max height adjusted for layout
                };
                chatInput.addEventListener('input', autoResize);
                chatInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        chatForm.requestSubmit();
                    } else if (e.key === 'Enter' && e.shiftKey) {
                        autoResize();
                    }
                });
                autoResize();
            }

            // --- File Attachment Preview (retained, adapted to new styling) ---
            if (chatFile) {
                chatFile.addEventListener('change', function() {
                    uploadedFiles = Array.from(this.files || []);
                    renderFilePreview();
                });
            }

            // --- AI Image Preview Box (retained, adapted to new styling) ---
            if (aiPrevClose) aiPrevClose.addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
            if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
                const img = aiPrevImgBox.querySelector('img');
                if (img) {
                    const a = document.createElement('a');
                    a.href = img.src;
                    a.download = 'philadelphia_ai_image.png';
                    a.click();
                }
            });

            // --- Lightbox for Chat Images (retained) ---
            if (lightbox) {
                lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
            }
            if (chatBox) {
                chatBox.addEventListener('click', e => {
                    if (e.target.tagName === 'IMG' && e.target.closest('.chat-message.ai .msg')) {
                        e.preventDefault();
                        const lbImg = lightbox.querySelector('img');
                        if (lbImg) {
                            lbImg.src = e.target.src;
                            lightbox.classList.add('active');
                        }
                    }
                });
            }

            // --- Firebase Auth State Changed (retained) ---
            onAuthStateChanged(auth, user => {
                if (!user) {
                    try {
                        window.location.href = "signup-login.html";
                    } catch (e) {}
                    return;
                }
                currentUser = user;
                // Update profile info in both nav and modal
                profileNavUser.textContent = user.displayName || "User";
                profileNavEmail.textContent = user.email || "";
                profilePicNav.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

                profileModalUser.textContent = user.displayName || "User";
                profileModalEmail.textContent = user.email || "";
                profilePicModal.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

                editName.value = user.displayName || "";
                editPhoto.value = user.photoURL || "";

                loadUserChats(user.uid);
            });

            // --- Profile Form Submission (retained, adapted to modal) ---
            if (profileForm) {
                profileForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!currentUser) return;
                    const status = profileStatusMsg;
                    if (status) status.textContent = 'Updating profile data...';
                    try {
                        await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
                        if (auth.currentUser) await auth.currentUser.reload();
                        if (status) {
                            status.textContent = "Profile data updated!";
                            status.style.color = "var(--primary-accent)";
                        }
                        // Refresh display names/photos in both places
                        profileNavUser.textContent = auth.currentUser.displayName || "User";
                        profilePicNav.src = auth.currentUser.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";
                        profileModalUser.textContent = auth.currentUser.displayName || "User";
                        profilePicModal.src = auth.currentUser.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

                        setTimeout(() => {
                            profileModal?.classList.remove('active');
                        }, 800);
                    } catch (err) {
                        if (status) {
                            status.textContent = err.message;
                            status.style.color = "#d9534f";
                        }
                    }
                });
            }

            // --- Chat Management (Firebase Firestore) (retained, adapted to nav/modal) ---
            async function loadUserChats(userId) {
                if (chatsUnsubscribe) chatsUnsubscribe();
                const chatsCol = collection(db, 'users', userId, 'chats');
                const q = query(chatsCol, orderBy('createdAt', 'desc'));
                chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                    if (snapshot.empty) {
                        await createNewChat(userId);
                        return;
                    }
                    chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatsList(chatsListNav); // Render in left nav
                    renderChatsList(chatsListModal); // Render in profile modal
                    if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                        currentChatId = chats[0].id;
                    }
                    subscribeToMessages(userId, currentChatId);
                }, (error) => {
                    console.error("Error fetching chats: ", error);
                    chatsListNav.innerHTML = `<div style="color: #d9534f;">Error loading chat archives.</div>`;
                    chatsListModal.innerHTML = `<div style="color: #d9534f;">Error loading chat archives.</div>`;
                });
            }

            async function createNewChat(userId) {
                if (!userId) userId = currentUser?.uid;
                if (!userId) return;
                const chatsCol = collection(db, 'users', userId, 'chats');
                try {
                    const newChatDoc = await addDoc(chatsCol, { name: "New Chat Archive", createdAt: serverTimestamp() });
                    currentChatId = newChatDoc.id;
                } catch (e) {
                    console.error("Error creating new chat: ", e);
                }
            }

            function subscribeToMessages(userId, chatId) {
                if (messagesUnsubscribe) messagesUnsubscribe();
                if (!userId || !chatId) {
                    renderChatBox([]);
                    return;
                }
                const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
                const q = query(messagesCol, orderBy('createdAt'));
                messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                    currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderChatBox(currentMessages);
                }, (error) => {
                    console.error("Error fetching messages: ", error);
                    chatBox.innerHTML = `<div style="color: #d9534f; text-align: center; margin-top: 20px;">Error loading messages for this chat archive.</div>`;
                });
            }

            if (newChatBtnNav) newChatBtnNav.addEventListener('click', () => createNewChat(currentUser.uid));
            if (newChatBtnModal) newChatBtnModal.addEventListener('click', () => createNewChat(currentUser.uid));

            function renderChatsList(element) {
                if (!element) return;
                element.innerHTML = '';
                if (chats.length === 0) {
                    element.innerHTML = `<div style="padding: 10px; color: var(--subtle-text-color);">No chat archives found.</div>`;
                    return;
                }
                chats.forEach((chat) => {
                    const container = document.createElement('div');
                    container.className = `chat-list-item ${chat.id === currentChatId ? 'active-chat' : ''}`;

                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = chat.name || `Chat Archive`;
                    titleSpan.className = 'chat-list-item-title';
                    titleSpan.onclick = () => {
                        currentChatId = chat.id;
                        subscribeToMessages(currentUser.uid, currentChatId);
                        renderChatsList(chatsListNav);
                        renderChatsList(chatsListModal);
                        profileModal?.classList.remove('active'); // Close modal if open
                    };

                    const renameBtn = document.createElement('button');
                    renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                    renameBtn.title = 'Rename';
                    renameBtn.onclick = async (e) => {
                        e.stopPropagation();
                        const newName = prompt("Rename chat archive:", chat.name);
                        if (newName && newName.trim()) {
                            const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                            await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
                        }
                    };

                    const delBtn = document.createElement('button');
                    delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                    delBtn.title = 'Delete';
                    delBtn.onclick = async (e) => {
                        e.stopPropagation();
                        if (!confirm(`Delete "${chat.name}"? This will purge all messages.`)) return;

                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                        const messagesSnap = await getDocs(messagesCol);
                        const batch = writeBatch(db);
                        messagesSnap.docs.forEach(d => batch.delete(d.ref));
                        await batch.commit();

                        const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                        await deleteDoc(chatDoc);

                        if (currentChatId === chat.id) {
                            currentChatId = null;
                        }
                    };

                    container.appendChild(titleSpan);
                    container.appendChild(renameBtn);
                    container.appendChild(delBtn);
                    element.appendChild(container);
                });
            }

            // --- Markdown & Code Rendering (retained) ---
            const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

            function inlineMarkdown(t = '') {
                let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
                s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
                s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
                s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                return s.replace(/\n/g, '<br>');
            }

            function renderMarkdown(text = '') {
                const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
                let html = '';
                let lastIndex = 0;
                text = text || '';
                text.replace(codeBlockRegex, (match, lang, code, offset) => {
                    const before = text.slice(lastIndex, offset);
                    html += inlineMarkdown(before);
                    const language = (lang || '').toLowerCase().trim();
                    const safe = escapeHTML(code);
                    html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safe}</code></pre>`;
                    lastIndex = offset + match.length;
                    return match;
                });
                html += inlineMarkdown(text.slice(lastIndex));
                return { html };
            }

            function enhanceCodeBlocks(container) {
                if (!container) return;
                container.querySelectorAll('pre').forEach(pre => {
                    const codeEl = pre.querySelector('code');
                    if (window.hljs && codeEl) {
                        try { hljs.highlightElement(codeEl); } catch (e) { /* ignore */ }
                    }
                    const btn = pre.querySelector('.copy-btn');
                    if (btn && codeEl) {
                        btn.addEventListener('click', async () => {
                            try {
                                await navigator.clipboard.writeText(codeEl.innerText);
                                const prev = btn.textContent;
                                btn.textContent = 'Copied!';
                                setTimeout(() => btn.textContent = prev, 800);
                            } catch (e) {
                                btn.textContent = 'Failed';
                                setTimeout(() => btn.textContent = 'Copy', 800);
                            }
                        });
                    }
                });
            }

            // --- Chat Box Rendering (retained, adapted to new styling) ---
            function renderChatBox(messages = []) {
                if (!chatBox) return;
                chatBox.innerHTML = '';
                (messages || []).forEach((msg) => {
                    const div = document.createElement('div');
                    div.className = 'chat-message ' + (msg.role === 'user' ? 'user' : 'ai');
                    div.setAttribute('data-message-id', msg.id);
                    let innerHtml = '';

                    if (msg.role === 'user') {
                        const fileHtml = (msg.files || [])
                            .map(file => {
                                let icon = 'fa-file';
                                if (file.type.startsWith('image/')) icon = 'fa-file-image';
                                else if (file.type.startsWith('video/')) icon = 'fa-file-video';
                                else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
                                else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
                                return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                            })
                            .join('');

                        innerHtml = `<div class="msg">
                            ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                            ${escapeHTML(msg.text || '')}
                            <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                                <button class="inline-edit-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                            </div>
                        </div>`;
                    } else {
                        let content;
                        if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                            content = msg.text;
                        } else {
                            content = renderMarkdown(msg.text || '').html;
                        }
                        innerHtml = `<div class="msg">${content}
                            <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                                <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                                <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                                <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                            </div>
                        </div>`;
                    }
                    div.innerHTML = innerHtml;
                    chatBox.appendChild(div);
                });
                enhanceCodeBlocks(chatBox);
                hookAiMsgControls();
                hookUserMsgControls();
                setTimeout(() => {
                    chatBox.scrollTop = chatBox.scrollHeight;
                }, 50);
            }

            // --- Message Deletion for Regeneration/Editing (retained) ---
            async function deleteMessagesFrom(messageId) {
                if (!currentChatId || !currentUser) return;
                const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                if (msgIndex === -1) return;
                const batch = writeBatch(db);
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                for (let i = msgIndex; i < currentMessages.length; i++) {
                    const msgToDel = currentMessages[i];
                    const docRef = doc(messagesCol, msgToDel.id);
                    batch.delete(docRef);
                }
                try {
                    await batch.commit();
                } catch (e) {
                    console.error("Error deleting messages: ", e);
                }
            }

            // --- AI Message Controls (retained) ---
            function hookAiMsgControls() {
                if (!chatBox) return;
                chatBox.querySelectorAll('.chat-message.ai').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;

                    const controls = div.querySelector('.ai-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const shareBtn = controls.querySelector('.inline-share-btn');
                    const regenBtn = controls.querySelector('.regen-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                        } catch (e) {
                            console.warn('copy failed', e);
                        }
                    };

                    if (shareBtn) shareBtn.onclick = () => {
                        try {
                            const url = window.location.origin;
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const plainText = tempDiv.textContent || tempDiv.innerText || '';
                            const shareText = `${plainText}\n\nShared via Philadelphia AI Command Center: ${url}`;
                            if (navigator.share) navigator.share({ title: "Philadelphia AI Command Center", text: shareText, url }).catch(()=>{});
                            else prompt("Copy and share manually:", shareText);
                        } catch (e) {
                            console.warn('share failed', e);
                        }
                    };

                    if (regenBtn) regenBtn.onclick = async () => {
                        const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                        if (msgIndex < 1) return;
                        const userMsg = currentMessages[msgIndex - 1];
                        if (userMsg.role !== 'user') return;

                        await deleteMessagesFrom(messageId);
                        chatInput.value = userMsg.text;
                        chatInput.style.height = 'auto';
                        chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
                        uploadedFiles = [];
                        renderFilePreview();

                        showTypingAtNext();

                        const historyForRegen = currentMessages
                            .slice(0, msgIndex - 1)
                            .map(m => ({ role: m.role, content: m.text || '' }));

                        try {
                            const res = await fetch(`${API_BASE_URL}/chat`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ message: userMsg.text, history: historyForRegen, user_id: currentUser?.uid || "user" })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Server error.");
                            removeTyping();
                            await startTypewriter(data.response, false);
                        } catch (err) {
                            removeTyping();
                            await startTypewriter(` Regeneration error: ${err.message}`, false);
                        }
                    };
                });
            }

            // --- User Message Controls (retained) ---
            function hookUserMsgControls() {
                if (!chatBox) return;
                chatBox.querySelectorAll('.chat-message.user').forEach(div => {
                    const messageId = div.getAttribute('data-message-id');
                    const msg = currentMessages.find(m => m.id === messageId);
                    if (!msg) return;

                    const controls = div.querySelector('.user-msg-controls');
                    if (!controls) return;

                    const copyBtn = controls.querySelector('.inline-copy-btn');
                    const editBtn = controls.querySelector('.inline-edit-btn');

                    if (copyBtn) copyBtn.onclick = () => {
                        try {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = msg.text;
                            const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                            navigator.clipboard.writeText(textToCopy);
                            copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                            setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                        } catch (e) {
                            console.warn('copy failed', e);
                        }
                    };

                    if (editBtn) editBtn.onclick = async () => {
                        try {
                            if (!msg.text) return;
                            chatInput.value = msg.text;
                            chatInput.focus();
                            await deleteMessagesFrom(messageId);
                        } catch (e) {
                            console.warn('edit failed', e);
                        }
                    };
                });
            }

            // --- Typing Status Indicators (retained, adapted to new styling) ---
            function showTypingAtNext() {
                if (!typingStatus) return;
                typingStatus.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span></div>`;
                typingStatus.style.display = 'flex';
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            function showTypingWithText(text) {
                if (!typingStatus) return;
                typingStatus.innerHTML = `<div class="msg" style="display:flex;align-items:center; color:var(--subtle-text-color);"><span class="spinner"></span> <span style="margin-left:10px; font-style:italic;">${text}</span></div>`;
                typingStatus.style.display = 'flex';
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            function removeTyping() {
                if (!typingStatus) return;
                typingStatus.style.display = 'none';
                typingStatus.innerHTML = '';
            }

            // --- Typewriter Effect for AI Responses (retained) ---
            async function startTypewriter(text, saveToDb = true) {
                if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) {
                    if (saveToDb) {
                        await addMessageToChat('ai', text);
                    } else {
                        const tempDiv = document.createElement('div');
                        tempDiv.className = "chat-message ai";
                        tempDiv.innerHTML = `<div class="msg">${text}</div>`;
                        chatBox.appendChild(tempDiv);
                        chatBox.scrollTop = chatBox.scrollHeight;

                        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                        try {
                            await addDoc(messagesCol, { role: 'ai', text: text, createdAt: serverTimestamp() });
                        } catch (e) {
                            console.error("Error saving regenerated AI tool message: ", e);
                        }
                    }
                    return;
                }

                if (!chatBox) return;

                const div = document.createElement('div');
                div.className = "chat-message ai";
                const msgdiv = document.createElement('div');
                msgdiv.className = 'msg';
                div.appendChild(msgdiv);
                chatBox.appendChild(div);

                let sofar = '';
                const words = text.split(/(\s+)/);
                let tempText = '';
                for (const word of words) {
                    if (currentController?.signal.aborted) {
                        text = tempText;
                        break;
                    }
                    tempText += word;
                    if (tempText.includes('```')) {
                        const parts = tempText.split('```');
                        sofar = parts.slice(0, parts.length -1).join('```');
                        if(parts.length % 2 === 0) sofar += '```';
                    } else {
                        sofar = tempText;
                    }
                    msgdiv.innerHTML = renderMarkdown(sofar).html;
                    chatBox.scrollTop = chatBox.scrollHeight;
                    const delay = word.match(/[\s\.\,\!\?]/) ? 10 : 25; // Slightly faster typing for command center
                    await new Promise(res => setTimeout(res, delay));
                }

                const finalRenderText = text;

                msgdiv.innerHTML = renderMarkdown(finalRenderText).html + `
                    <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                        <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                        <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                        <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                    </div>
                `;
                enhanceCodeBlocks(msgdiv);
                chatBox.scrollTop = chatBox.scrollHeight;

                if (saveToDb) {
                    const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                    try {
                        await addDoc(messagesCol, { role: 'ai', text: finalRenderText, createdAt: serverTimestamp() });
                    } catch (e) {
                        console.error("Error saving AI message: ", e);
                        msgdiv.innerHTML += "<br><small style='color: #d9534f;'>Failed to save message.</small>";
                    }
                }
            }

            // --- File Preview (bottom of screen) (retained, adapted styling) ---
            function renderFilePreview() {
                if (!filePreview) return;
                if (!uploadedFiles.length) {
                    filePreview.style.display = 'none';
                    filePreview.innerHTML = '';
                    return;
                }
                filePreview.style.display = 'block';
                filePreview.innerHTML = uploadedFiles.map((file, idx) => {
                    let preview = '';
                    if (file.type.startsWith('image/')) {
                        preview = `<img src="${URL.createObjectURL(file)}" style="max-width:48px;max-height:36px;vertical-align:middle;border-radius:4px;margin-right:6px;">`;
                    } else if (file.type.startsWith('video/')) {
                        preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:48px;height:36px;vertical-align:middle;border-radius:4px;margin-right:6px;"></video>`;
                    } else if (file.type.startsWith('audio/')) {
                        preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:48px;margin-right:6px;"></audio>`;
                    } else if (file.type === 'application/pdf') {
                        preview = `<span style="font-size:1.2em;margin-right:6px;"></span>`;
                    }
                    return `
                        <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;">
                            ${preview}
                            <span style="color:var(--subtle-text-color);font-size:0.9em;">${escapeHTML(file.name)}</span>
                            <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
                        </div>`;
                }).join('');

                filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const idx = parseInt(btn.getAttribute('data-idx'));
                        uploadedFiles.splice(idx, 1);
                        if (!uploadedFiles.length && chatFile) chatFile.value = '';
                        renderFilePreview();
                    });
                });
            }

            // --- Show AI Image in Floating Box (retained, adapted styling) ---
            function showAIImagePreview(base64, caption = '') {
                if (!aiPrevBox || !aiPrevImgBox) return;
                aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image">` + `<div style="color:var(--subtle-text-color);font-size:0.9em;margin-top:5px;text-align:center;">${caption}</div>`;
                aiPrevBox.style.display = 'block';
            }

            // --- Add Message to Firestore (retained) ---
            async function addMessageToChat(role, text, files = []) {
                if (!currentChatId || !currentUser) return;
                const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesCol, { role, text, files, createdAt: serverTimestamp() });
                } catch (e) {
                    console.error("Error adding message to Firestore: ", e);
                }
            }

            // --- Utility: Blob to Base64 (retained) ---
            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            // --- Video Generation Helper (retained, adapted language) ---
            async function handleVideoGeneration(payload, isImageToVideo = false) {
                showTypingWithText('Initiating video rendering sequence...');
                try {
                    const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
                    const commonPayload = { model: "MiniMax-Hailuo-02", duration: payload.duration || 6, resolution: payload.resolution || "1080P" };
                    let options;

                    if (isImageToVideo) {
                        payload.append('model', commonPayload.model);
                        payload.append('duration', commonPayload.duration);
                        payload.append('resolution', commonPayload.resolution);
                        options = { method: 'POST', body: payload };
                    } else {
                        const finalPayload = { ...payload, ...commonPayload };
                        options = {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(finalPayload)
                        };
                    }

                    const startRes = await fetch(API_BASE_URL + endpoint, options);
                    const startData = await startRes.json();

                    if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to initiate video task.');

                    removeTyping();
                    await startTypewriter(` Video task queued. ID: \`${startData.task_id}\`. Stand by for completion. This may take several minutes. Do not navigate away from this terminal.`);

                    const pollInterval = setInterval(async () => {
                        try {
                            const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                            const statusData = await statusRes.json();

                            if (statusRes.ok && statusData.url) {
                                clearInterval(pollInterval);
                                const videoHtml = ` Video rendering complete! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                                await addMessageToChat('ai', videoHtml);
                            } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                                clearInterval(pollInterval);
                                await startTypewriter(` Video rendering failed. Status: ${statusData.error || 'Unknown error'}`);
                            }
                        } catch (pollErr) {
                            clearInterval(pollInterval);
                            await startTypewriter(` Error querying video status.`);
                        }
                    }, 20000);
                } catch (err) {
                    removeTyping();
                    await startTypewriter(` Video task initiation failed: ${err.message}`);
                }
            }

            // --- Tool Definitions (retained content, updated language) ---
            const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
            const toolDefinitions = {
                "image": {
                    title: "Generate Image",
                    description: "Fabricate visuals from text input. Select a model for desired output characteristics.",
                    buildForm: () => `
                        <label for="tool-provider">Generation Engine</label>
                        <select id="tool-provider" class="edit-form-field"><option value="thena">Philadelphia (Stylized, Rapid)</option><option value="minimax">Seraphina (Creative, Realistic)</option></select>
                        <label for="tool-prompt">Image Prompt</label>
                        <textarea id="tool-prompt" class="edit-form-field" placeholder="A high-tech control room, glowing interfaces, data streams" required></textarea>
                        <label for="tool-style">Style (Philadelphia Engine only)</label>
                        <select id="tool-style" class="edit-form-field">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
                        <button type="submit" class="submit-btn" style="width:100%;">Initiate Image Synthesis</button>`,
                    handleSubmit: async (form) => {
                        const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                        const providerName = use_minimax ? 'Seraphina Engine' : 'Philadelphia Engine';
                        const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
                        await addMessageToChat('user', `Image synthesis request: "${payload.prompt}" (using ${providerName})`);
                        showTypingWithText('Synthesizing image data...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/generate-image`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                            removeTyping();
                            await addMessageToChat('ai', ' Image synthesis complete! View in floating preview or download.');
                            return null;
                        } catch (err) {
                            removeTyping();
                            return ` Image synthesis failed: ${err.message}`;
                        }
                    }
                },
                "edit-photo": {
                    title: "Edit Photo",
                    description: "Upload an image and provide directives for modification.",
                    buildForm: () => `
                        <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" class="edit-form-field" placeholder="Replace the background with a server rack humming with activity" required></textarea>
                        <label for="tool-file">Image for Edit</label><input type="file" id="tool-file" class="edit-form-field" accept="image/*" required>
                        <button type="submit" class="submit-btn" style="width:100%;">Execute Edit Protocol</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        const prompt = form.querySelector('#tool-prompt').value;
                        if (!file) return "Error: No image file selected.";
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('prompt', prompt);
                        await addMessageToChat('user', `Image edit request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Processing image modification...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error((await res.json()).error || 'Image modification failed.');
                            const blob = await res.blob();
                            const base64String = await blobToBase64(blob);
                            const imgHtml = ` Image modification complete! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return ` Image modification failed: ${err.message}`;
                        }
                    }
                },
                "remove-bg": {
                    title: "Remove Background",
                    description: "Select an image file for automated background removal.",
                    buildForm: () => `
                        <label for="tool-file">Target Image File</label><input type="file" id="tool-file" class="edit-form-field" accept="image/*" required style="display:block;margin-top:10px;">
                        <button type="submit" class="submit-btn" style="width:100%;">Execute BG Removal</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        if (!file) return "Error: No file selected.";
                        await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Executing background removal protocol...');
                        const fd = new FormData();
                        fd.append('file', file);
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const imgHtml = ` Background removal successful! <br><img src="${url}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                            removeTyping();
                            await addMessageToChat('ai', imgHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return ` Background removal failed: ${err.message}`;
                        }
                    }
                },
                "comic": {
                    title: "Create Comic",
                    description: "Input a narrative for conversion into a multi-panel comic strip. Use tags `[DIALOGUE]`, `[INSTRUCTION]`, `[NARRATION]` for structure.",
                    buildForm: () => `
                        <label for="tool-story">Comic Narrative</label><textarea id="tool-story" class="edit-form-field" placeholder="[DIALOGUE] System status critical!&#10;[NARRATION] Commander Nova assessed the flickering displays..." required></textarea>
                        <label for="tool-style">Art Style</label><select id="tool-style" class="edit-form-field"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
                        <label for="tool-panels">Panel Count</label><input type="number" id="tool-panels" class="edit-form-field" value="3" min="1" max="6" />
                        <button type="submit" class="submit-btn" style="width:100%;">Generate Comic Sequence</button>`,
                    handleSubmit: async (form) => {
                        const payload = {
                            story: form.querySelector('#tool-story').value,
                            style: form.querySelector('#tool-style').value,
                            panels: parseInt(form.querySelector('#tool-panels').value, 10),
                            user: currentUser?.displayName || "User"
                        };
                        await addMessageToChat('user', `Comic generation request with style: ${payload.style}.`);
                        showTypingWithText('Generating comic panel sequence...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join('');
                            const comicMessage = ` Comic sequence rendered! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                            removeTyping();
                            await addMessageToChat('ai', comicMessage);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return ` Comic sequence generation failed: ${err.message}`;
                        }
                    }
                },
                "voice-gen": {
                    title: "Voice Generation",
                    description: "Convert text input into synthetic speech. Select a provider and vocal profile.",
                    buildForm: () => `
                        <label for="tool-provider">Voice Synthesis Unit</label><select id="tool-provider" class="edit-form-field"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
                        <label for="tool-prompt">Text for Speech</label><textarea id="tool-prompt" class="edit-form-field" placeholder="System initiated. Awaiting command input." required></textarea>
                        <label for="tool-style">Vocal Profile</label><select id="tool-style" class="edit-form-field"></select>
                        <button type="submit" class="submit-btn" style="width:100%;">Synthesize Voice</button>`,
                    onFormReady: () => {
                        const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
                        const voices = {
                            gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                            minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                        };
                        const updateStyles = () => {
                            styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                        };
                        providerSelect.addEventListener('change', updateStyles);
                        updateStyles();
                    },
                    handleSubmit: async (form) => {
                        const provider = form.querySelector('#tool-provider').value,
                            text = form.querySelector('#tool-prompt').value,
                            style = form.querySelector('#tool-style').value;
                        const providerName = provider === 'minimax' ? 'Seraphina Unit' : 'Philadelphia Unit';
                        await addMessageToChat('user', `Voice synthesis request using ${providerName}.`);
                        showTypingWithText('Executing voice synthesis...');
                        try {
                            let res;
                            if (provider === 'gemini') {
                                const fd = new FormData();
                                fd.append('text', text);
                                fd.append('style', style);
                                res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                            } else {
                                res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({ text, voice_id: style })
                                });
                            }
                            if (!res.ok) throw new Error(await res.text());
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const audioHtml = ` Voice synthesis complete! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', audioHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return ` Voice synthesis failed: ${err.message}`;
                        }
                    }
                },
                "audio-narration": {
                    title: "Audio Narration",
                    description: "Upload a document (PDF, TXT) for conversion into a narrated audio summary.",
                    buildForm: () => `
                        <label for="tool-file">Document for Narration</label><input type="file" id="tool-file" class="edit-form-field" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;">
                        <button type="submit" class="submit-btn" style="width:100%;">Initiate Narration</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#tool-file').files[0];
                        if (!file) return "Error: No document selected.";
                        await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                        showTypingWithText('Processing document for narration...');
                        const fd = new FormData();
                        fd.append('file', file);
                        fd.append('style', 'podcast');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const narrationHtml = ` Narration sequence complete! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', narrationHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return ` Audio narration failed: ${err.message}`;
                        }
                    }
                },
                "video-text": {
                    title: "Generate Video from Text",
                    description: "Input text for automated video sequence generation. This process may require extended processing time.",
                    buildForm: () => `
                        <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" class="edit-form-field" placeholder="A drone flying over a futuristic city, data overlays, neon glow" required></textarea>
                        <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" class="edit-form-field" value="6" min="2" max="15">
                        <button type="submit" class="submit-btn" style="width:100%;">Start Video Generation</button>`,
                    handleSubmit: async (form) => {
                        const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
                        await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
                        handleVideoGeneration(payload);
                        return null;
                    }
                },
                "video-image": {
                    title: "Generate Video from Image",
                    description: "Provide a static image and directives for animation and video sequence generation.",
                    buildForm: () => `
                        <label for="video-image-prompt">Animation Directives</label><textarea id="video-image-prompt" class="edit-form-field" placeholder="Add subtle steam from the vents, a slow pan across the control panel" required></textarea>
                        <label for="video-image-file">Source Image</label><input type="file" id="video-image-file" class="edit-form-field" accept="image/*" required>
                        <button type="submit" class="submit-btn" style="width:100%;">Initiate Image-to-Video</button>`,
                    handleSubmit: async (form) => {
                        const file = form.querySelector('#video-image-file').files[0];
                        if (!file) return "Error: No source image provided.";
                        await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{name: file.name, type: file.type}]);
                        const fd = new FormData();
                        fd.append('prompt', form.querySelector('#video-image-prompt').value);
                        fd.append('file', file);
                        handleVideoGeneration(fd, true);
                        return null;
                    }
                },
                "music": {
                    title: "Generate Music",
                    description: "Compose audio tracks from a descriptive prompt, optional lyrics, and reference audio. Via Seraphina Audio Engine.",
                    buildForm: () => `
                        <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" class="edit-form-field" placeholder="An intense synthwave track, building suspense then a powerful drop" required></textarea>
                        <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" class="edit-form-field" placeholder="Verse 1: Code lines flow...&#10;Chorus: Digital heartbeat throbs..."></textarea>
                        <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" class="edit-form-field" accept="audio/*">
                        <button type="submit" class="submit-btn" style="width:100%;">Synthesize Audio Track</button>`,
                    handleSubmit: async (form) => {
                        const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
                        const refFile = form.querySelector('#music-ref').files[0];
                        await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
                        showTypingWithText('Composing audio track via Seraphina Audio Engine...');
                        try {
                            if (refFile) {
                                showTypingWithText('Uploading audio reference...');
                                const fd = new FormData();
                                fd.append('file', refFile);
                                const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                                const uploadData = await uploadRes.json();
                                if (!uploadRes.ok) throw new Error(uploadData.error || "Audio reference upload failed.");
                                if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                                if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                                showTypingWithText('Reference processed. Composing track...');
                            }
                            const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            if (!res.ok) throw new Error((await res.json()).detail || 'Audio engine request failed.');
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const musicHtml = ` Audio track synthesized! <br><audio controls src="${url}" class="chat-media-preview audio-preview-thumb"></audio>`;
                            removeTyping();
                            await addMessageToChat('ai', musicHtml);
                            return null;
                        } catch (err) {
                            removeTyping();
                            return ` Audio track synthesis failed: ${err.message}`;
                        }
                    }
                },
                "website": {
                    title: "Create Website",
                    description: "Provide a description for automated website generation and deployment.",
                    buildForm: () => `
                        <label for="website-prompt">Website Description</label><textarea id="website-prompt" class="edit-form-field" placeholder="A secure data analytics dashboard for AI performance metrics..." required></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;">Deploy Website</button>`,
                    handleSubmit: async (form) => {
                        const prompt = form.querySelector('#website-prompt').value;
                        await addMessageToChat('user', `Website deployment request: "${prompt.substring(0, 50)}..."`);
                        showTypingWithText('Initiating website deployment sequence...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt, user_id: currentUser.uid })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return ` Website deployed successfully! [Access here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return ` Website deployment failed: ${err.message}`;
                        }
                    }
                },
                "edit-website": {
                    title: "Edit Last Website",
                    description: "Submit instructions to modify the most recently deployed website.",
                    buildForm: () => `
                        <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" class="edit-form-field" placeholder="Change the primary data visualization to a real-time graph..." required></textarea>
                        <button type="submit" class="submit-btn" style="width:100%;">Apply Website Changes</button>`,
                    handleSubmit: async (form) => {
                        const instruction = form.querySelector('#edit-instruction').value;
                        await addMessageToChat('user', `Website modification request: "${instruction.substring(0, 50)}..."`);
                        showTypingWithText('Applying changes and redeploying website...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ instruction, user_id: currentUser.uid })
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || res.statusText);
                            removeTyping();
                            return ` Website updated! [Access new version here](${data.url})`;
                        } catch (err) {
                            removeTyping();
                            return ` Website modification failed: ${err.message}`;
                        }
                    }
                },
                "my-sites": {
                    isAction: true,
                    runAction: async () => {
                        await addMessageToChat('user', 'Requesting list of deployed websites.');
                        showTypingWithText('Querying database for deployed websites...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || 'Could not retrieve deployed sites.');
                            if (!data.sites || data.sites.length === 0) return "No websites currently deployed.";
                            const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank">${site.site_url}</a> (Deployed: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                            removeTyping();
                            return `Deployed websites:\n${siteList}`;
                        } catch (err) {
                            removeTyping();
                            return ` Error retrieving websites: ${err.message}`;
                        }
                    }
                },
                "research-report": {
                    title: "Research Report",
                    description: "Generate a comprehensive research report in PDF format on a specified topic.",
                    buildForm: () => `
                        <label for="research-topic">Research Topic</label><input type="text" id="research-topic" class="edit-form-field" placeholder="The ethical implications of advanced AI" required>
                        <button type="submit" class="submit-btn" style="width:100%;">Generate Research Report</button>`,
                    handleSubmit: async (form) => {
                        const topic = form.querySelector('#research-topic').value;
                        await addMessageToChat('user', `Research report request on: "${topic}"`);
                        showTypingWithText('Compiling research data for report generation...');
                        try {
                            const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ topic })
                            });
                            if (!res.ok) throw new Error(res.statusText);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--link-color);font-weight:bold;">Download PDF Report</a>`;
                            removeTyping();
                            return ` Research report on **${topic}** is ready! ${downloadLink}`;
                        } catch (err) {
                            removeTyping();
                            return ` Research report generation failed: ${err.message}`;
                        }
                    }
                },
            };

            // --- Tool Menu and Form Handling (adapted to right panel) ---
            toolList.addEventListener('click', async (e) => {
                const toolLink = e.target.closest('.tool-link');
                if (!toolLink) return;
                e.preventDefault();
                const toolKey = toolLink.getAttribute('data-tool');
                const tool = toolDefinitions[toolKey];
                if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);

                if (tool.isAction) {
                    const result = await tool.runAction();
                    removeTyping();
                    if(result) await startTypewriter(result);
                } else {
                    displayToolForm(toolKey);
                }
            });

            function displayToolForm(toolKey) {
                const tool = toolDefinitions[toolKey];
                if (!tool || !toolPanelContent) return; // Ensure toolPanelContent exists

                toolFormTitle.textContent = tool.title;
                const descriptionHtml = tool.description ? `<div style="color:var(--subtle-text-color);font-size:0.9em;margin-bottom:15px;">${tool.description}</div>` : '';
                toolForm.innerHTML = descriptionHtml + tool.buildForm();

                toolList.style.display = 'none'; // Hide tool list
                toolForm.style.display = 'block'; // Show tool form
                toolFormBackBtn.style.display = 'block'; // Show back button

                if (typeof tool.onFormReady === 'function') tool.onFormReady();

                toolForm.onsubmit = async (e) => {
                    e.preventDefault();
                    const submitButton = toolForm.querySelector('button[type="submit"]');
                    const originalButtonContent = submitButton.innerHTML;
                    submitButton.innerHTML = `<div class="spinner"></div> Processing...`;
                    submitButton.disabled = true;

                    // Immediately close the right panel if on mobile after submission
                    if (window.matchMedia("(max-width: 768px)").matches) {
                        isRightPanelOpen = false;
                        document.body.classList.remove('right-panel-open');
                        rightToolPanel.style.transform = 'translateX(100%)';
                    }

                    const resultText = await tool.handleSubmit(toolForm);
                    if (resultText) {
                        removeTyping();
                        await startTypewriter(resultText);
                    }
                    submitButton.innerHTML = originalButtonContent;
                    submitButton.disabled = false;

                    toolForm.reset(); // Clear form after submission
                    toolList.style.display = 'block'; // Show tool list again
                    toolForm.style.display = 'none'; // Hide tool form
                    toolFormBackBtn.style.display = 'none'; // Hide back button
                    toolFormTitle.textContent = "AI Command Nexus"; // Reset title
                };
            }

            if (toolFormBackBtn) {
                toolFormBackBtn.addEventListener('click', () => {
                    toolForm.style.display = 'none';
                    toolFormBackBtn.style.display = 'none';
                    toolList.style.display = 'block';
                    toolFormTitle.textContent = "AI Command Nexus"; // Reset title
                    toolStatusMsg.textContent = ''; // Clear status message
                });
            }


            // --- Main Chat Form Submission (retained) ---
            chatForm.addEventListener('submit', async function (e) {
                e.preventDefault();
                if (!currentChatId) {
                    statusMsg.textContent = "Error: Select or create a chat archive to transmit.";
                    return;
                }
                const msgText = chatInput.value.trim();
                if (!msgText && uploadedFiles.length === 0) {
                    statusMsg.textContent = "Error: Transmission empty. Enter data or attach file.";
                    setTimeout(() => statusMsg.textContent = '', 3000);
                    return;
                }

                const stopButton = document.createElement('button');
                stopButton.type = 'button';
                stopButton.id = 'stopBtn';
                stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>';
                sendBtn.replaceWith(stopButton);
                currentController = new AbortController();
                const signal = currentController.signal;
                let finalResponse = '';

                stopButton.addEventListener('click', () => {
                    if (currentController) {
                        currentController.abort();
                        statusMsg.textContent = 'Transmission interrupted.';
                        setTimeout(() => statusMsg.textContent = '', 3000);
                    }
                });

                const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
                await addMessageToChat('user', msgText, filesForHistory);
                const localUploadedFiles = [...uploadedFiles];
                chatInput.value = '';
                uploadedFiles = [];
                renderFilePreview();
                chatInput.style.height = 'auto';

                if (localUploadedFiles.length > 0) {
                    showTypingWithText('Analyzing uploaded data stream...');
                    let endpoint = '';
                    const file = localUploadedFiles[0];
                    if (file.type.startsWith('image/')) endpoint = '/understand-image';
                    else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                    else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                    else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                    else {
                        removeTyping();
                        finalResponse = "Error: System cannot process this data type.";
                    }
                    try {
                        if(endpoint) {
                            const fd = new FormData();
                            fd.append('prompt', msgText || `Analyze this ${file.type.split('/')[0]} data`);
                            fd.append('file', file);
                            const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Data analysis failed.");
                            finalResponse = data.response;
                        }
                    } catch (err) {
                        finalResponse = err.name === 'AbortError' ? ' Data analysis aborted.' : ` Data analysis failed: ${err.message}`;
                    }
                } else if (msgText) {
                    showTypingAtNext();
                    try {
                        const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                        const res = await fetch(`${API_BASE_URL}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }),
                            signal
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || "Server error.");
                        finalResponse = data.response;
                    } catch (err) {
                        finalResponse = err.name === 'AbortError' ? ' Transmission aborted.' : ` System error: ${err.message}`;
                    }
                }

                removeTyping();
                if (finalResponse) {
                    await startTypewriter(finalResponse);
                }

                stopButton.replaceWith(sendBtn);
                currentController = null;
            });

            // --- Theme Switching Logic (retained, adapted theme keys) ---
            const themes = {
                'tech-noir': { /* default, no class needed */ },
                'celestial-theme': { /* defined in CSS class */ },
                'starlight-theme': { /* defined in CSS class */ },
                'midnight-theme': { /* defined in CSS class */ },
                'forest-theme': { /* defined in CSS class */ },
                'volcano-theme': { /* defined in CSS class */ }
            };
            let currentThemeIdx = 0;
            const themeKeys = Object.keys(themes);

            function applyTheme(themeName) {
                document.body.className = ''; // Clear existing themes
                if (themeName !== 'tech-noir') { // 'tech-noir' is default, no class needed
                    document.body.classList.add(themeName);
                }

                localStorage.setItem('philadelphia-theme-command', themeName); // New local storage key

                // Update theme button icon
                const iconMap = {
                    'tech-noir': 'fa-desktop', // New icon for Tech Noir
                    'celestial-theme': 'fa-galaxy',
                    'starlight-theme': 'fa-star-half-stroke',
                    'midnight-theme': 'fa-moon',
                    'forest-theme': 'fa-leaf',
                    'volcano-theme': 'fa-fire'
                };
                themeBtnNav.innerHTML = `<i class="fa-solid ${iconMap[themeName] || 'fa-palette'}"></i> <span>Change Theme</span>`;
            }

            themeBtnNav.addEventListener('click', () => {
                currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
                applyTheme(themeKeys[currentThemeIdx]);
            });

            // Load saved theme or apply default
            const savedTheme = localStorage.getItem('philadelphia-theme-command');
            if (savedTheme && themes[savedTheme]) {
                currentThemeIdx = themeKeys.indexOf(savedTheme);
                applyTheme(savedTheme);
            } else {
                applyTheme('tech-noir'); // Default for Command Center
            }

            // --- Logout (retained) ---
            if (logoutBtnNav) logoutBtnNav.addEventListener('click', async () => {
                await signOut(auth);
                window.location.href = 'signup-login.html';
            });
            if (logoutBtnModal) logoutBtnModal.addEventListener('click', async () => {
                await signOut(auth);
                window.location.href = 'signup-login.html';
            });


            // --- Voice Call Functionality (retained, adapted language/styling) ---
            let speechRecognition;
            let isCallActive = false;
            let callHistory = [];
            let botIsSpeaking = false;
            let userSaidSomething = false;
            let currentAudio = null;
            let isMuted = false;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = true;
                speechRecognition.interimResults = true;
                speechRecognition.lang = 'en-US';

                speechRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    userSaidSomething = true;
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }

                    let userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                    if (!userMsgEl) {
                        userMsgEl = document.createElement('div');
                        userMsgEl.className = 'call-msg user interim';
                        callConversation.appendChild(userMsgEl);
                    }
                    userMsgEl.textContent = finalTranscript || interimTranscript;
                    callConversation.scrollTop = callConversation.scrollHeight;

                    callStatusMessage.textContent = finalTranscript ? 'User Transmitting (Final)' : 'User Transmitting (Interim)...';
                    tapToTalk.style.display = 'none';
                };

                speechRecognition.onspeechend = () => {
                    if (!botIsSpeaking) {
                         speechRecognition.stop();
                    }
                };

                speechRecognition.onend = () => {
                    if (!isCallActive) return;
                    if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                        return;
                    }

                    let finalTranscript = '';
                    const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                    if (userMsgEl) {
                        finalTranscript = userMsgEl.textContent.trim();
                        userMsgEl.classList.remove('interim');
                    }

                    if (botIsSpeaking) {
                        if (userMsgEl && finalTranscript === '') {
                            userMsgEl.remove();
                        }
                    } else if (finalTranscript && userSaidSomething) {
                        userSaidSomething = false;
                        callHistory.push({ role: 'user', content: finalTranscript });
                        handleCallBotResponse();
                    } else {
                        if (isCallActive && !isMuted) {
                            callStatusMessage.textContent = 'Awaiting input... (Tap to Transmit)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
                        }
                    }
                };

                speechRecognition.onerror = (event) => {
                    console.error('Speech recognition error', event.error);
                    if (event.error === 'no-speech' && isCallActive && !isMuted) {
                        userSaidSomething = false;
                        speechRecognition.stop();
                    } else if (event.error === 'network' && isCallActive) {
                        callStatusMessage.textContent = 'Network error. Attempting reconnection...';
                        speechRecognition.stop();
                    } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                        callStatusMessage.textContent = 'Microphone access denied. Please allow in browser settings for comms link.';
                        endCall();
                    }
                };
            } else {
                callBtn.style.display = 'none';
                console.warn("Speech Recognition not supported in this browser. Comms link unavailable.");
            }

            function addCallMessage(role, text) {
                const msgEl = document.createElement('div');
                msgEl.className = `call-msg ${role}`;
                msgEl.textContent = text;
                callConversation.appendChild(msgEl);
                callConversation.scrollTop = callConversation.scrollHeight;
            }

            async function handleCallBotResponse() {
                if (!isCallActive) return;
                callStatusMessage.textContent = 'Philadelphia AI processing input...';
                tapToTalk.style.display = 'none';

                let userMessageContent = '';
                if (callHistory.length > 0) {
                    const lastUserMessage = callHistory.slice().reverse().find(m => m.role === 'user');
                    if (lastUserMessage) {
                        userMessageContent = lastUserMessage.content;
                    }
                }

                const historyForBotAPI = callHistory.filter(m => m.role !== 'status').map(m => ({
                    role: m.role,
                    content: m.content
                }));

                try {
                    speechRecognition.stop();

                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: userMessageContent, history: historyForBotAPI.slice(0, -1), user_id: currentUser?.uid || "user" })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "Server error.");

                    const botResponseFullText = data.response;
                    
                    // --- Blunt Bot Response Logic for Call UI ---
                    let botDisplayMessage = botResponseFullText;
                    if (botResponseFullText.startsWith('Tool execution:')) {
                        const matchOutput = botResponseFullText.match(/"output":\s*"(.*?)"/);
                        if (matchOutput && matchOutput[1]) {
                             // Try to use a clean output string if available
                            botDisplayMessage = `Tool executed: ${matchOutput[1].replace(/\\n/g, '. ')}`;
                            if (botDisplayMessage.length > 100) botDisplayMessage = botDisplayMessage.substring(0, 97) + '...';
                        } else {
                            botDisplayMessage = "Tool execution initiated. Stand by.";
                        }
                    } else if (botResponseFullText.includes("Tool use:")) {
                         botDisplayMessage = "Consulting AI protocols for request.";
                    } else if (botResponseFullText.includes("Please click here to generate an image") || botResponseFullText.includes("Please click here to generate an image")) {
                        botDisplayMessage = "Visual content generation available. Access tools via main interface.";
                    } else if (botResponseFullText.includes("Download PDF Report")) {
                        botDisplayMessage = "Report generated. Download available via main interface.";
                    } else if (botResponseFullText.includes("Website deployed successfully!")) {
                        botDisplayMessage = "Website deployment successful. Access link via main interface.";
                    } else if (botResponseFullText.includes("<img") || botResponseFullText.includes("<audio") || botResponseFullText.includes("<video")) {
                        botDisplayMessage = "Media content generated. View via main interface.";
                    } else if (botResponseFullText.length > 150) { // Truncate very long text responses for call
                        botDisplayMessage = botResponseFullText.substring(0, 147) + '...';
                    }
                    // --- End Blunt Bot Response Logic ---

                    callHistory.push({ role: 'ai', content: botResponseFullText });
                    addCallMessage('bot', botDisplayMessage);
                    speakBotResponse(botResponseFullText); // Still speak the full detailed response
                } catch (err) {
                    const errorMsg = ` Comms link error: ${err.message}`;
                    addCallMessage('bot', errorMsg);
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Awaiting input... (Tap to Transmit)';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
                    }
                }
            }

            async function speakBotResponse(text) {
                if (!isCallActive) return;
                botIsSpeaking = true;
                botImageContainer.classList.add('speaking');
                callStatusMessage.textContent = 'Philadelphia AI transmitting...';
                try {
                    const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ text: text, voice_id: 'elder' })
                    });
                    if (!res.ok) throw new Error(await res.text());
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    currentAudio = audio;
                    audio.onended = audio.onerror = () => {
                        botIsSpeaking = false;
                        botImageContainer.classList.remove('speaking');
                        currentAudio = null;
                        if (isCallActive && !isMuted) {
                            callStatusMessage.textContent = 'Awaiting input... (Tap to Transmit)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
                        } else if (isMuted) {
                            callStatusMessage.textContent = 'Microphone Muted.';
                            tapToTalk.style.display = 'none';
                        }
                    };
                    audio.play();
                } catch (err) {
                    console.error("Voice synthesis error:", err);
                    botIsSpeaking = false;
                    botImageContainer.classList.remove('speaking');
                    if (isCallActive && !isMuted) {
                        callStatusMessage.textContent = 'Awaiting input (Voice system offline)...';
                        tapToTalk.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
                    } else if (isMuted) {
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                    }
                }
            }

            function stopBotSpeakingAndStartListening() {
                if (!isCallActive) return;
                if (botIsSpeaking && currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                    botIsSpeaking = false;
                    botImageContainer.classList.remove('speaking');
                }
                
                if (!isMuted) {
                    callStatusMessage.textContent = 'Awaiting input... (Tap to Transmit)';
                    tapToTalk.style.display = 'block';
                    try {
                        speechRecognition.stop();
                        speechRecognition.start();
                    } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
                } else {
                    callStatusMessage.textContent = 'Microphone Muted.';
                    tapToTalk.style.display = 'none';
                }
                const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
                if (userMsgEl) userMsgEl.textContent = '';
                userSaidSomething = false;
            }

            callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
            callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);

            callBtn.addEventListener('click', () => {
                if (!SpeechRecognition) {
                    alert("Error: Browser does not support Speech Recognition. Comms link unavailable.");
                    return;
                }
                isCallActive = true;
                isMuted = false;
                muteCallBtn.classList.remove('muted');
                muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute';
                callModal.classList.add('active');
                callConversation.innerHTML = '';
                addCallMessage('status', 'Establishing secure comms link...');
                callStatusMessage.textContent = 'Establishing secure link...';
                tapToTalk.style.display = 'none';
                callHistory = [];
                userSaidSomething = false;
                setTimeout(() => {
                    if (!isCallActive) return;
                    addCallMessage('status', 'Secure comms link established. Transmit when ready.');
                    callStatusMessage.textContent = 'Awaiting input... (Tap to Transmit)';
                    tapToTalk.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) { console.error("Speech recognition start failed", e); callStatusMessage.textContent = 'Microphone error. Check permissions.'; }
                }, 1500);
            });

            function endCall() {
                isCallActive = false;
                botIsSpeaking = false;
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }
                callModal.classList.remove('active');
                try { speechRecognition.stop(); } catch(e) {}
                botImageContainer.classList.remove('speaking');
                tapToTalk.style.display = 'none';
                callStatusMessage.textContent = 'Comms link terminated.';
            }

            endCallBtn.addEventListener('click', endCall);

            if (muteCallBtn) {
                muteCallBtn.addEventListener('click', () => {
                    isMuted = !isMuted;
                    if (isMuted) {
                        muteCallBtn.classList.add('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute';
                        speechRecognition.stop();
                        callStatusMessage.textContent = 'Microphone Muted.';
                        tapToTalk.style.display = 'none';
                    } else {
                        muteCallBtn.classList.remove('muted');
                        muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute';
                        if (isCallActive && !botIsSpeaking) {
                            callStatusMessage.textContent = 'Awaiting input... (Tap to Transmit)';
                            tapToTalk.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
                        } else if (isCallActive && botIsSpeaking) {
                            callStatusMessage.textContent = 'Philadelphia AI transmitting...';
                            tapToTalk.style.display = 'none';
                        }
                    }
                });
            }

            if(chatInput) chatInput.focus();
        });
    </script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
 window.dataLayer = window.dataLayer || [];
 function gtag(){dataLayer.push(arguments);}
 gtag('js', new Date()); 

 gtag('config', 'G-J1YTKP10ZX');
</script>
