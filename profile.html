<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Philadelphia AI Chat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <!-- Preconnect to Google Fonts for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Combined Font Imports for efficiency -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <!-- Highlight.js for Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
</head>
<body>
    <div id="app-container">
        <!-- Background Stars Effect -->
        <div id="stars-container" aria-hidden="true"></div>

        <!-- Main Header Bar -->
        <header class="header-bar">
            <button class="menu-btn" id="openProfileMenu" aria-label="Open profile menu">
                <i class="fa-solid fa-user"></i>
            </button>
            <div class="header-titles">
                <h1 class="site-heading">ðŸ¦…Philadelphia AIðŸ¦…</h1>
                <p class="header-welcome" id="headerWelcome" aria-live="polite">Welcome, User</p>
            </div>
            <button class="menu-btn" id="themeBtn" aria-label="Change theme">
                <i class="fa-solid fa-moon"></i>
            </button>
            <button class="menu-btn" id="openLinksMenu" aria-label="Open links menu">
                <i class="fa-solid fa-link"></i>
            </button>
        </header>

        <!-- Main Content Area (Chat, Tools, etc.) -->
        <main class="main-content">
            <!-- Chat Display Box -->
            <section class="chat-box" id="chatBox" aria-live="polite" aria-atomic="false"></section>

            <!-- AI Typing Indicator -->
            <div id="typing-status" class="chat-message ai" style="display: none;"></div>

            <!-- Chat Input Form -->
            <form class="chat-input-row" id="chatForm" autocomplete="off" aria-label="Chat input">
                <button type="button" id="emojiBtn" title="Emoji" aria-label="Open emoji panel">
                    <i class="fa-regular fa-face-smile"></i>
                </button>
                <label for="chatFile" class="file-upload-btn" title="Attach file" aria-label="Attach file">
                    <i class="fa-solid fa-paperclip"></i>
                </label>
                <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
                <textarea id="chatInput" placeholder="Type hereâ€¦ (Shift+Enter = new line)" aria-label="Chat message input"></textarea>
                <button type="button" id="callBtn" title="Start Voice Call" aria-label="Start voice call">
                    <i class="fa-solid fa-phone"></i>
                </button>
                <button type="button" id="toolBtn" title="Philadelphia Tools" aria-controls="toolMenu" aria-expanded="false" aria-label="Open AI tools menu">
                    <i class="fa-solid fa-wrench"></i>
                </button>
                <button type="submit" id="sendBtn" title="Send" aria-label="Send message">
                    <i class="fa-solid fa-paper-plane"></i>
                </button>
            </form>
        </main>

        <!-- Status Message (e.g., "File uploaded") -->
        <div class="status-message" id="statusMsg" aria-live="assertive"></div>

        <!-- File Preview for Uploaded Files -->
        <div id="filePreview" class="file-preview" style="display:none;" aria-relevant="additions removals" aria-live="polite"></div>

        <!-- Emoji Picker Panel -->
        <div id="emojiPanel" style="display:none;" role="menu" aria-label="Emoji picker"></div>

        <!-- AI Image Preview Pop-up -->
        <div id="ai-image-preview" class="ai-image-preview-modal" style="display:none;" role="dialog" aria-labelledby="ai-image-title">
            <h2 id="ai-image-title" class="sr-only">AI Generated Image Preview</h2>
            <button id="ai-image-close" class="close-btn" aria-label="Close image preview">&times;</button>
            <div id="ai-image-container"></div>
            <button id="ai-image-dl" class="submit-btn" aria-label="Download image">Download</button>
        </div>

        <!-- Modals & Side Panels -->
        <div class="panel-bg" id="profileMenuBg" aria-hidden="true" tabindex="-1">
            <nav class="side-panel" id="profileMenu" role="dialog" aria-labelledby="profile-menu-heading">
                <div class="panel-header-flex">
                    <h2 id="profile-menu-heading" class="panel-title">Chats</h2>
                    <button class="close-btn" onclick="profileMenuBg.classList.remove('active');" aria-label="Close chat list">&times;</button>
                </div>
                <div id="chatsList" class="chats-list" role="list" aria-label="Your chats">
                    <div class="spinner" aria-label="Loading chats"></div>
                </div>
                <button id="newChatBtn" class="submit-btn full-width" aria-label="Start a new chat">
                    <i class="fa-solid fa-plus"></i> New Chat
                </button>
                <hr class="panel-divider">
                <div class="panel-header">
                    <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo" class="profile-avatar">
                    <div class="username" id="profileMenuUser">User</div>
                    <div class="email" id="profileMenuEmail">email@example.com</div>
                </div>
                <form class="edit-form" id="profileForm" autocomplete="off" aria-label="Edit profile form">
                    <label for="edit-name">Name</label>
                    <input type="text" id="edit-name" required aria-required="true">
                    <label for="edit-photo">Photo URL</label>
                    <input type="url" id="edit-photo" placeholder="Paste image link">
                    <span class="tip-text">
                        Tip: <a href="https://postimg.cc/" target="_blank" rel="noopener noreferrer" class="external-link">Upload at postimg.cc</a>
                    </span>
                    <button type="submit" class="submit-btn full-width">Save Profile</button>
                    <div class="status-message" id="profileStatusMsg" aria-live="polite"></div>
                </form>
                <button class="submit-btn logout-btn full-width" id="logoutBtn" aria-label="Logout from account">Logout</button>
            </nav>
        </div>

        <div class="panel-bg" id="linkMenuBg" aria-hidden="true" tabindex="-1">
            <nav class="side-panel" id="linkMenu" role="dialog" aria-labelledby="link-menu-heading">
                <div class="panel-header-flex">
                    <h2 id="link-menu-heading" class="panel-title">Navigation</h2>
                    <button class="close-btn" onclick="linkMenuBg.classList.remove('active');" aria-label="Close navigation menu">&times;</button>
                </div>
                <div class="panel-links" role="menu">
                    <a href="philadelphia.html" role="menuitem"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a>
                    <a href="index.html" role="menuitem"><i class="fa-solid fa-home"></i>Elvion Homepage</a>
                    <a href="about.html" role="menuitem"><i class="fa-solid fa-circle-info"></i> About US</a>
                    <a href="privacy.html" role="menuitem"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
                    <a href="terms.html" role="menuitem"><i class="fa-solid fa-file-contract"></i> Terms</a>
                    <a href="https://t.me/writingurubot" target="_blank" rel="noopener noreferrer" role="menuitem"><i class="fab fa-telegram"></i> Try Telegram Version</a>
                </div>
            </nav>
        </div>

        <div class="panel-bg" id="toolsMenuBg" aria-hidden="true" tabindex="-1">
            <nav class="side-panel" id="toolsMenu" role="dialog" aria-labelledby="tools-menu-heading">
                <div class="panel-header-flex">
                    <h2 id="tools-menu-heading" class="panel-title">Philadelphia AI Tools</h2>
                    <button class="close-btn" onclick="toolsMenuBg.classList.remove('active');" aria-label="Close tools menu">&times;</button>
                </div>
                <div class="panel-links" role="menu">
                    <h3 class="panel-section-title">Creative Suite</h3>
                    <a href="#" class="tool-link" data-tool="image" role="menuitem"><i class="fa-solid fa-image"></i> Generate Image</a>
                    <a href="#" class="tool-link" data-tool="edit-photo" role="menuitem"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
                    <a href="#" class="tool-link" data-tool="remove-bg" role="menuitem"><i class="fa-solid fa-scissors"></i> Remove Background</a>
                    <a href="#" class="tool-link" data-tool="comic" role="menuitem"><i class="fa-solid fa-book-open"></i> Create Comic</a>
                    <hr class="panel-divider">
                    <h3 class="panel-section-title">Audio & Video</h3>
                    <a href="#" class="tool-link" data-tool="voice-gen" role="menuitem"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
                    <a href="#" class="tool-link" data-tool="audio-narration" role="menuitem"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
                    <a href="#" class="tool-link" data-tool="video-text" role="menuitem"><i class="fa-solid fa-film"></i> Text-to-Video</a>
                    <a href="#" class="tool-link" data-tool="video-image" role="menuitem"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
                    <a href="#" class="tool-link" data-tool="music" role="menuitem"><i class="fa-solid fa-music"></i> Generate Music</a>
                    <hr class="panel-divider">
                    <h3 class="panel-section-title">Web & Research</h3>
                    <a href="#" class="tool-link" data-tool="website" role="menuitem"><i class="fa-solid fa-globe"></i> Create Website</a>
                    <a href="#" class="tool-link" data-tool="edit-website" role="menuitem"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
                    <a href="#" class="tool-link" data-tool="my-sites" role="menuitem"><i class="fa-solid fa-list-check"></i> My Websites</a>
                    <a href="#" class="tool-link" data-tool="research-report" role="menuitem"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
                </div>
                <button class="submit-btn full-width" onclick="closeToolMenu();" aria-label="Close tools menu">Close</button>
            </nav>
        </div>

        <div class="panel-bg" id="toolFormModalBg" aria-hidden="true" tabindex="-1">
            <nav class="side-panel" id="toolFormModal" role="dialog" aria-labelledby="tool-form-title">
                <div class="panel-header-flex">
                    <h2 id="tool-form-title" class="panel-title">Tool Title</h2>
                    <button class="close-btn" onclick="toolFormModalBg.classList.remove('active'); openToolMenu();" aria-label="Close tool form">&times;</button>
                </div>
                <form class="edit-form" id="toolForm" aria-label="Tool options form"></form>
                <button id="toolFormBackBtn" class="submit-btn secondary-btn full-width" aria-label="Back to tools list">
                    <i class="fa-solid fa-arrow-left"></i> Back to Tools
                </button>
                <div class="status-message" id="toolStatusMsg" aria-live="polite"></div>
            </nav>
        </div>

        <!-- Image Lightbox Modal -->
        <div id="lightbox" class="lightbox" style="display: none;" role="dialog" aria-modal="true" aria-label="Image preview">
            <img src="" alt="Lightbox image" />
        </div>

        <!-- Voice Call Modal -->
        <div id="callModal" class="call-modal" style="display: none;" role="dialog" aria-modal="true" aria-labelledby="callHeader">
            <h2 id="callHeader">Philadelphia AI - Live Call</h2>
            <div id="botImageContainer" class="bot-image-container">
                <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="AI Bot Avatar">
                <div id="botSpeakingIndicator" class="bot-speaking-indicator"></div>
            </div>
            <p id="callStatusMessage" class="call-status-message" aria-live="polite">Connecting...</p>
            <p id="tapToTalk" class="tap-to-talk-message" style="display: none;" aria-live="polite">Tap Anywhere to Speak</p>
            <div id="callConversation" class="call-conversation" aria-live="polite" aria-atomic="false">
                <div class="call-msg status">Waiting for connection...</div>
            </div>
            <div id="callControls" class="call-controls">
                <button id="muteCallBtn" class="submit-btn" aria-label="Mute microphone">
                    <i class="fa-solid fa-microphone"></i> Mute Microphone
                </button>
                <button id="endCallBtn" class="submit-btn error-btn" aria-label="End call">
                    <i class="fa-solid fa-phone-slash"></i> End Call
                </button>
            </div>
        </div>
    </div>

    <!-- Consolidated Styles -->
    <style>
        :root {
            /* Default Cyber Theme */
            --color-primary: #00fff7;
            --color-secondary: #0a8afe;
            --color-background-dark: #070b1a;
            --color-fade-blue: #133c8b;
            --gradient-main: linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%);
            --gradient-user: linear-gradient(120deg, #0857ee 32%, #00fff0 89%);
            --chat-bubble-glow: 0 0 13px #00d8ffb1, 0 0 24px #0197ff40;
            --user-bubble-glow: 0 0 22px #0fffd555, 0 0 14px #36f9ff70;
            --header-bg: rgba(17, 29, 47, 0.92);
            --code-bg: linear-gradient(92deg, #031d39 79%, #092ff8 120%);
            --code-border: #15faff;
            --code-text: #17fafd;
            --text-main: #e1fafe;
            --text-link: #13efff;
            --input-bg: #09284c;
            --body-bg-gradient-1: radial-gradient(circle at 60% 45%, #112250 37%, #060e1e 88%, #1e0942 100%) fixed;
            --body-bg-gradient-2: repeating-linear-gradient(100deg, #061c4c 0 9%, #080e20 16% 19%, #030721 30% 41%, #052650 44% 62%, #050b16 74% 89%, #041048 99% 100%);
            --body-blend-mode: lighten, color-dodge;
            --panel-bg: linear-gradient(118deg, #131642 80%, #1629af 200%);
            --panel-border: #00fbffcb;
            --panel-shadow: 0 0 42px #25f8ffc9;
            --submit-button-bg: linear-gradient(94deg, #00ffff, #0090ff 90%);
            --submit-button-text: #102649;
            --submit-button-hover-bg: #008cff;
            --submit-button-hover-text: #fff;
            --header-text-glow: 0 0 12px #00ffe0cc, 0 0 27px #178fcf88;
            --header-text-anim-glow-1: 0 0 17px #00e7ff70, 0 0 30px #0b8fff44;
            --header-text-anim-glow-2: 0 0 29px #00ffe9ee, 0 0 44px #31d2ff82;
            --header-text-fill: linear-gradient(90deg, #00fff1, #00b4ff 40%, #fff 59%, #1093f1 89%, #24e0fa 100%);
        }

        /* Base Styles */
        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            color: var(--text-main);
            background: var(--body-bg-gradient-1), var(--body-bg-gradient-2);
            background-blend-mode: var(--body-blend-mode);
            font-family: 'Roboto', 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            transition: background 0.3s ease;
            overflow: hidden; /* Ensure no scrollbars on body */
        }

        /* Accessibility: Screen Reader Only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        /* App Container for Full Viewport */
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Prevent scrolling here */
        }

        /* Star Background Effect */
        #stars-container {
            pointer-events: none;
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            overflow: hidden;
        }

        .star {
            position: absolute;
            background: var(--color-primary);
            box-shadow: 0 0 12px var(--color-primary), 0 0 22px var(--color-primary);
            opacity: 0.23;
            border-radius: 50%;
            pointer-events: none;
            animation: star-twinkle 2.7s infinite alternate;
        }

        @keyframes star-twinkle {
            0% { opacity: .18; }
            41% { opacity: .88; }
            100% { opacity: .09; }
        }

        /* Header Bar */
        .header-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--header-bg);
            z-index: 1003;
            padding: 0;
            box-shadow: 0 7px 48px #00aaff27, 0 3px 41px #09fcfe15;
            border-radius: 0 0 22px 22px;
            height: 70px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        .header-titles {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            margin: 0 10px; /* Space from buttons */
        }

        .menu-btn {
            background: none;
            border: none;
            color: var(--color-primary);
            font-size: 2em;
            cursor: pointer;
            border-radius: 14px;
            margin: 0 5px; /* Adjust margin */
            padding: 7px 11px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-btn:hover {
            background: #00eaff28;
            color: #fff;
        }

        #themeBtn {
            font-size: 1.6em;
            padding: 7px 12px;
            margin-left: -10px;
        }

        .site-heading {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.28em;
            font-weight: 700;
            text-align: center;
            letter-spacing: .27px;
            white-space: nowrap;
            background: var(--header-text-fill);
            background-size: 250% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: neonglow 4.2s ease-in-out infinite alternate;
            text-shadow: var(--header-text-glow);
            user-select: none;
            margin: 0; /* Reset default margin */
            padding: 0;
        }

        @keyframes neonglow {
            0% { text-shadow: var(--header-text-anim-glow-1); }
            100% { text-shadow: var(--header-text-anim-glow-2); }
        }

        .header-welcome {
            color: #68e6fd;
            font-size: .97em;
            margin-top: 5px; /* Adjust spacing */
            text-align: center;
            text-shadow: 0 0 14px #00bcb4a8;
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow-y: hidden;
            position: relative;
            padding-top: 70px; /* Space for the header */
            padding-bottom: 86px; /* Space for the input row */
            box-sizing: border-box;
        }

        /* Chat Box */
        .chat-box {
            flex: 1 1 0px;
            overflow-y: auto;
            overflow-x: hidden;
            width: 100vw;
            max-width: 635px;
            margin: 0 auto;
            box-sizing: border-box;
            padding: 15px 8px;
            position: relative;
            z-index: 3;
            scroll-behavior: smooth;
            display: flex;
            flex-direction: column;
        }

        /* AI Typing Indicator */
        #typing-status {
            display: none; /* Hidden by default */
            max-width: 635px;
            margin: 0 auto;
            padding: 0 8px 10px 8px; /* Added bottom padding */
            width: 100vw;
            box-sizing: border-box;
            flex-shrink: 0;
            min-height: 20px;
        }

        .chat-message {
            width: 100%;
            display: flex;
            gap: 9px;
            align-items: flex-end;
            margin: 8px 0;
            max-width: 100vw;
            flex-shrink: 0;
        }

        .chat-message .msg {
            font-size: 1.01em;
            line-height: 1.58;
            max-width: 62vw;
            min-width: 0;
            padding: 11px 16px 12px 15px;
            border-radius: 16px 14px 11px 12px;
            word-break: break-word;
            white-space: pre-wrap;
            overflow-x: auto;
            background: var(--gradient-main);
            color: var(--text-main);
            text-shadow: 0 0 3px #23d8ff15;
            box-shadow: var(--chat-bubble-glow);
            margin-right: auto;
            margin-left: 0;
            border: 1.2px solid #0090ffa0;
            position: relative;
            transition: background .3s, color .3s, box-shadow .3s;
        }

        .chat-message.user {
            justify-content: flex-end;
        }

        .chat-message.user .msg {
            background: var(--gradient-user);
            color: var(--submit-button-text);
            font-weight: 700;
            text-shadow: 0 0 5px #00e0ff77, 0 0 2px #00ffe033;
            border-radius: 17px 13px 15px 11px;
            margin-left: auto;
            margin-right: 0;
            box-shadow: var(--user-bubble-glow);
            border: 1.2px solid #04eef4c9;
            max-width: 68vw;
        }

        /* Typing Indicator Animation */
        .typing-bubble {
            display: inline-flex;
            align-items: center;
            height: 28px;
            padding: 4px 12px;
            margin: 6px 4px;
            border-radius: 15px;
            background: linear-gradient(90deg, #0a4477dd 30%, #0ebfff88 95%);
            box-shadow: 0 2px 12px #0dfcff77;
            border: 1px solid #00ffff55;
        }

        .dot-anim {
            display: inline-block;
            width: 8px;
            height: 8px;
            margin: 0 3px;
            background: var(--color-primary);
            border-radius: 50%;
            opacity: 0.85;
            animation: typing-blink 1.4s infinite both;
            box-shadow: 0 0 6px var(--color-primary);
        }

        .dot-anim:nth-child(2) { animation-delay: .3s; }
        .dot-anim:nth-child(3) { animation-delay: .6s; }

        @keyframes typing-blink {
            0%, 100% { opacity: .25; transform: scale(0.8); }
            25% { opacity: .95; transform: scale(1.1); }
            50% { opacity: 1; transform: scale(1.2); }
            75% { opacity: .65; transform: scale(1); }
        }

        /* Code Blocks */
        pre, code {
            font-family: 'JetBrains Mono', 'Fira Mono', 'Menlo', monospace;
            font-size: .99em;
            background: var(--code-bg);
            border-radius: 11px;
            border: 1.7px solid var(--code-border);
            color: var(--code-text);
            box-shadow: 0 0 19px #00eaff38, 0 0 48px #0beaff38 inset;
            transition: background 0.3s, border-color 0.3s, color 0.3s;
        }

        pre {
            overflow-x: auto;
            padding: 1.18em 1.3em 1.16em 1.13em;
            margin: 1.15em 0 1em 0;
            position: relative;
        }

        pre:before {
            content: "CODE";
            color: var(--color-primary);
            font-size: 0.82em;
            font-family: 'Orbitron', monospace;
            position: absolute;
            top: 5px;
            right: 29px;
            opacity: 0.17;
            letter-spacing: 0.13em;
            pointer-events: none;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 13px;
            z-index: 3;
            border-radius: 8px;
            border: none;
            padding: 3px 15px;
            background: linear-gradient(95deg, #0cf3ff 40%, #0980ff 120%);
            color: #06182f;
            font-size: .98em;
            font-family: 'Inter';
            font-weight: bold;
            box-shadow: 0 2px 9px #18e3ffc5, 0 0 7px #00ffd7a4;
            transition: background .15s, color .15s;
            cursor: pointer;
            outline: none;
            border: 1px solid #0cf3ff35;
        }

        .copy-btn:hover {
            background: #008cee;
            color: #fff;
        }

        /* Inline Message Controls */
        .inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn {
            padding: 4px 10px;
            border-radius: 7px;
            border: none;
            background: var(--submit-button-bg);
            color: var(--submit-button-text);
            font-family: 'Inter', Arial, sans-serif;
            font-size: .96em;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-top: 6px;
            margin-right: 3px;
            cursor: pointer;
            box-shadow: 0 2px 7px #17f6fe51;
            transition: background .14s, color .13s;
        }

        .inline-copy-btn:hover, .inline-share-btn:hover, .regen-btn:hover, .inline-edit-btn:hover {
            background: var(--submit-button-hover-bg);
            color: var(--submit-button-hover-text);
        }

        /* Media Previews in Chat */
        .file-attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 8px 0;
            max-width: 100%;
        }

        .chat-media-preview {
            max-width: 100%;
            max-height: 250px;
            border-radius: 12px;
            display: block;
        }

        .image-preview-thumb, .video-preview-thumb {
            border: 2px solid var(--color-primary);
            box-shadow: 0 0 10px var(--color-primary);
        }

        /* Make AI images clickable */
        .chat-message.ai .msg img.chat-media-preview {
            cursor: zoom-in;
        }

        .audio-preview-thumb {
            width: 90%;
            min-height: 40px;
            border-radius: 10px;
        }

        .file-link, .file-placeholder {
            display: inline-block;
            padding: 8px 12px;
            background: #0b2447;
            border: 1px solid #1af8ff51;
            border-radius: 10px;
            color: var(--color-primary);
            text-decoration: none;
            font-size: 0.9em;
            font-weight: bold;
        }

        .file-link i, .file-placeholder i {
            margin-right: 5px;
        }

        /* File Preview at Bottom */
        .file-preview {
            display: none;
            background: rgba(15, 36, 65, 0.98);
            border-radius: 12px;
            color: #c4f2ff;
            font-size: .98em;
            box-shadow: 0 3px 15px #00aac0bb;
            margin: 0 auto 10px auto;
            width: 94vw;
            max-width: 520px;
            padding: 10px 14px 10px 15px;
            position: fixed;
            bottom: 100px; /* Above the input row */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            border: 1.5px solid #00ffff44;
        }

        .file-preview img, .file-preview video {
            max-width: 58px;
            max-height: 41px;
            border-radius: 6px;
            margin-right: 6px;
            vertical-align: middle;
        }

        .file-preview audio {
            width: 52px;
            margin-right: 7px;
        }

        .remove-file-btn {
            color: #fff !important;
            background: #d23 !important;
            border: none !important;
            border-radius: 50% !important;
            padding: 2px 6px !important;
            cursor: pointer !important;
            font-size: 1.2em !important;
            font-weight: bold !important;
            margin-left: 8px !important;
            transition: background .16s, color .16s !important;
            min-width: 24px !important;
            height: 24px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .remove-file-btn:hover {
            background: #ff4444 !important;
            color: #fff !important;
            transform: scale(1.1) !important;
        }

        /* Chat Input Row */
        .chat-input-row {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 0;
            display: flex;
            align-items: stretch;
            gap: 8px;
            background: rgba(17, 29, 47, 0.94);
            backdrop-filter: blur(8px);
            border: 1.5px solid #1af8ff51;
            border-radius: 23px 23px 0 0;
            width: 95vw;
            max-width: 900px;
            padding: 9px 12px 10px 13px;
            box-shadow: 0 0 39px #007fff22, 0 11px 33px #00fff014;
            z-index: 1003;
        }

        .chat-input-row textarea {
            flex: 1 1 auto;
            resize: none;
            min-height: 36px;
            max-height: 120px;
            background: var(--input-bg);
            color: var(--text-main);
            font-size: 1em;
            padding: 10px 12px;
            border: none;
            border-radius: 11px;
            box-shadow: 0 1px 6px #00f2ff27;
            transition: background 0.3s, color 0.3s;
        }

        .chat-input-row button, .chat-input-row label {
            background: none;
            border: none;
            color: var(--color-primary);
            font-size: 1.21em;
            cursor: pointer;
            border-radius: 10px;
            transition: color .13s, background .15s;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 33px;
            box-shadow: 0 0 3px #00eaff20;
        }

        .chat-input-row button:hover, .chat-input-row label:hover {
            color: #fff;
            background: #00cdf247;
        }

        #callBtn {
            font-size: 1.1em;
        }

        #stopBtn {
            background: #ff4d4d;
            color: white;
            font-size: 1.2em;
            border-radius: 10px;
            padding: 0;
            min-width: 33px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px #ff4d4d88;
            transition: background .1s, color .1s;
        }

        #stopBtn:hover {
            background: #ff7777;
        }

        /* Emoji Panel */
        #emojiPanel {
            display: none;
            position: fixed;
            left: 10px;
            bottom: 110px;
            z-index: 2222;
            background: #051f46f9;
            border-radius: 15px;
            padding: 16px 15px 12px 15px;
            box-shadow: 0 5px 22px #00fff194;
            border: 1px solid #00ffff66;
            flex-wrap: wrap; /* Allow emojis to wrap */
            gap: 5px; /* Spacing between emojis */
        }

        .emoji-pick {
            font-size: 1.23em;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 10px;
            transition: background .13s;
            user-select: none;
            display: inline-block; /* Ensure proper spacing */
        }

        .emoji-pick:hover {
            background: #35cdfd66;
        }

        /* Status Messages */
        .status-message {
            padding: 6px 13px;
            color: #12ffc7;
            font-size: .98em;
            min-height: 17px;
            text-align: center;
            margin: 4px auto 0 auto;
            max-width: 430px;
            word-break: break-word;
        }

        /* Panel Overlay Background */
        .panel-bg {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(13, 20, 52, 0.86);
            z-index: 1200;
        }

        .panel-bg.active {
            display: block;
        }

        /* Side Panels */
        .side-panel {
            position: fixed; /* Changed from absolute for better modal behavior */
            top: 0;
            left: -350px; /* Start off-screen */
            height: 100vh;
            width: 325px;
            background: var(--panel-bg);
            border-right: 2.5px solid var(--panel-border);
            box-shadow: var(--panel-shadow);
            z-index: 1212;
            padding: 18px 16px 20px 15px;
            overflow-y: auto;
            border-radius: 0 24px 32px 0;
            transition: left 0.3s ease-out, background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .panel-bg.active .side-panel {
            left: 0; /* Slide in */
        }

        .side-panel .panel-header {
            text-align: center;
            margin: 18px 0 13px 0;
        }
        .panel-header-flex {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 18px 0 13px 0;
        }
        .panel-title {
            font-size: 1.17em;
            font-weight: 700;
            color: #00ffff;
            margin: 0;
        }
        .close-btn {
            background: transparent;
            border: none;
            color: #f44;
            font-size: 1.55em;
            cursor: pointer;
            border-radius: 7px;
            padding: 3px 8px;
            transition: color 0.1s;
        }
        .close-btn:hover {
            color: #ff8888;
        }


        .profile-avatar {
            width: 56px;
            height: 56px;
            border-radius: 53%;
            margin-bottom: 8px;
            border: 2px solid #31f6ffea;
            object-fit: cover;
        }

        .username {
            font-weight: 700;
            font-size: 1.11em;
            color: #08d0fe;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 8px #00eaffbb;
        }

        .email {
            font-size: .97em;
            color: #a8eaff;
        }

        .panel-links {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px; /* Spacing between links */
        }

        .panel-links a {
            color: var(--text-link);
            text-decoration: none;
            font-weight: 500;
            font-size: 1.08em;
            padding: 8px 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-radius: 9px;
            transition: background .14s;
        }

        .panel-links a:hover {
            background: #00eaff55;
            color: #f4fdff;
        }

        .panel-links a i {
            width: 20px;
            text-align: center;
        }

        /* Chats List in Profile Menu */
        .chats-list {
            margin: 7px 0 8px 6px;
            max-height: 161px;
            overflow-y: auto;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.1);
            padding: 5px;
        }
        .chats-list::-webkit-scrollbar { width: 8px; }
        .chats-list::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
        .chats-list::-webkit-scrollbar-thumb { background: var(--color-primary); border-radius: 10px; }
        .chats-list::-webkit-scrollbar-thumb:hover { background: #00eaff; }

        .chats-list-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            background: transparent;
            border-radius: 8px;
            transition: background 0.15s ease;
        }
        .chats-list-item.selected {
            background: rgba(0, 234, 255, 0.15);
        }

        .chats-list-item-title {
            flex: 1;
            cursor: pointer;
            padding: 8px 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-main);
        }
        .chats-list-item-title:hover {
            color: var(--color-primary);
        }

        .chats-list-item-btn {
            background: none;
            border: none;
            cursor: pointer;
            outline: none;
            font-size: 1.11em;
            margin: 0 5px;
            vertical-align: middle;
            border-radius: 7px;
            padding: 3px 5px;
        }

        .chats-list-item-btn .fa-pen {
            color: #0fe0ee;
            transition: color .13s;
        }
        .chats-list-item-btn .fa-pen:hover {
            color: #ffd800;
        }

        .chats-list-item-btn .fa-trash {
            color: #ff244e;
            transition: color .10s;
        }
        .chats-list-item-btn .fa-trash:hover {
            color: #fff900;
        }

        /* Form Styles in Panels/Modals */
        .edit-form label {
            display: block;
            margin-top: 10px;
            font-size: .99em;
            color: #38e4ff;
            text-shadow: 0 1px 14px #11aaff71;
        }

        .edit-form input, .edit-form textarea, .edit-form select {
            width: calc(100% - 22px); /* Adjust for padding */
            padding: 7px 11px;
            margin-top: 5px;
            border: 1.7px solid #13f0ff95;
            border-radius: 9px;
            background: #071f35;
            color: #fff;
            font-size: 1.02em;
            box-shadow: 0 0 8px #04f6fd81 inset;
            transition: border-color .17s, box-shadow .17s, background 0.17s;
        }

        .edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus {
            border-color: #27eeff;
            background: #273f5d;
            color: #fff;
            outline: none;
        }

        .edit-form textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Submit Buttons */
        .submit-btn {
            margin-top: 14px;
            padding: 10px 20px;
            background: var(--submit-button-bg);
            border: none;
            border-radius: 10px;
            color: var(--submit-button-text);
            font-weight: bold;
            cursor: pointer;
            font-size: 1.11em;
            box-shadow: 0 2px 13px #00fff292;
            transition: background .14s, color .13s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .submit-btn:hover {
            background: var(--submit-button-hover-bg);
            color: var(--submit-button-hover-text);
        }
        .submit-btn.full-width {
            width: 100%;
        }
        .submit-btn.secondary-btn {
            background: #10213b;
            color: #00eefd;
            box-shadow: 0 2px 7px #00eefd66;
        }
        .submit-btn.secondary-btn:hover {
            background: #1a3355;
            color: #fff;
        }
        .submit-btn.error-btn {
            background: #d23;
            box-shadow: 0 0 10px #d2388;
        }
        .submit-btn.error-btn:hover {
            background: #ff4444;
            box-shadow: 0 0 15px #ff4444aa;
        }
        .logout-btn {
             background: #10213b;
             color: #00eefd;
             margin-top: 15px; /* Adjust spacing */
             box-shadow: none; /* Less prominent for logout */
        }
        .logout-btn:hover {
            background: #0056b3;
            color: #fff;
        }

        /* Divider in Panels */
        .panel-divider {
            width: 91%;
            margin: 11px auto 7px auto;
            border: 1px solid #00fff031;
        }

        /* Tip Text */
        .tip-text {
            font-size: 0.83em;
            color: #aae;
            display: block;
            margin: 5px 0 7px 2px;
        }
        .tip-text .external-link {
            color: #19fcff;
            text-decoration: underline;
        }

        /* Panel Section Titles */
        .panel-section-title {
            color: #00aaff;
            margin: 10px 0 5px 4px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* AI Image Preview Modal */
        .ai-image-preview-modal {
            display: none;
            position: fixed;
            z-index: 1210;
            right: 22px;
            bottom: 100px;
            max-width: 320px;
            background: #191a26e9;
            padding: 12px;
            border-radius: 17px;
            box-shadow: 0 2px 19px #00fff2b8;
            flex-direction: column; /* Organize content */
            align-items: center;
        }
        .ai-image-preview-modal .close-btn { /* Reusing close-btn style */
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 1.5em;
            color: var(--color-primary);
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        #ai-image-container img {
            max-width: 210px;
            max-height: 210px;
            border-radius: 12px;
            display: block;
            margin-bottom: 5px;
        }
        #ai-image-container div {
            color: #aee;
            font-size: .95em;
            text-align: center;
        }
        #ai-image-dl {
            margin-top: 9px;
            padding: 7px 20px;
            background: linear-gradient(90deg, #00ffff, #0090ff);
            color: #222;
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 7px #00fff2c7;
            cursor: pointer;
            font-weight: bold;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        #ai-image-dl:hover {
            background: #008cee;
            color: #fff;
        }


        /* Lightbox for images */
        .lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            z-index: 5000;
            justify-content: center;
            align-items: center;
            cursor: zoom-out;
        }

        .lightbox.active {
            display: flex;
        }

        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            border: 2px solid var(--color-primary);
            border-radius: 10px;
            box-shadow: 0 0 50px var(--color-primary);
        }

        /* Voice Call Modal */
        .call-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--color-background-dark);
            z-index: 4000;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            justify-content: space-between; /* Space out content */
        }

        .call-modal.active {
            display: flex;
        }

        #callHeader {
            color: var(--color-primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            text-shadow: 0 0 10px var(--color-primary);
            margin-bottom: 20px;
        }

        .bot-image-container {
            margin-top: 20px;
            position: relative;
        }

        .bot-image-container img {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid var(--color-primary);
            box-shadow: 0 0 30px var(--color-primary);
            transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            object-fit: cover;
        }

        @keyframes head-nod {
            0% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
            100% { transform: translateY(0); }
        }

        @keyframes glow-spread {
            0% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; }
            50% { box-shadow: 0 0 30px #00ff00, 0 0 50px #00ff0088; opacity: 1; }
            100% { box-shadow: 0 0 10px #00ff00; opacity: 0.7; }
        }

        .bot-image-container.speaking img {
            border-color: #00ff00;
            box-shadow: 0 0 30px #00ff00;
            transform: scale(1.05);
            animation: head-nod 1.2s infinite ease-in-out;
        }

        .bot-speaking-indicator {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 160px;
            height: 160px;
            border-radius: 50%;
            border: 5px solid transparent;
            box-shadow: 0 0 20px var(--color-primary);
            animation: pulse 1s infinite;
            display: none;
            z-index: -1;
        }

        .bot-image-container.speaking .bot-speaking-indicator {
            box-shadow: 0 0 30px #00ff00;
            border-color: #00ff00;
            display: block;
            animation: glow-spread 1.7s infinite ease-in-out;
        }

        .call-status-message {
            color: var(--color-primary);
            font-size: 1.1em;
            margin-top: 15px;
            height: 30px;
            text-align: center;
            font-style: italic;
            text-shadow: 0 0 5px #00aaff;
        }

        .tap-to-talk-message {
            color: #ff00ff;
            font-size: 1.2em;
            margin-top: 5px;
            text-shadow: 0 0 8px #ff00ff;
            animation: neon-pulse 1.5s infinite alternate;
            display: none;
        }

        @keyframes neon-pulse {
            from { opacity: 0.7; transform: scale(1.0); }
            to { opacity: 1.0; transform: scale(1.02); }
        }

        @keyframes pulse {
            0% { opacity: 0; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0; transform: scale(1); }
        }

        .call-conversation {
            flex-grow: 1;
            width: 100%;
            max-width: 600px;
            overflow-y: auto;
            margin: 20px 0;
            border: 1px solid var(--color-fade-blue);
            border-radius: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .call-conversation::-webkit-scrollbar { width: 8px; }
        .call-conversation::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 10px; }
        .call-conversation::-webkit-scrollbar-thumb { background: rgba(0,255,247,0.4); border-radius: 10px; }


        .call-msg {
            padding: 8px 12px;
            border-radius: 10px;
            line-height: 1.5;
            word-break: break-word;
            flex-shrink: 0;
        }

        .call-msg.user {
            background: var(--gradient-user);
            color: var(--submit-button-text);
            text-align: right;
            margin-left: auto;
            max-width: 80%;
            box-shadow: 0 0 8px rgba(0, 255, 247, 0.3);
        }

        .call-msg.bot {
            background: var(--gradient-main);
            color: var(--text-main);
            margin-right: auto;
            max-width: 80%;
            box-shadow: 0 0 8px rgba(16, 191, 255, 0.3);
        }

        .call-msg.status {
            text-align: center;
            color: #888;
            font-style: italic;
            background: none;
            font-size: 0.9em;
        }

        .call-controls {
            display: flex;
            gap: 20px;
            padding-bottom: 20px;
            margin-top: auto;
        }

        #muteCallBtn {
            background: #007bff; /* Default blue for unmute */
            box-shadow: 0 0 10px #007bff88;
        }

        #muteCallBtn.muted {
            background: #555; /* Grey when muted */
            box-shadow: none;
        }

        #muteCallBtn.muted:hover {
            background: #777;
        }

        /* Spinner for loading states */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 247, 0.3);
            border-radius: 50%;
            border-top-color: var(--color-primary);
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Media Queries for Responsiveness */
        @media (max-width: 920px) {
            .chat-input-row {
                width: 95vw;
                max-width: 100%;
                left: 50%;
                transform: translateX(-50%);
                border-radius: 22px 22px 8px 8px;
            }
        }

        @media (max-width: 790px) {
            .chat-box {
                max-width: 100vw;
                padding: 15px 4px;
            }
            #typing-status {
                padding: 0 4px 10px 4px;
            }
            .chat-message .msg {
                font-size: .97em;
                padding: 9px 4vw 10px 5vw;
                max-width: 80vw;
            }
            .chat-message.user .msg {
                max-width: 83vw;
            }
            .side-panel {
                width: 280px; /* Smaller on mobile */
            }
            .ai-image-preview-modal {
                right: 10px;
                bottom: 80px;
                max-width: 280px;
                padding: 10px;
            }
        }

        @media (max-width: 500px) {
            .header-bar {
                height: 60px;
            }
            .main-content {
                padding-top: 60px;
            }
            .site-heading {
                font-size: 1.1em;
            }
            .header-welcome {
                font-size: 0.85em;
            }
            .menu-btn {
                font-size: 1.7em;
                padding: 5px 8px;
            }
            #themeBtn {
                font-size: 1.4em;
            }
            .chat-input-row {
                gap: 5px;
                padding: 7px 8px 8px 9px;
            }
            .chat-input-row textarea {
                min-height: 32px;
            }
            .chat-input-row button, .chat-input-row label {
                font-size: 1.1em;
                min-width: 28px;
            }
        }

    </style>

    <!-- Highlight.js and Firebase Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        // --- START OF FULLY REVAMPED & FIRESTORE-INTEGRATED JAVASCRIPT ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        // Firebase Configuration (Replace with your actual config)
        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // API Base URL
        const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

        // --- Global State Management ---
        let chats = []; // Array of {id, name, createdAt}
        let currentChatId = null;
        let currentMessages = []; // Array of {id, role, text, files, createdAt}
        let uploadedFiles = []; // Files selected for the current message
        let currentUser = null;
        let currentController = null; // AbortController for ongoing fetch requests

        // Firestore listener unsubscribers
        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;

        // --- DOM Element Cache ---
        const DOM = {
            $: (id) => document.getElementById(id),
            starsContainer: null,
            profileMenuBg: null, profileMenu: null, linkMenuBg: null, linkMenu: null,
            toolsMenuBg: null, toolsMenu: null, toolBtn: null, logoutBtn: null,
            headerWelcome: null, profileMenuUser: null, profileMenuEmail: null,
            editName: null, editPhoto: null, profilePicPreview: null, profileForm: null,
            chatBox: null, chatForm: null, chatInput: null, sendBtn: null, chatFile: null,
            filePreview: null, newChatBtn: null, chatsListEl: null, emojiPanel: null,
            emojiBtn: null, toolFormModalBg: null, toolForm: null, toolFormTitle: null,
            toolFormBackBtn: null, aiPrevBox: null, aiPrevClose: null, aiPrevDLBtn: null,
            aiPrevImgBox: null, themeBtn: null, lightbox: null, callBtn: null,
            callModal: null, endCallBtn: null, muteCallBtn: null, callConversation: null,
            botImageContainer: null, callStatusMessage: null, tapToTalk: null,
            typingStatus: null, statusMsg: null
        };

        // --- Utility Functions ---

        /** Fetches a DOM element by ID and caches it. */
        const getDomElement = (id) => {
            if (!DOM[id]) {
                DOM[id] = document.getElementById(id);
                if (!DOM[id]) console.warn(`Element with ID "${id}" not found.`);
            }
            return DOM[id];
        };

        /** Escapes HTML special characters. */
        const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

        /** Applies inline markdown formatting (bold, italics, links, inline code). */
        function inlineMarkdown(text = '') {
            let processedText = String(text);
            processedText = processedText.replace(/`([^`]+?)`/g, (_, content) => `<code>${escapeHTML(content)}</code>`);
            processedText = processedText.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            processedText = processedText.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
            processedText = processedText.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            return processedText.replace(/\n/g, '<br>');
        }

        /** Renders markdown including code blocks. */
        function renderMarkdown(text = '') {
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            let html = '';
            let lastIndex = 0;
            text = text || '';

            text.replace(codeBlockRegex, (match, lang, code, offset) => {
                const before = text.slice(lastIndex, offset);
                html += inlineMarkdown(before);
                const language = (lang || '').toLowerCase().trim();
                const safeCode = escapeHTML(code);
                html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safeCode}</code></pre>`;
                lastIndex = offset + match.length;
                return match;
            });

            html += inlineMarkdown(text.slice(lastIndex));
            return { html };
        }

        /** Enhances code blocks with syntax highlighting and copy buttons. */
        function enhanceCodeBlocks(container) {
            if (!container) return;
            container.querySelectorAll('pre').forEach(pre => {
                const codeEl = pre.querySelector('code');
                if (window.hljs && codeEl) {
                    try {
                        hljs.highlightElement(codeEl);
                    } catch (e) {
                        console.warn("Highlight.js failed:", e);
                    }
                }
                const btn = pre.querySelector('.copy-btn');
                if (btn && codeEl) {
                    btn.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard.writeText(codeEl.innerText);
                            const prev = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => btn.textContent = prev, 800);
                        } catch (e) {
                            btn.textContent = 'Failed';
                            setTimeout(() => btn.textContent = 'Copy', 800);
                        }
                    });
                }
            });
        }

        /** Converts a Blob to a Base64 string. */
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        /** Displays a temporary status message to the user. */
        function showStatusMessage(message, isError = false) {
            const statusMsgEl = getDomElement('statusMsg');
            if (!statusMsgEl) return;
            statusMsgEl.textContent = message;
            statusMsgEl.style.color = isError ? '#ff4d4d' : '#12ffc7';
            clearTimeout(statusMsgEl._timer);
            statusMsgEl._timer = setTimeout(() => {
                statusMsgEl.textContent = '';
            }, 3000);
        }

        // --- UI Rendering ---

        /** Renders messages in the chat box. */
        function renderChatBox(messages = []) {
            const chatBoxEl = getDomElement('chatBox');
            if (!chatBoxEl) return;

            chatBoxEl.innerHTML = ''; // Clear existing messages

            (messages || []).forEach((msg) => {
                const div = document.createElement('div');
                div.className = 'chat-message ' + (msg.role === 'user' ? 'user' : 'ai');
                div.setAttribute('data-message-id', msg.id);

                let innerHtml = '';
                if (msg.role === 'user') {
                    const fileHtml = (msg.files || [])
                        .map(file => {
                            let icon = 'fa-file';
                            if (file.type && file.type.startsWith('image/')) icon = 'fa-file-image';
                            else if (file.type && file.type.startsWith('video/')) icon = 'fa-file-video';
                            else if (file.type && file.type.startsWith('audio/')) icon = 'fa-file-audio';
                            else if (file.type && file.type === 'application/pdf') icon = 'fa-file-pdf';
                            return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
                        })
                        .join('');

                    innerHtml = `
                        <div class="msg">
                            ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
                            ${escapeHTML(msg.text || '')}
                            <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                                <button class="inline-edit-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                            </div>
                        </div>`;
                } else {
                    let content;
                    if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video'))) {
                        content = msg.text; // Render raw HTML for tool outputs (like media players)
                    } else {
                        content = renderMarkdown(msg.text || '').html;
                    }

                    innerHtml = `
                        <div class="msg">${content}
                            <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                                <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                                <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                                <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                            </div>
                        </div>`;
                }
                div.innerHTML = innerHtml;
                chatBoxEl.appendChild(div);
            });

            enhanceCodeBlocks(chatBoxEl);
            hookAiMsgControls();
            hookUserMsgControls();

            // Auto-scroll to bottom
            setTimeout(() => {
                chatBoxEl.scrollTop = chatBoxEl.scrollHeight;
            }, 50);
        }

        /** Renders the list of chats in the sidebar. */
        function renderChatsListSidebar() {
            const chatsListEl = getDomElement('chatsList');
            if (!chatsListEl) return;

            chatsListEl.innerHTML = ''; // Clear existing list

            if (chats.length === 0) {
                chatsListEl.innerHTML = `<div style="padding: 10px; color: #a8eaff; text-align: center;">No chats yet.</div>`;
                return;
            }

            chats.forEach((chat) => {
                const container = document.createElement('div');
                container.className = `chats-list-item ${chat.id === currentChatId ? 'selected' : ''}`;
                container.setAttribute('role', 'listitem');

                const titleSpan = document.createElement('span');
                titleSpan.textContent = chat.name || `Chat`;
                titleSpan.className = 'chats-list-item-title';
                titleSpan.onclick = () => {
                    currentChatId = chat.id;
                    subscribeToMessages(currentUser.uid, currentChatId);
                    renderChatsListSidebar(); // Re-render to show selection
                    getDomElement('profileMenuBg')?.classList.remove('active'); // Close menu
                };

                const renameBtn = document.createElement('button');
                renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                renameBtn.title = 'Rename Chat';
                renameBtn.className = 'chats-list-item-btn';
                renameBtn.setAttribute('aria-label', `Rename chat "${chat.name}"`);
                renameBtn.onclick = async (e) => {
                    e.stopPropagation();
                    const newName = prompt("Rename chat:", chat.name);
                    if (newName && newName.trim()) {
                        const chatDocRef = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                        await setDoc(chatDocRef, { name: newName.trim() }, { merge: true });
                    }
                };

                const delBtn = document.createElement('button');
                delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                delBtn.title = 'Delete Chat';
                delBtn.className = 'chats-list-item-btn';
                delBtn.setAttribute('aria-label', `Delete chat "${chat.name}"`);
                delBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!confirm(`Are you sure you want to delete "${chat.name}"? This will delete all messages.`)) return;

                    // Delete all messages in subcollection (batched)
                    const messagesColRef = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                    const messagesSnap = await getDocs(messagesColRef);
                    const batch = writeBatch(db);
                    messagesSnap.docs.forEach(d => batch.delete(d.ref));
                    await batch.commit();

                    // Delete chat doc
                    const chatDocRef = doc(db, 'users', currentUser.uid, 'chats', chat.id);
                    await deleteDoc(chatDocRef);

                    // If deleting current chat, reset
                    if (currentChatId === chat.id) {
                        currentChatId = null;
                    }
                };

                container.appendChild(titleSpan);
                container.appendChild(renameBtn);
                container.appendChild(delBtn);
                chatsListEl.appendChild(container);
            });
        }

        /** Renders the file preview at the bottom of the chat. */
        function renderFilePreview() {
            const filePreviewEl = getDomElement('filePreview');
            const chatFileEl = getDomElement('chatFile');
            if (!filePreviewEl) return;

            if (!uploadedFiles.length) {
                filePreviewEl.style.display = 'none';
                filePreviewEl.innerHTML = '';
                if (chatFileEl) chatFileEl.value = ''; // Clear file input
                return;
            }

            filePreviewEl.style.display = 'block';
            filePreviewEl.innerHTML = uploadedFiles.map((file, idx) => {
                let preview = '';
                if (file.type.startsWith('image/')) {
                    preview = `<img src="${URL.createObjectURL(file)}" alt="Image preview" />`;
                } else if (file.type.startsWith('video/')) {
                    preview = `<video src="${URL.createObjectURL(file)}" controls></video>`;
                } else if (file.type.startsWith('audio/')) {
                    preview = `<audio controls src="${URL.createObjectURL(file)}"></audio>`;
                } else if (file.type === 'application/pdf') {
                    preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`;
                }
                return `
                    <div style="display:flex;align-items:center;gap:7px;margin-bottom:1px;">
                        ${preview}
                        <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span>
                        <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
                    </div>`;
            }).join('');

            filePreviewEl.querySelectorAll('.remove-file-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.getAttribute('data-idx'));
                    uploadedFiles.splice(idx, 1);
                    renderFilePreview();
                });
            });
        }

        /** Displays an AI generated image preview. */
        function showAIImagePreview(base64, caption = '') {
            const aiPrevBox = getDomElement('ai-image-preview');
            const aiPrevImgBox = getDomElement('ai-image-container');
            if (!aiPrevBox || !aiPrevImgBox) return;

            aiPrevImgBox.innerHTML = `
                <img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:210px;max-height:210px;border-radius:12px;display:block;">
                <div style="color:#aee;font-size:.95em;margin-top:3px;text-align:center;">${caption}</div>
            `;
            aiPrevBox.style.display = 'flex'; // Use flex for centering if needed
        }

        // --- Typing Indicator Functions ---

        /** Shows the generic typing indicator (...). */
        function showTypingAtNext() {
            const typingStatusEl = getDomElement('typing-status');
            const chatBoxEl = getDomElement('chatBox');
            if (!typingStatusEl || !chatBoxEl) return;

            typingStatusEl.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span></div>`;
            typingStatusEl.style.display = 'flex';
            chatBoxEl.scrollTop = chatBoxEl.scrollHeight; // Scroll to bottom
        }

        /** Shows the typing indicator with specific text. */
        function showTypingWithText(text) {
            const typingStatusEl = getDomElement('typing-status');
            const chatBoxEl = getDomElement('chatBox');
            if (!typingStatusEl || !chatBoxEl) return;

            typingStatusEl.innerHTML = `<div class="msg" style="display:flex;align-items:center;"><span class="spinner"></span> <span style="margin-left:8px; color:var(--text-main); font-style:italic;">${text}</span></div>`;
            typingStatusEl.style.display = 'flex';
            chatBoxEl.scrollTop = chatBoxEl.scrollHeight; // Scroll to bottom
        }

        /** Hides the typing indicator. */
        function removeTyping() {
            const typingStatusEl = getDomElement('typing-status');
            if (!typingStatusEl) return;
            typingStatusEl.style.display = 'none';
            typingStatusEl.innerHTML = '';
        }

        // --- Typewriter Effect ---

        /** Simulates typing a response into the chat. */
        async function startTypewriter(text, saveToDb = true) {
            const chatBoxEl = getDomElement('chatBox');
            if (!chatBoxEl) return;

            // If text contains media HTML, skip typewriter and add directly
            if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video'))) {
                await addMessageToChat('ai', text); // Save full HTML to DB
                return;
            }

            // Create a temporary message node for the animation
            const div = document.createElement('div');
            div.className = "chat-message ai";
            const msgdiv = document.createElement('div');
            msgdiv.className = 'msg';
            div.appendChild(msgdiv);
            chatBoxEl.appendChild(div);

            let sofar = '';
            const words = text.split(/(\s+)/); // Split on spaces, keeping them

            for (const word of words) {
                if (currentController?.signal.aborted) {
                    text = sofar; // Save the text typed so far
                    break;
                }

                sofar += word;

                // Render the current segment. Only render full code blocks, not partial ones
                let displayHtml;
                if (sofar.includes('```')) {
                    const parts = sofar.split('```');
                    let tempRender = parts.slice(0, parts.length - 1).join('```');
                    if (parts.length % 2 === 0) tempRender += '```'; // Re-add the last separator if we're inside a block
                    displayHtml = renderMarkdown(tempRender).html;
                } else {
                    displayHtml = renderMarkdown(sofar).html;
                }
                msgdiv.innerHTML = displayHtml;

                chatBoxEl.scrollTop = chatBoxEl.scrollHeight; // Scroll to keep up with typing

                const delay = word.match(/[\s\.\,\!\?]/) ? 10 : 30; // Faster for symbols/spaces, slower for words
                await new Promise(res => setTimeout(res, delay));
            }

            // Final rendering with controls
            msgdiv.innerHTML = renderMarkdown(text).html + `
                <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
                    <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
                    <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
                    <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
                </div>`;
            enhanceCodeBlocks(msgdiv);
            chatBoxEl.scrollTop = chatBoxEl.scrollHeight;

            // Save the final message to Firestore if needed
            if (saveToDb) {
                const messagesColRef = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
                try {
                    await addDoc(messagesColRef, { role: 'ai', text: text, createdAt: serverTimestamp() });
                } catch (e) {
                    console.error("Error saving AI message: ", e);
                    msgdiv.innerHTML += "<br><small style='color: #f44;'>Failed to save message.</small>";
                }
            }
        }

        // --- Chat Interaction Handlers ---

        /** Adds a message to the current chat in Firestore. */
        async function addMessageToChat(role, text, files = []) {
            if (!currentChatId || !currentUser) return;

            const messagesColRef = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            try {
                await addDoc(messagesColRef, { role, text, files, createdAt: serverTimestamp() });
            } catch (e) {
                console.error("Error adding message to Firestore: ", e);
                showStatusMessage('Failed to save message.', true);
            }
        }

        /** Deletes a message and all subsequent messages from Firestore. */
        async function deleteMessagesFrom(messageId) {
            if (!currentChatId || !currentUser) return;

            const msgIndex = currentMessages.findIndex(m => m.id === messageId);
            if (msgIndex === -1) return;

            const batch = writeBatch(db);
            const messagesColRef = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');

            for (let i = msgIndex; i < currentMessages.length; i++) {
                const msgToDel = currentMessages[i];
                const docRef = doc(messagesColRef, msgToDel.id);
                batch.delete(docRef);
            }

            try {
                await batch.commit();
                showStatusMessage('Messages deleted.');
            } catch (e) {
                console.error("Error deleting messages: ", e);
                showStatusMessage('Failed to delete messages.', true);
            }
        }

        /** Attaches event listeners to AI message controls (copy, share, regenerate). */
        function hookAiMsgControls() {
            const chatBoxEl = getDomElement('chatBox');
            if (!chatBoxEl) return;

            chatBoxEl.querySelectorAll('.chat-message.ai').forEach(div => {
                const messageId = div.getAttribute('data-message-id');
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;

                const controls = div.querySelector('.ai-msg-controls');
                if (!controls) return;

                const copyBtn = controls.querySelector('.inline-copy-btn');
                const shareBtn = controls.querySelector('.inline-share-btn');
                const regenBtn = controls.querySelector('.regen-btn');

                if (copyBtn) copyBtn.onclick = () => {
                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.text;
                        const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                        navigator.clipboard.writeText(textToCopy);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                    } catch (e) {
                        console.warn('Copy failed:', e);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Failed";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                    }
                };

                if (shareBtn) shareBtn.onclick = () => {
                    try {
                        const url = window.location.origin;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.text;
                        const plainText = tempDiv.textContent || tempDiv.innerText || '';
                        const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;
                        if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
                        else prompt("Copy and share manually:", shareText);
                    } catch (e) {
                        console.warn('Share failed:', e);
                    }
                };

                if (regenBtn) regenBtn.onclick = async () => {
                    const msgIndex = currentMessages.findIndex(m => m.id === messageId);
                    if (msgIndex < 1) return; // Cannot regenerate the very first message
                    const userMsg = currentMessages[msgIndex - 1];
                    if (userMsg.role !== 'user') return; // Preceding message must be from user

                    await deleteMessagesFrom(messageId); // Delete AI message and subsequent ones

                    const chatInputEl = getDomElement('chatInput');
                    if (chatInputEl) {
                        chatInputEl.value = userMsg.text; // Load user's message into input
                        chatInputEl.style.height = 'auto';
                        chatInputEl.style.height = Math.min(chatInputEl.scrollHeight, 168) + 'px';
                    }

                    uploadedFiles = []; // Clear current files
                    renderFilePreview();

                    showTypingAtNext();

                    // Build history for regeneration (all messages *before* the user's prompt)
                    const historyForRegen = currentMessages
                        .slice(0, msgIndex - 1)
                        .map(m => ({ role: m.role, content: m.text || '' }));

                    try {
                        currentController = new AbortController();
                        const signal = currentController.signal;

                        const res = await fetch(`${API_BASE_URL}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: userMsg.text, history: historyForRegen, user_id: currentUser?.uid || "user" }),
                            signal
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || "Server error.");

                        removeTyping();
                        await startTypewriter(data.response, true); // Typewriter effect for regen, save to DB
                    } catch (err) {
                        removeTyping();
                        await startTypewriter(err.name === 'AbortError' ? 'âŒ Regeneration stopped.' : `âŒ Regeneration error: ${err.message}`, false);
                    } finally {
                        currentController = null;
                    }
                };
            });
        }

        /** Attaches event listeners to User message controls (copy, edit). */
        function hookUserMsgControls() {
            const chatBoxEl = getDomElement('chatBox');
            if (!chatBoxEl) return;

            chatBoxEl.querySelectorAll('.chat-message.user').forEach(div => {
                const messageId = div.getAttribute('data-message-id');
                const msg = currentMessages.find(m => m.id === messageId);
                if (!msg) return;

                const controls = div.querySelector('.user-msg-controls');
                if (!controls) return;

                const copyBtn = controls.querySelector('.inline-copy-btn');
                const editBtn = controls.querySelector('.inline-edit-btn');

                if (copyBtn) copyBtn.onclick = () => {
                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.text;
                        const textToCopy = tempDiv.textContent || tempDiv.innerText || '';
                        navigator.clipboard.writeText(textToCopy);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                    } catch (e) {
                        console.warn('Copy failed:', e);
                        copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Failed";
                        setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
                    }
                };

                if (editBtn) editBtn.onclick = async () => {
                    const chatInputEl = getDomElement('chatInput');
                    if (!msg.text || !chatInputEl) return;

                    chatInputEl.value = msg.text;
                    chatInputEl.focus();

                    // Delete this message and all subsequent messages
                    await deleteMessagesFrom(messageId);
                    // UI will update via onSnapshot
                };
            });
        }

        // --- Firebase Chat Logic ---

        /** Loads and subscribes to user chats from Firestore. */
        async function loadUserChats(userId) {
            if (chatsUnsubscribe) chatsUnsubscribe(); // Unsubscribe from old listener

            const chatsColRef = collection(db, 'users', userId, 'chats');
            const q = query(chatsColRef, orderBy('createdAt', 'desc'));

            chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                if (snapshot.empty) {
                    await createNewChat(userId); // Create a default chat if none exist
                    return;
                }
                chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderChatsListSidebar();

                // If no chat is selected or selected chat was deleted, select the newest one
                if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                    currentChatId = chats[0].id;
                }
                subscribeToMessages(userId, currentChatId);
            }, (error) => {
                console.error("Error fetching chats: ", error);
                const chatsListEl = getDomElement('chatsList');
                if (chatsListEl) chatsListEl.innerHTML = `<div style="color: #f44;">Error loading chats.</div>`;
            });
        }

        /** Creates a new chat entry in Firestore. */
        async function createNewChat(userId) {
            if (!userId) userId = currentUser?.uid;
            if (!userId) return;

            const chatsColRef = collection(db, 'users', userId, 'chats');
            try {
                const newChatDoc = await addDoc(chatsColRef, { name: "New Chat", createdAt: serverTimestamp() });
                currentChatId = newChatDoc.id; // The listener will re-run and select this chat
                showStatusMessage('New chat created!');
            } catch (e) {
                console.error("Error creating new chat: ", e);
                showStatusMessage('Failed to create new chat.', true);
            }
        }

        /** Subscribes to messages for a specific chat from Firestore. */
        function subscribeToMessages(userId, chatId) {
            if (messagesUnsubscribe) messagesUnsubscribe(); // Unsubscribe from old messages

            if (!userId || !chatId) {
                renderChatBox([]); // Clear chat box
                return;
            }

            const messagesColRef = collection(db, 'users', userId, 'chats', chatId, 'messages');
            const q = query(messagesColRef, orderBy('createdAt'));

            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderChatBox(currentMessages);
            }, (error) => {
                console.error("Error fetching messages: ", error);
                const chatBoxEl = getDomElement('chatBox');
                if (chatBoxEl) chatBoxEl.innerHTML = `<div style="color: #f44; text-align: center; margin-top: 20px;">Error loading messages for this chat.</div>`;
            });
        }

        // --- Panel & Modal Management ---

        /** Closes the tools menu. */
        function closeToolMenu() {
            getDomElement('toolsMenuBg')?.classList.remove('active');
        }

        /** Opens the tools menu. */
        function openToolMenu() {
            getDomElement('toolsMenuBg')?.classList.add('active');
        }

        /** Displays a specific tool's form in a modal. */
        function displayToolForm(toolKey) {
            const tool = toolDefinitions[toolKey];
            const toolFormModalBg = getDomElement('toolFormModalBg');
            const toolFormTitle = getDomElement('toolFormTitle');
            const toolFormEl = getDomElement('toolForm');
            if (!tool || !toolFormModalBg || !toolFormTitle || !toolFormEl) return;

            toolFormTitle.textContent = tool.title;
            const descriptionHtml = tool.description ? `<p style="color:#a8eaff;font-size:.9em;margin-bottom:12px;">${tool.description}</p>` : '';
            toolFormEl.innerHTML = descriptionHtml + tool.buildForm();

            if (typeof tool.onFormReady === 'function') tool.onFormReady();

            toolFormEl.onsubmit = async (e) => {
                e.preventDefault();
                const submitButton = toolFormEl.querySelector('button[type="submit"]');
                const originalButtonContent = submitButton.innerHTML;
                submitButton.innerHTML = `<span class="spinner"></span> Processing...`;
                submitButton.disabled = true;

                toolFormModalBg.classList.remove('active'); // Close tool form modal after submission

                const resultText = await tool.handleSubmit(toolFormEl);

                if (resultText) {
                    removeTyping();
                    await startTypewriter(resultText);
                }

                submitButton.innerHTML = originalButtonContent;
                submitButton.disabled = false;
            };

            toolFormModalBg.classList.add('active');
        }


        // --- Authentication & Profile Management ---

        /** Handles user authentication state changes. */
        onAuthStateChanged(auth, user => {
            if (!user) {
                // If no user, redirect to signup/login page
                try {
                    window.location.href = "signup-login.html";
                } catch (e) {
                    console.error("Failed to redirect to login:", e);
                }
                return;
            }
            currentUser = user;

            const headerWelcomeEl = getDomElement('headerWelcome');
            const profileMenuUserEl = getDomElement('profileMenuUser');
            const profileMenuEmailEl = getDomElement('profileMenuEmail');
            const editNameEl = getDomElement('edit-name');
            const editPhotoEl = getDomElement('edit-photo');
            const profilePicPreviewEl = getDomElement('profilePicPreview');

            if (headerWelcomeEl) headerWelcomeEl.textContent = "Welcome, " + (user.displayName || (user.email || '').split('@')[0]);
            if (profileMenuUserEl) profileMenuUserEl.textContent = user.displayName || "User";
            if (profileMenuEmailEl) profileMenuEmailEl.textContent = user.email || "";
            if (editNameEl) editNameEl.value = user.displayName || "";
            if (editPhotoEl) editPhotoEl.value = user.photoURL || "";
            if (profilePicPreviewEl) profilePicPreviewEl.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

            // Start loading chats from Firestore
            loadUserChats(user.uid);
        });

        // --- Theme Switching Logic ---
        const themes = {
            cyber: { /* ... (Your existing cyber theme variables) ... */
                '--color-primary': '#00fff7', '--color-secondary': '#0a8afe', '--color-background-dark': '#070b1a', '--color-fade-blue': '#133c8b', '--gradient-main': 'linear-gradient(120deg, #000a2e 39%, #04336a 68%, #10bfff 97%)', '--gradient-user': 'linear-gradient(120deg, #0857ee 32%, #00fff0 89%)', '--chat-bubble-glow': '0 0 13px #00d8ffb1, 0 0 24px #0197ff40', '--user-bubble-glow': '0 0 22px #0fffd555, 0 0 14px #36f9ff70', '--header-bg': 'rgba(17,29,47,0.92)', '--code-bg': 'linear-gradient(92deg,#031d39 79%,#092ff8 120%)', '--code-border': '#15faff', '--code-text': '#17fafd', '--text-main': '#e1fafe', '--text-link': '#13efff', '--input-bg': '#09284c', '--body-bg-gradient-1': 'radial-gradient(circle at 60% 45%, #112250 37%, #060e1e 88%, #1e0942 100%) fixed', '--body-bg-gradient-2': 'repeating-linear-gradient(100deg,#061c4c 0 9%,#080e20 16% 19%,#030721 30% 41%,#052650 44% 62%,#050b16 74% 89%,#041048 99% 100%)', '--body-blend-mode': 'lighten, color-dodge', '--panel-bg': 'linear-gradient(118deg,#131642 80%,#1629af 200%)', '--panel-border': '#00fbffcb', '--panel-shadow': '0 0 42px #25f8ffc9', '--submit-button-bg': 'linear-gradient(94deg,#00ffff,#0090ff 90%)', '--submit-button-text': '#102649', '--submit-button-hover-bg': '#008cff', '--submit-button-hover-text': '#fff', '--header-text-glow': '0 0 12px #00ffe0cc, 0 0 27px #178fcf88', '--header-text-anim-glow-1': '0 0 17px #00e7ff70,0 0 30px #0b8fff44', '--header-text-anim-glow-2': '0 0 29px #00ffe9ee,0 0 44px #31d2ff82', '--header-text-fill': 'linear-gradient(90deg,#00fff1,#00b4ff 40%,#fff 59%,#1093f1 89%,#24e0fa 100%)'
            },
            celestial: { /* ... (Your existing celestial theme variables) ... */
                '--color-primary': '#ff00ff', '--color-secondary': '#8a2be2', '--color-background-dark': '#0f001a', '--color-fade-blue': '#2b003e', '--gradient-main': 'linear-gradient(120deg, #2b003e 39%, #580080 68%, #ff00ff 97%)', '--gradient-user': 'linear-gradient(120deg, #8a2be2 32%, #ff00ff 89%)', '--chat-bubble-glow': '0 0 15px #ff00ffb1', '--user-bubble-glow': '0 0 25px #ff66ff55, 0 0 16px #cc00cc70', '--header-bg': 'rgba(25,0,35,0.92)', '--code-bg': 'linear-gradient(92deg,#2b003e 79%,#8a2be2 120%)', '--code-border': '#ff00ff', '--code-text': '#f0e6ff', '--text-main': '#f0e6ff', '--text-link': '#ff66ff', '--input-bg': '#2b003e', '--body-bg-gradient-1': 'radial-gradient(circle at 50% 50%, #1a0033 0%, #0f001a 100%)', '--body-bg-gradient-2': 'none', '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#2b003e 80%,#580080 200%)', '--panel-border': '#ff00ffcb', '--panel-shadow': '0 0 45px #ff00ffc9', '--submit-button-bg': 'linear-gradient(94deg,#ff00ff,#8a2be2 90%)', '--submit-button-text': '#0f001a', '--submit-button-hover-bg': '#8a2be2', '--submit-button-hover-text': '#fff', '--header-text-glow': '0 0 15px #ff00ffcc', '--header-text-anim-glow-1': '0 0 20px #ff00ff70', '--header-text-anim-glow-2': '0 0 35px #ff00ffee', '--header-text-fill': 'linear-gradient(90deg,#ff00ff,#8a2be2 40%,#fff 59%,#8a2be2 89%,#ff00ff 100%)'
            },
            starlight: { /* ... (Your existing starlight theme variables) ... */
                '--color-primary': '#a6faff', '--color-secondary': '#00c3ff', '--color-background-dark': '#030010', '--color-fade-blue': '#100c25', '--gradient-main': 'linear-gradient(120deg, #100c25 39%, #1c153f 68%, #3f337f 97%)', '--gradient-user': 'linear-gradient(120deg, #00c3ff 32%, #a6faff 89%)', '--chat-bubble-glow': '0 0 13px #00c3ffb1', '--user-bubble-glow': '0 0 22px #a6faff55', '--header-bg': 'rgba(16,12,37,0.92)', '--code-bg': 'linear-gradient(92deg,#100c25 79%,#3f337f 120%)', '--code-border': '#a6faff', '--code-text': '#a6faff', '--text-main': '#f0faff', '--text-link': '#a6faff', '--input-bg': '#100c25', '--body-bg-gradient-1': 'radial-gradient(ellipse at bottom, #0d0920 0%, #030010 70%)', '--body-bg-gradient-2': 'none', '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#100c25 80%,#1c153f 200%)', '--panel-border': '#a6faffcb', '--panel-shadow': '0 0 42px #a6faffc9', '--submit-button-bg': 'linear-gradient(94deg,#a6faff,#00c3ff 90%)', '--submit-button-text': '#030010', '--submit-button-hover-bg': '#00c3ff', '--submit-button-hover-text': '#fff', '--header-text-glow': '0 0 12px #a6faffcc', '--header-text-anim-glow-1': '0 0 17px #a6faff70', '--header-text-anim-glow-2': '0 0 29px #a6faffee', '--header-text-fill': 'linear-gradient(90deg,#a6faff,#00c3ff 40%,#fff 59%,#00f2ff 89%,#a6faff 100%)'
            },
            midnight: { /* ... (Your existing midnight theme variables) ... */
                '--color-primary': '#3391ff', '--color-secondary': '#007bff', '--color-background-dark': '#121212', '--color-fade-blue': '#282828', '--gradient-main': 'linear-gradient(120deg, #282828 39%, #333 68%, #444 97%)', '--gradient-user': 'linear-gradient(120deg, #007bff 32%, #3391ff 89%)', '--chat-bubble-glow': '0 0 8px #007bff44', '--user-bubble-glow': '0 0 12px #3391ff44', '--header-bg': 'rgba(18,18,18,0.92)', '--code-bg': 'linear-gradient(92deg,#222 79%,#333 120%)', '--code-border': '#444', '--code-text': '#f1f1f1', '--text-main': '#f1f1f1', '--text-link': '#3391ff', '--input-bg': '#282828', '--body-bg-gradient-1': 'linear-gradient(180deg, #181818 0%, #121212 100%)', '--body-bg-gradient-2': 'none', '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#1e1e1e 80%,#282828 200%)', '--panel-border': '#444', '--panel-shadow': '0 0 20px #000000c9', '--submit-button-bg': 'linear-gradient(94deg,#007bff,#3391ff 90%)', '--submit-button-text': '#fff', '--submit-button-hover-bg': '#0069d9', '--submit-button-hover-text': '#fff', '--header-text-glow': '0 0 10px #3391ffaa', '--header-text-anim-glow-1': '0 0 12px #3391ff70', '--header-text-anim-glow-2': '0 0 15px #3391ffee', '--header-text-fill': 'linear-gradient(90deg,#3391ff,#007bff 40%,#fff 59%,#3391ff 89%,#aaccff 100%)'
            },
            forest: { /* ... (Your existing forest theme variables) ... */
                '--color-primary': '#99cc99', '--color-secondary': '#669966', '--color-background-dark': '#2a362a', '--color-fade-blue': '#4a5a4a', '--gradient-main': 'linear-gradient(120deg, #3a473a 39%, #5a6b5a 68%, #99cc99 97%)', '--gradient-user': 'linear-gradient(120deg, #669966 32%, #99cc99 89%)', '--chat-bubble-glow': '0 0 10px #99cc99b1', '--user-bubble-glow': '0 0 18px #99cc9955', '--header-bg': 'rgba(42,54,42,0.92)', '--code-bg': 'linear-gradient(92deg,#3a473a 79%,#5a6b5a 120%)', '--code-border': '#99cc99', '--code-text': '#e0ffe0', '--text-main': '#e0ffe0', '--text-link': '#99cc99', '--input-bg': '#4a5a4a', '--body-bg-gradient-1': 'linear-gradient(180deg, #3a473a 0%, #2a362a 100%)', '--body-bg-gradient-2': 'none', '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#3a473a 80%,#4a5a4a 200%)', '--panel-border': '#99cc99cb', '--panel-shadow': '0 0 35px #99cc99c9', '--submit-button-bg': 'linear-gradient(94deg,#99cc99,#669966 90%)', '--submit-button-text': '#2a362a', '--submit-button-hover-bg': '#669966', '--submit-button-hover-text': '#fff', '--header-text-glow': '0 0 10px #99cc99cc', '--header-text-anim-glow-1': '0 0 15px #99cc9970', '--header-text-anim-glow-2': '0 0 25px #99cc99ee', '--header-text-fill': 'linear-gradient(90deg,#99cc99,#669966 40%,#fff 59%,#669966 89%,#99cc99 100%)'
            },
            volcano: { /* ... (Your existing volcano theme variables) ... */
                '--color-primary': '#ff7043', '--color-secondary': '#bf360c', '--color-background-dark': '#3e1a0b', '--color-fade-blue': '#5e2a1b', '--gradient-main': 'linear-gradient(120deg, #4e2211 39%, #6e3a2c 68%, #ff7043 97%)', '--gradient-user': 'linear-gradient(120deg, #bf360c 32%, #ff7043 89%)', '--chat-bubble-glow': '0 0 12px #ff7043b1', '--user-bubble-glow': '0 0 20px #ff704355', '--header-bg': 'rgba(62,26,11,0.92)', '--code-bg': 'linear-gradient(92deg,#4e2211 79%,#6e3a2c 120%)', '--code-border': '#ff7043', '--code-text': '#fff0e0', '--text-main': '#fff0e0', '--text-link': '#ff7043', '--input-bg': '#5e2a1b', '--body-bg-gradient-1': 'radial-gradient(circle at 50% 50%, #6e3a2c 0%, #3e1a0b 100%)', '--body-bg-gradient-2': 'none', '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#4e2211 80%,#5e2a1b 200%)', '--panel-border': '#ff7043cb', '--panel-shadow': '0 0 40px #ff7043c9', '--submit-button-bg': 'linear-gradient(94deg,#ff7043,#bf360c 90%)', '--submit-button-text': '#3e1a0b', '--submit-button-hover-bg': '#bf360c', '--submit-button-hover-text': '#fff', '--header-text-glow': '0 0 12px #ff7043cc', '--header-text-anim-glow-1': '0 0 17px #ff704370', '--header-text-anim-glow-2': '0 0 29px #ff7043ee', '--header-text-fill': 'linear-gradient(90deg,#ff7043,#bf360c 40%,#fff 59%,#bf360c 89%,#ff7043 100%)'
            }
        };

        let currentThemeIdx = 0;
        const themeKeys = Object.keys(themes);

        /** Applies a given theme to the document. */
        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) return;

            for (const key in theme) {
                document.documentElement.style.setProperty(key, theme[key]);
            }
            localStorage.setItem('philadelphia-theme', themeName);

            // Update theme icon
            const themeBtnEl = getDomElement('themeBtn');
            if (themeBtnEl) {
                let iconClass = 'fa-moon'; // Default
                if (themeName === 'forest') iconClass = 'fa-leaf';
                else if (themeName === 'volcano') iconClass = 'fa-fire';
                else if (themeName === 'celestial') iconClass = 'fa-galaxy'; // Example unique icon for celestial
                else if (themeName === 'starlight') iconClass = 'fa-star'; // Example unique icon for starlight
                themeBtnEl.innerHTML = `<i class="fa-solid ${iconClass}"></i>`;
            }
        }

        // --- Voice Call Logic ---
        let speechRecognition;
        let isCallActive = false;
        let callHistory = [];
        let botIsSpeaking = false;
        let userSaidSomething = false; // Flag to track if user actually spoke
        let currentAudio = null;
        let isMuted = false;

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        /** Initializes speech recognition. */
        function initSpeechRecognition() {
            if (!SpeechRecognition) {
                console.warn("Speech Recognition not supported in this browser.");
                const callBtnEl = getDomElement('callBtn');
                if (callBtnEl) callBtnEl.style.display = 'none'; // Hide call button if not supported
                return;
            }

            speechRecognition = new SpeechRecognition();
            speechRecognition.continuous = true;
            speechRecognition.interimResults = true;
            speechRecognition.lang = 'en-US';

            speechRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                userSaidSomething = true; // User has started talking

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                const callConversationEl = getDomElement('callConversation');
                const callStatusMessageEl = getDomElement('callStatusMessage');
                const tapToTalkEl = getDomElement('tapToTalk');

                let userMsgEl = callConversationEl.querySelector('.call-msg.user.interim');
                if (!userMsgEl) {
                    userMsgEl = document.createElement('div');
                    userMsgEl.className = 'call-msg user interim';
                    callConversationEl.appendChild(userMsgEl);
                }
                userMsgEl.textContent = finalTranscript || interimTranscript;
                callConversationEl.scrollTop = callConversationEl.scrollHeight;

                if (callStatusMessageEl) callStatusMessageEl.textContent = finalTranscript ? 'User Speaking (Final)' : 'User Speaking...';
                if (tapToTalkEl) tapToTalkEl.style.display = 'none';
            };

            speechRecognition.onspeechend = () => {
                // Fired when user stops talking
            };

            speechRecognition.onend = () => {
                if (!isCallActive) return;

                if (isMuted) {
                    if (getDomElement('callStatusMessage')) getDomElement('callStatusMessage').textContent = 'Microphone Muted.';
                    if (getDomElement('tapToTalk')) getDomElement('tapToTalk').style.display = 'none';
                    return;
                }

                let finalTranscript = '';
                const userMsgEl = getDomElement('callConversation').querySelector('.call-msg.user.interim');
                if (userMsgEl) {
                    finalTranscript = userMsgEl.textContent.trim();
                    userMsgEl.classList.remove('interim');
                }

                if (botIsSpeaking) {
                    // Bot is speaking, recognition will restart after bot finishes
                } else if (finalTranscript && userSaidSomething) {
                    userSaidSomething = false; // Reset flag
                    callHistory.push({ role: 'user', content: finalTranscript });
                    handleCallBotResponse();
                } else {
                    // User didn't say anything, restart listening
                    if (isCallActive && !isMuted) {
                        if (getDomElement('callStatusMessage')) getDomElement('callStatusMessage').textContent = 'Listening... (Tap to Speak)';
                        if (getDomElement('tapToTalk')) getDomElement('tapToTalk').style.display = 'block';
                        try {
                            speechRecognition.start();
                        } catch(e) { console.warn("Speech recognition failed to start automatically:", e); }
                    }
                }
            };

            speechRecognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                const callStatusMessageEl = getDomElement('callStatusMessage');

                if (event.error === 'no-speech' && isCallActive && !isMuted) {
                    userSaidSomething = false; // Reset flag if no speech detected
                    speechRecognition.stop(); // Stop might trigger onend, which then restarts
                } else if (event.error === 'network' && isCallActive) {
                    if (callStatusMessageEl) callStatusMessageEl.textContent = 'Network error. Attempting restart...';
                    speechRecognition.stop();
                } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    if (callStatusMessageEl) callStatusMessageEl.textContent = 'Microphone permission denied. Please allow in browser settings.';
                    endCall(); // End call if permission is denied
                }
            };
        }

        /** Adds a message to the call conversation UI. */
        function addCallMessage(role, text) {
            const callConversationEl = getDomElement('callConversation');
            if (!callConversationEl) return;
            const msgEl = document.createElement('div');
            msgEl.className = `call-msg ${role}`;
            msgEl.textContent = text;
            callConversationEl.appendChild(msgEl);
            callConversationEl.scrollTop = callConversationEl.scrollHeight;
        }

        /** Handles getting a response from the bot during a call. */
        async function handleCallBotResponse() {
            if (!isCallActive) return;
            const callStatusMessageEl = getDomElement('callStatusMessage');
            const tapToTalkEl = getDomElement('tapToTalk');

            if (callStatusMessageEl) callStatusMessageEl.textContent = 'Philadelphia AI is thinking...';
            if (tapToTalkEl) tapToTalkEl.style.display = 'none';

            const historyForBot = callHistory.map(m => m);
            const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : "";

            try {
                speechRecognition.stop(); // Stop recognition while thinking

                const res = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: userMessage, history: historyForBot.slice(0, -1), user_id: currentUser?.uid || "user" })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || "Server error.");

                const botResponse = data.response;
                callHistory.push({ role: 'ai', content: botResponse });
                addCallMessage('bot', botResponse);
                speakBotResponse(botResponse);
            } catch (err) {
                const errorMsg = `âŒ Call error: ${err.message}`;
                addCallMessage('bot', errorMsg);
                // Restart listening if active and not muted
                if (isCallActive && !isMuted) {
                    if (callStatusMessageEl) callStatusMessageEl.textContent = 'Listening... (Tap to Speak)';
                    if (tapToTalkEl) tapToTalkEl.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) { console.warn("Speech recognition failed to start after error:", e); }
                }
            }
        }

        /** Plays the bot's response audio. */
        async function speakBotResponse(text) {
            if (!isCallActive) return;
            const botImageContainerEl = getDomElement('botImageContainer');
            const callStatusMessageEl = getDomElement('callStatusMessage');
            const tapToTalkEl = getDomElement('tapToTalk');

            botIsSpeaking = true;
            if (botImageContainerEl) botImageContainerEl.classList.add('speaking');
            if (callStatusMessageEl) callStatusMessageEl.textContent = 'Philadelphia AI is speaking...';
            if (tapToTalkEl) tapToTalkEl.style.display = 'none';

            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, voice_id: 'elder' }) // Using 'elder' voice
                });
                if (!res.ok) throw new Error(await res.text());

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                currentAudio = audio; // Store reference

                audio.onended = audio.onerror = () => {
                    botIsSpeaking = false;
                    if (botImageContainerEl) botImageContainerEl.classList.remove('speaking');
                    currentAudio = null;
                    if (isCallActive && !isMuted) {
                        if (callStatusMessageEl) callStatusMessageEl.textContent = 'Listening... (Tap to Speak)';
                        if (tapToTalkEl) tapToTalkEl.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) { console.warn("Speech recognition failed to start after speaking:", e); }
                    } else if (isMuted) {
                        if (callStatusMessageEl) callStatusMessageEl.textContent = 'Microphone Muted.';
                        if (tapToTalkEl) tapToTalkEl.style.display = 'none';
                    }
                };
                audio.play();
            } catch (err) {
                console.error("Voice generation error:", err);
                botIsSpeaking = false;
                if (botImageContainerEl) botImageContainerEl.classList.remove('speaking');
                // Failed to speak, just restart listening
                if (isCallActive && !isMuted) {
                    if (callStatusMessageEl) callStatusMessageEl.textContent = 'Listening (Voice Failed)...';
                    if (tapToTalkEl) tapToTalkEl.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) { console.warn("Speech recognition failed to start after voice error:", e); }
                } else if (isMuted) {
                    if (callStatusMessageEl) callStatusMessageEl.textContent = 'Microphone Muted.';
                    if (tapToTalkEl) tapToTalkEl.style.display = 'none';
                }
            }
        }

        /** Stops bot speaking and restarts user listening. */
        function stopBotSpeakingAndStartListening() {
            if (!isCallActive || !botIsSpeaking) return;

            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            botIsSpeaking = false;
            const botImageContainerEl = getDomElement('botImageContainer');
            const callStatusMessageEl = getDomElement('callStatusMessage');
            const tapToTalkEl = getDomElement('tapToTalk');

            if (botImageContainerEl) botImageContainerEl.classList.remove('speaking');

            if (!isMuted) {
                if (callStatusMessageEl) callStatusMessageEl.textContent = 'Listening... (Tap to Speak)';
                if (tapToTalkEl) tapToTalkEl.style.display = 'block';
                try {
                    speechRecognition.stop();
                    speechRecognition.start();
                } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
            } else {
                if (callStatusMessageEl) callStatusMessageEl.textContent = 'Microphone Muted.';
                if (tapToTalkEl) tapToTalkEl.style.display = 'none';
            }
            // Clear interim message if it exists
            const userMsgEl = getDomElement('callConversation').querySelector('.call-msg.user.interim');
            if (userMsgEl) userMsgEl.textContent = '';
        }

        /** Ends the current voice call. */
        function endCall() {
            isCallActive = false;
            botIsSpeaking = false;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            getDomElement('callModal')?.classList.remove('active');
            try { speechRecognition.stop(); } catch(e) {}
            getDomElement('botImageContainer')?.classList.remove('speaking');
            getDomElement('tapToTalk')?.style.display = 'none';
            if (getDomElement('callStatusMessage')) getDomElement('callStatusMessage').textContent = 'Call Ended.';
        }

        // --- Tool Definitions ---
        const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
        const toolDefinitions = {
            "image": {
                title: "Generate Image",
                description: "Create stunning visuals from a text prompt. Choose a model for different results.",
                buildForm: () => `
                    <label for="tool-provider">Generation Model</label>
                    <select id="tool-provider" aria-label="Image generation model">
                        <option value="thena">Version 1 (Stylized, Fast & Recommended)</option>
                        <option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option>
                    </select>
                    <label for="tool-prompt">Image Prompt</label>
                    <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required aria-required="true"></textarea>
                    <label for="tool-style">Style (for Version 1 only)</label>
                    <select id="tool-style" aria-label="Image style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-sparkles"></i> Generate</button>
                `,
                handleSubmit: async (form) => {
                    const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
                    const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)';
                    const payload = {
                        prompt: form.querySelector('#tool-prompt').value,
                        model: form.querySelector('#tool-style').value,
                        use_minimax
                    };
                    await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
                    showTypingWithText('Generating your image...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/generate-image`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                        removeTyping();
                        return 'âœ… Image generated! Check the floating image box to view or download.';
                    } catch (err) {
                        removeTyping();
                        return `âŒ Image generation failed: ${err.message}`;
                    }
                }
            },
            "edit-photo": {
                title: "Edit Photo",
                description: "Upload a photo and describe the changes you want to make.",
                buildForm: () => `
                    <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required aria-required="true"></textarea>
                    <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required aria-required="true">
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>
                `,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    const prompt = form.querySelector('#tool-prompt').value;
                    if (!file) return "Please select a file to edit.";

                    const fd = new FormData();
                    fd.append('file', file);
                    fd.append('prompt', prompt);

                    await addMessageToChat('user', `Photo edit request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
                    showTypingWithText('Editing your photo...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error((await res.json()).error || 'Failed to edit photo.');
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob);
                        const imgHtml = `âœ… Photo edited successfully! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
                        removeTyping();
                        await addMessageToChat('ai', imgHtml);
                        return null; // Handled by addMessageToChat
                    } catch (err) {
                        removeTyping();
                        return `âŒ Photo edit failed: ${err.message}`;
                    }
                }
            },
            "remove-bg": {
                title: "Remove Background",
                description: "Select an image file to automatically remove its background.",
                buildForm: () => `
                    <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required aria-required="true" style="display:block;margin-top:10px;">
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-scissors"></i> Remove Background</button>
                `,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    if (!file) return "Please select a file.";

                    await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                    showTypingWithText('Removing background...');
                    const fd = new FormData();
                    fd.append('file', file);
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob); // Convert to base64 for persistence
                        const imgHtml = `âœ… Background removed! <br><img src="${base64String}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                        removeTyping();
                        await addMessageToChat('ai', imgHtml);
                        return null; // Handled by addMessageToChat
                    } catch (err) {
                        removeTyping();
                        return `âŒ Background removal failed: ${err.message}`;
                    }
                }
            },
            "comic": {
                title: "Create Comic",
                description: "Write a story and watch it transform into a comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.",
                buildForm: () => `
                    <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?\n[NARRATION] Lilo and switch were once best friends..." required aria-required="true"></textarea>
                    <label for="tool-style">Comic Style</label><select id="tool-style" aria-label="Comic style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
                    <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" aria-label="Number of comic panels"/>
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-book-open"></i> Create Comic</button>
                `,
                handleSubmit: async (form) => {
                    const payload = {
                        story: form.querySelector('#tool-story').value,
                        style: form.querySelector('#tool-style').value,
                        panels: parseInt(form.querySelector('#tool-panels').value, 10),
                        user: currentUser?.displayName || "User"
                    };
                    await addMessageToChat('user', `Comic creation request with style: ${payload.style}.`);
                    showTypingWithText('Generating your comic panels...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join('');
                        const comicMessage = `ðŸ–¼ï¸ Comic successfully created! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                        removeTyping();
                        await addMessageToChat('ai', comicMessage);
                        return null;
                    } catch (err) {
                        removeTyping();
                        return `âŒ Comic generation failed: ${err.message}`;
                    }
                }
            },
            "voice-gen": {
                title: "Voice Generation",
                description: "Transform text into realistic speech. Choose a provider and voice style.",
                buildForm: () => `
                    <label for="tool-provider">Voice Provider</label><select id="tool-provider" aria-label="Voice provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
                    <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required aria-required="true"></textarea>
                    <label for="tool-style">Voice Style</label><select id="tool-style" aria-label="Voice style"></select>
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-microphone"></i> Generate Voice</button>
                `,
                onFormReady: () => {
                    const providerSelect = getDomElement('tool-provider'), styleSelect = getDomElement('tool-style');
                    const voices = {
                        gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"],
                        minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"]
                    };
                    const updateStyles = () => {
                        styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join('');
                    };
                    providerSelect.addEventListener('change', updateStyles);
                    updateStyles();
                },
                handleSubmit: async (form) => {
                    const provider = form.querySelector('#tool-provider').value, text = form.querySelector('#tool-prompt').value, style = form.querySelector('#tool-style').value;
                    const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';
                    await addMessageToChat('user', `Voice generation request using ${providerName}.`);
                    showTypingWithText('Generating your audio...');
                    try {
                        let res;
                        if (provider === 'gemini') {
                            const fd = new FormData();
                            fd.append('text', text);
                            fd.append('style', style);
                            res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                        } else {
                            res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({ text, voice_id: style })
                            });
                        }
                        if (!res.ok) throw new Error(await res.text());
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob); // Convert to base64 for persistence
                        const audioHtml = `ðŸ—£ï¸ Voice generated! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                        removeTyping();
                        await addMessageToChat('ai', audioHtml);
                        return null;
                    } catch (err) {
                        removeTyping();
                        return `âŒ Voice generation failed: ${err.message}`;
                    }
                }
            },
            "audio-narration": {
                title: "Audio Narration",
                description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.",
                buildForm: () => `
                    <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required aria-required="true" style="display:block;margin-top:10px;">
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>
                `,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#tool-file').files[0];
                    if (!file) return "Please select a file.";

                    await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
                    showTypingWithText('Analyzing and narrating document...');
                    const fd = new FormData();
                    fd.append('file', file);
                    fd.append('style', 'podcast');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob); // Convert to base64 for persistence
                        const narrationHtml = `ðŸ—£ï¸ Narration generated! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                        removeTyping();
                        await addMessageToChat('ai', narrationHtml);
                        return null;
                    } catch (err) {
                        removeTyping();
                        return `âŒ Audio narration failed: ${err.message}`;
                    }
                }
            },
            "video-text": {
                title: "Generate Video from Text",
                description: "Describe the video you want to create. This process can take a few minutes.",
                buildForm: () => `
                    <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required aria-required="true"></textarea>
                    <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15" aria-label="Video duration in seconds">
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-play"></i> Start Generation</button>
                `,
                handleSubmit: async (form) => {
                    const payload = {
                        prompt: form.querySelector('#video-prompt').value,
                        duration: parseInt(form.querySelector('#video-duration').value, 10),
                        resolution: "1080P"
                    };
                    await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
                    await handleVideoGeneration(payload, false); // Pass false for isImageToVideo
                    return null; // Handled internally
                }
            },
            "video-image": {
                title: "Generate Video from Image",
                description: "Upload a starting image and describe how you want to animate it.",
                buildForm: () => `
                    <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required aria-required="true"></textarea>
                    <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required aria-required="true">
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-play"></i> Start Generation</button>
                `,
                handleSubmit: async (form) => {
                    const file = form.querySelector('#video-image-file').files[0];
                    if (!file) return "Please select an image.";

                    await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{name: file.name, type: file.type}]);
                    const fd = new FormData();
                    fd.append('prompt', form.querySelector('#video-image-prompt').value);
                    fd.append('file', file);
                    await handleVideoGeneration(fd, true); // Pass true for isImageToVideo
                    return null; // Handled internally
                }
            },
            "music": {
                title: "Generate Music",
                description: "Generate music from a prompt, lyrics, and optional reference audio. Thanks to MiniMax.",
                buildForm: () => `
                    <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required aria-required="true"></textarea>
                    <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...\nChorus..."></textarea>
                    <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*">
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-music"></i> Generate Music</button>
                `,
                handleSubmit: async (form) => {
                    const payload = {
                        prompt: form.querySelector('#music-prompt').value,
                        lyrics: form.querySelector('#music-lyrics').value,
                        model: 'music-1.5'
                    };
                    const refFile = form.querySelector('#music-ref').files[0];
                    await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
                    showTypingWithText('Composing your music...');
                    try {
                        if (refFile) {
                            showTypingWithText('Uploading reference audio first...');
                            const fd = new FormData();
                            fd.append('file', refFile);
                            const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                            const uploadData = await uploadRes.json();
                            if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed.");
                            if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                            if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                            showTypingWithText('Reference uploaded. Composing music...');
                        }
                        const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                        const blob = await res.blob();
                        const base64String = await blobToBase64(blob); // Convert to base64 for persistence
                        const musicHtml = `ðŸŽµ Your music is ready! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                        removeTyping();
                        await addMessageToChat('ai', musicHtml);
                        return null;
                    } catch (err) {
                        removeTyping();
                        return `âŒ Music generation failed: ${err.message}`;
                    }
                }
            },
            "website": {
                title: "Create Website",
                description: "Describe the website you want to build and get a live, working prototype.",
                buildForm: () => `
                    <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required aria-required="true"></textarea>
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-globe"></i> Generate Website</button>
                `,
                handleSubmit: async (form) => {
                    const prompt = form.querySelector('#website-prompt').value;
                    await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`);
                    showTypingWithText('Building and deploying your website...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ prompt, user_id: currentUser.uid })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        removeTyping();
                        return `ðŸŒ Website deployed successfully! [View here](${data.url})`;
                    } catch (err) {
                        removeTyping();
                        return `âŒ Website creation failed: ${err.message}`;
                    }
                }
            },
            "edit-website": {
                title: "Edit Last Website",
                description: "Provide an instruction to modify the most recent website you created.",
                buildForm: () => `
                    <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required aria-required="true"></textarea>
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>
                `,
                handleSubmit: async (form) => {
                    const instruction = form.querySelector('#edit-instruction').value;
                    await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`);
                    showTypingWithText('Editing and redeploying your website...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ instruction, user_id: currentUser.uid })
                        });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || res.statusText);
                        removeTyping();
                        return `âœï¸ Website updated successfully! [View new version here](${data.url})`;
                    } catch (err) {
                        removeTyping();
                        return `âŒ Website edit failed: ${err.message}`;
                    }
                }
            },
            "my-sites": {
                isAction: true,
                runAction: async () => {
                    await addMessageToChat('user', 'Show me a list of my websites.');
                    showTypingWithText('Fetching your website list...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || 'Could not fetch sites.');
                        if (!data.sites || data.sites.length === 0) return "You haven't created any websites yet.";
                        const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                        removeTyping();
                        return `Here are the websites you've created:\n${siteList}`;
                    } catch (err) {
                        removeTyping();
                        return `âŒ Error fetching websites: ${err.message}`;
                    }
                }
            },
            "research-report": {
                title: "Research Report",
                description: "Generate a comprehensive research report in PDF format on any topic.",
                buildForm: () => `
                    <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required aria-required="true">
                    <button type="submit" class="submit-btn full-width"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>
                `,
                handleSubmit: async (form) => {
                    const topic = form.querySelector('#research-topic').value;
                    await addMessageToChat('user', `Research report request on: "${topic}"`);
                    showTypingWithText('Conducting research and compiling report...');
                    try {
                        const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ topic })
                        });
                        if (!res.ok) throw new Error(res.statusText);
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const downloadLink = `<a href="${url}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--text-link);font-weight:bold;">Download PDF Report</a>`;
                        removeTyping();
                        return `âœ… Research report on **${topic}** is ready! ${downloadLink}`;
                    } catch (err) {
                        removeTyping();
                        return `âŒ Research report failed: ${err.message}`;
                    }
                }
            },
        };

        // Helper for video generation (used by video-text and video-image tools)
        async function handleVideoGeneration(payload, isImageToVideo = false) {
            showTypingWithText('Submitting video generation job...');
            try {
                const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';

                // Common parameters for video tools
                const commonPayload = {
                    model: "MiniMax-Hailuo-02", // Explicitly set model
                    duration: payload.duration || 6, // Default duration
                    resolution: payload.resolution || "1080P" // Default resolution
                };

                let options;
                if (isImageToVideo) {
                    // For image-to-video, payload is FormData
                    payload.append('model', commonPayload.model);
                    payload.append('duration', commonPayload.duration);
                    payload.append('resolution', commonPayload.resolution);
                    options = { method: 'POST', body: payload };
                } else {
                    // For text-to-video, payload is JSON
                    const finalPayload = { ...payload, ...commonPayload };
                    options = {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(finalPayload)
                    };
                }

                const startRes = await fetch(API_BASE_URL + endpoint, options);
                const startData = await startRes.json();

                if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to start video task.');

                removeTyping();
                await startTypewriter(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. I'll notify you when it's ready. This can take a few minutes. Do not leave this page or send another message or task.`);

                const pollInterval = setInterval(async () => {
                    try {
                        const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                        const statusData = await statusRes.json();

                        if (statusRes.ok && statusData.url) {
                            clearInterval(pollInterval);
                            const videoHtml = `ðŸŽ‰ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                            await addMessageToChat('ai', videoHtml);
                        } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                            clearInterval(pollInterval);
                            await startTypewriter(`âŒ Video generation failed. Reason: ${statusData.error || 'Unknown error'}`);
                        }
                    } catch (pollErr) {
                        clearInterval(pollInterval);
                        await startTypewriter(`âŒ Error checking video status.`);
                    }
                }, 20000); // Poll every 20 seconds
            } catch (err) {
                removeTyping();
                await startTypewriter(`âŒ Could not start video generation: ${err.message}`);
            }
        }


        // --- DOMContentLoaded Event Listener ---
        document.addEventListener('DOMContentLoaded', () => {
            // Cache all common DOM elements
            Object.keys(DOM).forEach(key => { if (key !== '$') DOM[key] = getDomElement(key); });

            // --- Star Background Initialization ---
            if (DOM.starsContainer) {
                DOM.starsContainer.innerHTML = '';
                for (let i = 0; i < 34; i++) {
                    const s = document.createElement('div');
                    s.className = 'star';
                    const z = Math.random() * 2.1 + 1;
                    s.style.width = z + 'px';
                    s.style.height = z + 'px';
                    s.style.left = Math.random() * 100 + '%';
                    s.style.top = Math.random() * 100 + '%';
                    s.style.animationDelay = (Math.random() * 3.69) + 's';
                    s.style.animationDuration = (2.2 + Math.random() * 1.1) + 's';
                    DOM.starsContainer.appendChild(s);
                }
            }

            // --- Emoji Panel Logic ---
            const emojis = ["ðŸ˜€", "ðŸ˜‚", "ðŸ˜", "ðŸ¥°", "ðŸ˜Ž", "ðŸ‘", "ðŸ™", "ðŸ”¥", "ðŸ’¯", "ðŸŽ‰", "ðŸ˜‡", "ðŸ¤–", "ðŸ‘€"];
            if (DOM.emojiBtn && DOM.emojiPanel && DOM.chatInput) {
                DOM.emojiBtn.addEventListener('click', (e) => {
                    DOM.emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button" tabindex="0">${em}</span>`).join('');
                    DOM.emojiPanel.style.display = DOM.emojiPanel.style.display === 'flex' ? 'none' : 'flex'; // Use flex for layout
                    try {
                        const rect = DOM.emojiBtn.getBoundingClientRect();
                        DOM.emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
                    } catch (e) { /* ignore positioning errors */ }

                    DOM.emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
                        span.addEventListener('click', function () {
                            const text = this.textContent || '';
                            const start = DOM.chatInput.selectionStart || 0;
                            const end = DOM.chatInput.selectionEnd || 0;
                            DOM.chatInput.value = DOM.chatInput.value.slice(0, start) + text + DOM.chatInput.value.slice(end);
                            DOM.chatInput.focus();
                            DOM.chatInput.selectionStart = DOM.chatInput.selectionEnd = start + text.length;
                            DOM.emojiPanel.style.display = 'none';
                            DOM.chatInput.dispatchEvent(new Event('input')); // Trigger resize
                        });
                    });
                });
                document.addEventListener('click', e => {
                    if (DOM.emojiPanel && !DOM.emojiPanel.contains(e.target) && e.target !== DOM.emojiBtn) {
                        DOM.emojiPanel.style.display = 'none';
                    }
                });
            }

            // --- Chat Input Auto-Resize & Keydown Handling ---
            if (DOM.chatInput) {
                const autoResize = () => {
                    DOM.chatInput.style.height = 'auto';
                    DOM.chatInput.style.height = Math.min(DOM.chatInput.scrollHeight, 168) + 'px';
                };
                DOM.chatInput.addEventListener('input', autoResize);
                DOM.chatInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Prevent default Enter (new line)
                        DOM.chatForm.requestSubmit(); // Submit on Enter
                    } else if (e.key === 'Enter' && e.shiftKey) {
                        // Allow Shift+Enter for new line
                        const start = DOM.chatInput.selectionStart;
                        const end = DOM.chatInput.selectionEnd;
                        DOM.chatInput.value = DOM.chatInput.value.substring(0, start) + "\n" + DOM.chatInput.value.substring(end);
                        DOM.chatInput.selectionStart = DOM.chatInput.selectionEnd = start + 1;
                        autoResize();
                    }
                });
                autoResize();
            }

            // --- Chat File Input Handling ---
            if (DOM.chatFile) {
                DOM.chatFile.addEventListener('change', function() {
                    uploadedFiles = Array.from(this.files || []);
                    renderFilePreview();
                });
            }

            // --- AI Image Preview Handling ---
            if (DOM.aiPrevClose) DOM.aiPrevClose.addEventListener('click', () => { DOM.aiPrevBox.style.display = 'none'; });
            if (DOM.aiPrevDLBtn) DOM.aiPrevDLBtn.addEventListener('click', () => {
                const img = DOM.aiPrevImgBox.querySelector('img');
                if (img) {
                    const a = document.createElement('a');
                    a.href = img.src;
                    a.download = 'philadelphia_ai_image.png';
                    a.click();
                }
            });

            // --- Image Lightbox Handling ---
            if (DOM.lightbox) {
                DOM.lightbox.addEventListener('click', () => DOM.lightbox.classList.remove('active'));
            }
            if (DOM.chatBox) {
                DOM.chatBox.addEventListener('click', e => {
                    if (e.target.tagName === 'IMG' && e.target.closest('.chat-message.ai .msg')) {
                        e.preventDefault();
                        const lbImg = DOM.lightbox.querySelector('img');
                        if (lbImg) {
                            lbImg.src = e.target.src;
                            DOM.lightbox.classList.add('active');
                        }
                    }
                });
            }

            // --- Sidebar Panel Toggles ---
            const togglePanel = (menuId, bgId) => {
                const menu = getDomElement(menuId);
                const bg = getDomElement(bgId);
                if (!menu || !bg) return;
                bg.classList.toggle('active');
                menu.style.left = bg.classList.contains('active') ? '0' : '-350px';
            };

            if (DOM.openProfileMenu) DOM.openProfileMenu.addEventListener('click', () => togglePanel('profileMenu', 'profileMenuBg'));
            if (DOM.openLinksMenu) DOM.openLinksMenu.addEventListener('click', () => togglePanel('linkMenu', 'linkMenuBg'));
            if (DOM.toolBtn) DOM.toolBtn.addEventListener('click', () => togglePanel('toolsMenu', 'toolsMenuBg'));

            // Close panels when clicking background overlay
            [DOM.profileMenuBg, DOM.linkMenuBg, DOM.toolsMenuBg, DOM.toolFormModalBg].forEach(bg => {
                if (bg) {
                    bg.addEventListener('click', e => {
                        if (e.target === bg) {
                            bg.classList.remove('active');
                            const panel = bg.querySelector('.side-panel');
                            if(panel) panel.style.left = '-350px'; // Reset position
                        }
                    });
                }
            });

            if (DOM.toolFormBackBtn) {
                DOM.toolFormBackBtn.addEventListener('click', () => {
                    DOM.toolFormModalBg.classList.remove('active');
                    openToolMenu(); // Re-open tools menu
                });
            }

            // --- Logout Handler ---
            if (DOM.logoutBtn) {
                DOM.logoutBtn.addEventListener('click', () => {
                    auth.signOut();
                    window.location.href = 'signup-login.html';
                });
            }

            // --- Profile Form Submission ---
            if (DOM.profileForm) {
                DOM.profileForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!currentUser) return;
                    const status = getDomElement('profileStatusMsg');
                    if (status) status.textContent = 'Saving...';
                    try {
                        await updateProfile(currentUser, {
                            displayName: getDomElement('edit-name').value,
                            photoURL: getDomElement('edit-photo').value
                        });
                        await auth.currentUser.reload(); // Reload user data
                        if (status) {
                            status.textContent = "Profile updated!";
                            status.style.color = "#00ffff";
                        }
                        setTimeout(() => {
                            getDomElement('profileMenuBg')?.classList.remove('active');
                        }, 800);
                        if (DOM.headerWelcome) DOM.headerWelcome.textContent = "Welcome, " + (auth.currentUser?.displayName || 'User');
                    } catch (err) {
                        if (status) {
                            status.textContent = err.message;
                            status.style.color = "#ffd700";
                        }
                    }
                });
            }

            // --- New Chat Button ---
            if (DOM.newChatBtn) {
                DOM.newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));
            }

            // --- Tools Menu Link Handlers ---
            if (DOM.toolsMenu) {
                DOM.toolsMenu.addEventListener('click', async (e) => {
                    const toolLink = e.target.closest('.tool-link');
                    if (!toolLink) return;
                    e.preventDefault();
                    const toolKey = toolLink.getAttribute('data-tool');
                    const tool = toolDefinitions[toolKey];
                    if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);

                    closeToolMenu(); // Close the main tools menu

                    if (tool.isAction) {
                        const result = await tool.runAction();
                        removeTyping();
                        if(result) await startTypewriter(result);
                    } else {
                        displayToolForm(toolKey);
                    }
                });
            }

            // --- Main Chat Form Submission ---
            if (DOM.chatForm) {
                DOM.chatForm.addEventListener('submit', async function (e) {
                    e.preventDefault();
                    if (!currentChatId) {
                        showStatusMessage("Please select a chat or create a new one.", true);
                        return;
                    }

                    const msgText = DOM.chatInput.value.trim();
                    if (!msgText && uploadedFiles.length === 0) return;

                    // Replace Send button with Stop button
                    const stopButton = document.createElement('button');
                    stopButton.type = 'button';
                    stopButton.id = 'stopBtn';
                    stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>';
                    DOM.sendBtn.replaceWith(stopButton);

                    currentController = new AbortController();
                    const signal = currentController.signal;
                    let finalResponse = '';

                    stopButton.addEventListener('click', () => {
                        if (currentController) {
                            currentController.abort();
                            showStatusMessage('Operation stopped.', true);
                        }
                    });

                    // Save user message first
                    const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
                    await addMessageToChat('user', msgText, filesForHistory);

                    const localUploadedFiles = [...uploadedFiles]; // Copy for processing
                    DOM.chatInput.value = '';
                    uploadedFiles = [];
                    renderFilePreview();
                    DOM.chatInput.style.height = 'auto'; // Reset height

                    if (localUploadedFiles.length > 0) {
                        showTypingWithText('Analyzing your file(s)...');
                        let endpoint = '';
                        const file = localUploadedFiles[0];

                        if (file.type.startsWith('image/')) endpoint = '/understand-image';
                        else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                        else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                        else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                        else {
                            removeTyping();
                            finalResponse = "Sorry, I can't analyze that file type.";
                        }

                        try {
                            if(endpoint) {
                                const fd = new FormData();
                                fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]}`);
                                fd.append('file', file);
                                const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
                                const data = await res.json();
                                if (!res.ok) throw new Error(data.error || "Analysis failed.");
                                finalResponse = data.response;
                            }
                        } catch (err) {
                            finalResponse = err.name === 'AbortError' ? 'âŒ File analysis stopped.' : `âŒ File analysis failed: ${err.message}`;
                        }
                    } else if (msgText) {
                        showTypingAtNext();
                        try {
                            const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                            const res = await fetch(`${API_BASE_URL}/chat`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }),
                                signal
                            });
                            const data = await res.json();
                            if (!res.ok) throw new Error(data.error || "Server error.");
                            finalResponse = data.response;
                        } catch (err) {
                            finalResponse = err.name === 'AbortError' ? 'âŒ Response stopped.' : `âŒ An error occurred: ${err.message}`;
                        }
                    }

                    // Handle final response and cleanup
                    removeTyping();
                    if (finalResponse) {
                        await startTypewriter(finalResponse);
                    }

                    // Restore button and clear controller
                    stopButton.replaceWith(DOM.sendBtn);
                    currentController = null;
                });
            }

            // --- Theme Switcher ---
            if (DOM.themeBtn) {
                DOM.themeBtn.addEventListener('click', () => {
                    currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
                    applyTheme(themeKeys[currentThemeIdx]);
                });
                // Load saved theme or apply default
                const savedTheme = localStorage.getItem('philadelphia-theme');
                if (savedTheme && themes[savedTheme]) {
                    currentThemeIdx = themeKeys.indexOf(savedTheme);
                    applyTheme(savedTheme);
                } else {
                    applyTheme('cyber'); // Default theme
                }
            }

            // --- Voice Call Initialization & Event Listeners ---
            initSpeechRecognition(); // Initialize speech recognition
            if (DOM.callBtn) {
                DOM.callBtn.addEventListener('click', () => {
                    if (!SpeechRecognition) {
                        alert("Sorry, your browser doesn't support the Speech Recognition needed for this feature.");
                        return;
                    }
                    isCallActive = true;
                    isMuted = false;
                    const muteCallBtnEl = getDomElement('muteCallBtn');
                    if (muteCallBtnEl) {
                        muteCallBtnEl.classList.remove('muted');
                        muteCallBtnEl.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
                    }
                    getDomElement('callModal')?.classList.add('active');
                    getDomElement('callConversation').innerHTML = '';
                    addCallMessage('status', 'Connecting to Philadelphia AI...');
                    if (getDomElement('callStatusMessage')) getDomElement('callStatusMessage').textContent = 'Calling...';
                    if (getDomElement('tapToTalk')) getDomElement('tapToTalk').style.display = 'none';
                    callHistory = [];

                    setTimeout(() => {
                        if (!isCallActive) return;
                        addCallMessage('status', 'Call Connected. Speak when ready.');
                        if (getDomElement('callStatusMessage')) getDomElement('callStatusMessage').textContent = 'Listening... (Tap to Speak)';
                        if (getDomElement('tapToTalk')) getDomElement('tapToTalk').style.display = 'block';
                        try {
                            speechRecognition.start();
                        } catch(e) {
                            console.error("Speech recognition start failed", e);
                            if (getDomElement('callStatusMessage')) getDomElement('callStatusMessage').textContent = 'Microphone error. Check permissions.';
                        }
                    }, 1500);
                });
            }

            if (DOM.endCallBtn) DOM.endCallBtn.addEventListener('click', endCall);

            if (DOM.muteCallBtn) {
                DOM.muteCallBtn.addEventListener('click', () => {
                    isMuted = !isMuted;
                    const muteCallBtnEl = getDomElement('muteCallBtn');
                    const callStatusMessageEl = getDomElement('callStatusMessage');
                    const tapToTalkEl = getDomElement('tapToTalk');

                    if (isMuted) {
                        muteCallBtnEl.classList.add('muted');
                        muteCallBtnEl.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute Microphone';
                        speechRecognition.stop();
                        if (callStatusMessageEl) callStatusMessageEl.textContent = 'Microphone Muted.';
                        if (tapToTalkEl) tapToTalkEl.style.display = 'none';
                    } else {
                        muteCallBtnEl.classList.remove('muted');
                        muteCallBtnEl.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
                        if (isCallActive && !botIsSpeaking) {
                            if (callStatusMessageEl) callStatusMessageEl.textContent = 'Listening... (Tap to Speak)';
                            if (tapToTalkEl) tapToTalkEl.style.display = 'block';
                            try { speechRecognition.start(); } catch(e) { console.warn("Speech recognition failed to start after unmute:", e); }
                        } else if (isCallActive && botIsSpeaking) {
                            if (callStatusMessageEl) callStatusMessageEl.textContent = 'Philadelphia AI is speaking...';
                            if (tapToTalkEl) tapToTalkEl.style.display = 'none';
                        }
                    }
                });
            }

            // Add event listeners to the call modal to stop bot speaking
            if (DOM.callModal) {
                DOM.callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
                DOM.callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);
            }

            // Initial focus on chat input
            if(DOM.chatInput) DOM.chatInput.focus();
        }); // end DOMContentLoaded
    </script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
