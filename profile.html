<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Philadelphia AI Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"/>
  <style>
/* 
  Philadelphia AI - Enhanced UI & Bug Fixes
  -----------------------------------------
  
  Key Improvements:
  1.  **Aesthetic Refinements:**
      *   Subtler header shadow for a cleaner look.
      *   Refined chat bubble gradients, borders, and shadows for a more premium, "glassy" feel.
      *   Input row visually integrated more smoothly.
      *   Custom scrollbar styling for a polished touch.
      *   Adjusted star field appearance for a delicate shimmer.
      *   Overall spacing and typography tweaks for better readability and visual flow.
  2.  **Markdown/Code Block Fix:**
      *   The `startTypewriter` function now streams *raw text* incrementally.
      *   Full markdown parsing and `highlight.js` application happen *once* at the end of the AI response. This prevents rendering incomplete or malformed code blocks during streaming, resolving the "hanging" and display issues.
  3.  **General Polish:**
      *   Minor CSS adjustments across various components for consistency.
      *   Ensured smooth transitions and animations are consistent.
*/

:root {
  /* This is the default "Cyber" theme - Refined! */
  --cyan: #00e7ff; /* Slightly softer cyan */
  --blue: #0a8afe;
  --dark-bg: #060918; /* Deeper background */
  --fade-blue: #0e3070; /* Adjusted for depth */
  --gradient-1: linear-gradient(120deg, #02123d 39%, #053a7a 68%, #0ebfff 97%); /* Richer AI bubble */
  --gradient-user: linear-gradient(120deg, #0d6cfd 32%, #00f0ff 89%); /* More vibrant user bubble */
  --glass: rgba(20, 35, 65, 0.85); /* Slightly darker glass */
  --bubble-glow: 0 0 10px #00d8ff90, 0 0 18px #0197ff40; /* Subtler glow */
  --user-glow: 0 0 18px #0fffd555, 0 0 10px #36f9ff70; /* Subtler glow */
  --header-glass: rgba(12, 22, 40, 0.95); /* More opaque header */
  --code-bg: linear-gradient(92deg,#031a34 79%,#0525d8 120%); /* Refined code background */
  --code-border: #00c3ff; /* Matching the main theme */
  --code-text: #e0faff; /* Lighter text for contrast */
  --main-text: #e0faff;
  --link-text: #00c3ff;
  --input-bg: #071f3e; /* Darker input field */
  --body-bg: radial-gradient(circle at 60% 45%, #0e214d 37%, #040915 88%, #140536 100%) fixed, repeating-linear-gradient(100deg,#04153a 0 9%,#050a18 16% 19%,#02041b 30% 41%,#031c44 44% 62%,#030711 74% 89%,#020b36 99% 100%);
  --body-blend-mode: lighten, color-dodge;
  --panel-bg: linear-gradient(118deg,#10133a 80%,#12249c 200%); /* Refined panel background */
  --panel-border: #00bfffcc;
  --panel-shadow: 0 0 35px #00eaffc9; /* Subtler panel glow */
  --submit-bg: linear-gradient(94deg,#00d8ff,#0078ff 90%); /* Refined submit button */
  --submit-text: #0b1a38;
  --submit-hover-bg: #0066d9;
  --submit-hover-text: #fff;
  --header-text-glow: 0 0 10px #00e0ffaa, 0 0 20px #00bfff88;
  --header-text-anim-glow-1: 0 0 14px #00eaff70,0 0 25px #00bfff44;
  --header-text-anim-glow-2: 0 0 24px #00f0ffdd,0 0 38px #00d2ff82;
  --header-text-fill: linear-gradient(90deg,#00f0ff,#00aaff 40%,#fff 59%,#0087ed 89%,#00c3ff 100%);

  /* Custom Scrollbar Styles */
  --scrollbar-track-bg: #0a1f40;
  --scrollbar-thumb-bg: #00aaff;
  --scrollbar-thumb-hover-bg: #00ccff;
}
html, body {
  height: 100vh; width: 100vw; margin: 0; padding: 0;
  color: var(--main-text);
  background: var(--body-bg);
  background-blend-mode: var(--body-blend-mode);
  font-family: 'Roboto','Inter',system-ui,-apple-system,Segoe UI,sans-serif;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  transition: background 0.3s ease;
  overflow: hidden; /* Ensure no scroll on body directly */
}
/* Custom Scrollbar Styles (for Webkit browsers) */
::-webkit-scrollbar { width: 10px; }
::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); border-radius: 10px; }
::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb-bg); border-radius: 10px; transition: background 0.2s ease; }
::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover-bg); }

#stars-container {
  pointer-events: none;
  position: fixed; left:0; top:0;right:0;bottom:0;
  width:100vw; height:100vh; z-index:1;
  overflow: hidden;
}
.star {
  position:absolute;
  background: var(--cyan);
  box-shadow: 0 0 8px var(--cyan) inset, 0 0 15px var(--cyan); /* Subtler star glow */
  opacity: 0.18; /* Less opaque for a delicate shimmer */
  border-radius: 50%;
  pointer-events: none;
  animation: star-twinkle 3s infinite alternate; /* Slightly longer twinkle */
}
@keyframes star-twinkle {
  0% { opacity:.15; transform: scale(0.9); }
  41% { opacity:.75; transform: scale(1.1); } /* More dynamic scale */
  100%{ opacity:.10; transform: scale(0.85);}
}
.header-bar {
  position: fixed; top: 0; left: 0; width: 100vw;
  display: flex; align-items: center; justify-content: space-between;
  background: var(--header-glass);
  z-index: 1003;
  padding: 0;
  box-shadow: 0 5px 35px #00aaff20, 0 2px 30px #09fcfe10; /* Softer shadow */
  border-radius: 0 0 18px 18px; /* Slightly smaller radius */
  height: 65px; /* Slightly more compact header */
  transition: background 0.3s ease, box-shadow 0.3s ease;
}
.menu-btn {
  background: none; border: none;
  color: var(--cyan); font-size: 1.8em; cursor: pointer; /* Slightly smaller icon */
  border-radius: 12px; margin-left: 15px; margin-right: 2px;
  padding: 6px 10px; /* Adjusted padding */
  transition: background 0.15s ease, color 0.15s ease;
}
.menu-btn:hover { background: #00eaff20; color: #fff; }
/* Theme switcher button style */
#themeBtn {
  font-size: 1.5em; /* Adjusted size */
  padding: 6px 11px;
  margin-left: -8px;
}
.site-heading {
  font-family: 'Orbitron',sans-serif;
  font-size: 1.2em; font-weight: 700; /* Slightly smaller font */
  text-align: center; flex: 1;
  letter-spacing: .25px;
  white-space:nowrap;
  background: var(--header-text-fill);
  background-size: 250% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: neonglow 4s ease-in-out infinite alternate; /* Adjusted animation duration */
  text-shadow: var(--header-text-glow);
  user-select: none; margin-left: 7px; margin-right: 9px;
}
.header-welcome {
  color: #68e6fd; font-size: .9em; margin: -2px 0 .6em 0; text-align: center;
  text-shadow: 0 0 12px #00bcb4a0; /* Subtler shadow */
}
.main-content {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    overflow-y: hidden;
    position: relative;
    padding-top: 65px; /* Adjust for header height */
    padding-bottom: 86px; /* Space for the input row */
    box-sizing: border-box;
}
.chat-box {
  flex: 1 1 0px; 
  overflow-y: auto;
  overflow-x: hidden;
  width: 100vw; max-width: 680px; /* Slightly wider chat area */
  margin: 0 auto;
  box-sizing: border-box;
  padding: 15px 12px 15px 12px; /* Increased side padding */
  position: relative;
  z-index:3;
  scroll-behavior: smooth;
  display: flex;
  flex-direction: column;
}
#typing-status {
  display: none;
  max-width: 680px; /* Match chat box width */
  margin: 0 auto;
  padding: 0 12px; /* Match chat box padding */
  width: 100vw;
  box-sizing: border-box;
  flex-shrink: 0;
  min-height: 25px; /* More space for indicator */
  padding-bottom: 12px;
}
.chat-message {
  width: 100%; display: flex; gap:10px; align-items: flex-end; /* Slightly increased gap */
  margin: 9px 0; max-width:100vw; /* Adjusted margin */
  flex-shrink: 0;
}
.chat-message .msg {
  font-size: 1em; line-height: 1.55; /* Refined line height */
  max-width: 65vw; min-width:0; 
  padding: 10px 15px 11px 14px; /* Adjusted padding */
  border-radius: 15px 13px 10px 11px; /* Slightly refined radius */
  word-break: break-word; white-space: pre-wrap; overflow-x: auto;
  background: var(--gradient-1); color: var(--main-text);
  text-shadow: 0 0 2px #23d8ff10; /* Lighter text shadow */
  box-shadow: var(--bubble-glow);
  margin-right: auto; margin-left: 0;
  border: 1.2px solid #0090ff80; /* Softer border */
  position:relative;
  transition:background .3s, color .3s, box-shadow .3s, border-color .3s;
}
.chat-message.user { justify-content: flex-end; }
.chat-message.user .msg {
  background: var(--gradient-user);
  color: var(--submit-text); font-weight: 700;
  text-shadow: 0 0 4px #00e0ff70, 0 0 1px #00ffe030; /* Subtler shadow */
  border-radius: 16px 12px 14px 10px; /* Refined radius */
  margin-left: auto; margin-right: 0;
  box-shadow: var(--user-glow);
  border: 1.2px solid #00eff4b0; /* Softer border */
  max-width: 70vw; /* Adjusted max-width */
}
@media (max-width:790px) {
  .chat-box { max-width:100vw; padding: 15px 8px 15px 8px; } /* Mobile padding */
  #typing-status { padding: 0 8px 12px 8px; }
  .chat-message .msg { font-size: .96em; padding:9px 4vw 10px 5vw; max-width:85vw;}
  .chat-message.user .msg { max-width: 88vw; }
}
.typing-bubble {
  display: inline-flex;
  align-items: center;
  height: 30px; /* Slightly taller */
  padding: 5px 13px; /* Adjusted padding */
  margin: 6px 4px;
  border-radius: 16px; /* Slightly larger radius */
  background: linear-gradient(90deg,#0a4070dd 30%,#0db2ff88 95%); /* Refined gradient */
  box-shadow: 0 2px 10px #0dfcff60; /* Softer shadow */
  border: 1px solid #00ffff45; /* Softer border */
}
.dot-anim {
  width: 9px; height: 9px; /* Slightly larger dots */
  margin:0 3.5px; /* Adjusted spacing */
  background: var(--cyan);
  box-shadow: 0 0 7px var(--cyan); /* Stronger glow for dots */
}
pre, code {
  font-family: 'JetBrains Mono','Fira Mono','Menlo',monospace;
  font-size: .95em; /* Slightly smaller code font */
  background: var(--code-bg);
  border-radius: 10px; /* Softer radius */
  border: 1.5px solid var(--code-border); /* Slightly thinner border */
  color: var(--code-text);
  box-shadow: 0 0 15px #00eaff30, 0 0 35px #0beaff30 inset; /* Subtler glow */
}
pre {
  padding: 1em 1.2em 1em 1em; /* Adjusted padding */
  margin: 1em 0 .9em 0;
}
pre:before {
  content: "CODE";
  color: var(--cyan);
  font-size: 0.78em; /* Smaller label */
  top: 4px; right: 25px; opacity: 0.15; /* Adjusted position and opacity */
}
.copy-btn {
  top: 8px; right: 10px; /* Adjusted position */
  border-radius: 7px; padding: 2px 13px; /* Adjusted padding */
  background: linear-gradient(95deg,#00d8ff 40%,#0078ff 120%); /* Refined gradient */
  color: #0c1f3d; font-size: .92em; /* Smaller font */
  box-shadow: 0 1px 7px #00d8ffc0,0 0 5px #00d8ffa0; /* Subtler shadow */
}
.copy-btn:hover { background: #0066d9; color: #fff; }

.inline-copy-btn, .inline-share-btn, .regen-btn, .inline-edit-btn {
  padding:5px 11px; border-radius:8px; /* Refined padding and radius */
  font-size:.92em; /* Smaller font */
  gap:5px; margin-top:7px; margin-right: 4px;
  box-shadow:0 2px 6px #00eaff50; /* Subtler shadow */
}
.file-link, .file-placeholder {
  padding: 7px 11px;
  background: #081e3a; /* Darker background */
  border: 1px solid #00eaff50; /* Softer border */
  border-radius: 9px;
  color: var(--cyan);
  font-size: 0.88em; /* Smaller font */
}
.file-preview{
  background:rgba(12,25,50,0.95); /* Darker, slightly less opaque */
  border-radius:15px;color:#c0efff;font-size:.95em;
  box-shadow:0 3px 12px #00a0b0a0; /* Subtler shadow */
  padding:10px 15px 10px 15px;
  bottom: 95px; /* Slightly higher position */
  border: 1.5px solid #00c3ff35; /* Softer border */
}

/* --- IMPROVED KEYBOARD FIT --- */
.chat-input-row {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 0;
  display: flex;
  align-items: stretch;
  gap: 10px; /* Slightly increased gap */
  background: rgba(12, 22, 40, 0.96); /* More integrated with header glass */
  backdrop-filter: blur(10px); /* Stronger blur */
  border: 1.5px solid #00eaff50; /* Softer border */
  border-radius: 20px 20px 0 0; /* Slightly smaller radius */
  width: 96vw; /* Slightly wider */
  max-width: 920px; /* Wider max-width */
  padding: 10px 14px 11px 15px; /* Adjusted padding */
  box-shadow: 0 0 30px #007fff20, 0 8px 25px #00fff010; /* Subtler shadow */
  z-index: 1003;
}
@media (max-width: 920px) {
  .chat-input-row {
    width: 96vw;
    max-width: 100%;
    left: 50%;
    transform: translateX(-50%);
    border-radius: 20px 20px 8px 8px; /* Maintain rounded top for mobile */
  }
}
.chat-input-row textarea{
  flex:1 1 auto;resize:none;min-height:38px;max-height:130px; /* Adjusted heights */
  background: var(--input-bg);color: var(--main-text);font-size:.98em; /* Smaller font */
  padding:11px 13px;border:none;border-radius:10px; /* Refined radius */
  box-shadow:0 1px 5px #00f2ff20 inset; /* Inner shadow for depth */
  transition: background 0.3s, color 0.3s, box-shadow 0.2s;
}
.chat-input-row button, .chat-input-row label{
  background:none;border:none;color:var(--cyan);font-size:1.15em; /* Smaller icon */
  cursor:pointer;border-radius:9px;transition:color .13s,background .15s;padding:0;
  display:flex;align-items:center;justify-content:center;min-width:32px; /* Adjusted size */
  box-shadow: 0 0 2px #00eaff15; /* Subtler shadow */
}
.chat-input-row button:hover, .chat-input-row label:hover{color:#fff;background:#00cdf23a;} /* Softer hover */
#callBtn { font-size: 1.05em; } /* Smaller phone icon */

#stopBtn {
  background: #e63e3e; /* Slightly softer red */
  color: white;
  font-size: 1.15em; /* Adjusted size */
  border-radius: 10px;
  padding: 0;
  min-width: 32px;
  box-shadow: 0 0 8px #e63e3e80; /* Subtler shadow */
}

#stopBtn:hover { background: #ff5555; }

#emojiPanel {
  background: #041a3cd0; /* Deeper, more opaque */
  border-radius: 18px; /* Larger radius */
  padding: 18px 16px 14px 16px; /* Adjusted padding */
  box-shadow: 0 5px 20px #00eaff80; /* Subtler shadow */
  border: 1px solid #00c3ff55; /* Softer border */
}
.emoji-pick {
  font-size:1.2em;
  padding:3px 7px;
  border-radius:9px;
}
.emoji-pick:hover { background:#30c0f055; }
.status-message{padding:5px 12px;color:#00ffcc;font-size:.95em;min-height:15px;} /* Adjusted style */
.panel-bg { background:rgba(10,16,36,0.9); } /* Darker overlay */
.side-panel{
  width:310px; /* Slightly narrower */
  background: var(--panel-bg);
  border-right:2px solid var(--panel-border); /* Thinner border */
  box-shadow: var(--panel-shadow);
  padding:15px 14px 18px 14px; /* Adjusted padding */
  border-radius:0 20px 28px 0; /* Refined radius */
}
.side-panel .panel-header{margin:15px 0 10px 0;}
.side-panel img{width:50px;height:50px;border-radius:50%;margin-bottom:7px;border:2px solid #30f0ffea;} /* Smaller image */
.side-panel .username{font-weight:700;font-size:1.05em;color:#00c3ff;font-family:'Orbitron',sans-serif;text-shadow:0 0 7px #00eaffb0;} /* Adjusted font & shadow */
.side-panel .email{font-size:.92em;color:#a0e0ff;} /* Adjusted font */
.panel-links a{color: var(--link-text);font-size:1.02em;padding:7px 3px;gap:10px;border-radius:8px;} /* Adjusted style */
.panel-links a:hover{background:#00eaff45;color:#f0faff;}
#chatsList button{font-size:1.05em;margin:0 4px;padding:2px 4px;} /* Adjusted size */
.edit-form label{margin-top:9px;font-size:.96em;color:#30e0ff;text-shadow:0 1px 12px #10aaff60;}
.edit-form input, .edit-form textarea, .edit-form select{
  padding:6px 10px;margin-top:4px;
  border:1.5px solid #10e0ff80;border-radius:8px;background:#051a2f;color:#fff;font-size:.98em;
  box-shadow:0 0 7px #00f0ff70 inset;
}
.edit-form input:focus, .edit-form textarea:focus, .edit-form select:focus{border-color:#20e0ff;background:#203550;}
.submit-btn{
  margin-top:12px; padding:9px 18px;
  background: var(--submit-bg);
  border-radius:9px;
  color: var(--submit-text); font-weight:bold; cursor:pointer; font-size:1.05em;
  box-shadow:0 2px 10px #00eaff80;
}
.submit-btn:hover{background: var(--submit-hover-bg);color: var(--submit-hover-text);}

/* Lightbox for images */
#lightbox {
  background: rgba(0,0,0,0.9); /* More opaque */
}
#lightbox img {
  border: 2px solid var(--cyan);
  border-radius: 8px;
  box-shadow: 0 0 40px var(--cyan); /* Stronger glow */
}

/* Voice Call Modal */
#callModal {
  background: var(--dark-bg);
}
#callHeader {
  color: var(--cyan); font-family: 'Orbitron', sans-serif;
  font-size: 1.4em; text-shadow: 0 0 8px var(--cyan); /* Subtler shadow */
  margin-bottom: 18px;
}
#botImageContainer {
  margin-top: 18px;
}
#botImageContainer img {
  width: 140px; height: 140px; /* Slightly smaller image */
  border: 3px solid var(--cyan); /* Thinner border */
  box-shadow: 0 0 25px var(--cyan); /* Subtler shadow */
}
#botImageContainer.speaking img {
    border-color: #00ff00;
    box-shadow: 0 0 25px #00ff00;
}
#botSpeakingIndicator {
  width: 150px; height: 150px; /* Adjusted indicator size */
  border: 4px solid transparent; /* Thinner border */
  box-shadow: 0 0 18px var(--cyan); /* Subtler shadow */
}
#botImageContainer.speaking #botSpeakingIndicator {
    box-shadow: 0 0 25px #00ff00;
    border-color: #00ff00;
}

#callStatusMessage {
    color: var(--cyan);
    font-size: 1em; /* Smaller font */
    margin-top: 12px;
    height: 25px;
    text-shadow: 0 0 4px #00aaff;
}
#tapToTalk {
    color: #ff00ff;
    font-size: 1.1em; /* Smaller font */
    margin-top: 4px;
    text-shadow: 0 0 7px #ff00ff;
}
#callConversation {
  margin: 18px 0;
  border: 1px solid var(--fade-blue);
  border-radius: 9px; padding: 9px;
  background: rgba(0, 0, 0, 0.15); /* Lighter background */
}
.call-msg {
  padding: 7px 11px; border-radius: 9px;
  margin-bottom: 8px;
}
#callControls { 
  gap: 18px; 
  padding-bottom: 18px;
}
#endCallBtn, #muteCallBtn {
  background: #d03030; /* Softer red */
  font-size: 1.1em; padding: 9px 18px;
  border-radius: 9px;
  box-shadow: 0 0 8px #d0303080;
}
#endCallBtn:hover, #muteCallBtn:hover {
  background: #ff6060;
  box-shadow: 0 0 12px #ff6060aa;
}
#muteCallBtn {
    background: #0060d9; /* Softer blue */
    box-shadow: 0 0 8px #0060d980;
}
#muteCallBtn.muted {
    background: #444;
}
#muteCallBtn.muted:hover {
    background: #666;
}

/* Spinner for loading states */
.spinner {
  width: 18px; height: 18px; /* Slightly smaller */
  border: 2px solid rgba(0, 255, 247, 0.3); /* Thinner border */
  border-top-color: var(--cyan);
  margin-right: 7px;
}
  </style>
</head>
<body>
  <div id="stars-container"></div>

  <div class="main-content">
    
    <div class="header-bar">
      <button class="menu-btn" id="openProfileMenu" aria-label="Open profile menu"><i class="fa-solid fa-user"></i></button>
      <div class="header-titles">
        <span class="site-heading">ðŸ¦…Philadelphia AIðŸ¦…</span>
        <div class="header-welcome" id="headerWelcome"></div>
      </div>
      <button class="menu-btn" id="themeBtn" aria-label="Change theme"><i class="fa-solid fa-moon"></i></button>
      <button class="menu-btn" id="openLinksMenu" aria-label="Open links menu"><i class="fa-solid fa-link"></i></button>
    </div>

    <div class="chat-box" id="chatBox"></div>
    
    <div id="typing-status" class="chat-message ai" style="display: none;"></div>

    <form class="chat-input-row" id="chatForm" autocomplete="off">
      <button type="button" id="emojiBtn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>
      <label for="chatFile" class="file-upload-btn" title="Attach file"><i class="fa-solid fa-paperclip"></i></label>
      <input type="file" id="chatFile" accept="application/pdf,image/*,audio/*,video/*" multiple style="display:none">
      <textarea id="chatInput" placeholder="Type hereâ€¦ (Shift+Enter = new line)"></textarea>
      <button type="button" id="callBtn" title="Start Voice Call"><i class="fa-solid fa-phone"></i></button>
      <button type="button" id="toolBtn" title="Philadelphia Tools" aria-controls="toolMenu" aria-expanded="false"><i class="fa-solid fa-wrench"></i></button>
      <button type="submit" id="sendBtn" title="Send"><i class="fa-solid fa-paper-plane"></i></button>
    </form>
  </div>
  
  <div id="emojiPanel"></div>
  <div class="status-message" id="statusMsg"></div>
  <div id="filePreview" class="file-preview"></div>
  
  <div class="panel-bg" id="profileMenuBg">
    <nav class="side-panel" id="profileMenu">
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <span style="font-size:1.17em;font-weight:700;color:#00ffff;margin:18px 0 0 13px;">Chats</span>
        <button style="font-size:1.55em;color:#f44;background:transparent;border:none;margin:13px 11px 0 0;cursor:pointer;border-radius:7px;"
          onclick="profileMenuBg.classList.remove('active');">&times;</button>
      </div>
      <div id="chatsList" style="margin:7px 0 8px 6px;max-height:161px;overflow-y:auto;">
        <div class="spinner" style="margin: 20px auto; display: block;"></div>
      </div>
      <button id="newChatBtn" class="submit-btn" style="margin:0 0 12px 11px;"><i class="fa-solid fa-plus"></i> New Chat</button>
      <hr style="width:91%;margin:11px 0 7px 3%;border:1px solid #00fff031;">
      <div class="panel-header">
        <img id="profilePicPreview" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo">
        <div class="username" id="profileMenuUser">User</div>
        <div class="email" id="profileMenuEmail">email@example.com</div>
      </div>
      <form class="edit-form" id="profileForm" autocomplete="off" style="padding:0 6px;">
        <label for="edit-name">Name</label>
        <input type="text" id="edit-name" required>
        <label for="edit-photo">Photo URL</label>
        <input type="url" id="edit-photo" placeholder="Paste image link">
        <span style="font-size:0.83em;color:#aae;display:block;margin:5px 0 7px 2px;">
          Tip: <a href="https://postimg.cc/" target="_blank" style="color:#19fcff;">Upload at postimg.cc</a>
        </span>
        <button type="submit" class="submit-btn">Save</button>
        <div class="status-message" id="profileStatusMsg"></div>
      </form>
      <button class="submit-btn" id="logoutBtn" style="background:#10213b;color:#00eefd;margin:7px 7px 17px 7px;">Logout</button>
    </nav>
  </div>
  
  <div id="ai-image-preview" style="display:none;position:fixed;z-index:1210;right:22px;bottom:100px;max-width:320px;background:#191a26e9;padding:12px;border-radius:17px;box-shadow:0 2px 19px #00fff2b8;">
    <button id="ai-image-close" style="float:right;background:#23233a;border:none;border-radius:7px;color:#00ffff;font-size:1.5em;cursor:pointer;margin-left:5px;">&times;</button>
    <div id="ai-image-container"></div>
    <button id="ai-image-dl" style="margin-top:9px;padding:7px 20px;background:linear-gradient(90deg,#00ffff,#0090ff);color:#222;border:none;border-radius:8px;box-shadow:0 2px 7px #00fff2c7;cursor:pointer;font-weight:bold;">Download</button>
  </div>
  
  <div class="panel-bg" id="linkMenuBg">
    <nav class="side-panel" id="linkMenu">
      <div class="panel-header">
        <img src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Philadelphia logo">
        <div class="username">Philadelphia AI</div>
      </div>
      <div class="panel-links">
        <a href="philadelphia.html"><i class="fa-solid fa-home"></i>Philadelphia Homepage</a>
        <a href="index.html"><i class="fa-solid fa-home"></i>Elvion Homepage</a>
        <a href="about.html"><i class="fa-solid fa-circle-info"></i> About US</a>
        <a href="privacy.html"><i class="fa-solid fa-shield-halved"></i> Privacy Policy</a>
        <a href="terms.html"><i class="fa-solid fa-file-contract"></i> Terms</a>
        <a href="https://t.me/writingurubot" target="_blank"><i class="fab fa-telegram"></i> Try Telegram Version</a>
      </div>
    </nav>
  </div>

  <div class="panel-bg" id="toolsMenuBg">
    <nav class="side-panel" id="toolsMenu">
        <div class="panel-header" style="text-align:left;">
            <div class="username" style="font-size:1.2em;margin-left:-8px;text-align:center;">Philadelphia AI Tools</div>
        </div>
        <div class="panel-links">
            <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Creative Suite</h3>
            <a href="#" class="tool-link" data-tool="image"><i class="fa-solid fa-image"></i> Generate Image</a>
            <a href="#" class="tool-link" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> Edit Photo</a>
            <a href="#" class="tool-link" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> Remove Background</a>
            <a href="#" class="tool-link" data-tool="comic"><i class="fa-solid fa-book-open"></i> Create Comic</a>
            <hr style="border-color: #00eaff30; margin: 10px 0;">
            <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Audio & Video</h3>
            <a href="#" class="tool-link" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> Voice Generation</a>
            <a href="#" class="tool-link" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> Audio Narration</a>
            <a href="#" class="tool-link" data-tool="video-text"><i class="fa-solid fa-film"></i> Text-to-Video</a>
            <a href="#" class="tool-link" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> Image-to-Video</a>
            <a href="#" class="tool-link" data-tool="music"><i class="fa-solid fa-music"></i> Generate Music</a>
            <hr style="border-color: #00eaff30; margin: 10px 0;">
            <h3 style="color:#00aaff;margin:10px 0 5px 4px;font-size:0.9em;text-transform:uppercase;">Web & Research</h3>
            <a href="#" class="tool-link" data-tool="website"><i class="fa-solid fa-globe"></i> Create Website</a>
            <a href="#" class="tool-link" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> Edit Last Website</a>
            <a href="#" class="tool-link" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> My Websites</a>
            <a href="#" class="tool-link" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> Research Report</a>
        </div>
        <button class="submit-btn" style="margin-top:17px;" onclick="closeToolMenu();">Close</button>
    </nav>
  </div>

  <div class="panel-bg" id="toolFormModalBg">
    <nav class="side-panel" id="toolFormModal">
      <div class="panel-header">
        <div class="username" id="toolFormTitle">Tool Title</div>
      </div>
      <form class="edit-form" id="toolForm" style="padding:0 6px;"></form>
      <button id="toolFormBackBtn" class="submit-btn" style="background:#10213b;color:#00eefd;margin:7px 7px 17px 7px;">
          <i class="fa-solid fa-arrow-left"></i> Back to Tools
      </button>
      <div class="status-message" id="toolStatusMsg"></div>
    </nav>
  </div>

  <div id="lightbox">
    <img src="" alt="Lightbox image">
  </div>

  <div id="callModal">
    <div id="callHeader">Philadelphia AI - Live Call</div>
    <div id="botImageContainer">
      <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="Bot">
      <div id="botSpeakingIndicator"></div>
    </div>
    <div id="callStatusMessage">Connecting...</div>
    <div id="tapToTalk">Tap Anywhere to Speak</div>
    <div id="callConversation">
      <div class="call-msg status">Waiting for connection...</div>
    </div>
    <div id="callControls">
      <button id="muteCallBtn" class="submit-btn"><i class="fa-solid fa-microphone"></i> Mute Microphone</button>
      <button id="endCallBtn" class="submit-btn" style="background: #d23;"><i class="fa-solid fa-phone-slash"></i> End Call</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="module">
// --- START OF FULLY REVAMPED & FIRESTORE-INTEGRATED JAVASCRIPT ---

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getAuth, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
// Import Firestore modules
import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, 
         query, orderBy, serverTimestamp, getDocs, writeBatch 
       } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
  authDomain: "elvionai.firebaseapp.com",
  projectId: "elvionai",
  storageBucket: "elvionai.appspot.com",
  messagingSenderId: "161078300830",
  appId: "1:161078300830:web:f460df8591704eb0e96b8f"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app); // Initialize Firestore

// Short helper
const $ = id => document.getElementById(id);

// API Base URL
const API_BASE_URL = 'https://web-production-9a18.up.railway.app';

// ---------- Global State Management & AbortController ----------
let chats = []; // Array of {id, name, createdAt}
let currentChatId = null;
let currentMessages = []; // Array of {id, role, text, files, createdAt}
let uploadedFiles = [];
let currentUser = null;
let currentController = null; // Controller for ongoing chat/file fetch

// Firestore listener unsubscribers
let chatsUnsubscribe = null;
let messagesUnsubscribe = null;

window.addEventListener('DOMContentLoaded', () => {
  // ---------- Element Selectors ----------
  const starsContainer = $('stars-container');
  const profileMenuBg = $('profileMenuBg');
  const profileMenu = $('profileMenu');
  const linkMenuBg = $('linkMenuBg');
  const linkMenu = $('linkMenu');
  const toolsMenuBg = $('toolsMenuBg');
  const toolsMenu = $('toolsMenu');
  const toolBtn = $('toolBtn');
  const logoutBtn = $('logoutBtn');
  const headerWelcome = $('headerWelcome');
  const profileMenuUser = $('profileMenuUser');
  const profileMenuEmail = $('profileMenuEmail');
  const editName = $('edit-name');
  const editPhoto = $('edit-photo');
  const profilePicPreview = $('profilePicPreview');
  const profileForm = $('profileForm');
  const chatBox = $('chatBox');
  const chatForm = $('chatForm');
  const chatInput = $('chatInput');
  const sendBtn = $('sendBtn');
  const chatFile = $('chatFile');
  const filePreview = $('filePreview');
  const newChatBtn = $('newChatBtn');
  const chatsListEl = $('chatsList');
  const emojiPanel = $('emojiPanel');
  const emojiBtn = $('emojiBtn');
  const toolFormModalBg = $('toolFormModalBg');
  const toolForm = $('toolForm');
  const toolFormTitle = $('toolFormTitle');
  const toolFormBackBtn = $('toolFormBackBtn');
  const aiPrevBox = $('ai-image-preview');
  const aiPrevClose = $('ai-image-close');
  const aiPrevDLBtn = $('ai-image-dl');
  const aiPrevImgBox = $('ai-image-container');
  const themeBtn = $('themeBtn');
  const lightbox = $('lightbox');
  const callBtn = $('callBtn');
  const callModal = $('callModal');
  const endCallBtn = $('endCallBtn');
  const muteCallBtn = $('muteCallBtn'); // NEW: Mute button
  const callConversation = $('callConversation');
  const botImageContainer = $('botImageContainer');
  const callStatusMessage = $('callStatusMessage');
  const tapToTalk = $('tapToTalk');
  const typingStatus = $('typing-status'); 

  if (!chatForm || !chatBox || !toolsMenu || !typingStatus) {
    console.error("Essential UI elements are missing. App functionality will be limited.");
    return;
  }

  // ---------- UI Initializers & Event Handlers ----------
  if (starsContainer) {
    starsContainer.innerHTML = '';
    for (let i = 0; i < 34; i++) {
      const s = document.createElement('div'); s.className = 'star';
      const z = Math.random() * 2.1 + 1; s.style.width = z + 'px'; s.style.height = z + 'px';
      s.style.left = Math.random() * 100 + '%'; s.style.top = Math.random() * 100 + '%';
      s.style.animationDelay = (Math.random() * 3.69) + 's';
      s.style.animationDuration = (2.2 + Math.random() * 1.1) + 's';
      starsContainer.appendChild(s);
    }
  }

  const emojis = ["ðŸ˜€","ðŸ˜‚","ðŸ˜","ðŸ¥°","ðŸ˜Ž","ðŸ‘","ðŸ™","ðŸ”¥","ðŸ’¯","ðŸŽ‰","ðŸ˜‡","ðŸ¤–","ðŸ‘€"];
  if (emojiBtn && emojiPanel && chatInput) {
    emojiBtn.addEventListener('click', (e) => {
      emojiPanel.innerHTML = emojis.map(em => `<span class="emoji-pick" role="button">${em}</span>`).join('');
      emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block';
      try {
        const rect = emojiBtn.getBoundingClientRect();
        emojiPanel.style.left = `${Math.max(8, rect.left)}px`;
      } catch (e) { /* ignore positioning errors */ }
      emojiPanel.querySelectorAll('.emoji-pick').forEach(span => {
        span.addEventListener('click', function () {
          const text = this.textContent || '';
          const start = chatInput.selectionStart || 0;
          const end = chatInput.selectionEnd || 0;
          chatInput.value = chatInput.value.slice(0, start) + text + chatInput.value.slice(end);
          chatInput.focus();
          chatInput.selectionStart = chatInput.selectionEnd = start + text.length;
          emojiPanel.style.display = 'none';
          chatInput.dispatchEvent(new Event('input'));
        });
      });
    });
    document.addEventListener('click', e => {
      if (emojiPanel && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
        emojiPanel.style.display = 'none';
      }
    });
  }

  if (chatInput) {
    const autoResize = () => { chatInput.style.height = 'auto'; chatInput.style.height = Math.min(chatInput.scrollHeight, 168) + 'px'; };
    chatInput.addEventListener('input', autoResize);
    // *** FIX: Standardized keyboard input. Enter to submit, Shift+Enter for new line.
    chatInput.addEventListener('keydown', e => { 
        if (e.key === 'Enter' && !e.shiftKey) { 
            e.preventDefault(); 
            chatForm.requestSubmit();
        }
        // Shift+Enter will naturally create a new line, so no special handling is needed.
    });
    autoResize();
  }
  
  if (chatFile) {
      chatFile.addEventListener('change', function() {
          uploadedFiles = Array.from(this.files || []);
          renderFilePreview();
      });
  }
  
  if (aiPrevClose) aiPrevClose.addEventListener('click', () => { aiPrevBox.style.display = 'none'; });
  if (aiPrevDLBtn) aiPrevDLBtn.addEventListener('click', () => {
    const img = aiPrevImgBox.querySelector('img');
    if (img) {
      const a = document.createElement('a'); a.href = img.src; a.download = 'philadelphia_ai_image.png'; a.click();
    }
  });

  // Image Lightbox handler
  if (lightbox) {
    lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
  }
  if (chatBox) {
    chatBox.addEventListener('click', e => {
      if (e.target.tagName === 'IMG' && e.target.closest('.chat-message.ai .msg')) {
        e.preventDefault();
        const lbImg = lightbox.querySelector('img');
        if (lbImg) {
          lbImg.src = e.target.src;
          lightbox.classList.add('active');
        }
      }
    });
  }

  // ---------- Panel & Modal Management ----------
  window.closeToolMenu = () => { if (toolsMenuBg) toolsMenuBg.classList.remove('active'); };
  window.openToolMenu = () => { if (toolsMenuBg) toolsMenuBg.classList.add('active'); };

  if (profileMenuBg) {
    $('openProfileMenu').addEventListener('click', () => {
      profileMenuBg.classList.add('active');
      setTimeout(() => profileMenu.classList.add('active'), 10);
    });
    profileMenuBg.addEventListener('click', e => { if (e.target === profileMenuBg) { profileMenu.classList.remove('active'); setTimeout(() => profileMenuBg.classList.remove('active'), 110); } });
  }
  if (linkMenuBg) {
    $('openLinksMenu').addEventListener('click', () => {
      linkMenuBg.classList.add('active');
      setTimeout(() => linkMenu.classList.add('active'), 10);
    });
    linkMenuBg.addEventListener('click', e => { if (e.target === linkMenuBg) { linkMenu.classList.remove('active'); setTimeout(() => linkMenuBg.classList.remove('active'), 110); } });
  }
  if (toolBtn) toolBtn.addEventListener('click', openToolMenu);
  if (toolsMenuBg) toolsMenuBg.addEventListener('click', e => { if (e.target === toolsMenuBg) closeToolMenu(); });
  if (toolFormBackBtn) {
    toolFormBackBtn.addEventListener('click', () => {
      toolFormModalBg.classList.remove('active');
      openToolMenu();
    });
  }
  if (toolFormModalBg) toolFormModalBg.addEventListener('click', e => { if (e.target === toolFormModalBg) toolFormModalBg.classList.remove('active'); });
  if (logoutBtn) logoutBtn.addEventListener('click', () => {
      auth.signOut();
      window.location.href = 'signup-login.html';
  });


  // ---------- Authentication & Profile Management ----------
  onAuthStateChanged(auth, user => {
    if (!user) {
      try { window.location.href = "signup-login.html"; } catch (e) {}
      return;
    }
    currentUser = user;
    if (headerWelcome) headerWelcome.textContent = "Welcome, " + (user.displayName || (user.email || '').split('@')[0]);
    if (profileMenuUser) profileMenuUser.textContent = user.displayName || "User";
    if (profileMenuEmail) profileMenuEmail.textContent = user.email || "";
    if (editName) editName.value = user.displayName || "";
    if (editPhoto) editPhoto.value = user.photoURL || "";
    if (profilePicPreview) profilePicPreview.src = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

    // Start loading chats from Firestore
    loadUserChats(user.uid);
  });

  if (profileForm) {
    profileForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!currentUser) return;
      const status = $('profileStatusMsg');
      if (status) status.textContent = 'Saving...';
      try {
        await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
        if (auth.currentUser) await auth.currentUser.reload();
        if (status) { status.textContent = "Profile updated!"; status.style.color = "#00ffff"; }
        setTimeout(() => { profileMenuBg?.classList.remove('active'); }, 800);
        if (headerWelcome) headerWelcome.textContent = "Welcome, " + (auth.currentUser?.displayName || 'User');
      } catch (err) {
        if (status) { status.textContent = err.message; status.style.color = "#ffd700"; }
      }
    });
  }

  // ---------- Firestore Chat Logic ----------

  async function loadUserChats(userId) {
    if (chatsUnsubscribe) chatsUnsubscribe(); // Unsubscribe from old listener
    
    const chatsCol = collection(db, 'users', userId, 'chats');
    const q = query(chatsCol, orderBy('createdAt', 'desc'));
    
    chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
      if (snapshot.empty) {
        // No chats exist, create one
        await createNewChat(userId);
        // The listener will re-run, so we just return
        return;
      }
      
      chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      renderChatsListSidebar();
      
      if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
        // If no chat is selected, or selected chat was deleted, select the newest one
        currentChatId = chats[0].id;
      }
      
      // Subscribe to messages for the currently selected chat
      subscribeToMessages(userId, currentChatId);
    }, (error) => {
      console.error("Error fetching chats: ", error);
      chatsListEl.innerHTML = `<div style="color: #f44;">Error loading chats.</div>`;
    });
  }

  async function createNewChat(userId) {
    if (!userId) userId = currentUser?.uid;
    if (!userId) return;
    
    const chatsCol = collection(db, 'users', userId, 'chats');
    try {
      const newChatDoc = await addDoc(chatsCol, {
        name: "New Chat",
        createdAt: serverTimestamp()
      });
      currentChatId = newChatDoc.id;
      // No need to manually switch, the listener will handle it
    } catch (e) {
      console.error("Error creating new chat: ", e);
    }
  }

  function subscribeToMessages(userId, chatId) {
    if (messagesUnsubscribe) messagesUnsubscribe(); // Unsubscribe from old messages
    
    if (!userId || !chatId) {
      renderChatBox([]); // Clear chat box if no chat is selected
      return;
    }
    
    const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
    const q = query(messagesCol, orderBy('createdAt'));
    
    messagesUnsubscribe = onSnapshot(q, (snapshot) => {
      currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      renderChatBox(currentMessages);
    }, (error) => {
      console.error("Error fetching messages: ", error);
      chatBox.innerHTML = `<div style="color: #f44; text-align: center; margin-top: 20px;">Error loading messages for this chat.</div>`;
    });
  }

  if (newChatBtn) {
    newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));
  }

  function renderChatsListSidebar() {
    if (!chatsListEl) return;
    chatsListEl.innerHTML = '';
    
    if (chats.length === 0) {
        chatsListEl.innerHTML = `<div style="padding: 10px; color: #a8eaff;">No chats yet.</div>`;
        return;
    }
    
    chats.forEach((chat) => {
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.marginBottom = '6px';
      container.style.background = chat.id === currentChatId ? 'rgba(0, 234, 255, 0.15)' : 'transparent';
      container.style.borderRadius = '8px';

      const titleSpan = document.createElement('span');
      titleSpan.textContent = chat.name || `Chat`;
      titleSpan.style.flex = '1';
      titleSpan.style.cursor = 'pointer';
      titleSpan.style.padding = '8px 5px';
      titleSpan.onclick = () => {
        currentChatId = chat.id;
        subscribeToMessages(currentUser.uid, currentChatId);
        renderChatsListSidebar(); // Re-render to show selection
        profileMenu?.classList.remove('active');
        profileMenuBg?.classList.remove('active');
      };

      const renameBtn = document.createElement('button');
      renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
      renameBtn.title = 'Rename';
      renameBtn.style.margin = '0 6px 0 8px';
      renameBtn.onclick = async (e) => {
        e.stopPropagation();
        const newName = prompt("Rename chat:", chat.name);
        if (newName && newName.trim()) {
          const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
          await setDoc(chatDoc, { name: newName.trim() }, { merge: true });
          // Listener will update UI
        }
      };

      const delBtn = document.createElement('button');
      delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
      delBtn.title = 'Delete';
      delBtn.style.marginLeft = '6px';
      delBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm(`Delete "${chat.name}"? This will delete all messages.`)) return;
        
        // Delete all messages in subcollection (batched)
        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
        const messagesSnap = await getDocs(messagesCol);
        const batch = writeBatch(db);
        messagesSnap.docs.forEach(d => batch.delete(d.ref));
        await batch.commit();

        // Delete chat doc
        const chatDoc = doc(db, 'users', currentUser.uid, 'chats', chat.id);
        await deleteDoc(chatDoc);
        
        // If deleting current chat, reset
        if (currentChatId === chat.id) {
            currentChatId = null;
        }
        // Listener will update sidebar
      };

      container.appendChild(titleSpan);
      container.appendChild(renameBtn);
      container.appendChild(delBtn);
      chatsListEl.appendChild(container);
    });
  }

  // ---------- Chat Rendering Logic ----------

  const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

  function inlineMarkdown(t = '') {
    let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
    s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
    s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
    s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
    return s.replace(/\n/g, '<br>');
  }

  function renderMarkdown(text = '') {
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    let html = '';
    let lastIndex = 0;
    text = text || '';
    text.replace(codeBlockRegex, (match, lang, code, offset) => {
      const before = text.slice(lastIndex, offset);
      html += inlineMarkdown(before);
      const language = (lang || '').toLowerCase().trim();
      const safe = escapeHTML(code);
      html += `<pre><button class="copy-btn">Copy</button><code class="language-${language || 'plaintext'}">${safe}</code></pre>`;
      lastIndex = offset + match.length;
      return match;
    });
    html += inlineMarkdown(text.slice(lastIndex));
    return { html };
  }

  function enhanceCodeBlocks(container) {
    if (!container) return;
    container.querySelectorAll('pre').forEach(pre => {
      const codeEl = pre.querySelector('code');
      if (window.hljs && codeEl) {
        try { hljs.highlightElement(codeEl); } catch (e) { /* ignore */ }
      }
      const btn = pre.querySelector('.copy-btn');
      if (btn && codeEl) {
        btn.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(codeEl.innerText);
            const prev = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = prev, 800);
          } catch (e) { btn.textContent = 'Failed'; setTimeout(() => btn.textContent = 'Copy', 800); }
        });
      }
    });
  }
  
  function renderChatBox(messages = []) {
    if (!chatBox) return;
    chatBox.innerHTML = '';

    (messages || []).forEach((msg) => {
      const div = document.createElement('div');
      div.className = 'chat-message ' + (msg.role === 'user' ? 'user' : 'ai');
      div.setAttribute('data-message-id', msg.id);

      let innerHtml = '';
      if (msg.role === 'user') {
        const fileHtml = (msg.files || [])
          .map(file => {
            let icon = 'fa-file';
            if (file.type.startsWith('image/')) icon = 'fa-file-image';
            else if (file.type.startsWith('video/')) icon = 'fa-file-video';
            else if (file.type.startsWith('audio/')) icon = 'fa-file-audio';
            else if (file.type === 'application/pdf') icon = 'fa-file-pdf';
            
            return `<div class="file-placeholder"><i class="fa-solid ${icon}"></i> ${escapeHTML(file.name)}</div>`;
          })
          .join('');
        
        innerHtml = `<div class="msg">
          ${fileHtml ? `<div class="file-attachments">${fileHtml}</div>` : ''}
          ${escapeHTML(msg.text || '')}
          <div class="user-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
            <button class="inline-edit-btn" title="Edit"><i class="fa-solid fa-pen-to-square"></i></button>
            <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
          </div>
        </div>`;
      } else { // AI message
        let content;
        // Check for media tags or download links to render as raw HTML
        if (msg.text && (msg.text.includes('<img') || msg.text.includes('<audio') || msg.text.includes('<video') || msg.text.includes('download='))) {
             content = msg.text;
        } else {
             content = renderMarkdown(msg.text || '').html;
        }

        innerHtml = `<div class="msg">${content}
          <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
            <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
            <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
            <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
          </div>
        </div>`;
      }
      
      div.innerHTML = innerHtml;
      chatBox.appendChild(div);
    });
    enhanceCodeBlocks(chatBox);
    hookAiMsgControls();
    hookUserMsgControls();
    
    setTimeout(() => {
        chatBox.scrollTop = chatBox.scrollHeight;
    }, 50); 
  }

  // --- New Firestore-Aware Message Controls ---

  async function deleteMessagesFrom(messageId) {
      if (!currentChatId || !currentUser) return;

      const msgIndex = currentMessages.findIndex(m => m.id === messageId);
      if (msgIndex === -1) return;

      const batch = writeBatch(db);
      const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
      
      for (let i = msgIndex; i < currentMessages.length; i++) {
          const msgToDel = currentMessages[i];
          const docRef = doc(messagesCol, msgToDel.id);
          batch.delete(docRef);
      }
      
      try {
          await batch.commit();
      } catch (e) {
          console.error("Error deleting messages: ", e);
      }
  }

  function hookAiMsgControls() {
    if (!chatBox) return;
    chatBox.querySelectorAll('.chat-message.ai').forEach(div => {
      const messageId = div.getAttribute('data-message-id');
      const msg = currentMessages.find(m => m.id === messageId);
      if (!msg) return;

      const controls = div.querySelector('.ai-msg-controls');
      if (!controls) return;
      
      const copyBtn = controls.querySelector('.inline-copy-btn');
      const shareBtn = controls.querySelector('.inline-share-btn');
      const regenBtn = controls.querySelector('.regen-btn');

      if (copyBtn) copyBtn.onclick = () => {
        try {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = msg.text;
          const textToCopy = tempDiv.textContent || tempDiv.innerText || '';

          navigator.clipboard.writeText(textToCopy);
          copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
          setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
        } catch (e) { console.warn('copy failed', e); }
      };

      if (shareBtn) shareBtn.onclick = () => {
        try {
          const url = window.location.origin;
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = msg.text;
          const plainText = tempDiv.textContent || tempDiv.innerText || '';
          const shareText = `${plainText}\n\nShared via Philadelphia AI: ${url}`;
          if (navigator.share) navigator.share({ title: "Philadelphia AI", text: shareText, url }).catch(()=>{});
          else prompt("Copy and share manually:", shareText);
        } catch (e) { console.warn('share failed', e); }
      };

      // *** FIX: Corrected regeneration logic to be persistent.
      if (regenBtn) regenBtn.onclick = async () => {
          const msgIndex = currentMessages.findIndex(m => m.id === messageId);
          if (msgIndex < 1) return; // Can't regenerate first message

          const userMsg = currentMessages[msgIndex - 1];
          if (userMsg.role !== 'user') return; // Preceding message wasn't user

          // Delete this AI message and all subsequent messages
          await deleteMessagesFrom(messageId);
          
          // Show "thinking..." immediately
          showTypingAtNext();
          
          // Build history for regen
          const historyForRegen = currentMessages
              .slice(0, msgIndex - 1) // Get all messages *before* the user's prompt
              .map(m => ({ role: m.role, content: m.text || '' }));

          try {
              const res = await fetch(`${API_BASE_URL}/chat`, { 
                  method: 'POST', 
                  headers: { 'Content-Type': 'application/json' }, 
                  body: JSON.stringify({ 
                      message: userMsg.text, 
                      history: historyForRegen, 
                      user_id: currentUser?.uid || "user" 
                  }) 
              });
              const data = await res.json();
              removeTyping();
              if (!res.ok) throw new Error(data.error || "Server error.");
              
              // This now correctly saves the new response. The onSnapshot listener will render it.
              await addMessageToChat('ai', data.response);

          } catch (err) {
              removeTyping();
              // Save the error as a message
              await addMessageToChat('ai', `âŒ Regeneration error: ${err.message}`);
          }
      };
    });
  }

  function hookUserMsgControls() {
    if (!chatBox) return;
    chatBox.querySelectorAll('.chat-message.user').forEach(div => {
      const messageId = div.getAttribute('data-message-id');
      const msg = currentMessages.find(m => m.id === messageId);
      if (!msg) return;

      const controls = div.querySelector('.user-msg-controls');
      if (!controls) return;
      const copyBtn = controls.querySelector('.inline-copy-btn');
      const editBtn = controls.querySelector('.inline-edit-btn');

      if (copyBtn) copyBtn.onclick = () => {
        try {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = msg.text;
          const textToCopy = tempDiv.textContent || tempDiv.innerText || '';

          navigator.clipboard.writeText(textToCopy);
          copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i> Copied!";
          setTimeout(() => copyBtn.innerHTML = "<i class='fa-solid fa-copy'></i>", 950);
        } catch (e) { console.warn('copy failed', e); }
      };

      if (editBtn) editBtn.onclick = async () => {
        try {
          if (!msg.text) return;
          chatInput.value = msg.text;
          chatInput.focus();
          
          // Delete this message and all subsequent messages
          await deleteMessagesFrom(messageId);
          
        } catch (e) { console.warn('edit failed', e); }
      };
    });
  }

  // --- Typing Indicator Functions ---
  function showTypingAtNext() {
    if (!typingStatus) return;
    typingStatus.innerHTML = `<div class="msg"><span class="typing-bubble"><span class="dot-anim"></span><span class="dot-anim"></span><span class="dot-anim"></span></span></div>`;
    typingStatus.style.display = 'flex';
    // Ensure scroll to bottom to show typing indicator
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  function showTypingWithText(text) {
      if (!typingStatus) return;
      // Removed the bubble and just show the spinner and text
      typingStatus.innerHTML = `<div class="msg" style="display:flex;align-items:center;"><span class="spinner"></span> <span style="margin-left:8px; color:var(--main-text); font-style:italic;">${text}</span></div>`;
      typingStatus.style.display = 'flex';
      // Ensure scroll to bottom to show typing indicator
      chatBox.scrollTop = chatBox.scrollHeight;
  }

  function removeTyping() {
    if (!typingStatus) return;
    typingStatus.style.display = 'none';
    typingStatus.innerHTML = '';
  }

  // --- Typewriter Function (FIXED: Simplified and improved to always save to DB) ---
  async function startTypewriter(text) {
    // If the text contains media, save it directly without typewriter effect.
    if (text && (text.includes('<img') || text.includes('<audio') || text.includes('<video') || text.includes('download='))) {
        await addMessageToChat('ai', text);
        return;
    }

    // Standard Typewriter (for text/markdown)
    if (!chatBox) return;
    
    // 1. Create a temporary message node for the animation
    const div = document.createElement('div');
    div.className = "chat-message ai";
    const msgdiv = document.createElement('div');
    msgdiv.className = 'msg';
    div.appendChild(msgdiv);
    chatBox.appendChild(div); // Add temp node to chatBox

    let sofar = '';
    const words = text.split(/(\s+)/); // Split on spaces, keeping them

    for (const word of words) {
      if (currentController?.signal.aborted) {
        text = sofar; // Save the aborted text
        break;
      }
      sofar += word;
      msgdiv.textContent = sofar; // Append raw text content
      chatBox.scrollTop = chatBox.scrollHeight;
      
      const delay = word.match(/[\s\.\,\!\?]/) ? 10 : 30; // Speed check
      await new Promise(res => setTimeout(res, delay));
    }
    
    // Final render with markdown and controls
    msgdiv.innerHTML = renderMarkdown(text).html + `
      <div class="ai-msg-controls" style="display:flex;justify-content:flex-end;gap:10px;margin-top:8px;">
          <button class="inline-copy-btn" title="Copy"><i class="fa-solid fa-copy"></i></button>
          <button class="inline-share-btn" title="Share"><i class="fa-solid fa-share"></i></button>
          <button class="regen-btn" title="Regenerate"><i class="fa-solid fa-rotate-right"></i></button>
      </div>
    `;
    enhanceCodeBlocks(msgdiv);
    chatBox.scrollTop = chatBox.scrollHeight;

    // 3. Save the final message to Firestore
    try {
        const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
        await addDoc(messagesCol, {
            role: 'ai',
            text: text, // Save the full (or aborted) text
            createdAt: serverTimestamp()
        });
        // The onSnapshot listener will now fire,
        // replacing our temporary animated node with the permanent, DB-driven one.
        // It will look seamless.
    } catch (e) {
        console.error("Error saving AI message: ", e);
        msgdiv.innerHTML += "<br><small style='color: #f44;'>Failed to save message.</small>";
    }
  }


  function renderFilePreview() {
    if (!filePreview) return;
    if (!uploadedFiles.length) {
      filePreview.style.display = 'none';
      filePreview.innerHTML = '';
      return;
    }
    filePreview.style.display = 'block';
    filePreview.innerHTML = uploadedFiles.map((file, idx) => {
      let preview = '';
      if (file.type.startsWith('image/')) {
        preview = `<img src="${URL.createObjectURL(file)}" style="max-width:58px;max-height:41px;vertical-align:middle;border-radius:8px;margin-right:6px;">`;
      } else if (file.type.startsWith('video/')) {
        preview = `<video src="${URL.createObjectURL(file)}" controls style="max-width:58px;height:41px;vertical-align:middle;border-radius:8px;margin-right:7px;"></video>`;
      } else if (file.type.startsWith('audio/')) {
        preview = `<audio controls src="${URL.createObjectURL(file)}" style="vertical-align:middle;width:52px;margin-right:7px;"></audio>`;
      } else if (file.type === 'application/pdf') {
        preview = `<span style="font-size:1.25em;margin-right:7px;">ðŸ“„</span>`;
      }
      return `
      <div style="display:flex;align-items:center;gap:7px;margin-bottom:1px;">
        ${preview}
        <span style="color:#aee;font-size:.99em;">${escapeHTML(file.name)}</span>
        <button type="button" data-idx="${idx}" class="remove-file-btn" aria-label="Remove file">&times;</button>
      </div>`;
    }).join('');
    filePreview.querySelectorAll('.remove-file-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = parseInt(btn.getAttribute('data-idx'));
        uploadedFiles.splice(idx, 1);
        if (!uploadedFiles.length && chatFile) chatFile.value = '';
        renderFilePreview();
      });
    });
  }

  function showAIImagePreview(base64, caption = '') {
    if (!aiPrevBox || !aiPrevImgBox) return;
    aiPrevImgBox.innerHTML = `<img src="data:image/png;base64,${base64}" alt="AI generated image" style="max-width:210px;max-height:210px;border-radius:12px;display:block;">` +
                              `<div style="color:#aee;font-size:.95em;margin-top:3px;text-align:center;">${caption}</div>`;
    aiPrevBox.style.display = 'block';
  }

  async function addMessageToChat(role, text, files = []) {
      if (!currentChatId || !currentUser) return;
      
      const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
      try {
          await addDoc(messagesCol, {
              role,
              text,
              files, // This will be an array of {name, type}
              createdAt: serverTimestamp()
          });
          // The onSnapshot listener will handle the UI update
      } catch (e) {
          console.error("Error adding message to Firestore: ", e);
      }
  }
  
  // Helper to convert Blob to Base64 for persistent storage
  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
  }

  async function handleVideoGeneration(payload, isImageToVideo = false) {
    showTypingWithText('Submitting video generation job...');
    try {
        const endpoint = isImageToVideo ? '/api/tools/generate-video-from-image' : '/api/tools/generate-video-from-text';
        const commonPayload = {
            model: "MiniMax-Hailuo-02", // Explicitly set model
            duration: payload.duration || 6, // Default duration if not provided
            resolution: payload.resolution || "1080P" // Default resolution
        };

        let options;
        if (isImageToVideo) {
            payload.append('model', commonPayload.model);
            payload.append('duration', commonPayload.duration);
            payload.append('resolution', commonPayload.resolution);
            options = { method: 'POST', body: payload };
        } else {
            const finalPayload = { ...payload, ...commonPayload };
            options = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(finalPayload) };
        }

        const startRes = await fetch(API_BASE_URL + endpoint, options);
        const startData = await startRes.json();
        if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'Failed to start video task.');
        
        removeTyping();
        await startTypewriter(`âœ… Video job submitted! Task ID: \`${startData.task_id}\`. I'll notify you when it's ready. This can take a few minutes. Do not leave this page or send another message or task.`);
        
        const pollInterval = setInterval(async () => {
            try {
                const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${startData.task_id}`);
                const statusData = await statusRes.json();
                if (statusRes.ok && statusData.url) {
                    clearInterval(pollInterval);
                    const videoHtml = `ðŸŽ‰ Your video is ready! <br><video controls src="${statusData.url}" class="chat-media-preview video-preview-thumb"></video>`;
                    await addMessageToChat('ai', videoHtml); // Save HTML directly
                } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                    clearInterval(pollInterval);
                    await startTypewriter(`âŒ Video generation failed. Reason: ${statusData.error || 'Unknown error'}`);
                }
            } catch (pollErr) {
                clearInterval(pollInterval);
                await startTypewriter(`âŒ Error checking video status.`);
            }
        }, 20000);
    } catch (err) {
        removeTyping();
        await startTypewriter(`âŒ Could not start video generation: ${err.message}`);
    }
  }

  const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
  const toolDefinitions = {
    "image": {
        title: "Generate Image",
        description: "Create stunning visuals from a text prompt. Choose a model for different results.",
        buildForm: () => `
            <label for="tool-provider">Generation Model</label>
            <select id="tool-provider"><option value="thena">Version 1 (Stylized, Fast & Recommended)</option><option value="minimax">Version 2 (Creative, Realistic, good for text in images)</option></select>
            <label for="tool-prompt">Image Prompt</label>
            <textarea id="tool-prompt" placeholder="A futuristic cityscape, vibrant neon signs, flying cars" required></textarea>
            <label for="tool-style">Style (for Version1 only)</label>
            <select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-sparkles"></i> Generate</button>`,
        handleSubmit: async (form) => {
            const use_minimax = form.querySelector('#tool-provider').value === 'minimax';
            const providerName = use_minimax ? 'Version 2 (Creative)' : 'Version 1 (Stylized)';
            const payload = { prompt: form.querySelector('#tool-prompt').value, model: form.querySelector('#tool-style').value, use_minimax };
            await addMessageToChat('user', `Image generation request: "${payload.prompt}" (using ${providerName})`);
            showTypingWithText('Generating your image...');
            try {
                const res = await fetch(`${API_BASE_URL}/generate-image`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || res.statusText);
                showAIImagePreview(data.image_b64, `Generated by Philadelphia AI`);
                removeTyping();
                await addMessageToChat('ai', 'âœ… Image generated! Check the floating image box to view or download.');
                return null;
            } catch (err) { removeTyping(); return `âŒ Image generation failed: ${err.message}`; }
        }
    },
    "edit-photo": {
        title: "Edit Photo",
        description: "Upload a photo and describe the changes you want to make.",
        buildForm: () => `
            <label for="tool-prompt">Edit Instruction</label><textarea id="tool-prompt" placeholder="Change the background to a sunny beach" required></textarea>
            <label for="tool-file">Image to Edit</label><input type="file" id="tool-file" accept="image/*" required>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-wand-magic-sparkles"></i> Apply Edit</button>`,
        handleSubmit: async (form) => {
            const file = form.querySelector('#tool-file').files[0];
            const prompt = form.querySelector('#tool-prompt').value;
            if (!file) return "Please select a file to edit.";
            const fd = new FormData(); fd.append('file', file); fd.append('prompt', prompt);
            await addMessageToChat('user', `Photo edit request for ${file.name}: "${prompt}"`, [{name: file.name, type: file.type}]);
            showTypingWithText('Editing your photo...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                if (!res.ok) throw new Error((await res.json()).error || 'Failed to edit photo.');
                const blob = await res.blob();
                // *** FIX: Use base64 for persistent storage.
                const base64String = await blobToBase64(blob);
                const imgHtml = `âœ… Photo edited successfully! <br><img src="${base64String}" alt="Edited Photo" class="chat-media-preview image-preview-thumb">`;
                removeTyping();
                await addMessageToChat('ai', imgHtml);
                return null;
            } catch (err) { removeTyping(); return `âŒ Photo edit failed: ${err.message}`; }
        }
    },
     "remove-bg": {
        title: "Remove Background",
        description: "Select an image file to automatically remove its background.",
        buildForm: () => `
            <label for="tool-file">Select Image File</label><input type="file" id="tool-file" accept="image/*" required style="display:block;margin-top:10px;">
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-scissors"></i> Remove Background</button>`,
        handleSubmit: async (form) => {
            const file = form.querySelector('#tool-file').files[0];
            if (!file) return "Please select a file.";
            await addMessageToChat('user', `Background removal request for: "${file.name}"`, [{name: file.name, type: file.type}]);
            showTypingWithText('Removing background...');
            const fd = new FormData(); fd.append('file', file);
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                if (!res.ok) throw new Error(res.statusText);
                const blob = await res.blob();
                // *** FIX: Use base64 for persistent storage.
                const base64String = await blobToBase64(blob);
                const imgHtml = `âœ… Background removed! <br><img src="${base64String}" alt="Image with background removed" class="chat-media-preview image-preview-thumb">`;
                removeTyping();
                await addMessageToChat('ai', imgHtml);
                return null;
            } catch (err) { removeTyping(); return `âŒ Background removal failed: ${err.message}`; }
        }
    },
    "comic": {
        title: "Create Comic",
        description: "Write a story and watch it transform into a comic strip. Use tags like [DIALOGUE], [INSTRUCTION] and [NARRATION] to guide the story.",
        buildForm: () => `
            <label for="tool-story">Comic Story</label><textarea id="tool-story" placeholder="[DIALOGUE] Are you seeing this?&#10;[NARRATION] Lilo and switch were once best friends..." required></textarea>
            <label for="tool-style">Comic Style</label><select id="tool-style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
            <label for="tool-panels">Number of Panels</label><input type="number" id="tool-panels" value="3" min="1" max="6" />
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-book-open"></i> Create Comic</button>`,
        handleSubmit: async (form) => {
            const payload = { story: form.querySelector('#tool-story').value, style: form.querySelector('#tool-style').value, panels: parseInt(form.querySelector('#tool-panels').value, 10), user: currentUser?.displayName || "User" };
            await addMessageToChat('user', `Comic creation request with style: ${payload.style}.`);
            showTypingWithText('Generating your comic panels...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || res.statusText);
                const imagesHtml = data.images.map((img, idx) => `<img src="data:image/png;base64,${img}" alt="Comic Panel ${idx+1}" class="chat-media-preview image-preview-thumb" style="max-width: 150px; display: inline-block; margin: 5px;">`).join('');
                const comicMessage = `ðŸ–¼ï¸ Comic successfully created! <br><div class="file-attachments" style="justify-content:center;">${imagesHtml}</div>`;
                removeTyping();
                await addMessageToChat('ai', comicMessage);
                return null;
            } catch (err) { removeTyping(); return `âŒ Comic generation failed: ${err.message}`; }
        }
    },
    "voice-gen": {
        title: "Voice Generation",
        description: "Transform text into realistic speech. Choose a provider and voice style.",
        buildForm: () => `
            <label for="tool-provider">Voice Provider</label><select id="tool-provider"><option value="gemini">Philadelphia (Styles)</option><option value="minimax">Seraphina (Characters)</option></select>
            <label for="tool-prompt">Text to Speak</label><textarea id="tool-prompt" placeholder="The eagle soars high..." required></textarea>
            <label for="tool-style">Voice Style</label><select id="tool-style"></select>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-microphone"></i> Generate Voice</button>`,
        onFormReady: () => {
            const providerSelect = $('tool-provider'), styleSelect = $('tool-style');
            const voices = { gemini: ["podcast", "cinematic", "upbeat", "soft", "dramatic"], minimax: ["anime", "movie", "narrator", "knight", "elder", "sweet", "casual", "ceo", "hero", "elegant"] };
            const updateStyles = () => { styleSelect.innerHTML = voices[providerSelect.value].map(v => `<option value="${v}">${v.charAt(0).toUpperCase() + v.slice(1)}</option>`).join(''); };
            providerSelect.addEventListener('change', updateStyles);
            updateStyles();
        },
        handleSubmit: async (form) => {
            const provider = form.querySelector('#tool-provider').value, text = form.querySelector('#tool-prompt').value, style = form.querySelector('#tool-style').value;
            const providerName = provider === 'minimax' ? 'Seraphina' : 'Philadelphia';
            await addMessageToChat('user', `Voice generation request using ${providerName}.`);
            showTypingWithText('Generating your audio...');
            try {
                let res;
                if (provider === 'gemini') {
                    const fd = new FormData(); fd.append('text', text); fd.append('style', style);
                    res = await fetch(`${API_BASE_URL}/voicegen`, { method: 'POST', body: fd });
                } else {
                    res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ text, voice_id: style }) });
                }
                if (!res.ok) throw new Error(await res.text());
                const blob = await res.blob();
                // *** FIX: Use base64 for persistent storage.
                const base64String = await blobToBase64(blob);
                const audioHtml = `ðŸ—£ï¸ Voice generated! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                removeTyping();
                await addMessageToChat('ai', audioHtml);
                return null;
            } catch (err) { removeTyping(); return `âŒ Voice generation failed: ${err.message}`; }
        }
    },
    "audio-narration": {
        title: "Audio Narration",
        description: "Upload a document (PDF, TXT) to get a podcast-style narrated audio summary.",
        buildForm: () => `
          <label for="tool-file">Select File for Narration</label><input type="file" id="tool-file" accept="application/pdf, text/plain" required style="display:block;margin-top:10px;">
          <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-file-audio"></i> Generate Narration</button>`,
        handleSubmit: async (form) => {
            const file = form.querySelector('#tool-file').files[0];
            if (!file) return "Please select a file.";
            await addMessageToChat('user', `Audio narration request for: "${file.name}"`, [{name: file.name, type: file.type}]);
            showTypingWithText('Analyzing and narrating document...');
            const fd = new FormData(); fd.append('file', file); fd.append('style', 'podcast');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                if (!res.ok) throw new Error(res.statusText);
                const blob = await res.blob();
                // *** FIX: Use base64 for persistent storage.
                const base64String = await blobToBase64(blob);
                const narrationHtml = `ðŸ—£ï¸ Narration generated! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                removeTyping();
                await addMessageToChat('ai', narrationHtml);
                return null;
            } catch (err) { removeTyping(); return `âŒ Audio narration failed: ${err.message}`; }
        }
    },
    "video-text": {
        title: "Generate Video from Text",
        description: "Describe the video you want to create. This process can take a few minutes.",
        buildForm: () => `
            <label for="video-prompt">Video Prompt</label><textarea id="video-prompt" placeholder="A majestic eagle flying over mountains..." required></textarea>
            <label for="video-duration">Duration (seconds)</label><input type="number" id="video-duration" value="6" min="2" max="15">
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
        handleSubmit: async (form) => {
            const payload = { prompt: form.querySelector('#video-prompt').value, duration: parseInt(form.querySelector('#video-duration').value, 10), resolution: "1080P" };
            await addMessageToChat('user', `Text-to-Video request: "${payload.prompt}"`);
            handleVideoGeneration(payload); // This will handle its own typing indicators
            return null;
        }
    },
    "video-image": {
        title: "Generate Video from Image",
        description: "Upload a starting image and describe how you want to animate it.",
        buildForm: () => `
            <label for="video-image-prompt">Animation Prompt</label><textarea id="video-image-prompt" placeholder="Make the clouds move, gentle zoom in" required></textarea>
            <label for="video-image-file">Starting Image</label><input type="file" id="video-image-file" accept="image/*" required>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-play"></i> Start Generation</button>`,
        handleSubmit: async (form) => {
            const file = form.querySelector('#video-image-file').files[0];
            if (!file) return "Please select an image.";
            await addMessageToChat('user', `Image-to-Video request for: ${file.name}`, [{name: file.name, type: file.type}]);
            const fd = new FormData(); 
            fd.append('prompt', form.querySelector('#video-image-prompt').value); 
            fd.append('file', file);
            handleVideoGeneration(fd, true); // This will handle its own typing indicators
            return null;
        }
    },
    "music": {
        title: "Generate Music",
        description: "Generate music from a prompt, lyrics, and optional reference audio. Thanks to MiniMax.",
        buildForm: () => `
            <label for="music-prompt">Music Prompt / Description</label><textarea id="music-prompt" placeholder="Upbeat electronic pop song..." required></textarea>
            <label for="music-lyrics">Lyrics (Optional)</label><textarea id="music-lyrics" placeholder="Verse 1...&#10;Chorus..."></textarea>
            <label for="music-ref">Reference Audio (Optional)</label><input type="file" id="music-ref" accept="audio/*">
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-music"></i> Generate Music</button>`,
        handleSubmit: async (form) => {
            const payload = { prompt: form.querySelector('#music-prompt').value, lyrics: form.querySelector('#music-lyrics').value, model: 'music-1.5' };
            const refFile = form.querySelector('#music-ref').files[0];
            await addMessageToChat('user', `Music generation request: "${payload.prompt}"`);
            showTypingWithText('Composing your music...');
            try {
                if (refFile) {
                    showTypingWithText('Uploading reference audio first...');
                    const fd = new FormData(); fd.append('file', refFile);
                    const uploadRes = await fetch(`${API_BASE_URL}/api/tools/upload-music`, { method: 'POST', body: fd });
                    const uploadData = await uploadRes.json();
                    if (!uploadRes.ok) throw new Error(uploadData.error || "Reference upload failed.");
                    if (uploadData.instrumental_id) payload.instrumental_id = uploadData.instrumental_id;
                    if (uploadData.voice_id) payload.voice_id = uploadData.voice_id;
                    showTypingWithText('Reference uploaded. Composing music...');
                }
                const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!res.ok) throw new Error((await res.json()).detail || 'API request failed.');
                const blob = await res.blob();
                // *** FIX: Use base64 for persistent storage.
                const base64String = await blobToBase64(blob);
                const musicHtml = `ðŸŽµ Your music is ready! <br><audio controls src="${base64String}" class="chat-media-preview audio-preview-thumb"></audio>`;
                removeTyping();
                await addMessageToChat('ai', musicHtml);
                return null;
            } catch (err) { removeTyping(); return `âŒ Music generation failed: ${err.message}`; }
        }
    },
    "website": {
        title: "Create Website",
        description: "Describe the website you want to build and get a live, working prototype.",
        buildForm: () => `
            <label for="website-prompt">Website Description</label><textarea id="website-prompt" placeholder="A simple portfolio website for a graphic designer..." required></textarea>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-globe"></i> Generate Website</button>`,
        handleSubmit: async (form) => {
            const prompt = form.querySelector('#website-prompt').value;
            await addMessageToChat('user', `Website creation request: "${prompt.substring(0, 50)}..."`);
            showTypingWithText('Building and deploying your website...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ prompt, user_id: currentUser.uid }) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || res.statusText);
                removeTyping();
                return `ðŸŒ Website deployed successfully! [View here](${data.url})`;
            } catch (err) { removeTyping(); return `âŒ Website creation failed: ${err.message}`; }
        }
    },
    "edit-website": {
        title: "Edit Last Website",
        description: "Provide an instruction to modify the most recent website you created.",
        buildForm: () => `
            <label for="edit-instruction">Edit Instruction</label><textarea id="edit-instruction" placeholder="Change the main heading to 'Welcome to my Studio'..." required></textarea>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-pen-ruler"></i> Apply Changes</button>`,
        handleSubmit: async (form) => {
            const instruction = form.querySelector('#edit-instruction').value;
            await addMessageToChat('user', `Website edit request: "${instruction.substring(0, 50)}..."`);
            showTypingWithText('Editing and redeploying your website...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ instruction, user_id: currentUser.uid }) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || res.statusText);
                removeTyping();
                return `âœï¸ Website updated successfully! [View new version here](${data.url})`;
            } catch (err) { removeTyping(); return `âŒ Website edit failed: ${err.message}`; }
        }
    },
    "my-sites": {
        isAction: true,
        runAction: async () => {
            await addMessageToChat('user', 'Show me a list of my websites.');
            showTypingWithText('Fetching your website list...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Could not fetch sites.');
                if (!data.sites || data.sites.length === 0) return "You haven't created any websites yet.";
                const siteList = data.sites.map(site => `- <a href="${site.site_url}" target="_blank">${site.site_url}</a> (Created: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                removeTyping();
                return `Here are the websites you've created:\n${siteList}`;
            } catch (err) { removeTyping(); return `âŒ Error fetching websites: ${err.message}`; }
        }
    },
    "research-report": {
        title: "Research Report",
        description: "Generate a comprehensive research report in PDF format on any topic.",
        buildForm: () => `
            <label for="research-topic">Research Topic</label><input type="text" id="research-topic" placeholder="The history of artificial intelligence" required>
            <button type="submit" class="submit-btn" style="width:100%;"><i class="fa-solid fa-flask-vial"></i> Generate Report</button>`,
        handleSubmit: async (form) => {
            const topic = form.querySelector('#research-topic').value;
            await addMessageToChat('user', `Research report request on: "${topic}"`);
            showTypingWithText('Conducting research and compiling report...');
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/research`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ topic }) });
                if (!res.ok) throw new Error(res.statusText);
                const blob = await res.blob();
                // *** FIX: Use base64 for persistent download link.
                const base64String = await blobToBase64(blob);
                const downloadLink = `<a href="${base64String}" download="research_${topic.replace(/\s/g, '_')}.pdf" style="color:var(--link-text);font-weight:bold;">Download PDF Report</a>`;
                removeTyping();
                return `âœ… Research report on **${topic}** is ready! ${downloadLink}`;
            } catch (err) { removeTyping(); return `âŒ Research report failed: ${err.message}`; }
        }
    },
  };

  if (toolsMenu) {
    toolsMenu.addEventListener('click', async (e) => {
        const toolLink = e.target.closest('.tool-link');
        if (!toolLink) return;
        e.preventDefault();
        const toolKey = toolLink.getAttribute('data-tool');
        const tool = toolDefinitions[toolKey];
        if (!tool) return console.error(`Tool "${toolKey}" is not defined.`);
        closeToolMenu();
        if (tool.isAction) {
            const result = await tool.runAction();
            removeTyping();
            if(result) await startTypewriter(result); // Use typewriter
        } else {
            displayToolForm(toolKey);
        }
    });
  }

  function displayToolForm(toolKey) {
    const tool = toolDefinitions[toolKey];
    if (!tool || !toolFormModalBg) return;
    toolFormTitle.textContent = tool.title;
    const descriptionHtml = tool.description ? `<div style="color:#a8eaff;font-size:.9em;margin-bottom:12px;">${tool.description}</div>` : '';
    toolForm.innerHTML = descriptionHtml + tool.buildForm();
    if (typeof tool.onFormReady === 'function') tool.onFormReady();
    toolForm.onsubmit = async (e) => {
        e.preventDefault();
        const submitButton = toolForm.querySelector('button[type="submit"]');
        const originalButtonContent = submitButton.innerHTML;
        submitButton.innerHTML = `<div class="spinner"></div> Processing...`;
        submitButton.disabled = true;
        toolFormModalBg.classList.remove('active');
        const resultText = await tool.handleSubmit(toolForm);
        
        // This handles cases where the tool returns a string result (e.g., website link, error)
        if (resultText) {
            removeTyping();
            await startTypewriter(resultText); // Use typewriter
        }
        submitButton.innerHTML = originalButtonContent;
        submitButton.disabled = false;
    };
    toolFormModalBg.classList.add('active');
  }

  /* ---------- MAIN CHAT SUBMIT HANDLER ---------- */
  chatForm.addEventListener('submit', async function (e) {
    e.preventDefault();
    if (!currentChatId) {
      alert("Please select a chat or create a new one.");
      return;
    }
    const msgText = chatInput.value.trim();
    if (!msgText && uploadedFiles.length === 0) return;

    const stopButton = document.createElement('button');
    stopButton.type = 'button';
    stopButton.id = 'stopBtn';
    stopButton.innerHTML = '<i class="fa-solid fa-stop"></i>';
    sendBtn.replaceWith(stopButton);

    currentController = new AbortController();
    const signal = currentController.signal;
    let finalResponse = '';

    stopButton.addEventListener('click', () => {
      if (currentController) {
        currentController.abort();
      }
    });
    
    // Save user message first
    const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type }));
    await addMessageToChat('user', msgText, filesForHistory);
    
    const localUploadedFiles = [...uploadedFiles]; // Copy for processing
    chatInput.value = ''; 
    uploadedFiles = []; 
    renderFilePreview();
    chatInput.style.height = 'auto'; // Reset height
    
    if (localUploadedFiles.length > 0) {
      showTypingWithText('Analyzing your file(s)...');
      
      let endpoint = '';
      const file = localUploadedFiles[0];
      if (file.type.startsWith('image/')) endpoint = '/understand-image';
      else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
      else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
      else if (file.type.startsWith('video/')) endpoint = '/understand-video';
      else { removeTyping(); finalResponse = "Sorry, I can't analyze that file type."; }
      
      try {
        if(endpoint) {
          const fd = new FormData();
          fd.append('prompt', msgText || `Describe this ${file.type.split('/')[0]}`);
          fd.append('file', file);
          const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Analysis failed.");
          finalResponse = data.response;
        }
      } catch (err) {
        finalResponse = err.name === 'AbortError' ? 'âŒ File analysis stopped.' : `âŒ File analysis failed: ${err.message}`;
      }
    } else if (msgText) {
      showTypingAtNext(); // Show "..."
      try {
        // Build history from currentMessages
        const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
        
        const res = await fetch(`${API_BASE_URL}/chat`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: msgText, history, user_id: currentUser?.uid || "user" }), signal });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || "Server error.");
        finalResponse = data.response;
      } catch (err) {
        finalResponse = err.name === 'AbortError' ? 'âŒ Response stopped.' : `âŒ An error occurred: ${err.message}`;
      }
    }

    // Handle final response and cleanup
    removeTyping(); 
    if (finalResponse) {
      await startTypewriter(finalResponse); 
    }
    
    stopButton.replaceWith(sendBtn);
    currentController = null;
  });
  
  // ---------- Theme Switcher Logic ----------
  const themes = {
    cyber: { // Default (Enhanced)
      '--cyan': '#00e7ff', '--blue': '#0a8afe', '--dark-bg': '#060918', '--fade-blue': '#0e3070',
      '--gradient-1': 'linear-gradient(120deg, #02123d 39%, #053a7a 68%, #0ebfff 97%)',
      '--gradient-user': 'linear-gradient(120deg, #0d6cfd 32%, #00f0ff 89%)',
      '--bubble-glow': '0 0 10px #00d8ff90, 0 0 18px #0197ff40', '--user-glow': '0 0 18px #0fffd555, 0 0 10px #36f9ff70',
      '--header-glass': 'rgba(12, 22, 40, 0.95)', '--code-bg': 'linear-gradient(92deg,#031a34 79%,#0525d8 120%)',
      '--code-border': '#00c3ff', '--code-text': '#e0faff', '--main-text': '#e0faff', '--link-text': '#00c3ff',
      '--input-bg': '#071f3e',
      '--body-bg': 'radial-gradient(circle at 60% 45%, #0e214d 37%, #040915 88%, #140536 100%) fixed, repeating-linear-gradient(100deg,#04153a 0 9%,#050a18 16% 19%,#02041b 30% 41%,#031c44 44% 62%,#030711 74% 89%,#020b36 99% 100%)',
      '--body-blend-mode': 'lighten, color-dodge', '--panel-bg': 'linear-gradient(118deg,#10133a 80%,#12249c 200%)',
      '--panel-border': '#00bfffcc', '--panel-shadow': '0 0 35px #00eaffc9',
      '--submit-bg': 'linear-gradient(94deg,#00d8ff,#0078ff 90%)', '--submit-text': '#0b1a38',
      '--submit-hover-bg': '#0066d9', '--submit-hover-text': '#fff',
      '--header-text-glow': '0 0 10px #00e0ffaa, 0 0 20px #00bfff88',
      '--header-text-anim-glow-1': '0 0 14px #00eaff70,0 0 25px #00bfff44',
      '--header-text-anim-glow-2': '0 0 24px #00f0ffdd,0 0 38px #00d2ff82',
      '--header-text-fill': 'linear-gradient(90deg,#00f0ff,#00aaff 40%,#fff 59%,#0087ed 89%,#00c3ff 100%)',
      '--scrollbar-track-bg': '#0a1f40', '--scrollbar-thumb-bg': '#00aaff', '--scrollbar-thumb-hover-bg': '#00ccff',
    },
    celestial: { // Otherworldly, Space (Deep Purple/Pink)
      '--cyan': '#ff00ff', '--blue': '#8a2be2', '--dark-bg': '#0f001a', '--fade-blue': '#2b003e',
      '--gradient-1': 'linear-gradient(120deg, #2b003e 39%, #580080 68%, #ff00ff 97%)',
      '--gradient-user': 'linear-gradient(120deg, #8a2be2 32%, #ff00ff 89%)',
      '--bubble-glow': '0 0 15px #ff00ffb1', '--user-glow': '0 0 25px #ff66ff55, 0 0 16px #cc00cc70',
      '--header-glass': 'rgba(25,0,35,0.92)', '--code-bg': 'linear-gradient(92deg,#2b003e 79%,#8a2be2 120%)',
      '--code-border': '#ff00ff', '--code-text': '#f0e6ff', '--main-text': '#f0e6ff', '--link-text': '#ff66ff',
      '--input-bg': '#2b003e',
      '--body-bg': 'radial-gradient(circle at 50% 50%, #1a0033 0%, #0f001a 100%)',
      '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#2b003e 80%,#580080 200%)',
      '--panel-border': '#ff00ffcb', '--panel-shadow': '0 0 45px #ff00ffc9',
      '--submit-bg': 'linear-gradient(94deg,#ff00ff,#8a2be2 90%)', '--submit-text': '#0f001a',
      '--submit-hover-bg': '#8a2be2', '--submit-hover-text': '#fff',
      '--header-text-glow': '0 0 15px #ff00ffcc',
      '--header-text-anim-glow-1': '0 0 20px #ff00ff70', '--header-text-anim-glow-2': '0 0 35px #ff00ffee',
      '--header-text-fill': 'linear-gradient(90deg,#ff00ff,#8a2be2 40%,#fff 59%,#8a2be2 89%,#ff00ff 100%)',
      '--scrollbar-track-bg': '#2b003e', '--scrollbar-thumb-bg': '#ff00ff', '--scrollbar-thumb-hover-bg': '#ff66ff',
    },
    starlight: { // Perfectable Stars (Soft Blue/White)
      '--cyan': '#a6faff', '--blue': '#00c3ff', '--dark-bg': '#030010', '--fade-blue': '#100c25',
      '--gradient-1': 'linear-gradient(120deg, #100c25 39%, #1c153f 68%, #3f337f 97%)',
      '--gradient-user': 'linear-gradient(120deg, #00c3ff 32%, #a6faff 89%)',
      '--bubble-glow': '0 0 13px #00c3ffb1', '--user-glow': '0 0 22px #a6faff55',
      '--header-glass': 'rgba(16,12,37,0.92)', '--code-bg': 'linear-gradient(92deg,#100c25 79%,#3f337f 120%)',
      '--code-border': '#a6faff', '--code-text': '#a6faff', '--main-text': '#f0faff', '--link-text': '#a6faff',
      '--input-bg': '#100c25',
      '--body-bg': 'radial-gradient(ellipse at bottom, #0d0920 0%, #030010 70%)',
      '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#100c25 80%,#1c153f 200%)',
      '--panel-border': '#a6faffcb', '--panel-shadow': '0 0 42px #a6faffc9',
      '--submit-bg': 'linear-gradient(94deg,#a6faff,#00c3ff 90%)', '--submit-text': '#030010',
      '--submit-hover-bg': '#00c3ff', '--submit-hover-text': '#fff',
      '--header-text-glow': '0 0 12px #a6faffcc',
      '--header-text-anim-glow-1': '0 0 17px #a6faff70', '--header-text-anim-glow-2': '0 0 29px #a6faffee',
      '--header-text-fill': 'linear-gradient(90deg,#a6faff,#00c3ff 40%,#fff 59%,#00f2ff 89%,#a6faff 100%)',
      '--scrollbar-track-bg': '#100c25', '--scrollbar-thumb-bg': '#00c3ff', '--scrollbar-thumb-hover-bg': '#a6faff',
    },
    midnight: { // Regular Dark
      '--cyan': '#3391ff', '--blue': '#007bff', '--dark-bg': '#121212', '--fade-blue': '#282828',
      '--gradient-1': 'linear-gradient(120deg, #282828 39%, #333 68%, #444 97%)',
      '--gradient-user': 'linear-gradient(120deg, #007bff 32%, #3391ff 89%)',
      '--bubble-glow': '0 0 8px #007bff44', '--user-glow': '0 0 12px #3391ff44',
      '--header-glass': 'rgba(18,18,18,0.92)', '--code-bg': 'linear-gradient(92deg,#222 79%,#333 120%)',
      '--code-border': '#444', '--code-text': '#f1f1f1', '--main-text': '#f1f1f1', '--link-text': '#3391ff',
      '--input-bg': '#282828',
      '--body-bg': 'linear-gradient(180deg, #181818 0%, #121212 100%)',
      '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#1e1e1e 80%,#282828 200%)',
      '--panel-border': '#444', '--panel-shadow': '0 0 20px #000000c9',
      '--submit-bg': 'linear-gradient(94deg,#007bff,#3391ff 90%)', '--submit-text': '#fff',
      '--submit-hover-bg': '#0069d9', '--submit-hover-text': '#fff',
      '--header-text-glow': '0 0 10px #3391ffaa',
      '--header-text-anim-glow-1': '0 0 12px #3391ff70', '--header-text-anim-glow-2': '0 0 15px #3391ffee',
      '--header-text-fill': 'linear-gradient(90deg,#3391ff,#007bff 40%,#fff 59%,#3391ff 89%,#aaccff 100%)',
      '--scrollbar-track-bg': '#282828', '--scrollbar-thumb-bg': '#007bff', '--scrollbar-thumb-hover-bg': '#3391ff',
    },
    forest: { /* NEW THEME: Forest */
      '--cyan': '#99cc99', '--blue': '#669966', '--dark-bg': '#2a362a', '--fade-blue': '#4a5a4a',
      '--gradient-1': 'linear-gradient(120deg, #3a473a 39%, #5a6b5a 68%, #99cc99 97%)',
      '--gradient-user': 'linear-gradient(120deg, #669966 32%, #99cc99 89%)',
      '--bubble-glow': '0 0 10px #99cc99b1', '--user-glow': '0 0 18px #99cc9955',
      '--header-glass': 'rgba(42,54,42,0.92)', '--code-bg': 'linear-gradient(92deg,#3a473a 79%,#5a6b5a 120%)',
      '--code-border': '#99cc99', '--code-text': '#e0ffe0', '--main-text': '#e0ffe0', '--link-text': '#99cc99',
      '--input-bg': '#4a5a4a',
      '--body-bg': 'linear-gradient(180deg, #3a473a 0%, #2a362a 100%)',
      '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#3a473a 80%,#4a5a4a 200%)',
      '--panel-border': '#99cc99cb', '--panel-shadow': '0 0 35px #99cc99c9',
      '--submit-bg': 'linear-gradient(94deg,#99cc99,#669966 90%)', '--submit-text': '#2a362a',
      '--submit-hover-bg': '#669966', '--submit-hover-text': '#fff',
      '--header-text-glow': '0 0 10px #99cc99cc',
      '--header-text-anim-glow-1': '0 0 15px #99cc9970', '--header-text-anim-glow-2': '0 0 25px #99cc99ee',
      '--header-text-fill': 'linear-gradient(90deg,#99cc99,#669966 40%,#fff 59%,#669966 89%,#99cc99 100%)',
      '--scrollbar-track-bg': '#4a5a4a', '--scrollbar-thumb-bg': '#669966', '--scrollbar-thumb-hover-bg': '#99cc99',
    },
    volcano: { /* NEW THEME: Volcano */
      '--cyan': '#ff7043', '--blue': '#bf360c', '--dark-bg': '#3e1a0b', '--fade-blue': '#5e2a1b',
      '--gradient-1': 'linear-gradient(120deg, #4e2211 39%, #6e3a2c 68%, #ff7043 97%)',
      '--gradient-user': 'linear-gradient(120deg, #bf360c 32%, #ff7043 89%)',
      '--bubble-glow': '0 0 12px #ff7043b1', '--user-glow': '0 0 20px #ff704355',
      '--header-glass': 'rgba(62,26,11,0.92)', '--code-bg': 'linear-gradient(92deg,#4e2211 79%,#6e3a2c 120%)',
      '--code-border': '#ff7043', '--code-text': '#fff0e0', '--main-text': '#fff0e0', '--link-text': '#ff7043',
      '--input-bg': '#5e2a1b',
      '--body-bg': 'radial-gradient(circle at 50% 50%, #6e3a2c 0%, #3e1a0b 100%)',
      '--body-blend-mode': 'normal', '--panel-bg': 'linear-gradient(118deg,#4e2211 80%,#5e2a1b 200%)',
      '--panel-border': '#ff7043cb', '--panel-shadow': '0 0 40px #ff7043c9',
      '--submit-bg': 'linear-gradient(94deg,#ff7043,#bf360c 90%)', '--submit-text': '#3e1a0b',
      '--submit-hover-bg': '#bf360c', '--submit-hover-text': '#fff',
      '--header-text-glow': '0 0 12px #ff7043cc',
      '--header-text-anim-glow-1': '0 0 17px #ff704370', '--header-text-anim-glow-2': '0 0 29px #ff7043ee',
      '--header-text-fill': 'linear-gradient(90deg,#ff7043,#bf360c 40%,#fff 59%,#bf360c 89%,#ff7043 100%)',
      '--scrollbar-track-bg': '#5e2a1b', '--scrollbar-thumb-bg': '#bf360c', '--scrollbar-thumb-hover-bg': '#ff7043',
    }
  };
  
  let currentThemeIdx = 0;
  const themeKeys = Object.keys(themes);

  function applyTheme(themeName) {
    const theme = themes[themeName];
    if (!theme) return;
    for (const key in theme) {
      document.documentElement.style.setProperty(key, theme[key]);
    }
    localStorage.setItem('philadelphia-theme', themeName);
    
    // Update theme icon
    let icon = '';
    if (themeName === 'forest') icon = 'fa-leaf';
    else if (themeName === 'volcano') icon = 'fa-fire';
    else if (themeName === 'midnight') icon = 'fa-moon';
    else if (themeName === 'starlight') icon = 'fa-star';
    else if (themeName === 'celestial') icon = 'fa-globe-asia';
    else icon = 'fa-moon'; // Default icon

    themeBtn.innerHTML = `<i class="fa-solid ${icon}"></i>`;
  }

  themeBtn.addEventListener('click', () => {
    currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
    applyTheme(themeKeys[currentThemeIdx]);
  });

  // Load saved theme
  const savedTheme = localStorage.getItem('philadelphia-theme');
  if (savedTheme && themes[savedTheme]) {
    currentThemeIdx = themeKeys.indexOf(savedTheme);
    applyTheme(savedTheme);
  } else {
    applyTheme('cyber'); // Default
  }

  // ---------- Voice Call Logic ----------
  let speechRecognition;
  let isCallActive = false;
  let callHistory = [];
  let botIsSpeaking = false;
  let userSaidSomething = false;
  let currentAudio = null;
  let isMuted = false;

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (SpeechRecognition) {
    speechRecognition = new SpeechRecognition();
    speechRecognition.continuous = true;
    speechRecognition.interimResults = true;
    speechRecognition.lang = 'en-US';

    speechRecognition.onresult = (event) => {
        let interimTranscript = '';
        let finalTranscript = '';
        userSaidSomething = true;
        
        for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
                finalTranscript += event.results[i][0].transcript;
            } else {
                interimTranscript += event.results[i][0].transcript;
            }
        }
        
        // Update user's interim speech
        let userMsgEl = callConversation.querySelector('.call-msg.user.interim');
        if (!userMsgEl) {
            userMsgEl = document.createElement('div');
            userMsgEl.className = 'call-msg user interim';
            callConversation.appendChild(userMsgEl);
        }
        userMsgEl.textContent = finalTranscript || interimTranscript;
        callConversation.scrollTop = callConversation.scrollHeight;
        
        // Update status for user speaking
        callStatusMessage.textContent = finalTranscript ? 'User Speaking (Final)' : 'User Speaking...';
        tapToTalk.style.display = 'none';
    };
    
    speechRecognition.onspeechend = () => {
        // This fires when user stops talking
    };

    speechRecognition.onend = () => {
        if (!isCallActive) return;
        if (isMuted) { // If muted, don't restart recognition
            callStatusMessage.textContent = 'Microphone Muted.';
            tapToTalk.style.display = 'none';
            return;
        }
        
        let finalTranscript = '';
        const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
        if (userMsgEl) {
            finalTranscript = userMsgEl.textContent.trim();
            userMsgEl.classList.remove('interim');
        }

        if (botIsSpeaking) {
            // Bot is speaking, just wait for it to finish
        } else if (finalTranscript && userSaidSomething) {
            // User finished speaking, send to bot
            userSaidSomething = false; // Reset flag
            callHistory.push({ role: 'user', content: finalTranscript });
            handleCallBotResponse();
        } else {
            // User didn't say anything, just restart listening
            if (isCallActive && !isMuted) {
                callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                tapToTalk.style.display = 'block';
                try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start automatically:", e);}
            }
        }
    };
    
    speechRecognition.onerror = (event) => {
        console.error('Speech recognition error', event.error);
        if (event.error === 'no-speech' && isCallActive && !isMuted) {
             userSaidSomething = false; // Reset flag if no speech was detected
             speechRecognition.stop(); // This will trigger onend, which restarts listening
        } else if (event.error === 'network' && isCallActive) {
             callStatusMessage.textContent = 'Network error. Attempting restart...';
             speechRecognition.stop();
        } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
            callStatusMessage.textContent = 'Microphone permission denied. Please allow in browser settings.';
            endCall(); // End call if permission is denied
        }
    };

  } else {
    callBtn.style.display = 'none'; // Hide call button if not supported
    console.warn("Speech Recognition not supported in this browser.");
  }
  
  function addCallMessage(role, text) {
      const msgEl = document.createElement('div');
      msgEl.className = `call-msg ${role}`;
      msgEl.textContent = text;
      callConversation.appendChild(msgEl);
      callConversation.scrollTop = callConversation.scrollHeight;
  }

  async function handleCallBotResponse() {
      if (!isCallActive) return;
      
      callStatusMessage.textContent = 'Philadelphia AI is thinking...';
      tapToTalk.style.display = 'none';
      
      const historyForBot = callHistory.map(m => m);
      const userMessage = historyForBot.length > 0 ? historyForBot[historyForBot.length - 1].content : "";
      
      try {
          // Stop recognition while thinking
          speechRecognition.stop(); 
          
          const res = await fetch(`${API_BASE_URL}/chat`, { 
              method: 'POST', 
              headers: { 'Content-Type': 'application/json' }, 
              body: JSON.stringify({ 
                  message: userMessage, 
                  history: historyForBot.slice(0, -1), // Send history *before* last user msg
                  user_id: currentUser?.uid || "user" 
              }) 
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Server error.");
          
          const botResponse = data.response;
          callHistory.push({ role: 'ai', content: botResponse });
          
          // Add bot response text
          addCallMessage('bot', botResponse);
          
          // Speak the response
          speakBotResponse(botResponse);
          
      } catch (err) {
          const errorMsg = `âŒ Call error: ${err.message}`;
          addCallMessage('bot', errorMsg);
          
          // Restart listening
          if (isCallActive && !isMuted) {
             callStatusMessage.textContent = 'Listening... (Tap to Speak)';
             tapToTalk.style.display = 'block';
             try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
          }
      }
  }

  async function speakBotResponse(text) {
      if (!isCallActive) return;
      
      botIsSpeaking = true;
      botImageContainer.classList.add('speaking');
      callStatusMessage.textContent = 'Philadelphia AI is speaking...';
      
      try {
          const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, { 
              method: 'POST', 
              headers: {'Content-Type': 'application/json'}, 
              body: JSON.stringify({ text: text, voice_id: 'elder' }) 
          });
          if (!res.ok) throw new Error(await res.text());
          
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);
          const audio = new Audio(url);
          currentAudio = audio; // Store reference to allow stopping
          
          audio.onended = audio.onerror = () => {
              botIsSpeaking = false;
              botImageContainer.classList.remove('speaking');
              currentAudio = null;
              // Restart listening for user
              if (isCallActive && !isMuted) {
                  callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                  tapToTalk.style.display = 'block';
                  try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
              } else if (isMuted) {
                  callStatusMessage.textContent = 'Microphone Muted.';
                  tapToTalk.style.display = 'none';
              }
          };
          audio.play();
          
      } catch (err) {
          console.error("Voice gen error:", err);
          botIsSpeaking = false;
          botImageContainer.classList.remove('speaking');
          // Failed to speak, just restart listening
          if (isCallActive && !isMuted) {
              callStatusMessage.textContent = 'Listening (Voice Failed)...';
              tapToTalk.style.display = 'block';
              try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
          } else if (isMuted) {
              callStatusMessage.textContent = 'Microphone Muted.';
              tapToTalk.style.display = 'none';
          }
      }
  }
  
  function stopBotSpeakingAndStartListening() {
      if (!isCallActive || !botIsSpeaking) return; // Only act if call is active and bot is speaking
      
      if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio = null;
      }
      
      botIsSpeaking = false;
      botImageContainer.classList.remove('speaking');
      
      if (!isMuted) {
        callStatusMessage.textContent = 'Listening... (Tap to Speak)';
        tapToTalk.style.display = 'block';
        // Restart listening for user input
        try {
            speechRecognition.stop(); 
            speechRecognition.start();
        } catch(e) {
           console.warn("Could not restart speech recognition immediately:", e);
        }
      } else {
        callStatusMessage.textContent = 'Microphone Muted.';
        tapToTalk.style.display = 'none';
      }
      
      // Clear interim message if it exists
      const userMsgEl = callConversation.querySelector('.call-msg.user.interim');
      if (userMsgEl) userMsgEl.textContent = '';
  }
  
  callModal.addEventListener('mousedown', stopBotSpeakingAndStartListening);
  callModal.addEventListener('touchstart', stopBotSpeakingAndStartListening);

  callBtn.addEventListener('click', () => {
    if (!SpeechRecognition) {
        alert("Sorry, your browser doesn't support the Speech Recognition needed for this feature.");
        return;
    }
    isCallActive = true;
    isMuted = false; // Reset mute state
    muteCallBtn.classList.remove('muted');
    muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
    callModal.classList.add('active');
    callConversation.innerHTML = ''; // Clear old call
    addCallMessage('status', 'Connecting to Philadelphia AI...');
    callStatusMessage.textContent = 'Calling...';
    tapToTalk.style.display = 'none';
    callHistory = []; // Reset history
    
    // Initial delay to simulate connection, then start listening
    setTimeout(() => {
        if (!isCallActive) return;
        addCallMessage('status', 'Call Connected. Speak when ready.');
        callStatusMessage.textContent = 'Listening... (Tap to Speak)';
        tapToTalk.style.display = 'block';
        try {
            speechRecognition.start();
        } catch(e) {
            console.error("Speech recognition start failed", e);
            callStatusMessage.textContent = 'Microphone error. Check permissions.';
        }
    }, 1500);
  });

  function endCall() {
    isCallActive = false;
    botIsSpeaking = false;
    if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
    }
    callModal.classList.remove('active');
    try {
        speechRecognition.stop();
    } catch(e) {}
    botImageContainer.classList.remove('speaking');
    tapToTalk.style.display = 'none';
    callStatusMessage.textContent = 'Call Ended.';
  }

  endCallBtn.addEventListener('click', endCall);

  if (muteCallBtn) {
    muteCallBtn.addEventListener('click', () => {
        isMuted = !isMuted;
        if (isMuted) {
            muteCallBtn.classList.add('muted');
            muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> Unmute Microphone';
            speechRecognition.stop();
            callStatusMessage.textContent = 'Microphone Muted.';
            tapToTalk.style.display = 'none';
        } else {
            muteCallBtn.classList.remove('muted');
            muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> Mute Microphone';
            if (isCallActive && !botIsSpeaking) { // Only restart if call is active and bot isn't speaking
                callStatusMessage.textContent = 'Listening... (Tap to Speak)';
                tapToTalk.style.display = 'block';
                try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
            } else if (isCallActive && botIsSpeaking) {
                 callStatusMessage.textContent = 'Philadelphia AI is speaking...';
                 tapToTalk.style.display = 'none';
            }
        }
    });
  }


  // Final initial render (will be triggered by auth state)
  if(chatInput) chatInput.focus();
  
}); // end DOMContentLoaded
</script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
