<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Philadelphia AI - Cosmic Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;700&family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <!-- Using a minimalist highlight.js theme, will be dynamically applied -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/> 
    <style>
        :root {
            /* --- Default "Ethereal Nexus" Theme --- */
            --neon-blue: #00e7ff;
            --neon-purple: #ae00ff;
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue) 0%, var(--neon-purple) 100%);
            --plasma-gradient-alt: linear-gradient(135deg, var(--neon-purple) 0%, var(--neon-blue) 100%);

            --bg-darkest: #01020a; /* Core cosmic dark */
            --glass-bg-strong: rgba(10, 10, 25, 0.75); /* Darker, more prominent glass */
            --glass-bg-light: rgba(255, 255, 255, 0.08); /* Lighter elements */
            --glass-border: rgba(255, 255, 255, 0.15); /* Subtle white border */
            --glass-border-accent: rgba(0, 231, 255, 0.3); /* Neon border highlight */

            --text-color-primary: #e0eaff;
            --text-color-secondary: #a0a8bb;
            --text-glow: 0 0 10px rgba(0, 231, 255, 0.7), 0 0 20px rgba(174, 0, 255, 0.5);
            --box-glow: 0 0 20px rgba(0, 231, 255, 0.2);
            --user-bubble-glow: 0 0 15px rgba(0, 231, 255, 0.4), 0 0 25px rgba(174, 0, 255, 0.2);
            --ai-bubble-glow: 0 0 15px rgba(174, 0, 255, 0.4), 0 0 25px rgba(0, 231, 255, 0.2);

            --code-bg: rgba(15, 15, 40, 0.85); /* Darker code background */
            --code-border: var(--neon-blue);
            --code-text: #b3ecff; /* Lighter cyan for code */
            --code-shadow: 0 0 15px rgba(0, 231, 255, 0.3), inset 0 0 10px rgba(174, 0, 255, 0.1);

            --link-color: var(--neon-blue);
            --error-color: #ff4d4d;
        }

        /* --- Theme: Galactic Dawn --- */
        .galactic-dawn-theme {
            --neon-blue: #ff8c00; /* Deep Orange */
            --neon-purple: #ff2d55; /* Hot Pink */
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue) 0%, var(--neon-purple) 100%);
            --plasma-gradient-alt: linear-gradient(135deg, var(--neon-purple) 0%, var(--neon-blue) 100%);
            --bg-darkest: #0a0201;
            --glass-bg-strong: rgba(25, 5, 5, 0.75);
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            --glass-border-accent: rgba(255, 140, 0, 0.3);
            --text-color-primary: #fff5e0;
            --text-color-secondary: #e0b0a0;
            --text-glow: 0 0 10px rgba(255, 140, 0, 0.7), 0 0 20px rgba(255, 45, 85, 0.5);
            --box-glow: 0 0 20px rgba(255, 140, 0, 0.2);
            --user-bubble-glow: 0 0 15px rgba(255, 140, 0, 0.4), 0 0 25px rgba(255, 45, 85, 0.2);
            --ai-bubble-glow: 0 0 15px rgba(255, 45, 85, 0.4), 0 0 25px rgba(255, 140, 0, 0.2);
            --code-bg: rgba(40, 15, 15, 0.85);
            --code-border: var(--neon-blue);
            --code-text: #ffcfb3;
            --code-shadow: 0 0 15px rgba(255, 140, 0, 0.3), inset 0 0 10px rgba(255, 45, 85, 0.1);
            --link-color: var(--neon-blue);
        }

        /* --- Theme: Nebula Veil --- */
        .nebula-veil-theme {
            --neon-blue: #00ffcc; /* Mint Green */
            --neon-purple: #6a0dad; /* Dark Violet */
            --plasma-gradient: linear-gradient(135deg, var(--neon-blue) 0%, var(--neon-purple) 100%);
            --plasma-gradient-alt: linear-gradient(135deg, var(--neon-purple) 0%, var(--neon-blue) 100%);
            --bg-darkest: #070014;
            --glass-bg-strong: rgba(15, 5, 30, 0.75);
            --glass-bg-light: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            --glass-border-accent: rgba(0, 255, 204, 0.3);
            --text-color-primary: #e0faff;
            --text-color-secondary: #a0c0d0;
            --text-glow: 0 0 10px rgba(0, 255, 204, 0.7), 0 0 20px rgba(106, 13, 173, 0.5);
            --box-glow: 0 0 20px rgba(0, 255, 204, 0.2);
            --user-bubble-glow: 0 0 15px rgba(0, 255, 204, 0.4), 0 0 25px rgba(106, 13, 173, 0.2);
            --ai-bubble-glow: 0 0 15px rgba(106, 13, 173, 0.4), 0 0 25px rgba(0, 255, 204, 0.2);
            --code-bg: rgba(15, 10, 45, 0.85);
            --code-border: var(--neon-blue);
            --code-text: #b3ffeb;
            --code-shadow: 0 0 15px rgba(0, 255, 204, 0.3), inset 0 0 10px rgba(106, 13, 173, 0.1);
            --link-color: var(--neon-blue);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            height: 100vh;
            overflow: hidden;
            font-family: 'Inter', Roboto, Helvetica, sans-serif;
            background-color: var(--bg-darkest); /* Use CSS var */
            color: var(--text-color-primary);
            display: flex;
            justify-content: center;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        /* --- COSMIC BACKGROUND ENGINE --- */
        #cosmos-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .nebula-layer {
            position: absolute; top: 0; left: 0; width: 200%; height: 200%;
            background-size: cover;
            animation: drift var(--drift-duration) infinite linear;
            mix-blend-mode: screen; /* Blending for ethereal effect */
            background-image:
                radial-gradient(circle at 50% 50%, rgba(76, 0, 255, 0.15), transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 231, 255, 0.15), transparent 40%),
                linear-gradient(to bottom right, var(--bg-darkest), #1a0a2e);
        }
        .nebula-layer:nth-child(2) {
            animation-duration: var(--drift-duration-2);
            animation-direction: reverse;
            background-image: radial-gradient(circle at 20% 80%, rgba(174, 0, 255, 0.2), transparent 50%);
            mix-blend-mode: overlay; /* Different blend mode for depth */
        }
         .nebula-layer:nth-child(3) { /* Extra layer for depth and color */
            animation-duration: var(--drift-duration-3);
            animation-direction: alternate-reverse;
            background-image: radial-gradient(circle at 10% 30%, rgba(255, 255, 255, 0.08), transparent 60%);
            mix-blend-mode: lighten;
        }
        @keyframes drift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-50%, -50%); }
        }
        
        .star, .shooting-star, .stardust {
            position: absolute;
            pointer-events: none;
            opacity: 0; /* Hidden by default, animated in */
        }
        .star {
            background: white; border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out forwards;
            box-shadow: 0 0 5px rgba(255,255,255,0.8);
            opacity: var(--initial-opacity);
        }
        .stardust {
            background: var(--neon-blue); border-radius: 50%;
            width: 1px; height: 1px;
            opacity: 0;
            animation: floatUp var(--duration) infinite linear forwards;
            filter: drop-shadow(0 0 2px var(--neon-blue));
        }
        @keyframes twinkle { 0%, 100% { opacity: 0.3; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1.1); } }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 0.7; }
            100% { transform: translateY(calc(-100vh - 100px)); opacity: 0; }
        }

        .shooting-star {
            height: 2px;
            background: linear-gradient(-90deg, white, transparent);
            filter: drop-shadow(0 0 6px var(--neon-blue));
            animation: shoot var(--duration) ease-out forwards;
            opacity: 0; z-index: 0;
        }
        @keyframes shoot { 
            0% { transform: translate(var(--startX), var(--startY)) rotate(var(--angle)); opacity: 1; width: 0; }
            20% { width: var(--length); }
            100% { transform: translate(var(--endX), var(--endY)) rotate(var(--angle)); opacity: 0; width: 0; }
        }

        /* --- WOW Feature: Cosmic Glyph Animations --- */
        .cosmic-glyph {
            position: absolute; pointer-events: none; opacity: 0;
            font-size: 2rem; color: var(--neon-purple); text-shadow: var(--text-glow);
            animation: glyphPulse 10s infinite ease-in-out, glyphDrift var(--duration) infinite linear;
        }
        @keyframes glyphPulse {
            0%, 100% { opacity: 0.1; transform: scale(0.9); }
            50% { opacity: 0.4; transform: scale(1.1); }
        }
        @keyframes glyphDrift {
             0% { transform: translate(var(--startX), var(--startY)); }
             100% { transform: translate(var(--endX), var(--endY)); }
        }

        /* --- UI MAIN STRUCTURE --- */
        .ui-container {
            width: 100%; max-width: 650px; /* Slightly wider */
            height: 100%; display: flex; flex-direction: column;
            position: relative; z-index: 10;
            background: rgba(1, 2, 10, 0.3); /* Subtle darkening for readability */
            box-shadow: 0 0 50px rgba(0,0,0,0.5); /* Deep shadow */
        }

        /* Header */
        header {
            padding: 18px 25px; /* Adjusted padding */
            display: flex; justify-content: space-between; align-items: center;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(25px); /* Stronger blur */
            border-bottom: 1px solid var(--glass-border);
            box-shadow: 0 5px 25px rgba(0,0,0,0.3); /* Stronger shadow */
            flex-shrink: 0;
        }

        .brand-plasma {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem; font-weight: 800; letter-spacing: 1px;
            background: linear-gradient(90deg, #fff, var(--neon-blue), var(--neon-purple), #fff);
            background-size: 300% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: plasmaFlow 5s linear infinite;
            text-shadow: var(--text-glow);
            user-select: none;
            cursor: pointer;
        }
        @keyframes plasmaFlow { to { background-position: 300% center; } }

        .header-actions { display: flex; gap: 20px; font-size: 1.5rem; }
        .icon-btn { 
            cursor: pointer; opacity: 0.7; transition: 0.3s; position: relative;
            color: var(--text-color-primary);
        }
        .icon-btn:hover { opacity: 1; text-shadow: var(--text-glow); transform: scale(1.1); color: var(--neon-blue); }

        /* --- WOW Feature: Holographic Menu System --- */
        .holographic-menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); /* Nearly opaque background */
            backdrop-filter: blur(20px);
            z-index: 1000; display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .holographic-menu.active { opacity: 1; pointer-events: auto; }

        .menu-content {
            background: var(--glass-bg-strong);
            border: 1px solid var(--glass-border-accent);
            box-shadow: 0 0 30px rgba(0, 231, 255, 0.4), inset 0 0 15px rgba(174, 0, 255, 0.2);
            padding: 30px; border-radius: 20px;
            text-align: center; max-width: 90vw; max-height: 90vh; overflow-y: auto;
            transform: scale(0.9); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .holographic-menu.active .menu-content { transform: scale(1); opacity: 1; }

        .menu-content h2 {
            font-family: 'Orbitron', sans-serif; font-size: 1.8rem; margin-bottom: 25px;
            background: var(--plasma-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: var(--text-glow);
        }
        .menu-options a, .menu-options button {
            display: block; padding: 15px 25px; margin-bottom: 12px;
            background: var(--glass-bg-light); border: 1px solid var(--glass-border);
            border-radius: 12px; text-decoration: none;
            color: var(--text-color-primary); font-size: 1.1rem;
            transition: 0.3s; text-align: left; position: relative; overflow: hidden;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.05); cursor: pointer;
        }
        .menu-options a:hover, .menu-options button:hover {
            background: var(--glass-bg-strong);
            border-color: var(--neon-blue);
            box-shadow: var(--box-glow);
            transform: translateY(-3px); color: var(--neon-blue);
        }
        .menu-options i { margin-right: 15px; width: 25px; text-align: center; color: var(--neon-purple); }
        .menu-options a:hover i, .menu-options button:hover i { color: var(--neon-blue); }

        .modal-close-btn {
            position: absolute; top: 15px; right: 15px;
            background: rgba(255,255,255,0.1); border: 1px solid var(--error-color);
            color: var(--error-color); font-size: 1.2rem;
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer;
            transition: 0.3s; display: flex; align-items: center; justify-content: center;
        }
        .modal-close-btn:hover { background: var(--error-color); color: #fff; transform: rotate(90deg) scale(1.1); }


        /* Chat Area */
        #chat-viewport {
            flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px;
            scroll-behavior: smooth;
            scrollbar-width: none; -ms-overflow-style: none; /* Hide Scrollbar */
        }
        #chat-viewport::-webkit-scrollbar { display: none; }

        .message-group { display: flex; flex-direction: column; gap: 8px; max-width: 85%; position: relative; }
        .message-group.ai { align-self: flex-start; }
        .message-group.user { align-self: flex-end; align-items: flex-end; }

        .msg-bubble {
            padding: 16px 22px; border-radius: 24px;
            font-size: 1rem; line-height: 1.5;
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes popIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }

        .ai .msg-bubble {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.6), rgba(20, 20, 35, 0.8));
            border-bottom-left-radius: 4px;
            box-shadow: var(--ai-bubble-glow);
            color: var(--text-color-primary);
        }
        .user .msg-bubble {
            background: linear-gradient(135deg, rgba(0, 231, 255, 0.3), rgba(174, 0, 255, 0.3));
            border-bottom-right-radius: 4px;
            color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            box-shadow: var(--user-bubble-glow);
            border: 1px solid rgba(255,255,255,0.3);
        }

        .ai-msg-controls, .user-msg-controls {
            display: flex; gap: 8px; margin-top: 10px;
        }
        .ai-msg-controls button, .user-msg-controls button {
            background: var(--glass-bg-light); border: 1px solid var(--glass-border);
            color: var(--neon-blue); padding: 8px 12px; border-radius: 12px;
            font-size: 0.85rem; cursor: pointer; transition: 0.3s;
        }
        .ai-msg-controls button:hover, .user-msg-controls button:hover {
            background: var(--glass-bg-strong); color: var(--neon-purple); transform: translateY(-2px);
            box-shadow: 0 0 10px rgba(0, 231, 255, 0.2);
        }

        /* --- WOW Feature: Adaptive Plasma Glow for Input & Suggestions --- */
        .input-dock {
            padding: 20px 25px;
            background: var(--glass-bg-strong);
            backdrop-filter: blur(25px);
            border-top: 1px solid var(--glass-border);
            display: flex; gap: 15px; align-items: center;
            flex-shrink: 0;
            position: relative; /* For file preview */
        }
        .capsule-input {
            flex: 1; position: relative; height: 55px;
            background: var(--glass-bg-light);
            border-radius: 30px; border: 1px solid var(--glass-border);
            transition: 0.3s; display: flex; align-items: center;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
        }
        .capsule-input:focus-within, .capsule-input.active-glow {
            border-color: var(--neon-blue);
            box-shadow: var(--box-glow), inset 0 2px 10px rgba(0,0,0,0.2);
            background: rgba(0, 231, 255, 0.05);
        }
        .capsule-input input {
            width: 100%; height: 100%; background: transparent; border: none;
            padding: 0 25px; color: var(--text-color-primary); font-size: 1.05rem; outline: none;
        }
        .thruster-btn {
            width: 55px; height: 55px; border-radius: 50%; border: none; cursor: pointer;
            background: var(--plasma-gradient);
            display: flex; align-items: center; justify-content: center;
            box-shadow: var(--box-glow); transition: 0.3s;
            color: var(--bg-darkest);
        }
        .thruster-btn:hover { transform: scale(1.05) rotate(-10deg); box-shadow: 0 0 30px var(--neon-purple); }
        .thruster-btn.sending { animation: pulseGlow 1s infinite alternate; }
        @keyframes pulseGlow {
            0% { box-shadow: var(--box-glow); }
            100% { box-shadow: 0 0 25px var(--neon-blue), 0 0 40px var(--neon-purple); }
        }

        /* File Attachment Button in input dock */
        .file-attach-btn {
            width: 45px; height: 45px; border-radius: 50%; background: var(--glass-bg-light);
            border: 1px solid var(--glass-border); color: var(--neon-blue);
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            font-size: 1.2rem; transition: 0.3s;
        }
        .file-attach-btn:hover {
            background: var(--glass-bg-strong); border-color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 231, 255, 0.2);
            transform: scale(1.1);
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex; align-items: center; gap: 8px; margin-top: 10px;
            color: var(--text-color-secondary); font-style: italic;
            font-size: 0.9rem; animation: fadeIn 0.3s;
        }
        .typing-indicator .spinner {
            width: 16px; height: 16px; border: 2px solid rgba(0, 231, 255, 0.3);
            border-top-color: var(--neon-blue); border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- WOW Feature: System Status Message Pop-up --- */
        #status-popup {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%) translateY(-100px);
            background: var(--glass-bg-strong); border: 1px solid var(--glass-border-accent);
            padding: 10px 20px; border-radius: 10px;
            color: var(--text-color-primary); font-size: 0.9rem;
            box-shadow: var(--box-glow); z-index: 10000;
            opacity: 0; transition: transform 0.5s ease-out, opacity 0.5s ease-out;
        }
        #status-popup.visible { transform: translateX(-50%) translateY(0); opacity: 1; }

        /* Suggestions Dock */
        .suggestions-dock {
            display: flex; flex-wrap: wrap; justify-content: flex-end; gap: 10px; margin-top: 10px;
        }
        .chip {
            padding: 12px 20px; border-radius: 16px; font-size: 0.9rem; cursor: pointer;
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border-accent);
            backdrop-filter: blur(10px);
            transition: 0.3s; text-align: right; color: var(--text-color-primary);
            position: relative; overflow: hidden; /* For shimmer */
        }
        .chip:hover {
            background: var(--glass-bg-strong);
            border-color: var(--neon-blue);
            box-shadow: var(--box-glow);
            transform: translateY(-2px); color: var(--neon-blue);
        }
        .holo-shimmer::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(120deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transform: skewX(-25deg); animation: holoSheen 3s infinite linear;
        }
        @keyframes holoSheen { 0% { left: -100%; } 50%, 100% { left: 200%; } }

        /* Code Block Styling (Shining Code) */
        pre {
            background: var(--code-bg); border: 1px solid var(--code-border);
            padding: 15px 20px; margin: 15px 0; border-radius: 10px;
            overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; /* Ensure wrapping */
            font-family: 'JetBrains Mono', monospace; font-size: 0.95rem;
            color: var(--code-text); box-shadow: var(--code-shadow);
            position: relative;
            transition: background 0.3s, border-color 0.3s, box-shadow 0.3s;
        }
        pre code {
            display: block; /* Ensure code block takes full width */
            color: var(--code-text);
        }
        .copy-code-btn {
            position: absolute; top: 10px; right: 10px;
            background: var(--glass-bg-light); border: 1px solid var(--glass-border);
            color: var(--neon-blue); padding: 5px 10px; border-radius: 8px;
            font-size: 0.8rem; cursor: pointer; transition: 0.3s;
        }
        .copy-code-btn:hover {
            background: var(--glass-bg-strong); border-color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 231, 255, 0.2);
            color: var(--neon-purple);
        }

        /* File Preview Area (Floating above input) */
        #file-preview-strip {
            position: absolute; bottom: 80px; left: 20px; right: 20px;
            background: var(--glass-bg-strong); border: 1px solid var(--glass-border-accent);
            box-shadow: var(--box-glow); padding: 8px 15px; border-radius: 15px;
            display: none; /* Show only when files are attached */
            flex-wrap: wrap; gap: 10px;
            align-items: center; max-height: 100px; overflow-y: auto;
            transition: opacity 0.3s, transform 0.3s;
            opacity: 0; transform: translateY(20px);
        }
        #file-preview-strip.visible { opacity: 1; transform: translateY(0); display: flex; }
        .file-chip {
            display: flex; align-items: center; gap: 8px;
            background: var(--glass-bg-light); padding: 5px 10px; border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1); color: var(--text-color-secondary);
            font-size: 0.85rem;
        }
        .file-chip i { color: var(--neon-purple); }
        .file-chip img, .file-chip video, .file-chip audio {
            max-width: 30px; max-height: 25px; border-radius: 5px;
            object-fit: cover;
        }
        .file-chip .remove-file-btn {
            background: none; border: none; color: var(--error-color);
            font-size: 1.1rem; cursor: pointer; margin-left: 5px;
            transition: 0.2s;
        }
        .file-chip .remove-file-btn:hover { transform: scale(1.2); color: #ff0000; }


        /* Media Viewer Modal (for AI generated media links) */
        #media-viewer-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); z-index: 5000;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        #media-viewer-modal.active { opacity: 1; pointer-events: auto; }
        #media-viewer-modal .media-content-wrapper {
            background: var(--glass-bg-strong); border: 1px solid var(--glass-border-accent);
            box-shadow: 0 0 30px rgba(0, 231, 255, 0.4), inset 0 0 15px rgba(174, 0, 255, 0.2);
            padding: 20px; border-radius: 20px; text-align: center;
            max-width: 90vw; max-height: 90vh; overflow: hidden;
            position: relative; transform: scale(0.9); opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        #media-viewer-modal.active .media-content-wrapper { transform: scale(1); opacity: 1; }
        #media-viewer-modal .media-display {
            max-width: 100%; max-height: 70vh; margin-bottom: 15px;
            display: block; object-fit: contain; border-radius: 10px;
            border: 1px solid var(--glass-border);
        }
        #media-viewer-modal .media-caption {
            color: var(--text-color-secondary); font-size: 0.9rem; margin-top: 10px;
        }
        #media-viewer-modal .download-media-btn {
            background: var(--plasma-gradient); color: var(--bg-darkest);
            padding: 10px 20px; border: none; border-radius: 10px;
            font-weight: bold; cursor: pointer; margin-top: 15px;
            box-shadow: var(--box-glow); transition: 0.3s;
        }
        #media-viewer-modal .download-media-btn:hover { transform: scale(1.05); box-shadow: 0 0 30px var(--neon-purple); }


        /* --- Call Modal (Holographic Call Display) --- */
        #callModal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(15px);
            z-index: 4000; display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        #callModal.active { opacity: 1; pointer-events: auto; }

        #call-hologram-display {
            background: var(--glass-bg-strong); border: 2px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 231, 255, 0.5), inset 0 0 15px rgba(174, 0, 255, 0.3);
            padding: 25px; border-radius: 25px; max-width: 500px; width: 90%;
            display: flex; flex-direction: column; align-items: center;
            position: relative; transform: scale(0.9); opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        #callModal.active #call-hologram-display { transform: scale(1); opacity: 1; }

        #call-title {
            font-family: 'Orbitron', sans-serif; font-size: 1.6rem; margin-bottom: 20px;
            background: var(--plasma-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: var(--text-glow);
        }

        #bot-avatar-container {
            position: relative; margin-bottom: 20px;
        }
        #bot-avatar-container img {
            width: 120px; height: 120px; border-radius: 50%;
            border: 3px solid var(--neon-purple); box-shadow: 0 0 15px var(--neon-purple);
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        #bot-avatar-container.speaking img {
            border-color: var(--neon-blue); box-shadow: 0 0 20px var(--neon-blue), 0 0 30px var(--neon-purple);
            animation: pulse-avatar 1.5s infinite alternate;
        }
        @keyframes pulse-avatar {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.05); opacity: 0.9; }
        }

        #speaking-indicator {
            position: absolute; top: -5px; left: -5px; width: 130px; height: 130px;
            border-radius: 50%; border: 4px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--neon-blue); animation: scan-wave 2s infinite linear;
            opacity: 0;
        }
        #bot-avatar-container.speaking #speaking-indicator { opacity: 1; }
        @keyframes scan-wave {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.5; }
        }

        #call-status {
            color: var(--text-color-secondary); font-size: 0.9rem; font-style: italic;
            height: 30px; display: flex; align-items: center;
            text-shadow: 0 0 5px rgba(0, 231, 255, 0.3); margin-bottom: 15px;
        }
        #tap-to-speak {
            color: var(--neon-blue); font-size: 1.1rem; cursor: pointer;
            text-shadow: var(--text-glow); animation: text-pulse 1.5s infinite alternate;
            display: none; /* Only show when listening */
        }
        @keyframes text-pulse {
            0%, 100% { opacity: 0.7; } 50% { opacity: 1; }
        }

        #call-transcript {
            background: rgba(0,0,0,0.5); border: 1px solid var(--glass-border);
            border-radius: 10px; padding: 15px; max-height: 150px; overflow-y: auto;
            color: var(--text-color-primary); font-size: 0.9rem; line-height: 1.4;
            width: 100%; box-shadow: inset 0 0 10px rgba(0, 231, 255, 0.1);
            scrollbar-width: thin; scrollbar-color: var(--neon-blue) transparent;
        }
        #call-transcript::-webkit-scrollbar { width: 8px; }
        #call-transcript::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 10px; }
        #call-transcript::-webkit-scrollbar-thumb { background-color: var(--neon-blue); border-radius: 10px; }

        .transcript-line { margin-bottom: 5px; animation: fadeInCallTranscript 0.3s ease-out; }
        .transcript-line.user { color: var(--neon-purple); text-align: right; }
        .transcript-line.ai { color: var(--neon-blue); text-align: left; }
        .transcript-line.status { color: var(--text-color-secondary); font-style: italic; text-align: center; }
        @keyframes fadeInCallTranscript { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        #call-controls {
            display: flex; gap: 15px; margin-top: 25px;
        }
        #call-controls button {
            background: var(--plasma-gradient); color: var(--bg-darkest);
            padding: 12px 20px; border: none; border-radius: 12px;
            font-weight: bold; cursor: pointer; font-size: 0.95rem;
            box-shadow: var(--box-glow); transition: 0.3s;
        }
        #call-controls button:hover { transform: scale(1.05); box-shadow: 0 0 30px var(--neon-purple); }
        #call-controls .disconnect-btn {
            background: var(--error-color); color: #fff;
            box-shadow: 0 0 10px var(--error-color);
        }
        #call-controls .disconnect-btn:hover { background: #ff6666; box-shadow: 0 0 20px #ff6666; }
        #call-controls .mute-btn.muted {
            background: rgba(255,255,255,0.1); color: var(--text-color-secondary);
            border: 1px solid var(--glass-border); box-shadow: none;
        }
        #call-controls .mute-btn.muted:hover { background: var(--glass-bg-strong); color: var(--neon-blue); }

        /* --- Global Modals for Profile / Tools / Links --- */
        .global-overlay-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); backdrop-filter: blur(15px);
            z-index: 2000; display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .global-overlay-modal.active { opacity: 1; pointer-events: auto; }

        .modal-pane {
            background: var(--glass-bg-strong); border: 1px solid var(--glass-border-accent);
            box-shadow: 0 0 30px rgba(0, 231, 255, 0.4), inset 0 0 15px rgba(174, 0, 255, 0.2);
            padding: 25px; border-radius: 20px; text-align: center; max-width: 500px; width: 90%;
            max-height: 90vh; overflow-y: auto; position: relative;
            transform: scale(0.9); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .global-overlay-modal.active .modal-pane { transform: scale(1); opacity: 1; }

        .modal-pane h2 {
            font-family: 'Orbitron', sans-serif; font-size: 1.6rem; margin-bottom: 20px;
            background: var(--plasma-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: var(--text-glow);
        }
        .modal-pane label {
            display: block; text-align: left; margin-top: 15px; margin-bottom: 5px;
            color: var(--neon-blue); font-size: 0.95rem;
        }
        .modal-pane input, .modal-pane textarea, .modal-pane select {
            width: 100%; padding: 12px 15px; background: var(--glass-bg-light); border: 1px solid var(--glass-border);
            border-radius: 8px; color: var(--text-color-primary); font-size: 1rem;
            outline: none; transition: 0.3s;
        }
        .modal-pane input:focus, .modal-pane textarea:focus, .modal-pane select:focus {
            border-color: var(--neon-blue); box-shadow: 0 0 10px rgba(0, 231, 255, 0.3);
            background: rgba(0, 231, 255, 0.05);
        }
        .modal-pane textarea { min-height: 80px; resize: vertical; }

        .modal-pane .submit-action-btn {
            background: var(--plasma-gradient); color: var(--bg-darkest);
            padding: 12px 25px; border: none; border-radius: 12px;
            font-weight: bold; cursor: pointer; font-size: 1rem;
            box-shadow: var(--box-glow); transition: 0.3s; margin-top: 25px;
            width: 100%;
        }
        .modal-pane .submit-action-btn:hover { transform: scale(1.02); box-shadow: 0 0 30px var(--neon-purple); }

        .modal-pane .status-message {
            color: var(--neon-blue); font-size: 0.9rem; margin-top: 15px;
            text-shadow: 0 0 5px rgba(0, 231, 255, 0.3);
        }
        .modal-pane .status-message.error { color: var(--error-color); }

        /* Profile specific */
        .modal-profile-img {
            width: 100px; height: 100px; border-radius: 50%;
            border: 3px solid var(--neon-blue); box-shadow: 0 0 15px var(--neon-blue);
            margin-bottom: 15px;
        }
        .modal-profile-name {
            color: var(--neon-purple); font-size: 1.2rem; font-weight: bold;
            font-family: 'Orbitron', sans-serif;
        }
        .modal-profile-email { color: var(--text-color-secondary); font-size: 0.9rem; }
        .modal-profile-info-section { border-bottom: 1px dashed var(--glass-border); padding-bottom: 20px; margin-bottom: 20px; }

        /* Chat list in profile */
        .chat-archive-list { margin-top: 15px; max-height: 200px; overflow-y: auto; }
        .chat-archive-item {
            display: flex; justify-content: space-between; align-items: center;
            background: var(--glass-bg-light); border: 1px solid var(--glass-border);
            padding: 10px 15px; border-radius: 10px; margin-bottom: 8px;
            transition: 0.3s; cursor: pointer;
        }
        .chat-archive-item:hover {
            background: var(--glass-bg-strong); border-color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 231, 255, 0.2);
            transform: translateY(-2px);
        }
        .chat-archive-item.active-chat {
             border-color: var(--neon-purple); background: var(--glass-bg-strong);
             box-shadow: 0 0 15px rgba(174, 0, 255, 0.4);
        }
        .chat-archive-item-name { flex-grow: 1; text-align: left; color: var(--text-color-primary); }
        .chat-archive-item-actions button {
            background: none; border: none; color: var(--neon-blue); font-size: 1rem;
            cursor: pointer; margin-left: 8px; transition: 0.3s;
        }
        .chat-archive-item-actions button:hover { color: var(--neon-purple); transform: scale(1.1); }
        .chat-archive-item-actions .delete-btn { color: var(--error-color); }
        .chat-archive-item-actions .delete-btn:hover { color: #ff0000; }
        .new-chat-btn { margin-top: 15px; }

        /* Tool List in Tools Modal */
        .tool-category h3 {
            color: var(--neon-blue); font-size: 1.1rem; text-align: left; margin-top: 20px; margin-bottom: 10px;
            border-bottom: 1px dashed var(--glass-border); padding-bottom: 5px;
        }
        .tool-list-item {
            display: flex; align-items: center; background: var(--glass-bg-light);
            border: 1px solid var(--glass-border); padding: 12px 15px; border-radius: 10px;
            margin-bottom: 8px; transition: 0.3s; cursor: pointer; text-align: left;
            color: var(--text-color-primary); text-decoration: none;
        }
        .tool-list-item:hover {
            background: var(--glass-bg-strong); border-color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 231, 255, 0.2);
            transform: translateY(-2px); color: var(--neon-blue);
        }
        .tool-list-item i { margin-right: 15px; width: 20px; text-align: center; color: var(--neon-purple); }
        .tool-list-item:hover i { color: var(--neon-blue); }

        /* Links Modal */
        .links-list { margin-top: 15px; }
        .links-list a { display: block; margin-bottom: 10px; }


        @media (max-width: 650px) {
            .ui-container {
                max-width: 100%;
            }
            header {
                padding: 15px 20px;
            }
            .brand-plasma {
                font-size: 1.2rem;
            }
            .header-actions {
                gap: 15px;
                font-size: 1.2rem;
            }
            #chat-viewport, .input-dock {
                padding: 15px 20px;
            }
            .msg-bubble {
                padding: 12px 18px;
                font-size: 0.9rem;
            }
            .capsule-input {
                height: 48px;
            }
            .capsule-input input {
                font-size: 0.95rem;
            }
            .thruster-btn {
                width: 48px; height: 48px;
            }
            .file-attach-btn {
                width: 40px; height: 40px; font-size: 1rem;
            }
            .suggestions-dock {
                justify-content: center;
            }
            .chip {
                padding: 10px 15px;
                font-size: 0.85rem;
            }
            pre {
                padding: 12px 15px;
                font-size: 0.85rem;
            }
            .copy-code-btn {
                font-size: 0.7rem;
                padding: 4px 8px;
            }
            #file-preview-strip {
                bottom: 70px; /* Adjust for smaller input dock */
                left: 10px; right: 10px;
            }

            /* Call Modal */
            #call-hologram-display {
                padding: 20px;
            }
            #call-title {
                font-size: 1.4rem;
            }
            #bot-avatar-container img {
                width: 100px; height: 100px;
            }
            #speaking-indicator {
                width: 110px; height: 110px;
            }
            #call-transcript {
                font-size: 0.85rem;
                padding: 10px;
            }
            #call-controls button {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>

    <div id="cosmos-container">
        <div class="nebula-layer" style="--drift-duration: 60s;"></div>
        <div class="nebula-layer" style="--drift-duration-2: 45s;"></div>
        <div class="nebula-layer" style="--drift-duration-3: 75s;"></div>
    </div>

    <div class="ui-container">
        <header>
            <div class="brand-plasma" id="brandTitle">Philadelphia AI</div>
            <div class="header-actions">
                <div class="icon-btn" id="openMenuBtn" title="Menu"><i class="fa-solid fa-bars"></i></div>
            </div>
        </header>

        <div id="chat-viewport">
            <!-- Initial greeting message -->
            <div class="message-group ai">
                <div class="msg-bubble">
                    Greetings, traveler. ðŸ¦… The cosmos is aligned. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨
                </div>
            </div>
            <!-- Suggestions dock will be here, dynamically managed -->
            <div class="suggestions-dock" id="suggestions">
                <div class="chip holo-shimmer" data-suggestion="Create a comic. Style: Cyberpunk Anime." >Create a comic. Style: Cyberpunk Anime.</div>
                <div class="chip holo-shimmer" data-suggestion="Design a website landing page for 'Orbit'." >Design a website landing page for "Orbit".</div>
                <div class="chip holo-shimmer" data-suggestion="Generate a sci-fi short story prompt." >Generate a sci-fi short story prompt.</div>
            </div>
        </div>

        <!-- WOW Feature: File Preview Strip (Floating above input) -->
        <div id="file-preview-strip"></div>

        <div class="input-dock">
            <label for="fileInput" class="file-attach-btn" title="Attach file">
                <i class="fa-solid fa-paperclip"></i>
                <input type="file" id="fileInput" accept="image/*,video/*,audio/*,application/pdf" multiple style="display:none;">
            </label>
            <div class="capsule-input" id="inputCapsule">
                <input type="text" id="userInput" placeholder="Broadcast your message..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            </div>
            <button class="thruster-btn" id="sendBtn" title="Send message">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
            <button class="thruster-btn" id="stopBtn" style="display:none;" title="Stop generation">
                <i class="fa-solid fa-stop"></i>
            </button>
        </div>
    </div>

    <!-- WOW Feature: Holographic Menu Modal (Profile, Tools, Links, Theme) -->
    <div class="holographic-menu" id="holographicMenu">
        <div class="menu-content">
            <button class="modal-close-btn" onclick="holographicMenu.classList.remove('active');">X</button>
            <h2 id="menuTitle">COSMIC COMMAND PANEL</h2>

            <!-- Profile Section -->
            <div id="profileSection" class="menu-options" style="display:block;">
                <h3 style="color:var(--neon-blue); text-align:left; margin-bottom:15px; font-size:1.2rem; font-family:'Orbitron',sans-serif;">ACCESS LOGS & IDENTITY</h3>
                <div class="modal-profile-info-section">
                    <img id="profilePicMenu" src="https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg" alt="Profile photo" class="modal-profile-img">
                    <div class="modal-profile-name" id="profileMenuUser">TRAVELER_UNKNOWN</div>
                    <div class="modal-profile-email" id="profileMenuEmail">UNIDENTIFIED_SIGNAL@COSMOS.COM</div>
                </div>

                <h3 style="color:var(--neon-blue); text-align:left; margin-top:20px; margin-bottom:10px; font-size:1rem;">ARCHIVE NAVIGATION</h3>
                <div class="chat-archive-list" id="chatsListMenu">
                    <!-- Chat list populated here -->
                    <div class="typing-indicator" style="justify-content:center;"><span class="spinner"></span> Loading archives...</div>
                </div>
                <button id="newChatBtn" class="submit-action-btn new-chat-btn"><i class="fa-solid fa-plus"></i> NEW ARCHIVE</button>

                <h3 style="color:var(--neon-blue); text-align:left; margin-top:30px; margin-bottom:10px; font-size:1rem;">IDENTITY MANAGEMENT</h3>
                <form id="profileForm">
                    <label for="edit-name">CALLSIGN</label>
                    <input type="text" id="edit-name" required>
                    <label for="edit-photo">AVATAR CONSTRUCT URL</label>
                    <input type="url" id="edit-photo" placeholder="https://cosmic.link/avatar.jpg">
                    <span style="font-size:0.8em; color:var(--text-color-secondary); display:block; margin-top:5px;">(Tip: Use <a href="https://postimg.cc/" target="_blank" style="color:var(--link-color);">postimg.cc</a> for direct links)</span>
                    <button type="submit" class="submit-action-btn">UPDATE DATA</button>
                    <div class="status-message" id="profileStatusMsg"></div>
                </form>
                <button id="logoutBtn" class="submit-action-btn logout-btn"><i class="fa-solid fa-right-from-bracket"></i> TERMINATE SESSION</button>
            </div>

            <!-- Tools Section -->
            <div id="toolsSection" class="menu-options" style="display:none;">
                <h2>COSMIC FORGE</h2>
                <div id="toolListContainer">
                    <div class="tool-category">
                        <h3>VISUAL CONSTRUCTS</h3>
                        <a href="#" class="tool-list-item" data-tool="image"><i class="fa-solid fa-image"></i> IMAGERY MANIFESTATION</a>
                        <a href="#" class="tool-list-item" data-tool="edit-photo"><i class="fa-solid fa-wand-magic-sparkles"></i> PHOTO RECONSTRUCTION</a>
                        <a href="#" class="tool-list-item" data-tool="remove-bg"><i class="fa-solid fa-scissors"></i> BACKGROUND ISOLATION</a>
                        <a href="#" class="tool-list-item" data-tool="comic"><i class="fa-solid fa-book-open"></i> NARRATIVE STRIP GENERATION</a>
                    </div>
                    <div class="tool-category">
                        <h3>AUDITORY & KINETIC</h3>
                        <a href="#" class="tool-list-item" data-tool="voice-gen"><i class="fa-solid fa-microphone-lines"></i> VOCAL SYNTHESIS</a>
                        <a href="#" class="tool-list-item" data-tool="audio-narration"><i class="fa-solid fa-file-audio"></i> DOCUMENT AUDIFICATION</a>
                        <a href="#" class="tool-list-item" data-tool="video-text"><i class="fa-solid fa-film"></i> TEXT-TO-MOTION SEQUENCE</a>
                        <a href="#" class="tool-list-item" data-tool="video-image"><i class="fa-solid fa-photo-film"></i> STILL-TO-MOTION SEQUENCE</a>
                        <a href="#" class="tool-list-item" data-tool="music"><i class="fa-solid fa-music"></i> HARMONIC COMPOSITION</a>
                    </div>
                    <div class="tool-category">
                        <h3>NETWORK & INTELLECT</h3>
                        <a href="#" class="tool-list-item" data-tool="website"><i class="fa-solid fa-globe"></i> WEB PORTAL FABRICATION</a>
                        <a href="#" class="tool-list-item" data-tool="edit-website"><i class="fa-solid fa-pen-ruler"></i> WEB PORTAL RECONSTRUCTION</a>
                        <a href="#" class="tool-list-item" data-tool="my-sites"><i class="fa-solid fa-list-check"></i> DEPLOYED PORTAL LOGS</a>
                        <a href="#" class="tool-list-item" data-tool="research-report"><i class="fa-solid fa-flask-vial"></i> DATA CORRELATION REPORT</a>
                    </div>
                    <button id="startCallBtn" class="submit-action-btn" style="margin-top:30px;"><i class="fa-solid fa-phone"></i> INITIATE COMMS LINK</button>
                    <button id="cycleThemeBtn" class="submit-action-btn" style="margin-top:15px; background:var(--glass-bg-light); border:1px solid var(--glass-border); color:var(--text-color-primary);"><i class="fa-solid fa-palette"></i> CYCLE COSMIC THEME</button>
                </div>
                 <!-- Tool Form will be dynamically rendered here -->
                <form id="toolForm" style="display:none;">
                    <div id="toolFormContent"></div>
                    <button type="submit" class="submit-action-btn" id="toolFormSubmitBtn">PROCESS REQUEST</button>
                    <button type="button" class="submit-action-btn" id="toolFormBackBtn" style="background:var(--glass-bg-light); border:1px solid var(--glass-border); color:var(--text-color-primary); margin-top:15px;">BACK TO FORGE</button>
                    <div class="status-message" id="toolFormStatus"></div>
                </form>
            </div>

            <!-- Links Section -->
            <div id="linksSection" class="menu-options" style="display:none;">
                <h2>COSMIC NAVIGATION</h2>
                <div class="links-list">
                    <a href="philadelphia.html" class="tool-list-item"><i class="fa-solid fa-house-chimney"></i> PHI_AI HOME BASE</a>
                    <a href="index.html" class="tool-list-item"><i class="fa-solid fa-globe"></i> ELVION NETWORK HUB</a>
                    <a href="about.html" class="tool-list-item"><i class="fa-solid fa-circle-info"></i> SYSTEM_ABOUT_PROTOCOLS</a>
                    <a href="privacy.html" class="tool-list-item"><i class="fa-solid fa-shield-halved"></i> PRIVACY_MANIFESTO</a>
                    <a href="terms.html" class="tool-list-item"><i class="fa-solid fa-file-contract"></i> TERMS_OF_SERVICE_CONTRACT</a>
                    <a href="https://t.me/writingurubot" target="_blank" class="tool-list-item"><i class="fab fa-telegram"></i> ENGAGE TELEGRAM UNIT</a>
                </div>
            </div>
        </div>
    </div>

    <!-- System Status Pop-up -->
    <div id="status-popup"></div>

    <!-- Media Viewer Modal -->
    <div id="media-viewer-modal">
        <div class="menu-content media-content-wrapper">
            <button class="modal-close-btn">X</button>
            <div id="media-display-area"></div>
            <span class="media-caption" id="media-display-caption"></span>
            <button class="download-media-btn" id="download-media-btn"><i class="fa-solid fa-download"></i> DOWNLOAD ASSET</button>
        </div>
    </div>

    <!-- Call Modal -->
    <div id="callModal">
        <div id="call-hologram-display">
            <button class="modal-close-btn" onclick="endCall();">X</button>
            <h2 id="call-title">PHI_AI COMMS LINK ACTIVE</h2>
            <div id="bot-avatar-container">
                <img src="https://i.postimg.cc/XqL63yM9/IMG-20250824-133336-309.jpg" alt="AI Bot Avatar">
                <div id="speaking-indicator"></div>
            </div>
            <div id="call-status">ESTABLISHING SECURE CHANNEL...</div>
            <div id="tap-to-speak">TAP TO TRANSMIT</div>
            <div id="call-transcript">
                <div class="transcript-line status">INITIATING SECURE CHANNEL...</div>
            </div>
            <div id="call-controls">
                <button id="muteCallBtn" class="mute-btn"><i class="fa-solid fa-microphone"></i> MUTE</button>
                <button id="endCallBtn" class="disconnect-btn"><i class="fa-solid fa-phone-slash"></i> TERMINATE LINK</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getAuth, onAuthStateChanged, updateProfile, signOut } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, addDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

        // --- Firebase Configuration (replace with your actual config) ---
        const firebaseConfig = {
            apiKey: "AIzaSyAyROm0aBGjry6NUfhNM3e0qwPcCDoIqSk",
            authDomain: "elvionai.firebaseapp.com",
            projectId: "elvionai",
            storageBucket: "elvionai.appspot.com",
            messagingSenderId: "161078300830",
            appId: "1:161078300830:web:f460df8591704eb0e96b8f"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const $ = id => document.getElementById(id);
        const API_BASE_URL = 'https://web-production-9a18.up.railway.app'; // Your backend API

        // --- Global State Variables ---
        let chats = [];
        let currentChatId = null;
        let currentMessages = [];
        let uploadedFiles = []; // For files attached in current input
        let currentUser = null;
        let currentController = null; // For aborting API calls

        let chatsUnsubscribe = null;
        let messagesUnsubscribe = null;

        // --- DOM Elements Cache ---
        const cosmosContainer = $('cosmos-container');
        const brandTitle = $('brandTitle');
        const openMenuBtn = $('openMenuBtn');
        const holographicMenu = $('holographicMenu');
        const menuTitle = $('menuTitle');

        // Menu Sections
        const profileSection = $('profileSection');
        const toolsSection = $('toolsSection');
        const linksSection = $('linksSection');

        // Profile Elements
        const profilePicMenu = $('profilePicMenu');
        const profileMenuUser = $('profileMenuUser');
        const profileMenuEmail = $('profileMenuEmail');
        const profileForm = $('profileForm');
        const editName = $('edit-name');
        const editPhoto = $('edit-photo');
        const profileStatusMsg = $('profileStatusMsg');
        const chatsListMenu = $('chatsListMenu');
        const newChatBtn = $('newChatBtn');
        const logoutBtn = $('logoutBtn');

        // Tools Elements
        const toolListContainer = $('toolListContainer');
        const toolForm = $('toolForm');
        const toolFormContent = $('toolFormContent');
        const toolFormSubmitBtn = $('toolFormSubmitBtn');
        const toolFormBackBtn = $('toolFormBackBtn');
        const toolFormStatus = $('toolFormStatus');
        const startCallBtn = $('startCallBtn');
        const cycleThemeBtn = $('cycleThemeBtn');

        // Chat Elements
        const chatViewport = $('chat-viewport');
        const suggestionsDock = $('suggestions');
        const filePreviewStrip = $('file-preview-strip');
        const fileInput = $('fileInput');
        const inputCapsule = $('inputCapsule');
        const userInput = $('userInput');
        const sendBtn = $('sendBtn');
        const stopBtn = $('stopBtn');
        const statusPopup = $('status-popup');

        // Media Viewer Elements
        const mediaViewerModal = $('media-viewer-modal');
        const mediaDisplayArea = $('media-display-area');
        const mediaDisplayCaption = $('media-display-caption');
        const downloadMediaBtn = $('download-media-btn');

        // Call Elements
        const callModal = $('callModal');
        const callHologramDisplay = $('call-hologram-display');
        const callTitle = $('call-title');
        const botAvatarContainer = $('bot-avatar-container');
        const callStatus = $('call-status');
        const tapToSpeak = $('tap-to-speak');
        const callTranscript = $('call-transcript');
        const muteCallBtn = $('muteCallBtn');
        const endCallBtn = $('endCallBtn');


        // --- DOM Ready ---
        window.addEventListener('DOMContentLoaded', () => {
            igniteCosmos();
            setupEventListeners();
            initAuthWatcher();
            setupChatInput();
        });

        // --- WOW Feature: Cosmic Background Engine ---
        function igniteCosmos() {
            const numStars = 250;
            const numStardust = 100;
            const numGlyphs = 10; // New: for cosmic glyphs

            // Nebula layer durations (more varied and longer for ethereal feel)
            document.querySelector('.nebula-layer:nth-child(1)').style.setProperty('--drift-duration', `${Math.random() * 30 + 50}s`);
            document.querySelector('.nebula-layer:nth-child(2)').style.setProperty('--drift-duration-2', `${Math.random() * 30 + 40}s`);
            document.querySelector('.nebula-layer:nth-child(3)').style.setProperty('--drift-duration-3', `${Math.random() * 30 + 60}s`);

            // Stars
            for (let i = 0; i < numStars; i++) {
                createParticle('star', 100, 30, Math.random() * 0.8 + 0.2); // Slower twinkle, varied initial opacity
            }
            // Stardust
            for (let i = 0; i < numStardust; i++) {
               createParticle('stardust', 150, 45, 0.7); // Wider spread, slower float
            }
            // Cosmic Glyphs (WOW Feature 1)
            const glyphs = ['ðŸœ', 'ðŸœƒ', 'ðŸœ„', 'ðŸœ‚', 'â˜¿', 'â™€', 'â™', 'â™‚', 'â™ƒ', 'â™„', 'â™…', 'â™†', 'â™‡', 'âš³', 'âš´', 'ðŸ°', 'ðŸ²', 'ðŸ³', 'ðŸ´', 'ðŸµ'];
            for (let i = 0; i < numGlyphs; i++) {
                createCosmicGlyph(glyphs[Math.floor(Math.random() * glyphs.length)]);
            }

            // Shooting Stars (more dynamic)
            const randomLaunch = () => {
                launchShootingStar();
                setTimeout(randomLaunch, Math.random() * 4000 + 4000); // Between 4 and 8 seconds
            }
            randomLaunch();
        }

        function createParticle(type, spread, maxDuration, initialOpacity = 0) {
            const particle = document.createElement('div');
            particle.className = type;
            const size = Math.random() * (type === 'star' ? 2 : 1.5) + 0.5;
            particle.style.width = `${size}px`; particle.style.height = `${size}px`;
            particle.style.left = `${Math.random() * spread}%`;
            particle.style.top = `${Math.random() * spread}%`;
            particle.style.setProperty('--duration', `${Math.random() * maxDuration + 10}s`); // Slower duration
            particle.style.setProperty('--initial-opacity', initialOpacity);
            cosmosContainer.appendChild(particle);
        }

        function launchShootingStar() {
            const star = document.createElement('div');
            star.className = 'shooting-star';
            const startX = Math.random() * window.innerWidth * 1.5 - (window.innerWidth * 0.25); // Start slightly off screen
            const startY = Math.random() * window.innerHeight * 0.2 - 100; // Start higher up
            const length = Math.random() * 150 + 80; // Longer tails
            const angle = Math.random() * 40 - 20; // Varied angles
            
            star.style.setProperty('--startX', `${startX}px`);
            star.style.setProperty('--startY', `${startY}px`);
            star.style.setProperty('--length', `${length}px`);
            star.style.setProperty('--angle', `${angle}deg`);
            star.style.setProperty('--duration', `${Math.random() * 2 + 3}s`); // Duration between 3 and 5s
            
            // End coordinates to make it shoot off screen
            const endX = startX - (length * 4); 
            const endY = startY + (length * 3);
            star.style.setProperty('--endX', `${endX}px`);
            star.style.setProperty('--endY', `${endY}px`);

            cosmosContainer.appendChild(star);
            setTimeout(() => star.remove(), (parseFloat(star.style.getPropertyValue('--duration')) * 1000) + 100);
        }

        function createCosmicGlyph(symbol) { // WOW Feature 1 helper
            const glyph = document.createElement('div');
            glyph.className = 'cosmic-glyph';
            glyph.textContent = symbol;
            const duration = Math.random() * 50 + 70; // Long, slow drift
            const startX = Math.random() * 100 + 'vw';
            const startY = Math.random() * 100 + 'vh';
            const endX = parseFloat(startX) + (Math.random() * 200 - 100) + 'px'; // Drift slightly
            const endY = parseFloat(startY) + (Math.random() * 200 - 100) + 'px';

            glyph.style.left = startX;
            glyph.style.top = startY;
            glyph.style.setProperty('--duration', `${duration}s`);
            glyph.style.setProperty('--startX', startX);
            glyph.style.setProperty('--startY', startY);
            glyph.style.setProperty('--endX', endX);
            glyph.style.setProperty('--endY', endY);
            cosmosContainer.appendChild(glyph);
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            openMenuBtn.addEventListener('click', toggleHolographicMenu);
            holographicMenu.addEventListener('click', (e) => { // Close menu if click outside content
                if (e.target === holographicMenu) toggleHolographicMenu();
            });

            // Menu Section Switching
            document.querySelectorAll('#holographicMenu .menu-options').forEach(section => {
                const title = section.querySelector('h2'); // The title in each section (e.g., COSMIC FORGE)
                if (title) title.addEventListener('click', () => { // Clicking title goes to that section
                    showMenuSection(section.id);
                });
            });

            // Set initial menu view (Profile)
            showMenuSection('profileSection');

            // Suggestions dock clicks
            suggestionsDock.addEventListener('click', (e) => {
                const chip = e.target.closest('.chip');
                if (chip && chip.dataset.suggestion) {
                    sendSuggestion(chip.dataset.suggestion);
                }
            });

            // File input change
            fileInput.addEventListener('change', handleFileInput);

            // Drag and Drop (WOW Feature 3)
            chatViewport.addEventListener('dragover', (e) => {
                e.preventDefault();
                chatViewport.style.border = '2px dashed var(--neon-blue)'; // Visual feedback
            });
            chatViewport.addEventListener('dragleave', (e) => {
                e.preventDefault();
                chatViewport.style.border = 'none';
            });
            chatViewport.addEventListener('drop', handleFileDrop);

            // Send/Stop buttons
            sendBtn.addEventListener('click', sendMessage);
            stopBtn.addEventListener('click', stopAIGeneration);

            // Profile form
            profileForm.addEventListener('submit', handleProfileUpdate);
            newChatBtn.addEventListener('click', () => createNewChat(currentUser.uid));
            logoutBtn.addEventListener('click', handleLogout);

            // Tools section buttons
            toolListContainer.addEventListener('click', handleToolSelection);
            toolFormSubmitBtn.addEventListener('click', handleToolFormSubmit);
            toolFormBackBtn.addEventListener('click', () => showToolSection('list'));
            startCallBtn.addEventListener('click', initiateVoiceCall);
            cycleThemeBtn.addEventListener('click', cycleCosmicTheme);

            // Media viewer buttons
            downloadMediaBtn.addEventListener('click', handleMediaDownload);
        }

        // --- Auth Watcher ---
        function initAuthWatcher() {
            onAuthStateChanged(auth, user => {
                if (!user) {
                    window.location.href = "signup-login.html"; // Redirect if not authenticated
                    return;
                }
                currentUser = user;
                updateProfileUI(user);
                loadUserChats(user.uid);
            });
        }

        // --- UI Updates ---
        function updateProfileUI(user) {
            const displayName = user.displayName || 'TRAVELER_UNKNOWN';
            const photoURL = user.photoURL || "https://i.ibb.co/YTkKPfvf/IMG-20250715-102103-129.jpg";

            profileMenuUser.textContent = displayName.toUpperCase();
            profileMenuEmail.textContent = user.email || 'UNIDENTIFIED_SIGNAL@COSMOS.COM';
            profilePicMenu.src = photoURL;
            
            editName.value = user.displayName || '';
            editPhoto.value = user.photoURL || '';

            // Update status popup user name if it ever shows one
            // statusPopup.textContent = `Welcome, ${displayName}!`; 
        }

        function showStatusPopup(message, isError = false) { // WOW Feature 5 helper
            statusPopup.textContent = message;
            statusPopup.classList.toggle('error', isError);
            statusPopup.classList.add('visible');
            setTimeout(() => {
                statusPopup.classList.remove('visible');
            }, isError ? 5000 : 3000);
        }

        // --- Chat Input ---
        function setupChatInput() {
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    sendMessage();
                }
            });
            // WOW Feature 4: Adaptive Plasma Glow
            userInput.addEventListener('input', () => {
                inputCapsule.classList.toggle('active-glow', userInput.value.trim().length > 0);
            });
            userInput.addEventListener('focus', () => {
                inputCapsule.classList.add('active-glow');
            });
            userInput.addEventListener('blur', () => {
                if (userInput.value.trim().length === 0) {
                    inputCapsule.classList.remove('active-glow');
                }
            });
        }


        // --- Message Handling ---
        async function sendMessage() {
            const messageText = userInput.value.trim();
            if (!messageText && uploadedFiles.length === 0) {
                showStatusPopup('BROADCAST_EMPTY: Enter message or attach file.', true);
                return;
            }
            
            suggestionsDock.style.display = 'none'; // Hide suggestions after user sends message

            // Add user message to UI
            addMessage(messageText, 'user');
            
            const filesForHistory = uploadedFiles.map(file => ({ name: file.name, type: file.type, url: file.url }));
            await addMessageToChat('user', messageText, filesForHistory);

            // Prepare for API call
            userInput.value = '';
            inputCapsule.classList.remove('active-glow');
            clearFileInput();
            showStopButton();
            displayTypingIndicator(true, 'Intercepting transmission... analyzing stellar data structures. ðŸ›¸');

            let aiResponse = '';
            currentController = new AbortController();
            const signal = currentController.signal;

            try {
                if (uploadedFiles.length > 0) {
                    const file = uploadedFiles[0]; // For simplicity, assume one file for now
                    const fd = new FormData();
                    fd.append('prompt', messageText || `Analyze this ${file.type.split('/')[0]} artifact`);
                    // Convert data URL back to Blob for FormData if necessary
                    const blob = await (await fetch(file.url)).blob();
                    fd.append('file', blob, file.name);

                    let endpoint = '';
                    if (file.type.startsWith('image/')) endpoint = '/understand-image';
                    else if (file.type === 'application/pdf') endpoint = '/understand-pdf';
                    else if (file.type.startsWith('audio/')) endpoint = '/understand-audio';
                    else if (file.type.startsWith('video/')) endpoint = '/understand-video';
                    else {
                        aiResponse = "[ERROR]: SYSTEM_UNABLE_TO_PROCESS_FILE_TYPE.";
                    }

                    if (endpoint) {
                        const res = await fetch(API_BASE_URL + endpoint, { method: 'POST', body: fd, signal });
                        const data = await res.json();
                        if (!res.ok) throw new Error(data.error || "DATA_ANALYSIS_FAILED.");
                        aiResponse = data.response;
                    }
                } else {
                    const history = currentMessages.map(m => ({ role: m.role, content: m.text || '' }));
                    const res = await fetch(`${API_BASE_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: messageText, history, user_id: currentUser?.uid || "user" }),
                        signal
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || "SERVER_ERROR.");
                    aiResponse = data.response;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    aiResponse = "[SYSTEM]: TRANSMISSION_INTERRUPTED.";
                } else {
                    aiResponse = `[ERROR]: COSMIC_CHANNEL_DISTURBANCE: ${error.message}`;
                    console.error("AI Response Error:", error);
                }
            } finally {
                displayTypingIndicator(false);
                hideStopButton();
                if (aiResponse) {
                    await addAIMessageWithTyping(aiResponse); // Use custom typing function
                }
                currentController = null;
            }
        }

        async function addAIMessageWithTyping(text) { // Custom AI message typing (User request: "type code first then format")
            const group = document.createElement('div');
            group.className = `message-group ai`;
            const bubble = document.createElement('div');
            bubble.className = 'msg-bubble';
            group.appendChild(bubble);
            chatViewport.appendChild(group);
            chatViewport.scrollTo({ top: chatViewport.scrollHeight, behavior: 'smooth' });

            let currentTypedText = '';
            let isCodeBlockOpen = false;

            for (let i = 0; i < text.length; i++) {
                currentTypedText += text[i];
                if (currentTypedText.endsWith('```')) {
                    isCodeBlockOpen = !isCodeBlockOpen;
                }

                // If a code block is open, type raw. Otherwise, type with inline markdown.
                if (isCodeBlockOpen && !currentTypedText.endsWith('```')) {
                    bubble.textContent = currentTypedText; // Raw text for code typing
                } else {
                    bubble.innerHTML = inlineMarkdown(currentTypedText); // Apply basic markdown
                }
                chatViewport.scrollTop = chatViewport.scrollHeight;
                await new Promise(res => setTimeout(res, 15)); // Adjust typing speed
            }

            // After all text is typed, apply full markdown rendering and highlighting
            const { html } = renderMarkdown(text);
            bubble.innerHTML = html;
            enhanceCodeBlocks(bubble); // Apply highlighting and copy buttons

            // Check for media links within the fully rendered message
            const mediaLinkRegex = /\[(IMAGE_OUTPUT|VIDEO_OUTPUT|AUDIO_OUTPUT|PDF_OUTPUT|LINK_OUTPUT): (.*?)\]\((.*?)\)/g;
            bubble.innerHTML = bubble.innerHTML.replace(mediaLinkRegex, (match, mediaType, displayName, url) => {
                return `<a href="#" data-media-type="${mediaType.toLowerCase()}" data-media-url="${url}">${displayName || `[${mediaType.toUpperCase()}]`}</a>`;
            });
            bubble.querySelectorAll('a[data-media-type]').forEach(link => {
                link.addEventListener('click', handleMediaLinkClick);
            });


            await addMessageToChat('ai', text); // Save full, raw text to DB
            chatViewport.scrollTop = chatViewport.scrollHeight;
        }


        function addMessage(text, type) {
            const group = document.createElement('div');
            group.className = `message-group ${type}`;
            const bubble = document.createElement('div');
            bubble.className = 'msg-bubble';
            bubble.innerHTML = inlineMarkdown(text); // Apply markdown for user messages too
            group.appendChild(bubble);

            // Insert before suggestions dock if it's there, otherwise just append
            if (suggestionsDock.parentNode === chatViewport && suggestionsDock.style.display !== 'none') {
                chatViewport.insertBefore(group, suggestionsDock);
            } else {
                chatViewport.appendChild(group);
            }
            chatViewport.scrollTo({ top: chatViewport.scrollHeight, behavior: 'smooth' });
        }
        
        function sendSuggestion(suggestionText) {
            userInput.value = suggestionText;
            sendMessage();
            suggestionsDock.style.display = 'none';
        }

        // --- File Handling (WOW Feature 3) ---
        function clearFileInput() {
            uploadedFiles = [];
            fileInput.value = ''; // Reset input element
            filePreviewStrip.innerHTML = '';
            filePreviewStrip.classList.remove('visible');
        }

        function handleFileInput(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                processAndDisplayFiles(files);
            }
        }

        function handleFileDrop(e) {
            e.preventDefault();
            chatViewport.style.border = 'none'; // Clear drag feedback
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                processAndDisplayFiles(files);
            }
        }

        function processAndDisplayFiles(files) {
            uploadedFiles = []; // Reset for new uploads
            filePreviewStrip.innerHTML = ''; // Clear existing previews

            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    uploadedFiles.push({ file: file, name: file.name, type: file.type, url: dataUrl });
                    renderFilePreviewChip(file, dataUrl);
                };
                reader.readAsDataURL(file);
            });
            filePreviewStrip.classList.add('visible');
            showStatusPopup(`TRANSMISSION_READY: ${files.length} file(s) attached.`);
        }

        function renderFilePreviewChip(file, dataUrl) {
            const chip = document.createElement('div');
            chip.className = 'file-chip';

            let icon = 'fa-file-code'; // Default for generic files
            let mediaPreview = '';

            if (file.type.startsWith('image/')) {
                icon = 'fa-file-image';
                mediaPreview = `<img src="${dataUrl}" alt="Preview" />`;
            } else if (file.type.startsWith('video/')) {
                icon = 'fa-file-video';
                mediaPreview = `<video src="${dataUrl}" preload="metadata"></video>`;
            } else if (file.type.startsWith('audio/')) {
                icon = 'fa-file-audio';
                mediaPreview = `<audio src="${dataUrl}" preload="metadata"></audio>`;
            } else if (file.type === 'application/pdf') {
                icon = 'fa-file-pdf';
            }

            chip.innerHTML = `
                ${mediaPreview ? mediaPreview : `<i class="fa-solid ${icon}"></i>`}
                <span>${file.name}</span>
                <button type="button" class="remove-file-btn"><i class="fa-solid fa-xmark"></i></button>
            `;
            const removeBtn = chip.querySelector('.remove-file-btn');
            removeBtn.addEventListener('click', () => {
                uploadedFiles = uploadedFiles.filter(f => f.name !== file.name);
                chip.remove();
                if (uploadedFiles.length === 0) {
                    filePreviewStrip.classList.remove('visible');
                    fileInput.value = ''; // Reset actual file input
                }
                showStatusPopup(`TRANSMISSION_READY: File '${file.name}' removed.`);
            });
            filePreviewStrip.appendChild(chip);
        }


        // --- Markdown & Code Rendering ---
        const escapeHTML = (str = '') => String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');

        function inlineMarkdown(t = '') {
            let s = String(t).replace(/`([^`]+?)`/g, (_, a) => `<code>${escapeHTML(a)}</code>`);
            s = s.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            s = s.replace(/(^|[\s(])\*([^*]+?)\*(?=[\s).,!?:;]|$)/g, '$1<em>$2</em>');
            s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            return s.replace(/\n/g, '<br>');
        }

        function renderMarkdown(text = '') {
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            let html = '';
            let lastIndex = 0;
            text.replace(codeBlockRegex, (match, lang, code, offset) => {
                const before = text.slice(lastIndex, offset);
                html += inlineMarkdown(before);
                const language = (lang || '').toLowerCase().trim();
                const safe = escapeHTML(code);
                html += `<pre><button class="copy-code-btn">COPY</button><code class="language-${language || 'plaintext'}">${safe}</code></pre>`;
                lastIndex = offset + match.length;
                return match;
            });
            html += inlineMarkdown(text.slice(lastIndex));
            return { html };
        }

        function enhanceCodeBlocks(container) {
            if (!container) return;
            container.querySelectorAll('pre').forEach(pre => {
                const codeEl = pre.querySelector('code');
                if (window.hljs && codeEl) {
                    try { hljs.highlightElement(codeEl); } catch (e) { /* ignore */ }
                }
                const btn = pre.querySelector('.copy-code-btn');
                if (btn && codeEl) {
                    btn.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard.writeText(codeEl.innerText);
                            const prev = btn.textContent;
                            btn.textContent = 'COPIED!';
                            setTimeout(() => btn.textContent = prev, 800);
                        } catch (e) {
                            btn.textContent = 'FAILED';
                            setTimeout(() => btn.textContent = 'COPY', 800);
                        }
                    });
                }
            });
        }


        // --- Chat Management (Firebase Firestore) ---
        async function loadUserChats(userId) {
            if (chatsUnsubscribe) chatsUnsubscribe();
            const chatsCol = collection(db, 'users', userId, 'chats');
            const q = query(chatsCol, orderBy('createdAt', 'desc'));
            chatsUnsubscribe = onSnapshot(q, async (snapshot) => {
                if (snapshot.empty) {
                    await createNewChat(userId);
                    return;
                }
                chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderChatsListMenu();
                if (!currentChatId || !chats.find(c => c.id === currentChatId)) {
                    currentChatId = chats[0].id;
                    showStatusPopup(`ARCHIVE_LOADED: '${chats[0].name || 'Unnamed Archive'}'`, false);
                }
                subscribeToMessages(userId, currentChatId);
            }, (error) => {
                showStatusPopup(`ERROR_ARCHIVE_FETCH: ${error.message}`, true);
                chatsListMenu.innerHTML = `<div style="color:var(--error-color);">ERROR_LOADING_ARCHIVES.</div>`;
            });
        }

        async function createNewChat(userId) {
            if (!userId) {
                showStatusPopup('ERROR: USER_ID_MISSING_FOR_ARCHIVE_CREATION.', true);
                return;
            }
            const chatsCol = collection(db, 'users', userId, 'chats');
            try {
                const newChatDoc = await addDoc(chatsCol, { name: "New Archive", createdAt: serverTimestamp() });
                currentChatId = newChatDoc.id;
                showStatusPopup(`NEW_ARCHIVE_CREATED: ID '${newChatDoc.id}'.`, false);
            } catch (e) {
                showStatusPopup(`ERROR_ARCHIVE_CREATE: ${e.message}`, true);
            }
        }

        function subscribeToMessages(userId, chatId) {
            if (messagesUnsubscribe) messagesUnsubscribe();
            if (!userId || !chatId) {
                chatViewport.innerHTML = `<div class="message-group ai"><div class="msg-bubble">ERROR: NO_ACTIVE_ARCHIVE. USE_MENU_TO_CREATE_OR_LOAD.</div></div>`;
                return;
            }
            const messagesCol = collection(db, 'users', userId, 'chats', chatId, 'messages');
            const q = query(messagesCol, orderBy('createdAt'));
            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                currentMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderChatViewport(currentMessages);
            }, (error) => {
                showStatusPopup(`ERROR_MESSAGE_FETCH: ${error.message}`, true);
                chatViewport.innerHTML = `<div class="message-group ai"><div class="msg-bubble">ERROR_LOADING_ARCHIVE_MESSAGES.</div></div>`;
            });
        }

        function renderChatViewport(messages = []) {
            chatViewport.innerHTML = ''; // Clear current messages
            // Always insert suggestions dock at the bottom
            
            // Re-add initial greeting only if no messages
            if (messages.length === 0) {
                 addMessage('Greetings, traveler. ðŸ¦… The cosmos is aligned. How can Philadelphia AI illuminate your path today? I am fully charged and ready to create. âœ¨', 'ai');
            } else {
                messages.forEach(msg => {
                    // This will not re-type, just render immediately
                    const group = document.createElement('div');
                    group.className = `message-group ${msg.role}`;
                    const bubble = document.createElement('div');
                    bubble.className = 'msg-bubble';
                    const { html } = renderMarkdown(msg.text || '');
                    bubble.innerHTML = html;
                    enhanceCodeBlocks(bubble);

                    // Re-add media link functionality
                    const mediaLinkRegex = /\[(IMAGE_OUTPUT|VIDEO_OUTPUT|AUDIO_OUTPUT|PDF_OUTPUT|LINK_OUTPUT): (.*?)\]\((.*?)\)/g;
                    bubble.innerHTML = bubble.innerHTML.replace(mediaLinkRegex, (match, mediaType, displayName, url) => {
                        return `<a href="#" data-media-type="${mediaType.toLowerCase()}" data-media-url="${url}">${displayName || `[${mediaType.toUpperCase()}]`}</a>`;
                    });
                    bubble.querySelectorAll('a[data-media-type]').forEach(link => {
                        link.addEventListener('click', handleMediaLinkClick);
                    });

                    group.appendChild(bubble);
                    chatViewport.appendChild(group);
                });
            }
            chatViewport.appendChild(suggestionsDock); // Ensure suggestions are always at the bottom
            suggestionsDock.style.display = 'flex'; // Make sure suggestions are visible by default here

            chatViewport.scrollTo({ top: chatViewport.scrollHeight, behavior: 'smooth' });
        }

        function renderChatsListMenu() {
            chatsListMenu.innerHTML = '';
            if (chats.length === 0) {
                chatsListMenu.innerHTML = `<div class="chat-status-message">NO_ARCHIVES_FOUND.</div>`;
                return;
            }
            chats.forEach((chat) => {
                const item = document.createElement('div');
                item.className = `chat-archive-item ${chat.id === currentChatId ? 'active-chat' : ''}`;
                item.innerHTML = `
                    <span class="chat-archive-item-name">${chat.name || 'Unnamed Archive'}</span>
                    <div class="chat-archive-item-actions">
                        <button type="button" class="rename-btn"><i class="fa-solid fa-pen"></i></button>
                        <button type="button" class="delete-btn"><i class="fa-solid fa-trash"></i></button>
                    </div>
                `;
                item.querySelector('.chat-archive-item-name').addEventListener('click', () => {
                    if (currentChatId !== chat.id) {
                        currentChatId = chat.id;
                        subscribeToMessages(currentUser.uid, currentChatId);
                        holographicMenu.classList.remove('active'); // Close menu after selection
                        showStatusPopup(`ARCHIVE_LOADED: '${chat.name || 'Unnamed Archive'}'`, false);
                    }
                });
                item.querySelector('.rename-btn').addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const newName = prompt(`RENAME_ARCHIVE '${chat.name}':`);
                    if (newName && newName.trim()) {
                        try {
                            await setDoc(doc(db, 'users', currentUser.uid, 'chats', chat.id), { name: newName.trim() }, { merge: true });
                            showStatusPopup(`ARCHIVE_RENAMED: '${chat.id}' to '${newName}'.`, false);
                        } catch (err) {
                            showStatusPopup(`ERROR_RENAME: ${err.message}`, true);
                        }
                    }
                });
                item.querySelector('.delete-btn').addEventListener('click', async (e) => {
                    e.stopPropagation();
                    if (confirm(`CONFIRM_PURGE: Delete archive '${chat.name}' (ID: ${chat.id}) AND ALL CONTENTS?`)) {
                        try {
                            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', chat.id, 'messages');
                            const messagesSnap = await getDocs(messagesCol);
                            const batch = writeBatch(db);
                            messagesSnap.docs.forEach(d => batch.delete(d.ref));
                            await batch.commit();
                            await deleteDoc(doc(db, 'users', currentUser.uid, 'chats', chat.id));
                            showStatusPopup(`ARCHIVE_PURGED: ID '${chat.id}'.`, false);
                        } catch (err) {
                            showStatusPopup(`ERROR_PURGE: ${err.message}`, true);
                        }
                    }
                });
                chatsListMenu.appendChild(item);
            });
        }

        async function addMessageToChat(role, text, files = []) {
            if (!currentChatId || !currentUser) {
                console.error("ERROR: NO_ACTIVE_ARCHIVE_OR_USER_FOR_LOGGING.");
                showStatusPopup("ERROR: CANNOT_LOG_MESSAGE_NO_ACTIVE_ARCHIVE.", true);
                return;
            }
            const messagesCol = collection(db, 'users', currentUser.uid, 'chats', currentChatId, 'messages');
            try {
                await addDoc(messagesCol, { role, text, files, createdAt: serverTimestamp() });
            } catch (e) {
                console.error("ERROR_FIRESTORE_LOGGING:", e);
                showStatusPopup(`ERROR_FIRESTORE_LOGGING: ${e.message}`, true);
            }
        }


        // --- User Actions ---
        async function handleProfileUpdate(e) {
            e.preventDefault();
            if (!currentUser) return;
            profileStatusMsg.textContent = 'UPDATE_INITIATED...';
            profileStatusMsg.classList.remove('error');
            try {
                await updateProfile(currentUser, { displayName: editName.value, photoURL: editPhoto.value });
                if (auth.currentUser) await auth.currentUser.reload();
                profileStatusMsg.textContent = 'PROFILE_DATA_UPDATED.';
                updateProfileUI(auth.currentUser);
                setTimeout(() => holographicMenu.classList.remove('active'), 1200);
            } catch (err) {
                profileStatusMsg.textContent = `ERROR_UPDATE: ${err.message}`;
                profileStatusMsg.classList.add('error');
            }
        }

        async function handleLogout() {
            showStatusPopup('TERMINATING_SESSION...', false);
            await signOut(auth);
            holographicMenu.classList.remove('active');
            // Redirect will be handled by initAuthWatcher
        }

        function toggleHolographicMenu() { // WOW Feature 5 helper
            holographicMenu.classList.toggle('active');
            if (holographicMenu.classList.contains('active')) {
                // Ensure profile section is always default when opening menu
                showMenuSection('profileSection'); 
                menuTitle.textContent = 'COSMIC COMMAND PANEL';
            }
        }

        function showMenuSection(sectionId) { // WOW Feature 5 helper
            [profileSection, toolsSection, linksSection].forEach(section => {
                section.style.display = 'none';
            });
            $(sectionId).style.display = 'block';

            // Update title based on active section
            if (sectionId === 'profileSection') menuTitle.textContent = 'ACCESS LOGS & IDENTITY';
            else if (sectionId === 'toolsSection') menuTitle.textContent = 'COSMIC FORGE';
            else if (sectionId === 'linksSection') menuTitle.textContent = 'COSMIC NAVIGATION';
            else menuTitle.textContent = 'COSMIC COMMAND PANEL'; // Default
        }

        // --- AI Tools ---
        const thenaModels = ["photoreal", "ultrarealistic", "anime", "deepanime", "animelegacy", "dreamcore"];
        const toolDefinitions = {
            "image": {
                title: "IMAGERY MANIFESTATION", description: "Generate image from text prompt.",
                buildForm: () => `
                    <label for="tool-prompt">PROMPT</label><textarea id="tool-prompt" required></textarea>
                    <label for="tool-style">STYLE</label><select id="tool-style">${thenaModels.map(s => `<option value="${s.toLowerCase()}">${s}</option>`).join('')}</select>`,
                handleSubmit: async (payload) => {
                    const provider = payload.model || 'thena';
                    showStatusPopup(`INITIATING_IMAGE_SYNTHESIS (${provider.toUpperCase()} ENGINE)...`);
                    const res = await fetch(`${API_BASE_URL}/generate-image`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: payload.prompt, model: payload.style, use_minimax: provider === 'minimax' })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || res.statusText);
                    return `IMAGE_SYNTHESIS_COMPLETE. [IMAGE_OUTPUT: Generated Image](${data.image_b64})`;
                }
            },
            "edit-photo": {
                title: "PHOTO RECONSTRUCTION", description: "Modify image with instructions.",
                buildForm: () => `
                    <label for="tool-instruction">INSTRUCTION</label><textarea id="tool-instruction" required></textarea>
                    <label for="tool-file-url">IMAGE_ASSET_URL</label><input type="url" id="tool-file-url" placeholder="Paste image link or Data URL" required>`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_PHOTO_RECONSTRUCTION...`);
                    const fd = new FormData();
                    fd.append('prompt', payload.instruction);
                    // Handle Data URL or external URL
                    if (payload.file_url.startsWith('data:image/')) {
                        const blob = await (await fetch(payload.file_url)).blob();
                        fd.append('file', blob, 'image_to_edit.png');
                    } else if (payload.file_url.startsWith('http')) {
                        // Backend needs to handle fetching external URL for this to work
                         return `ERROR: EXTERNAL_URL_FETCH_NOT_SUPPORTED_FOR_THIS_TOOL_CLI. USE_DATA_URL_OR_UPLOAD_THROUGH_CHAT.`;
                    } else {
                        throw new Error("INVALID_IMAGE_ASSET_URL.");
                    }
                    const res = await fetch(`${API_BASE_URL}/api/tools/edit-photo`, { method: 'POST', body: fd });
                    if (!res.ok) throw new Error((await res.json()).error || 'PHOTO_RECONSTRUCTION_FAILED.');
                    const blob = await res.blob();
                    const base64String = await blobToBase64(blob);
                    return `PHOTO_RECONSTRUCTION_COMPLETE. [IMAGE_OUTPUT: Reconstructed Photo](${base64String})`;
                }
            },
            "remove-bg": {
                title: "BACKGROUND ISOLATION", description: "Remove background from an image.",
                buildForm: () => `
                    <label for="tool-file-url">IMAGE_ASSET_URL</label><input type="url" id="tool-file-url" placeholder="Paste image link or Data URL" required>`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_BACKGROUND_ISOLATION...`);
                    const fd = new FormData();
                     if (payload.file_url.startsWith('data:image/')) {
                        const blob = await (await fetch(payload.file_url)).blob();
                        fd.append('file', blob, 'image_for_bg_removal.png');
                    } else if (payload.file_url.startsWith('http')) {
                        return `ERROR: EXTERNAL_URL_FETCH_NOT_SUPPORTED_FOR_THIS_TOOL_CLI. USE_DATA_URL_OR_UPLOAD_THROUGH_CHAT.`;
                    } else {
                        throw new Error("INVALID_IMAGE_ASSET_URL.");
                    }
                    const res = await fetch(`${API_BASE_URL}/api/tools/remove-background`, { method: 'POST', body: fd });
                    if (!res.ok) throw new Error(res.statusText);
                    const blob = await res.blob();
                    const base64String = await blobToBase64(blob);
                    return `BACKGROUND_ISOLATION_COMPLETE. [IMAGE_OUTPUT: Isolated Image](${base64String})`;
                }
            },
            "comic": {
                title: "NARRATIVE STRIP GENERATION", description: "Create a comic from a story.",
                buildForm: () => `
                    <label for="tool-story">STORY_INPUT</label><textarea id="tool-story" placeholder="[DIALOGUE] Commander, signals detected!&#10;[NARRATION] Across the quadrant, a new threat emerged." required></textarea>
                    <label for="tool-style">ART_STYLE</label><select id="tool-style"><option value="anime">Anime</option><option value="american">American Comic</option><option value="manga">Manga</option></select>
                    <label for="tool-panels">PANEL_COUNT</label><input type="number" id="tool-panels" value="3" min="1" max="6">`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_NARRATIVE_STRIP_GENERATION...`);
                    const res = await fetch(`${API_BASE_URL}/api/tools/generate-comic`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ story: payload.story, style: payload.style, panels: parseInt(payload.panels, 10), user: currentUser?.displayName || "Traveler" })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || res.statusText);
                    const imagesHtml = data.images.map((img, idx) => `[IMAGE_OUTPUT: Panel ${idx+1}](${img})`).join('\n');
                    return `NARRATIVE_STRIP_COMPLETE. \n${imagesHtml}`;
                }
            },
            "voice-gen": {
                title: "VOCAL SYNTHESIS", description: "Generate voice from text.",
                buildForm: () => `
                    <label for="tool-text">TEXT_TO_SYNTHESIZE</label><textarea id="tool-text" required></textarea>
                    <label for="tool-voice">VOCAL_PROFILE</label><select id="tool-voice">
                        <option value="elder">Elder</option><option value="anime">Anime</option><option value="narrator">Narrator</option>
                    </select>`, // Simplified voice options for CLI form
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_VOCAL_SYNTHESIS...`);
                    const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: payload.text, voice_id: payload.voice || 'elder' })
                    });
                    if (!res.ok) throw new Error(await res.text());
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    return `VOCAL_SYNTHESIS_COMPLETE. [AUDIO_OUTPUT: Synthesized Voice](${url})`;
                }
            },
            "audio-narration": {
                title: "DOCUMENT AUDIFICATION", description: "Narrate an audio summary from a document.",
                buildForm: () => `
                    <label for="tool-file-url">DOCUMENT_ASSET_URL</label><input type="url" id="tool-file-url" placeholder="Paste document link or Data URL" required>`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_DOCUMENT_AUDIFICATION...`);
                    const fd = new FormData();
                    if (payload.file_url.startsWith('data:application/pdf') || payload.file_url.startsWith('data:text/plain')) {
                        const blob = await (await fetch(payload.file_url)).blob();
                        const type = payload.file_url.split(';')[0].split(':')[1];
                        fd.append('file', blob, 'document_for_narration.' + (type.includes('pdf') ? 'pdf' : 'txt'));
                    } else if (payload.file_url.startsWith('http')) {
                        return `ERROR: EXTERNAL_URL_FETCH_NOT_SUPPORTED_FOR_THIS_TOOL_CLI. USE_DATA_URL_OR_UPLOAD_THROUGH_CHAT.`;
                    } else {
                        throw new Error("INVALID_DOCUMENT_ASSET_URL.");
                    }
                    fd.append('style', 'podcast');
                    const res = await fetch(`${API_BASE_URL}/api/tools/audio-narration`, { method: 'POST', body: fd });
                    if (!res.ok) throw new Error(res.statusText);
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    return `DOCUMENT_AUDIFICATION_COMPLETE. [AUDIO_OUTPUT: Document Narration](${url})`;
                }
            },
            "video-text": {
                title: "TEXT-TO-MOTION SEQUENCE", description: "Generate video from text prompt.",
                buildForm: () => `
                    <label for="tool-prompt">VIDEO_SCENE_PROMPT</label><textarea id="tool-prompt" required></textarea>
                    <label for="tool-duration">DURATION_SECONDS</label><input type="number" id="tool-duration" value="6" min="2" max="15">`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_TEXT_TO_MOTION_SEQUENCE...`);
                    const startRes = await fetch(`${API_BASE_URL}/api/tools/generate-video-from-text`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: payload.prompt, model: "MiniMax-Hailuo-02", duration: parseInt(payload.duration, 10), resolution: "1080P" })
                    });
                    const startData = await startRes.json();
                    if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'VIDEO_TASK_INITIATION_FAILED.');
                    showStatusPopup(`VIDEO_TASK_QUEUED: ID '${startData.task_id}'. STANDBY_FOR_COMPLETION.`);
                    await pollVideoStatus(startData.task_id);
                    return null; // Handled by poll
                }
            },
            "video-image": {
                title: "STILL-TO-MOTION SEQUENCE", description: "Generate video from image and animation prompt.",
                buildForm: () => `
                    <label for="tool-prompt">ANIMATION_DIRECTIVE</label><textarea id="tool-prompt" required></textarea>
                    <label for="tool-file-url">SOURCE_IMAGE_URL</label><input type="url" id="tool-file-url" placeholder="Paste image link or Data URL" required>`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_STILL_TO_MOTION_SEQUENCE...`);
                    const fd = new FormData();
                    fd.append('prompt', payload.prompt);
                    if (payload.file_url.startsWith('data:image/')) {
                        const blob = await (await fetch(payload.file_url)).blob();
                        fd.append('file', blob, 'source_image.png');
                    } else if (payload.file_url.startsWith('http')) {
                        return `ERROR: EXTERNAL_URL_FETCH_NOT_SUPPORTED_FOR_THIS_TOOL_CLI. USE_DATA_URL_OR_UPLOAD_THROUGH_CHAT.`;
                    } else {
                        throw new Error("INVALID_IMAGE_ASSET_URL.");
                    }
                    fd.append('model', "MiniMax-Hailuo-02");
                    fd.append('duration', 6); // Default
                    fd.append('resolution', "1080P");
                    const startRes = await fetch(`${API_BASE_URL}/api/tools/generate-video-from-image`, { method: 'POST', body: fd });
                    const startData = await startRes.json();
                    if (!startRes.ok || !startData.task_id) throw new Error(startData.detail || 'VIDEO_TASK_INITIATION_FAILED.');
                    showStatusPopup(`VIDEO_TASK_QUEUED: ID '${startData.task_id}'. STANDBY_FOR_COMPLETION.`);
                    await pollVideoStatus(startData.task_id);
                    return null; // Handled by poll
                }
            },
            "music": {
                title: "HARMONIC COMPOSITION", description: "Generate music from prompt.",
                buildForm: () => `
                    <label for="tool-prompt">MUSICAL_THEME_PROMPT</label><textarea id="tool-prompt" required></textarea>
                    <label for="tool-lyrics">LYRIC_INPUT (Optional)</label><textarea id="tool-lyrics"></textarea>`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_HARMONIC_COMPOSITION...`);
                    const res = await fetch(`${API_BASE_URL}/api/tools/generate-music`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: payload.prompt, lyrics: payload.lyrics || '', model: 'music-1.5' })
                    });
                    if (!res.ok) throw new Error((await res.json()).detail || 'HARMONIC_ENGINE_FAILURE.');
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    return `HARMONIC_COMPOSITION_COMPLETE. [AUDIO_OUTPUT: Synthesized Track](${url})`;
                }
            },
            "website": {
                title: "WEB PORTAL FABRICATION", description: "Generate and deploy a website.",
                buildForm: () => `
                    <label for="tool-description">PORTAL_SPECIFICATIONS</label><textarea id="tool-description" required></textarea>`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_WEB_PORTAL_FABRICATION...`);
                    const res = await fetch(`${API_BASE_URL}/api/tools/create-website`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: payload.description, user_id: currentUser.uid })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || res.statusText);
                    return `WEB_PORTAL_FABRICATION_COMPLETE. [LINK_OUTPUT: Access Portal](${data.url})`;
                }
            },
            "edit-website": {
                title: "WEB PORTAL RECONSTRUCTION", description: "Modify the last generated website.",
                buildForm: () => `
                    <label for="tool-instruction">RECONSTRUCTION_DIRECTIVE</label><textarea id="tool-instruction" required></textarea>`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_WEB_PORTAL_RECONSTRUCTION...`);
                    const res = await fetch(`${API_BASE_URL}/api/tools/edit-website`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ instruction: payload.instruction, user_id: currentUser.uid })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || res.statusText);
                    return `WEB_PORTAL_RECONSTRUCTION_COMPLETE. [LINK_OUTPUT: Access New Version](${data.url})`;
                }
            },
            "my-sites": {
                title: "DEPLOYED PORTAL LOGS", description: "List deployed websites.",
                isAction: true,
                runAction: async () => {
                    showStatusPopup(`QUERYING_DEPLOYED_PORTAL_LOGS...`);
                    const res = await fetch(`${API_BASE_URL}/api/tools/my-sites/${currentUser.uid}`);
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || 'UNABLE_TO_RETRIEVE_PORTAL_LOGS.');
                    if (!data.sites || data.sites.length === 0) return "NO_WEB_PORTALS_CURRENTLY_DEPLOYED.";
                    const siteList = data.sites.map(site => `- [LINK_OUTPUT: ${site.site_url}](${site.site_url}) (FABRICATED: ${new Date(site.created_at).toLocaleString()})`).join('\n');
                    return `DEPLOYED_WEB_PORTALS:\n${siteList}`;
                }
            },
            "research-report": {
                title: "DATA CORRELATION REPORT", description: "Generate a research report (PDF).",
                buildForm: () => `
                    <label for="tool-topic">RESEARCH_TOPIC</label><input type="text" id="tool-topic" required>`,
                handleSubmit: async (payload) => {
                    showStatusPopup(`INITIATING_DATA_CORRELATION_REPORT...`);
                    const res = await fetch(`${API_BASE_URL}/api/tools/research`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ topic: payload.topic })
                    });
                    if (!res.ok) throw new Error(res.statusText);
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    return `DATA_CORRELATION_REPORT_COMPLETE. [PDF_OUTPUT: Download Report](${url})`;
                }
            },
        };

        // --- Tool Execution Logic ---
        let currentToolKey = null;

        function handleToolSelection(e) {
            e.preventDefault();
            const toolLink = e.target.closest('.tool-list-item');
            if (!toolLink) return;

            const toolKey = toolLink.dataset.tool;
            const tool = toolDefinitions[toolKey];
            if (!tool) { showStatusPopup(`ERROR: UNKNOWN_TOOL_KEY '${toolKey}'.`, true); return; }

            currentToolKey = toolKey;

            if (tool.isAction) {
                executeToolAction(toolKey);
            } else {
                showToolSection('form');
                menuTitle.textContent = tool.title;
                toolFormContent.innerHTML = `
                    <p style="color:var(--text-color-secondary); margin-bottom:20px; font-size:0.9rem;">${tool.description}</p>
                    ${tool.buildForm()}
                `;
                // Re-add event listeners for dynamically created form elements if needed
            }
        }

        async function executeToolAction(toolKey) {
            holographicMenu.classList.remove('active'); // Close menu
            showStatusPopup(`INITIATING_TOOL_ACTION: ${toolDefinitions[toolKey].title}...`);
            try {
                const result = await toolDefinitions[toolKey].runAction();
                if (result) await addAIMessageWithTyping(result);
            } catch (error) {
                await addAIMessageWithTyping(`[ERROR]: TOOL_ACTION_FAILED: ${error.message}`);
            } finally {
                currentToolKey = null;
            }
        }

        async function handleToolFormSubmit(e) {
            e.preventDefault();
            if (!currentToolKey) { showStatusPopup('ERROR: NO_ACTIVE_TOOL_FORM.', true); return; }
            const tool = toolDefinitions[currentToolKey];
            const form = toolFormContent; // The form's container div

            const payload = {};
            try {
                // Collect data from dynamically generated form fields
                form.querySelectorAll('input, textarea, select').forEach(field => {
                    payload[field.id.replace('tool-', '')] = field.value;
                });
                
                holographicMenu.classList.remove('active'); // Close menu
                const result = await tool.handleSubmit(payload);
                if (result) await addAIMessageWithTyping(result);

            } catch (error) {
                showStatusPopup(`ERROR_TOOL_EXECUTION: ${error.message}`, true);
                await addAIMessageWithTyping(`[ERROR]: TOOL_EXECUTION_FAILED: ${error.message}`);
            } finally {
                currentToolKey = null;
                showToolSection('list'); // Go back to tool list
            }
        }

        function showToolSection(view) {
            if (view === 'list') {
                toolListContainer.style.display = 'block';
                toolForm.style.display = 'none';
                menuTitle.textContent = 'COSMIC FORGE';
            } else if (view === 'form') {
                toolListContainer.style.display = 'none';
                toolForm.style.display = 'block';
            }
        }

        async function pollVideoStatus(taskId) {
            const pollInterval = setInterval(async () => {
                try {
                    const statusRes = await fetch(`${API_BASE_URL}/api/tools/video-status?task_id=${taskId}`);
                    const statusData = await statusRes.json();

                    if (statusRes.ok && statusData.url) {
                        clearInterval(pollInterval);
                        showStatusPopup(`VIDEO_TASK_COMPLETE: ID '${taskId}'.`, false);
                        await addAIMessageWithTyping(`VIDEO_RENDERING_COMPLETE! [VIDEO_OUTPUT: Generated Video](${statusData.url})`);
                    } else if (!statusRes.ok || statusData.status?.toLowerCase().includes('fail')) {
                        clearInterval(pollInterval);
                        showStatusPopup(`VIDEO_TASK_FAILED: ID '${taskId}'.`, true);
                        await addAIMessageWithTyping(`[ERROR]: VIDEO_RENDERING_FAILED. STATUS: ${statusData.error || 'UNKNOWN_ERROR'}`);
                    } else {
                        // Optionally update status in UI for long polls
                        // showStatusPopup(`VIDEO_TASK_PROGRESS: ID '${taskId}'. STATUS: ${statusData.status || 'PROCESSING'}`);
                    }
                } catch (pollErr) {
                    clearInterval(pollInterval);
                    showStatusPopup(`ERROR_POLLING_VIDEO_STATUS: ${pollErr.message}`, true);
                    await addAIMessageWithTyping(`[ERROR]: ERROR_POLLING_VIDEO_STATUS: ${pollErr.message}`);
                }
            }, 20000); // Poll every 20 seconds
        }

        // --- Media Viewer Functions ---
        let currentMediaDataUrl = null;

        function handleMediaLinkClick(e) {
            e.preventDefault();
            const link = e.target;
            const mediaType = link.dataset.mediaType;
            const mediaUrl = link.dataset.mediaUrl;
            const displayName = link.textContent;

            currentMediaDataUrl = mediaUrl; // Store for download

            mediaDisplayArea.innerHTML = '';
            mediaDisplayCaption.textContent = `DISPLAYING: ${displayName}`;

            let mediaElement;
            if (mediaType.includes('image')) {
                mediaElement = document.createElement('img');
                mediaElement.src = mediaUrl;
                mediaElement.alt = displayName;
            } else if (mediaType.includes('video')) {
                mediaElement = document.createElement('video');
                mediaElement.src = mediaUrl;
                mediaElement.controls = true;
            } else if (mediaType.includes('audio')) {
                mediaElement = document.createElement('audio');
                mediaElement.src = mediaUrl;
                mediaElement.controls = true;
            } else if (mediaType.includes('pdf')) {
                mediaElement = document.createElement('iframe');
                mediaElement.src = mediaUrl;
                mediaElement.style.width = '100%';
                mediaElement.style.height = '60vh';
                mediaElement.style.border = 'none';
                mediaDisplayCaption.textContent = `VIEWING_PDF: ${displayName}`;
            } else if (mediaType.includes('link')) {
                window.open(mediaUrl, '_blank');
                showStatusPopup(`OPENING_EXTERNAL_LINK: ${mediaUrl}`, false);
                mediaViewerModal.classList.remove('active');
                return;
            } else {
                mediaDisplayCaption.textContent = `ERROR: UNSUPPORTED_MEDIA_TYPE: ${mediaType}`;
                downloadMediaBtn.style.display = 'none';
                return;
            }
            mediaDisplayArea.appendChild(mediaElement);
            downloadMediaBtn.style.display = 'block'; // Show download button
            mediaViewerModal.classList.add('active');
        }

        function handleMediaDownload() {
            if (currentMediaDataUrl) {
                const a = document.createElement('a');
                a.href = currentMediaDataUrl;
                a.download = `phi_ai_asset_${Date.now()}`; // Generic filename
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showStatusPopup('ASSET_DOWNLOAD_INITIATED.', false);
            }
        }


        // --- Voice Call Functionality ---
        let speechRecognition;
        let isCallActive = false;
        let callHistory = []; // Stores actual text of conversation for context
        let botIsSpeaking = false;
        let userSaidSomething = false; // Flag to ensure user actually spoke, not just silence
        let currentAudio = null;
        let isMuted = false;

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition) {
            speechRecognition = new SpeechRecognition();
            speechRecognition.continuous = false; // Set to false to get final result and restart
            speechRecognition.interimResults = true;
            speechRecognition.lang = 'en-US';

            speechRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                userSaidSomething = true; // User has definitely made sounds
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                // Update interim display (or create if not present)
                let userTxEl = callTranscript.querySelector('.transcript-line.user.interim');
                if (!userTxEl) {
                    userTxEl = document.createElement('div');
                    userTxEl.className = 'transcript-line user interim';
                    callTranscript.appendChild(userTxEl);
                }
                userTxEl.textContent = `USER_TX: ${finalTranscript || interimTranscript}`;
                callTranscript.scrollTop = callTranscript.scrollHeight;

                callStatus.textContent = finalTranscript ? 'USER_TX_FINAL' : 'USER_TX_ACTIVE...';
                tapToSpeak.style.display = 'none';
            };

            speechRecognition.onend = () => {
                if (!isCallActive) return; // Only process if call is truly active

                if (isMuted) {
                    callStatus.textContent = 'MIC_MUTED.';
                    tapToSpeak.style.display = 'none';
                    return;
                }

                let finalTranscript = '';
                const userTxEl = callTranscript.querySelector('.transcript-line.user.interim');
                if (userTxEl) {
                    finalTranscript = userTxEl.textContent.replace('USER_TX:', '').trim();
                    userTxEl.classList.remove('interim'); // Mark as no longer interim
                }

                if (botIsSpeaking) {
                    // If bot is speaking, it will restart listening when it finishes.
                    // Just clean up user's interim message if no final speech.
                    if (userTxEl && finalTranscript === '') {
                        userTxEl.remove();
                    }
                } else if (finalTranscript && userSaidSomething) {
                    userSaidSomething = false; // Reset flag for next turn
                    callHistory.push({ role: 'user', content: finalTranscript });
                    appendCallLog(finalTranscript, 'user');
                    handleCallBotResponse();
                } else {
                    // No speech or too brief, restart listening
                    if (isCallActive && !isMuted) {
                        callStatus.textContent = 'AWAITING_INPUT... (TAP_TO_TRANSMIT)';
                        tapToSpeak.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to restart automatically:", e);}
                    }
                }
            };

            speechRecognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                if (event.error === 'no-speech' && isCallActive && !isMuted) {
                    userSaidSomething = false;
                    // On "no-speech", onend will still fire, handling the restart.
                    // Explicitly stopping here might interrupt onend's proper cleanup.
                } else if (event.error === 'network' && isCallActive) {
                    callStatus.textContent = '[ERROR]: NETWORK_DROPPED. ATTEMPTING_RECONNECT...';
                    speechRecognition.stop(); // Stop, onend will fire.
                } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    callStatus.textContent = '[ERROR]: MIC_ACCESS_DENIED. ALLOW_BROWSER_SETTINGS_FOR_COMMS.';
                    endCall();
                }
            };
        } else {
            // Disable call button if SR not supported
            startCallBtn.style.display = 'none';
            showStatusPopup('BROWSER_COMMS_LINK_UNSUPPORTED. VOICE_CALL_DISABLED.', true);
        }

        function appendCallLog(text, type = 'ai') {
            const line = document.createElement('div');
            line.className = `transcript-line ${type}`;
            if (type === 'user') line.textContent = `USER_TX: ${text.toUpperCase()}`;
            else if (type === 'ai') line.textContent = `PHI_AI: ${text.toUpperCase()}`;
            else if (type === 'status') line.textContent = `SYSTEM: ${text.toUpperCase()}`;
            callTranscript.appendChild(line);
            callTranscript.scrollTop = callTranscript.scrollHeight;
        }

        async function handleCallBotResponse() {
            if (!isCallActive) return;
            callStatus.textContent = 'PHI_AI_PROCESSING_INPUT...';
            tapToSpeak.style.display = 'none';

            const lastUserMessage = callHistory.slice().reverse().find(m => m.role === 'user');
            const userMessageContent = lastUserMessage ? lastUserMessage.content : "";

            // historyForBotAPI should contain only 'user' and 'ai' roles for context
            const historyForBotAPI = callHistory.filter(m => m.role !== 'status').map(m => ({
                role: m.role,
                content: m.content
            }));

            try {
                // Ensure recognition is stopped while bot is processing/speaking
                speechRecognition.stop();

                const res = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: userMessageContent, history: historyForBotAPI.slice(0, -1), user_id: currentUser?.uid || "traveler" })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || "SERVER_ERROR.");

                const botResponseFullText = data.response;
                
                // --- Blunt Bot Response Logic for Call UI ---
                let botDisplayMessage = botResponseFullText;
                if (botResponseFullText.startsWith('Tool execution:')) {
                    const matchOutput = botResponseFullText.match(/"output":\s*"(.*?)"/);
                    if (matchOutput && matchOutput[1]) {
                        botDisplayMessage = `TOOL_EXEC: ${matchOutput[1].replace(/\\n/g, '. ')}`;
                        if (botDisplayMessage.length > 80) botDisplayMessage = botDisplayMessage.substring(0, 77) + '...';
                    } else {
                        botDisplayMessage = "TOOL_EXEC_INITIATED. STANDBY.";
                    }
                } else if (botResponseFullText.includes("Tool use:")) {
                    botDisplayMessage = "QUERYING_AI_PROTOCOLS.";
                } else if (botResponseFullText.includes("generate an image") || botResponseFullText.includes("generate a video") || botResponseFullText.includes("generate music") || botResponseFullText.includes("create website") || botResponseFullText.includes("research report")) {
                    botDisplayMessage = "CONTENT_GENERATION_AVAILABLE. ACCESS_TOOLS_MAIN_INTERFACE.";
                } else if (botResponseFullText.includes("<img") || botResponseFullText.includes("<audio") || botResponseFullText.includes("<video") || botResponseFullText.includes("PDF_OUTPUT")) {
                    botDisplayMessage = "MEDIA_CONTENT_GENERATED. VIEW_VIA_MAIN_INTERFACE.";
                } else if (botResponseFullText.includes("LINK_OUTPUT")) {
                    botDisplayMessage = "LINK_GENERATED. ACCESS_VIA_MAIN_INTERFACE.";
                } else if (botResponseFullText.length > 120) {
                    botDisplayMessage = botResponseFullText.substring(0, 117) + '...';
                }
                botDisplayMessage = botDisplayMessage.toUpperCase();
                // --- End Blunt Bot Response Logic ---

                callHistory.push({ role: 'ai', content: botResponseFullText });
                appendCallLog(botDisplayMessage, 'ai'); // Display blunt message in transcript
                speakBotResponse(botResponseFullText); // Speak the full response
            } catch (err) {
                const errorMsg = `COMMS_ERROR: ${err.message}`.toUpperCase();
                appendCallLog(errorMsg, 'status');
                if (isCallActive && !isMuted) {
                    callStatus.textContent = 'AWAITING_INPUT... (TAP_TO_TRANSMIT)';
                    tapToSpeak.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after error:", e);}
                }
            }
        }

        async function speakBotResponse(text) {
            if (!isCallActive) return;
            botIsSpeaking = true;
            botAvatarContainer.classList.add('speaking');
            callStatus.textContent = 'PHI_AI_TRANSMITTING_AUDIO...';
            try {
                const res = await fetch(`${API_BASE_URL}/api/tools/text-to-speech`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ text: text, voice_id: 'elder' }) // Using 'elder' voice
                });
                if (!res.ok) throw new Error(await res.text());
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                currentAudio = audio;
                audio.onended = audio.onerror = () => {
                    botIsSpeaking = false;
                    botAvatarContainer.classList.remove('speaking');
                    currentAudio = null; // Clear reference
                    if (isCallActive && !isMuted) {
                        callStatus.textContent = 'AWAITING_INPUT... (TAP_TO_TRANSMIT)';
                        tapToSpeak.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after speaking:", e);}
                    } else if (isMuted) {
                        callStatus.textContent = 'MIC_MUTED.';
                        tapToSpeak.style.display = 'none';
                    }
                };
                audio.play();
            } catch (err) {
                console.error("VOCAL_SYNTHESIS_ERROR:", err);
                botIsSpeaking = false;
                botAvatarContainer.classList.remove('speaking');
                if (isCallActive && !isMuted) {
                    callStatus.textContent = 'AWAITING_INPUT (VOCAL_SYSTEM_OFFLINE)...';
                    tapToSpeak.style.display = 'block';
                    try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after voice error:", e);}
                } else if (isMuted) {
                    callStatus.textContent = 'MIC_MUTED.';
                    tapToSpeak.style.display = 'none';
                }
            }
        }

        function stopBotSpeakingAndRestartListening() {
            if (!isCallActive) return;
            // Only interrupt bot if it's currently speaking
            if (botIsSpeaking && currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
                botIsSpeaking = false;
                botAvatarContainer.classList.remove('speaking');
            }
            
            // Clear any interim user transcript that might be lingering
            const userTxEl = callTranscript.querySelector('.transcript-line.user.interim');
            if (userTxEl) {
                userTxEl.remove();
            }
            userSaidSomething = false; // Reset the flag

            // Restart listening if not muted
            if (!isMuted) {
                callStatus.textContent = 'AWAITING_INPUT... (TAP_TO_TRANSMIT)';
                tapToSpeak.style.display = 'block';
                try {
                    speechRecognition.stop(); // Stop to ensure a clean start
                    speechRecognition.start();
                } catch(e) { console.warn("Could not restart speech recognition immediately:", e); }
            } else {
                callStatus.textContent = 'MIC_MUTED.';
                tapToSpeak.style.display = 'none';
            }
        }

        function initiateVoiceCall() {
            if (!SpeechRecognition) {
                showStatusPopup('BROWSER_COMMS_LINK_UNSUPPORTED. VOICE_CALL_DISABLED.', true);
                return;
            }
            holographicMenu.classList.remove('active'); // Close main menu
            isCallActive = true;
            isMuted = false;
            muteCallBtn.classList.remove('muted');
            muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> MUTE'; // Simple text
            callModal.classList.add('active');
            callTranscript.innerHTML = '';
            appendCallLog('ESTABLISHING SECURE CHANNEL...', 'status');
            callStatus.textContent = 'ESTABLISHING SECURE LINK...';
            tapToSpeak.style.display = 'none';
            callHistory = [];
            userSaidSomething = false; // Reset for new call
            
            // Allow modal click to interrupt bot and talk
            callHologramDisplay.addEventListener('mousedown', stopBotSpeakingAndRestartListening);
            callHologramDisplay.addEventListener('touchstart', stopBotSpeakingAndRestartListening);


            setTimeout(() => {
                if (!isCallActive) return;
                appendCallLog('SECURE CHANNEL ESTABLISHED. TRANSMIT WHEN READY.', 'status');
                callStatus.textContent = 'AWAITING_INPUT... (TAP_TO_TRANSMIT)';
                tapToSpeak.style.display = 'block';
                try { speechRecognition.start(); } catch(e) { console.error("Speech recognition start failed", e); callStatus.textContent = '[ERROR]: MIC_INIT_FAIL. CHECK_PERMISSIONS.'; }
            }, 1500);
        }

        function endCall() {
            isCallActive = false;
            botIsSpeaking = false;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            callModal.classList.remove('active');
            try { speechRecognition.stop(); } catch(e) {}
            botAvatarContainer.classList.remove('speaking');
            tapToSpeak.style.display = 'none';
            callStatus.textContent = 'COMMS_LINK_TERMINATED.';
            showStatusPopup('COMMS_LINK_TERMINATED.', false);

            // Remove event listener to avoid memory leaks
            callHologramDisplay.removeEventListener('mousedown', stopBotSpeakingAndRestartListening);
            callHologramDisplay.removeEventListener('touchstart', stopBotSpeakingAndRestartListening);
        }

        endCallBtn.addEventListener('click', endCall);

        if (muteCallBtn) {
            muteCallBtn.addEventListener('click', () => {
                isMuted = !isMuted;
                if (isMuted) {
                    muteCallBtn.classList.add('muted');
                    muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone-slash"></i> UNMUTE';
                    speechRecognition.stop();
                    callStatus.textContent = 'MIC_MUTED.';
                    tapToSpeak.style.display = 'none';
                } else {
                    muteCallBtn.classList.remove('muted');
                    muteCallBtn.innerHTML = '<i class="fa-solid fa-microphone"></i> MUTE';
                    if (isCallActive && !botIsSpeaking) {
                        callStatus.textContent = 'AWAITING_INPUT... (TAP_TO_TRANSMIT)';
                        tapToSpeak.style.display = 'block';
                        try { speechRecognition.start(); } catch(e) {console.warn("Speech recognition failed to start after unmute:", e);}
                    } else if (isCallActive && botIsSpeaking) {
                        callStatus.textContent = 'PHI_AI_TRANSMITTING_AUDIO...';
                        tapToSpeak.style.display = 'none';
                    }
                }
            });
        }

        // --- Stop API Generation ---
        function showStopButton() {
            sendBtn.style.display = 'none';
            stopBtn.style.display = 'flex';
            sendBtn.classList.remove('sending'); // Ensure glow is off if it was on
            stopBtn.classList.add('sending'); // Add glow for stop button
        }

        function hideStopButton() {
            sendBtn.style.display = 'flex';
            stopBtn.style.display = 'none';
            stopBtn.classList.remove('sending');
        }

        function stopAIGeneration() {
            if (currentController) {
                currentController.abort();
                showStatusPopup('AI_GENERATION_INTERRUPTED.', true);
                hideStopButton();
                displayTypingIndicator(false);
            }
        }

        // --- Theme Switching ---
        const themes = {
            'ethereal-nexus': { /* default */ },
            'galactic-dawn-theme': { /* class */ },
            'nebula-veil-theme': { /* class */ }
        };
        let currentThemeIdx = 0;
        const themeKeys = Object.keys(themes);

        function applyCosmicTheme(themeName) {
            document.body.className = ''; // Clear existing themes
            if (themeName !== 'ethereal-nexus') {
                document.body.classList.add(themeName);
            }
            localStorage.setItem('philadelphia-cosmic-theme', themeName);
        }

        function cycleCosmicTheme() {
            currentThemeIdx = (currentThemeIdx + 1) % themeKeys.length;
            applyCosmicTheme(themeKeys[currentThemeIdx]);
            showStatusPopup(`COSMIC_THEME_SET: '${themeKeys[currentThemeIdx].replace(/-/g, '_').toUpperCase()}'.`, false);
        }
        // Load saved theme or apply default on start
        const savedTheme = localStorage.getItem('philadelphia-cosmic-theme');
        if (savedTheme && themes[savedTheme]) {
            currentThemeIdx = themeKeys.indexOf(savedTheme);
            applyCosmicTheme(savedTheme);
        } else {
            applyCosmicTheme('ethereal-nexus'); // Default
        }

        // --- Initial Focus ---
        userInput.focus();
    </script>
</body>
</html>


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YTKP10ZX"></script>
<script>
Â  window.dataLayer = window.dataLayer || [];
Â  function gtag(){dataLayer.push(arguments);}
Â  gtag('js', new Date()); 

Â  gtag('config', 'G-J1YTKP10ZX');
</script>
